

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
    <meta charset="UTF-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
        <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    
    <meta name="theme-color" content="#2f4154">
    <meta name="author" content="Lunatic sky">
    <meta name="keywords" content="">
    
        <meta name="description" content="Effective C++ - Item49-52 - 定制new和delete 总览 这一模块的内容是在完整阅读《Effective C++》的基础上，参考了缪之灵大佬的一篇文章学完 Effective C++：条款 &amp; 实践进行总结。虽然缪之灵大佬的文章将最重要的部分总结的非常到位，但在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ - Item49-52 - 定制new和delete">
<meta property="og:url" content="http://lunaticsky-tql.github.io/posts/5982/index.html">
<meta property="og:site_name" content="Lunaticsky&#39;s Blog">
<meta property="og:description" content="Effective C++ - Item49-52 - 定制new和delete 总览 这一模块的内容是在完整阅读《Effective C++》的基础上，参考了缪之灵大佬的一篇文章学完 Effective C++：条款 &amp; 实践进行总结。虽然缪之灵大佬的文章将最重要的部分总结的非常到位，但在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-21T04:26:30.000Z">
<meta property="article:modified_time" content="2023-09-21T04:26:30.000Z">
<meta property="article:author" content="Lunatic sky">
<meta property="article:tag" content="EffectiveC++">
<meta name="twitter:card" content="summary_large_image">
    
    
    
    <title>Effective C++ - Item49-52 - 定制new和delete - Lunaticsky&#39;s Blog</title>

    
  
    <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
      
    <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />
      
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
      
        

          <!-- 主题依赖的图标库，不要自行修改 -->
          <!-- Do not modify the link that theme dependent icons -->
          
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">


            
<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


              <link  rel="stylesheet" href="/css/main.css" />

                
                  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
                    
                      <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
                        
                          

                            
                              
<link rel="stylesheet" href="/css/indeximg-hover.css">
<link rel="stylesheet" href="/css/remove-shadow.css">
<link rel="stylesheet" href="/css/zan.css">
<link rel="stylesheet" href="/css/code_fold.css">
<link rel="stylesheet" href="/css/link.css">

                                
    <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lunaticsky-tql.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":false,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"9zw4pzKGNFredmMKJc9n2JSH-gzGzoHsz","app_key":"rS2LQjQjNgLRcqtYrEVLwcSb","server_url":"https://9zw4pzkg.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
    <script  src="/js/utils.js" ></script>
    <script  src="/js/color-schema.js" ></script>
    

  

  

  

  

  

  

  
    
  


    <link  rel="stylesheet" href="/lib/font-awesome/css/all.min.css" />
    <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />
    <link  rel="stylesheet" href="/css/main.css" />

    
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>


<header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lunatic sky‘s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/fan1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Effective C++ - Item49-52 - 定制new和delete"></span>
          
        </div>

        
          
  <div class="mt-3">
    
        
          <span class="post-meta">
            <i class="iconfont icon-date-fill" aria-hidden="true"></i>
            <time datetime="2023-09-21 12:26" pubdate>
              2023年9月21日 中午
            </time>
          </span>
          
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
              12k 字
                
      </span>
      

        

            
              
                
                  <span id="leancloud-page-views-container" class="post-meta" style="display: none">
                    <i class="iconfont icon-eye" aria-hidden="true"></i>
                    <span id="leancloud-page-views"></span>
                       次
                  </span>
                  
                    
                          
  </div>
  
        
      </div>

      
    </div>
  </div>
</div>

</div>

</header>

<main>
    
        

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Effective C++ - Item49-52 - 定制new和delete</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="effective-c---item49-52---定制new和delete">Effective C++ -
Item49-52 - 定制new和delete</h1>
<h3 id="总览">总览</h3>
<p>这一模块的内容是在完整阅读《Effective C++》的基础上，参考了<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613356779">一篇文章学完 Effective
C++：条款 &amp; 实践</a>进行总结。虽然<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的文章将最重要的部分总结的非常到位，但在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁的前提下提高可读性。虽然原书有些地方写的比较拖沓，但作为经典的C++参考书，想要了解更多的细节，还是值得仔细去阅读的。</p>
<p>同时，假定阅读文章时对C++已经具有本科高级语言程序设计课程内容的理解水平。大部分情况下，除非它很重要，不会对C++基础的语法特性进行介绍。</p>
<p>本部分是第七章内容，对<strong>条款49-52</strong>进行介绍。</p>
<p>这一部分是对资源管理的延伸。其中条款16提到了成对使用new和delete时要采取相同形式。当我们为了各种目的（条款50）要自定义new和delete时，会发现有更多可能踩的坑，极有可能造成资源泄漏。这也非常考验我们C++的功力。因此虽然只有4个条款，但篇幅并不短。下面便对此进行详细的介绍，并穿插简略介绍现代C++有关内存管理的内容。</p>
<h3 id="条款-49了解-new-handler-的行为">条款 49：了解 new-handler
的行为</h3>
<p>当<code>operator new</code>无法满足某一内存分配需求时，会不断调用一个客户指定的错误处理函数，即所谓的
<strong>new-handler</strong>，直到找到足够内存为止，调用声明于<code>&lt;new&gt;</code>中的<code>set_new_handler</code>可以指定这个函数。<code>new_handler</code>和<code>set_new_handler</code>的定义如下：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2hmm0llnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-2hmm0llnpqvi9k"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">using</span> new_handler = <span class="hljs-built_in">void</span>(*)();
    <span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler)</span> <span class="hljs-title">throw</span> <span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回值为原来持有的 new-handler</span>
}</code></pre></div></div>
<blockquote>
<p>现代C++就不要再用<code>throw()</code>了（C++20已移除），用<code>noexcept</code>。后面代码也不会再写<code>throw()</code>了。</p>
</blockquote>
<p>当<code>operator new</code>无法满足内存申请时，它会<strong>不断</strong>调用<code>new-handler</code>函数，直到找到足够内存。</p>
<p>一个设计良好的 new-handler 函数必须做以下事情之一：</p>
<p><strong>让更多的内存可被使用：</strong>
可以让程序一开始执行就分配一大块内存，而后当 <code>new-handler</code>
第一次被调用，将它们释还给程序使用，造成<code>operator new</code>的下一次内存分配动作可能成功。</p>
<p><strong>设置另一个 new-handler：</strong> 如果目前这个
<code>new-handler</code>无法取得更多内存，可以调换为另一个可以完成目标的<code>new-handler</code>。</p>
<p>具体的，调用<code>set_new_handler</code>，这样下一次调用<code>new_heandler</code>就可以做些不同的事。为了达到这个目的，可以让
<code>new-handler</code> 修改“会影响 <code>new-handler</code>
行为”的静态或全局数据。</p>
<p><strong>卸除 new-handler：</strong>
将<code>nullptr</code>传给<code>set_new_handler</code>，这样会使<code>operator new</code>在内存分配不成功时抛出异常。</p>
<p><strong>抛出 bad_alloc（或派生自 bad_alloc）的异常：</strong>
这样的异常不会被<code>operator new</code>捕捉，因此会被传播到内存分配处。</p>
<p><strong>不返回：</strong>
通常调用<code>std::abort</code>或<code>std::exit</code>。</p>
<p>有的时候我们或许会希望在<strong>为不同的类分配对象时，使用不同的方式处理内存分配失败情况</strong>。这时候使用静态成员是不错的选择：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1tomdulnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-1tomdulnpqvi9k"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-keyword">noexcept</span></span>;
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">static</span> std::new_handler currentHandler;
};

<span class="hljs-comment">// 做和 std::set_new_handler 相同的事情，将它获得的指针存储起来，然后返回先前(在此调用之前)存储的指针</span>
<span class="hljs-function">std::new_handler <span class="hljs-title">Widget::set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-keyword">noexcept</span> </span>{
    std::new_handler oldHandler = currentHandler;
    currentHandler = p;
    <span class="hljs-keyword">return</span> oldHandler; 
}

<span class="hljs-function"><span class="hljs-type">void</span>* Widget::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{
    std::new_handler globalHandler = std::<span class="hljs-built_in">set_new_handler</span>(currentHandler);  <span class="hljs-comment">// 切换至 Widget 的专属 new-handler,暂存原来的供后续恢复</span>
    <span class="hljs-type">void</span>* ptr = ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);                           <span class="hljs-comment">// 分配内存或抛出异常</span>
    std::<span class="hljs-built_in">set_new_handler</span>(globalHandler);                        <span class="hljs-comment">// 切换回全局的 new-handler</span>
    <span class="hljs-keyword">return</span> globalHandler;
}

std::new_handler Widget::currentHandler = <span class="hljs-literal">nullptr</span>;</code></pre></div></div>
<blockquote>
<p>看上去写的有点复杂，再理一下我们要干什么：我们要为<code>Widget</code>写一个其专属的<code>handler</code>，其行为和标准的<code>handler</code>一致，但只对<code>Widget</code>生效，而且只对下一次new生效。</p>
</blockquote>
<p><code>Widget</code>的客户应该类似这样使用其 new-handling：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zo0hgdlnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-zo0hgdlnpqvi9k"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutOfMem</span><span class="hljs-params">()</span></span>{
  std::cout&lt;&lt;<span class="hljs-string">"Custom handler when running out of memory!"</span>
}

Widget::<span class="hljs-built_in">set_new_handler</span>(OutOfMem);
Widget* pw1 = <span class="hljs-keyword">new</span> Widget;              <span class="hljs-comment">// 若分配失败，则调用 OutOfMem</span>

Widget::<span class="hljs-built_in">set_new_handler</span>(<span class="hljs-literal">nullptr</span>);
Widget* pw2 = <span class="hljs-keyword">new</span> Widget;              <span class="hljs-comment">// 若分配失败，则抛出异常</span></code></pre></div></div>
<p>实现这一方案的代码并不因类的不同而不同，因此对这些代码加以复用是合理的构想。一个简单的做法是建立起一个“mixin”风格的基类，让其派生类继承它们所需的<code>set_new_handler</code>和<code>operator new</code>，并且使用模板确保每一个派生类获得一个实体互异的<code>currentHandler</code>成员变量：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w5hvk9lnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-w5hvk9lnpqvi9k"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerSupport</span> {       <span class="hljs-comment">// “mixin”风格的基类</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-keyword">noexcept</span></span>;
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span>;
    ...                         <span class="hljs-comment">// 其它的 operator new 版本，见条款 52</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">static</span> std::new_handler currentHandler;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::<span class="hljs-built_in">set_new_handler</span>(std::new_handler p) <span class="hljs-keyword">noexcept</span> {
    std::new_handler oldHandler = currentHandler;
    currentHandler = p;
    <span class="hljs-keyword">return</span> oldHandler;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{
    std::new_handler globalHandler = std::<span class="hljs-built_in">set_new_handler</span>(currentHandler);
    <span class="hljs-type">void</span>* ptr = ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);
    std::<span class="hljs-built_in">set_new_handler</span>(globalHandler);
    <span class="hljs-keyword">return</span> globalHandler;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="hljs-literal">nullptr</span>;

<span class="hljs-comment">//使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> : <span class="hljs-keyword">public</span> NewHandlerSupport&lt;Widget&gt; {
<span class="hljs-keyword">public</span>:
    ...                         <span class="hljs-comment">// 不必再声明 set_new_handler 和 operator new</span>
};</code></pre></div></div>
<p>注意此处的模板参数<code>T</code>并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，<strong>利用模板机制为每个派生类具现化出一份对应的<code>currentHandler</code></strong>。</p>
<p>这个做法用到了所谓的 <strong>CRTP（curious recurring template
pattern，奇异递归模板模式）</strong> 。</p>
<blockquote>
<p>C++的模版每具现化一次，都会生成其对应的具现化代码。通过上面的技巧写出的自定义handler代码，在<code>Widget</code>（或其他不同于<code>Widget</code>任何对象）的客户调用时，依旧可以直接使用<code>Widget::set_new_handler(OutOfMem);</code>。</p>
</blockquote>
<p>除了在上述设计模式中用到之外，它也被用于实现<strong>静态多态</strong>：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9x2aszlnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-9x2aszlnpqvi9k"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>&gt; 
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Interface</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">Implementation</span>();      <span class="hljs-comment">// 在基类中暴露接口</span>
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base&lt;Derived&gt; {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Implementation</span><span class="hljs-params">()</span></span>;                                  <span class="hljs-comment">// 在派生类中提供实现</span>
};</code></pre></div></div>
<p>除了会调用 new-handler 的<code>operator new</code>以外，C++
还保留了传统的“分配失败便返回空指针”的<code>operator new</code>，称为
<code>nothrow new</code>，通过<code>std::nothrow</code>对象来使用它：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wibjy1lnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-wibjy1lnpqvi9k"><pre><code class="hljs cpp">Widget* pw1 = <span class="hljs-keyword">new</span> Widget;                   <span class="hljs-comment">// 如果分配失败，抛出 bad_alloc</span>
<span class="hljs-keyword">if</span> (pw1 == <span class="hljs-literal">nullptr</span>) ...                     <span class="hljs-comment">// 这个测试一定失败</span>

Widget* pw2 = <span class="hljs-built_in">new</span> (std::nothrow) Widget;    <span class="hljs-comment">// 如果分配失败，返回空指针</span>
<span class="hljs-keyword">if</span> (pw2 == <span class="hljs-literal">nullptr</span>) ...                     <span class="hljs-comment">// 这个测试可能成功</span></code></pre></div></div>
<p><code>nothrow new</code>
对异常的强制保证性并不高，使用它只能保证<code>operator new</code>不抛出异常，而无法保证像<code>new (std::nothrow) Widget</code>这样的表达式不会导致异常，因此<strong>实际上并没有使用
nothrow new 的需要</strong>。</p>
<h3 id="条款-50了解-new-和-delete-的合理替换时机">条款 50：了解 new 和
delete 的合理替换时机</h3>
<p>以下是常见的替换默认<code>operator new</code>和<code>operator delete</code>的理由：</p>
<p><strong>用来检测运用上的错误：</strong> 如果将“new 所得内存”delete
掉却不幸失败，会导致内存泄漏；如果在“new 所得内存”身上多次 delete
则会导致未定义行为。</p>
<p>此外各式各样的编程错误可能导致
<strong>“overruns”（写入点在分配区块尾端之后）</strong> 和
<strong>“underruns”（写入点在分配区块起点之前）</strong>，以额外空间放置特定的
byte pattern
签名，检查签名是否原封不动就可以检测此类错误，下面给出了一个这样的范例：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cdd1shlnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-cdd1shlnpqvi9k"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> signature = <span class="hljs-number">0xDEADBEEF</span>;              <span class="hljs-comment">// 调试“魔数”</span>
<span class="hljs-keyword">using</span> Byte = <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>;

<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-type">size_t</span> realSize = size + <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);         <span class="hljs-comment">// 分配额外空间以塞入两个签名</span>

    <span class="hljs-type">void</span>* pMem = <span class="hljs-built_in">malloc</span>(realSize);                    <span class="hljs-comment">// 调用 malloc 取得内存</span>
    <span class="hljs-keyword">if</span> (!pMem) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();

    <span class="hljs-comment">// 将签名写入内存的起点和尾端</span>
    *(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pMem)) = signature;
    *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem) + realSize - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>))) = signature;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);    <span class="hljs-comment">// 返回指针指向第一个签名后的内存位置</span>
}</code></pre></div></div>
<p>实际上这段代码<strong>不能保证内存对齐</strong>，并且有许多地方不遵守
C++ 规范，我们将在条款 51 中进行详细讨论。</p>
<blockquote>
<p>比如x86平台上int4字节，double8字节。尽管Intel x86
上的doubles可被以任何byte边界对齐，但如果它是8-byte对齐，其访问速度会快许多。这个程序便不能保证。</p>
<p>所以作者还是认为有必要替换默认new和delete，但建议不要自己造轮子，可以根据需求看看已有的开源或者商业实现。</p>
</blockquote>
<p><strong>为了收集使用上的统计数据：</strong> 定制 new 和 delete
动态内存的相关信息：分配区块的大小分布，寿命分布，FIFO（先进先出）、LIFO（后进先出）或随机次序的倾向性，不同的分配/归还形态，使用的最大动态分配量等等。</p>
<p><strong>为了增加分配和归还的速度：</strong>
译器所带的<code>operator new</code>s和<code>operator delete</code>s需要考虑更多通用的因素。当定制的分配器专门针对某特定类型之对象设计时<strong>类专属的分配器可以做到“区块尺寸固定”</strong>，例如
Boost 提供的 Pool
程序库。又例如，编译器所带的内存管理器是线程安全的，但如果你的程序是单线程的，你也可以考虑写一个不线程安全的分配器来提高速度。当然，这需要你对程序进行分析，并确认程序瓶颈的确发生在那些内存函数身上。</p>
<p><strong>为了降低缺省内存管理器带来的空间额外开销：</strong>
泛用型分配器往往（虽然并非总是）还比定制型分配器使用更多内存，那是因为它们常常在每一个分配区块身上导致某些额外开销。针对小型对象而开发的分配器（例如
Boost 的 Pool 程序库）本质上消除了这样的额外开销。</p>
<p><strong>为了弥补缺省分配器中的非最佳内存对齐（suboptimal
alignment）：</strong>上文例子已经讲过。<code>std::max_align_t</code>用来返回当前平台的最大默认内存对齐类型，对于<code>malloc</code>分配的内存，其对齐和<code>max_align_t</code>类型的对齐大小应当是一致的，但若对<code>malloc</code>返回的指针进行偏移，就没有办法保证内存对齐。</p>
<blockquote>
<p>下面对现代C++中内存对齐的内容进行较深入讨论：</p>
<p>在 C++11 中，提供了以下内存对齐相关方法：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mi743olnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-mi743olnpqvi9k"><pre><code class="hljs cpp"><span class="hljs-comment">// alignas 用于指定栈上数据的内存对齐要求</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">8</span>) testStruct { <span class="hljs-type">double</span> data; };
<span class="hljs-comment">//ps：指定的必须是2的次幂，如果指定的次数大，超过下面提到的max_align_t，不一定能得到保证。这被叫做over-aligned。C++17对其进行了修复。</span>

<span class="hljs-comment">// alignof 和 std::alignment_of 用于得到给定类型的内存对齐要求</span>
std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(std::<span class="hljs-type">max_align_t</span>) &lt;&lt; std::endl;
std::cout &lt;&lt; std::alignment_of&lt;std::<span class="hljs-type">max_align_t</span>&gt;::value &lt;&lt; std::endl;
<span class="hljs-comment">//通常等于double所占字节数</span>

<span class="hljs-comment">// std::align 用于在一大块内存中获取一个符合指定内存要求的地址</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Arena</span> {
  <span class="hljs-type">void</span>* ptr = <span class="hljs-number">0</span>;
  std::<span class="hljs-type">size_t</span> size_remain = <span class="hljs-number">0</span>;
  
  [[nodiscard]]
  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">aligned_alloc</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> alignment, std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span> -&gt; <span class="hljs-type">void</span>*</span>
<span class="hljs-function">  </span>{	<span class="hljs-comment">//参数：期望的对齐方式，每个对齐单元大小，要对齐内存块的起始地址，要对齐内存块的大小；返回：内存块中满足对齐条件的指针，没有返回nullptr</span>
    <span class="hljs-type">void</span>* res = std::<span class="hljs-built_in">align</span>(alignment, size, ptr, size_remain);
    <span class="hljs-keyword">if</span> (res) {
        ptr = <span class="hljs-built_in">static_cast</span>&lt;std::byte*&gt;(res) + size;
        size_remain -= size;
        <span class="hljs-keyword">return</span> res;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  }
};</code></pre></div></div>
<p>可以参考<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/align">文档</a>。上面的案例取自<a target="_blank" rel="noopener" href="https://lesleylai.info/zh/std-align/">Align
Allocator实现</a>，实际上现在C++17已经提供了<code>std::aligned_alloc</code>实现。</p>
<p>在 C++17
后，可以使用<code>std::align_val_t</code>来重载需求额外内存对齐的<code>operator new</code>：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-po8cmklnpqvi9k"></i><span>cpp</span><div class="collapse show" id="collapse-po8cmklnpqvi9k"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> count, std::<span class="hljs-type">align_val_t</span> al)</span></span>;</code></pre></div></div>
<p>但是，这样必须同时重载与之配套的operator
delete。具体的，需要手动进行对象析构并且选择合适的带有对齐参数的delete。可以参见<a target="_blank" rel="noopener" href="https://github.com/MeouSker77/Cpp17/blob/master/markdown/src/ch30.md">这里</a></p>
</blockquote>
<p><strong>为了将相关对象成簇集中：</strong>
如果你知道特定的某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误（page
faults）”的频率降至最低，那么可以考虑为此数据结构创建一个堆，将它们成簇集中在尽可能少的内存页上。一般可以使用
placement new 达成这个目标（见条款 52）。</p>
<p><strong>为了获得非传统的行为：</strong>
有时候你会希望<code>operator new</code>和<code>operator delete</code>做编译器版不会做的事情，例如分配和归还共享内存（shared
memory），而这些事情只能被 C API 完成，则可以将 C API 封在 C++
的外壳里，写在定制的 new 和 delete 中。</p>
<blockquote>
<p>这涉及到linux系统调用。</p>
</blockquote>
<h3 id="条款-51编写-new-和-delete-时需固守常规">条款 51：编写 new 和
delete 时需固守常规</h3>
<p>我们在条款 49
中已经提到过一些<code>operator new</code>的规矩，比如内存不足时必须不断调用
new-handler，如果无法供应客户申请的内存，就抛出<code>std::bad_alloc</code>异常。C++
还有一个奇怪的规定，即使客户需求为0字节，<code>operator new</code>也得返回一个合法的指针，这种看似诡异的行为其实是为了简化语言其他部分。</p>
<p>根据这些规约，我们可以写出非成员函数版本的<code>operator new</code>伪代码：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xmehvhlnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-xmehvhlnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)      <span class="hljs-comment">// 处理0字节申请</span>
        size = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 将其视为1字节申请</span>

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (分配成功)
            <span class="hljs-keyword">return</span> (一个指针，指向分配得到的内存)

        <span class="hljs-comment">// 如果分配失败，调用目前的 new-handler</span>
        <span class="hljs-keyword">auto</span> globalHandler = <span class="hljs-built_in">get_new_handler</span>(); <span class="hljs-comment">// since C++11</span>

        <span class="hljs-keyword">if</span> (globalHandler) (*globalHandler)();
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();
    }
}</code></pre></div></div>
<blockquote>
<p>在C++11之前，我们没有任何办法可以直接取得new-handling函数指针。只能这样：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o27sd1lnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-o27sd1lnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-keyword">new</span> handler globalHandler <span class="hljs-built_in">set_new_handler</span>(<span class="hljs-number">0</span>);
<span class="hljs-built_in">set_new_handler</span>(globalHandler);</code></pre></div></div>
<p>这在多线程情况下可能出问题，必须加锁保证事务语义。</p>
</blockquote>
<p>上面的伪代码可以看做对条款49的具体遵循。</p>
<p><code>operator new</code>的成员函数版本一般只会分配大小刚好为类的大小的内存空间，但是情况并不总是如此，比如假设我们没有为派生类声明其自己的<code>operator new</code>，那么派生类会从基类继承<code>operator new</code>，这就导致派生类使用的是基类的
new 分配方式，但派生类和基类的大小很多时候是不同的。</p>
<blockquote>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w2x4wllnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-w2x4wllnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std:size t size)</span><span class="hljs-title">throw</span><span class="hljs-params">(std::bad alloc)</span></span>;
...
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base {...};<span class="hljs-comment">//假设Derived未声明operator new</span>

Derived* p <span class="hljs-keyword">new</span> Derived; <span class="hljs-comment">//这里调用的是Base::operator new</span></code></pre></div></div>
</blockquote>
<p>处理此情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准的<code>operator new</code>：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1exxpvlnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-1exxpvlnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>{
    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(Base))
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    <span class="hljs-comment">// 转交给标准的 operator new 进行处理</span>
    ...
}</code></pre></div></div>
<p>注意在<code>operator new</code>的成员函数版本中我们也不需要检测分配的大小是否为0了，因为在条款
39
中提到过，非附属对象必须有非零大小，所以<code>sizeof(Base)</code>无论如何也不能为0。</p>
<p>如果你打算实现<code>operator new[]</code>，即所谓的 array
new，那么你唯一要做的一件事就是分配一块未加工的原始内存，因为你无法对
array 之内迄今尚未存在的元素对象做任何事情，实际上你甚至无法计算这个
array 将含有多少元素对象，在多态的情境下更是如此。</p>
<blockquote>
<p>在More Effective C++
条款3中提到，绝对不要以多态(polymorphically)方式处理数组。对此情况进行了进一步的解释。</p>
</blockquote>
<p><code>operator delete</code>的规约更加简单，你需要记住的唯一一件事情就是
C++ 保证 <strong>“删除空指针永远安全”</strong>：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zuzzpclnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-zuzzpclnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory)</span> <span class="hljs-keyword">noexcept</span> </span>{
  	<span class="hljs-comment">//如果被删除的是null指针，什么也不用做</span>
    <span class="hljs-keyword">if</span> (rawMemory == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 归还 rawMemory 所指的内存</span>
}</code></pre></div></div>
<p><code>operator delete</code>的成员函数版本要多做的唯一一件事就是将大小有误的删除行为转交给标准的<code>operator delete</code>：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xiu2vxlnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-xiu2vxlnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory, std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span> </span>{
    <span class="hljs-keyword">if</span> (rawMemory == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(Base)) {
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(rawMemory)</span></span>;    <span class="hljs-comment">// 转交给标准的 operator delete 进行处理</span>
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 归还 rawMemory 所指的内存</span>
}</code></pre></div></div>
<p><strong>如果即将被删除的对象派生自某个基类而后者缺少虚析构函数，那么
C++
传给<code>operator delete</code>的<code>size</code>大小可能不正确</strong>，这或许是“为多态基类声明虚析构函数”的一个足够的理由，能作为对条款
7 的补充。</p>
<h3 id="条款-52写了-placement-new-也要写-placement-delete">条款 52：写了
placement new 也要写 placement delete</h3>
<blockquote>

</blockquote>
<p>placement new
最初的含义指的是“<strong>接受一个指针指向对象该被构造之处</strong>”的<code>operator new</code>版本，它在标准库中的用途广泛，其中之一是负责在
vector 的未使用空间上创建对象，它的声明如下：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ks8ctblnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-ks8ctblnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-keyword">noexcept</span></span>;</code></pre></div></div>
<p>我们此处要讨论的是广义上的 placement
new，即<strong>带有附加参数的<code>operator new</code></strong>，都叫placement
new。例如下面这种：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-53krlylnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-53krlylnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::ostream&amp; logStream)</span></span>;

<span class="hljs-keyword">auto</span> pw = <span class="hljs-built_in">new</span> (std::cerr) Widget;</code></pre></div></div>
<p>当我们在使用 new
表达式创建对象时，共有两个函数被调用：一个是用以分配内存的<code>operator new</code>，一个是对象的构造函数。假设第一个函数调用成功，而第二个函数却抛出异常，那么会由
C++ runtime 调用<code>operator delete</code>，归还已经分配好的内存。</p>
<blockquote>
<p>如：<code>Widget* pw new Widget;</code>共有两个函数被调用：一个是用以分配内存的operator
new，一个是Widget的 default构造函数。</p>
</blockquote>
<p>这一切的前提是 C++ runtime
能够找到<code>operator new</code>对应的<code>operator delete</code>。</p>
<p>如果我们使用的是自定义的 placement new，而没有为其准备对应的
placement delete 的话，就无法避免发生内存泄漏。</p>
<p>在下面的情景下我们希望在动态创建一个Widget时将相关的分配信息志记(Iogs)于cerr：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h7dgptlnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-h7dgptlnpqvi9l"><pre><code class="hljs cpp">Widget *pw=<span class="hljs-built_in">new</span> (std:cerr) Widget;</code></pre></div></div>
<p>因此，合格的代码应该是这样的：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h6i5ihlnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-h6i5ihlnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; logStream)</span></span>;   <span class="hljs-comment">// placement new</span>

    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory)</span></span>;                             <span class="hljs-comment">// delete 时调用的正常 operator delete</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory, std::ostream&amp; logStream)</span></span>;    <span class="hljs-comment">// placement delete，需要配套提供</span>
};</code></pre></div></div>
<p>另一个要注意的问题是，由于成员函数的名称会掩盖其外部作用域中的相同名称（见条款
33），所以单纯提供 placement new
会导致无法使用正常版本的<code>operator new</code>：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qq9p4ilnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-qq9p4ilnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; logStream)</span></span>;
    ...
};

<span class="hljs-keyword">auto</span> pb = <span class="hljs-keyword">new</span> Base;             <span class="hljs-comment">// 无法通过编译！因为正常形式的operator new被掩盖。</span>
<span class="hljs-keyword">auto</span> pb = <span class="hljs-built_in">new</span> (std::cerr) Base; <span class="hljs-comment">// 正确</span></code></pre></div></div>
<p>同样道理，派生类中的<code>operator new</code>会掩盖全局版本和继承而得的<code>operator new</code>版本：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-prg4ytlnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-prg4ytlnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span>; <span class="hljs-comment">//重新声明正常形式的new</span>
    ...
};

<span class="hljs-keyword">auto</span> pd = <span class="hljs-built_in">new</span> (std::clog) Derived;  <span class="hljs-comment">// 无法通过编译！因为Base的 placement new被掩盖了.</span>
<span class="hljs-keyword">auto</span> pd = <span class="hljs-keyword">new</span> Derived;              <span class="hljs-comment">// 正确</span></code></pre></div></div>
<p>为了避免名称遮掩问题，需要确保以下形式的<code>operator new</code>对于定制类型仍然可用（这些是C++标准程序库默认提供的），除非你的意图就是阻止客户使用它们：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1wvmoolnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-1wvmoolnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">operator</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;           <span class="hljs-comment">// normal new</span>
<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">operator</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span></span>;                 <span class="hljs-comment">// placement new</span>
<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">operator</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// nothrow new</span></code></pre></div></div>
<blockquote>
<p>这一部分的逻辑和类的构造函数类似。</p>
</blockquote>
<p>一个最简单的实现方式是，准备一个基类，内含所有正常形式的 new 和
delete：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rrzg06lnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-rrzg06lnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StadardNewDeleteForms</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// normal new/delete</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span>{
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);
    }
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-keyword">noexcept</span> </span>{
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;
    }

    <span class="hljs-comment">// placement new/delete</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* ptr)</span> </span>{
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, ptr);
    }
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory, <span class="hljs-type">void</span>* ptr)</span> <span class="hljs-keyword">noexcept</span> </span>{
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory, ptr)</span></span>;
    }

    <span class="hljs-comment">// nothrow new/delete</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp; nt)</span> </span>{
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size,nt);
    }
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory,<span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span> </span>{
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;
    }
};</code></pre></div></div>
<p>凡是想以自定义形式扩充标准形式的客户，可以利用继承和<code>using</code>声明式（见条款
33）取得标准形式：</p>
<div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h3coezlnpqvi9l"></i><span>cpp</span><div class="collapse show" id="collapse-h3coezlnpqvi9l"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> StandardNewDeleteForms{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;
    <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;

    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; logStream)</span></span>;
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">detele</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="hljs-keyword">noexcept</span></span>;
    ...
};</code></pre></div></div>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/EffectiveC/">#EffectiveC++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Effective C++ - Item49-52 - 定制new和delete</div>
      <div>http://lunaticsky-tql.github.io/posts/5982/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lunatic sky</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年9月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/27022/" title="Effective Modern C++ - Item1-6 - 类型推导">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Effective Modern C++ - Item1-6 - 类型推导</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/4565/" title="Effective C++ - Item41-47 - 模版与泛型编程">
                        <span class="hidden-mobile">Effective C++ - Item41-47 - 模版与泛型编程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>
              
              




              
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  




  
  









    

    
        <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
            <i class="iconfont icon-arrowup" aria-hidden="true"></i>
        </a>
    

    
        <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
</main>

<footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

</footer>

<!-- Scripts -->

  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script  src="https://unpkg.com/leancloud-storage@4.12.2/dist/av-live-query-min.js" ></script>

  <script defer src="/js/zan.js" ></script>

  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>




<noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
</noscript>
<!-- hexo injector body_end start -->
  <script src="/js/out_of_date.js"></script>
<!-- hexo injector body_end end --></body>
</html>
