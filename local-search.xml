<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络-书面作业2</title>
    <link href="/posts/55151/"/>
    <url>/posts/55151/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-书面作业2">计算机网络-书面作业2</h1><p>下表是一个使用CIDR（无类域间路由）的路由表，为了计算方便，IP地址使用十六进制表示。针对下面每个目的地址给出路由器所选择的下一步跳的标号，即A、B、C、D和E，并给出计算过程。</p><ol type="1"><li><p>C4.5E.13.87</p></li><li><p>C4.5E.22.09</p></li><li><p>C3.41.80.02</p></li><li><p>5E.43.91.12</p></li><li><p>C4.6D.31.2E</p></li><li><p>C4.6B.31.2E</p></li></ol><table><thead><tr class="header"><th>网络地址/前缀长度</th><th><strong>下一步跳</strong></th></tr></thead><tbody><tr class="odd"><td>C4.50.0.0/12</td><td>A</td></tr><tr class="even"><td>C4.5E.10.0/20</td><td>B</td></tr><tr class="odd"><td>C4.60.0.0/12</td><td>C</td></tr><tr class="even"><td>C4.68.0.0/14</td><td>D</td></tr><tr class="odd"><td>0.0.0.0</td><td>E</td></tr></tbody></table><p>首先方便最长匹配,将路由表重新排序:</p><table><thead><tr class="header"><th>网络地址/前缀长度</th><th><strong>下一步跳</strong></th></tr></thead><tbody><tr class="odd"><td>C4.5E.10.0/20</td><td>B</td></tr><tr class="even"><td>C4.68.0.0/14</td><td>D</td></tr><tr class="odd"><td>C4.60.0.0/12</td><td>C</td></tr><tr class="even"><td>C4.50.0.0/12</td><td>A</td></tr><tr class="odd"><td>0.0.0.0</td><td>E</td></tr></tbody></table><ol type="1"><li><p>C4.5E.13.87 前20位和第一条路由匹配，下一跳是B</p></li><li><p>C4.5E.22.09前20位和第一条路由不匹配，但与第四条路由前12位匹配，下一跳是A</p></li><li><p>C3.41.80.02 前四条路由都不匹配，选择默认路由 0.0.0.0，下一跳是E</p></li><li><p>5E.43.91.12 和(3)类似，下一跳是E</p></li><li><p>C4.6D.31.2E8是1000，D是1101，对于第二条路由第14位不匹配，因此只能匹配第三条路由，下一跳是C</p></li><li><p>C4.6B.31.2E8是1000，B是1011，前十四位与第二条路由匹配，下一跳是D</p></li></ol><p>事实上，为了更加有效地查找最长前缀匹配，通常将无分类编址的路由表存放在一种层次式数据结构中，然后自上而下地按层次进行查找。这里最常用的数据结构就是二叉线索。所以以2为例真实的查找方式是发现C4.50.0.0/12 匹配，查看孩子节点是否匹配，发现没有匹配的，则下一跳为A</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.2-基于UDP服务设计可靠传输协议(流量控制)</title>
    <link href="/posts/39007/"/>
    <url>/posts/39007/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.2-基于udp服务设计可靠传输协议流量控制">计算机网络实验3.2-基于UDP服务设计可靠传输协议(流量控制)</h1><div class="note note-info">写在前面：这次由于突然发烧隔离（虽然不是阳，也是挺重的一次感冒）导致没能及时检查作业，比较可惜。也借此提醒自己：一定要注意身体。另外也得接受教训。如金哥所言，提高应急处突能力还是非常重要的。</div><h2 id="实验要求">实验要求</h2><p>在实验3-1的基础上，将停等机制改成基于滑动窗口的流量控制机制，采用固定窗口大小，支持累积确认，完成给定测试文件的传输。</p><ul><li>多个序列号；</li><li>发送缓冲区、接受缓冲区；</li><li>滑动窗口：Go Back N；</li><li>有必要日志输出（须显示传输过程中发送端、接收端的窗口具体情况）。</li></ul><h2 id="程序流程展示">程序流程展示</h2><p>注：与实验3.1相同的部分仅作简要叙述，详细可以参见<a href="https://lunaticsky-tql.github.io/posts/24837/">计算机网络实验实验3.1</a></p><h3 id="协议设计">协议设计</h3><p>基于rdt3.0,本次实验实现了GBN和SR两种流水线协议，并采用多线程编程。</p><h4 id="报文结构">报文结构</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213512464145_894_image-20221210213415264.png" alt="image-20221210213415264"><figcaption aria-hidden="true">image-20221210213415264</figcaption></figure><p>如图所示，报文头长度共<code>128Bits</code>。下面介绍报文结构如下所示：</p><p>整个实验只使用一个序列号字段。对于发送端对应<code>TCP</code>中的<code>seq</code>,接收端对应<code>TCP</code>中的<code>ack</code>。</p><p>下面是十六位校验和以及数据报字段长度，与<code>TCP</code>相同。</p><p>使用<code>u_short</code>来存放<code>flag</code>。其字段含义如下：</p><p><code>F</code>:<code>FIN</code></p><p><code>S</code>:<code>SYN</code></p><p><code>A</code>:<code>ACK</code></p><p><code>H</code>:<code>FILE_HEAD</code></p><p><code>FILE_HEAD</code>用于指示接收端此报文包含文件信息的字段。</p><p><code>window_size</code>存放接收端通告给发送端的窗口大小。</p><p><code>option</code>为可选字段，在本次实验中暂时用于存放文件长度。</p><p><code>data</code>的最大长度可以调节，本次实验定义为1024字节。</p><p>此部分定义代码段如下;</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v2tybhlc651otn"></i><span>c++</span><div class="collapse show" id="collapse-v2tybhlc651otn"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 1024</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA 0x0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIN 0x1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYN 0x2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK 0x4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_SYN 0x6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_FIN 0x5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_HEAD 0x8</span><span class="hljs-comment">// datagram format:</span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet_head</span> {    u_int seq;    u_short check_sum;    u_short data_size;    u_short flag;    u_short window_size;    u_int option;    <span class="hljs-built_in">packet_head</span>() {        seq = <span class="hljs-number">0</span>;        check_sum = <span class="hljs-number">0</span>;        data_size = <span class="hljs-number">0</span>;        flag = <span class="hljs-number">0</span>;        window_size = <span class="hljs-number">0</span>;        option = <span class="hljs-number">0</span>;    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet</span> {    packet_head head;    <span class="hljs-type">char</span> data[MAX_SIZE]{};    <span class="hljs-built_in">packet</span>() {        <span class="hljs-built_in">packet_head</span>();        <span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0</span>, MAX_SIZE);    }};<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span></code></pre></div></div><p><code>#pragma pack(1)</code>用于指示结构体内容按1Byte对齐，以保证报文大小是我们期望的紧凑形式。</p><h4 id="建连和断连">建连和断连</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213259977349_103_image-20221119154308774.png" alt="image-20221119154308774"><figcaption aria-hidden="true">image-20221119154308774</figcaption></figure><p>建连和断连过程与3.1无太大变化。主要是在建连过程中增加了接收方初始窗口大小的通告。</p><h3 id="流程设计">流程设计</h3><p>程序支持一次建连发送多个文件。</p><p>本次实验与上次相比，整体逻辑没有变化，但序列号递增使用。在本次实验中序列号为<code>u_int</code>类型，可存储<span class="math inline">\(2^{32}\)</span>个序列号，每个数据包最大为<span class="math inline">\(1024\)</span>即<span class="math inline">\(2^{10}\)</span>字节，理论上最大可传输<span class="math inline">\(2^{42}=4TB\)</span>的单个文件。当然，由于在本实验中因为使用<code>option</code>字段存储文件长度，所以实际上能传输的最大长度是<span class="math inline">\(2^{32}\)</span>字节即即<span class="math inline">\(4GB\)</span>。总之，在不考虑可拓展性的前提下，不需循环使用序列号即可满足目前文件传输的需求。</p><h2 id="程序代码解释">程序代码解释</h2><h3 id="文件发送过程">文件发送过程</h3><h4 id="gbn">GBN</h4><p>下面先以基础的GBN为基础分析程序代码：</p><h5 id="发送端">发送端</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213515660596_123_image-20221210115848469.png" alt="image-20221210115848469"><figcaption aria-hidden="true">image-20221210115848469</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213517155143_340_image-20221210115903632.png" alt="image-20221210115903632"><figcaption aria-hidden="true">image-20221210115903632</figcaption></figure><p>课件中讲述也很直观，对照伪代码实现即可。</p><h6 id="发送进程主进程">发送进程（主进程）</h6><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-78pat4lc651otn"></i><span>c++</span><div class="collapse show" id="collapse-78pat4lc651otn"><pre><code class="hljs c++"><span class="hljs-comment">//wasted space but saved time for "shifting" sndpkt window</span><span class="hljs-keyword">auto</span> *sndpkt = <span class="hljs-keyword">new</span> packet[pkt_total + <span class="hljs-number">1</span>];<span class="hljs-keyword">while</span> (base &lt; pkt_total) {    <span class="hljs-comment">//send packets</span>    <span class="hljs-keyword">if</span> (nextseqnum &lt; base + N &amp;&amp; nextseqnum &lt; pkt_total) {        pkt_data_size = <span class="hljs-built_in">min</span>(MAX_SIZE, file_len - nextseqnum * MAX_SIZE);        sndpkt[nextseqnum] = <span class="hljs-built_in">make_pkt</span>(DATA, nextseqnum, pkt_data_size, file_data + nextseqnum * MAX_SIZE);        <span class="hljs-built_in">udt_send</span>(sndpkt[nextseqnum]);        cout &lt;&lt; <span class="hljs-string">"Sent packet "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum) + <span class="hljs-string">" "</span>;        <span class="hljs-keyword">if</span> (base == nextseqnum) {            timer.<span class="hljs-built_in">start_timer</span>();        }        nextseqnum++;        <span class="hljs-built_in">print_window</span>();    }    <span class="hljs-comment">//handle timeout</span>    <span class="hljs-keyword">if</span> (timer.<span class="hljs-built_in">timeout</span>()) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout, resend packets from "</span> + <span class="hljs-built_in">to_string</span>(base) + <span class="hljs-string">" to "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum - <span class="hljs-number">1</span>),                      WARNING);        <span class="hljs-keyword">for</span> (u_int i = base; i &lt; nextseqnum; i++) {            <span class="hljs-built_in">udt_send</span>(sndpkt[i]);        }        timer.<span class="hljs-built_in">start_timer</span>();    }}</code></pre></div></div><p>这一部分逻辑与状态机中右上角两个部分完全一致。其中<code>timer</code>是一个全局的计时器，为自己编写的类。用法可以顾名思义。<code>print_window();</code>按照<code>[base|nexeseqnum|base+n]</code>的格式将当前窗口状态打印出来。</p><h6 id="接收进程">接收进程</h6><p>接收进程在发送之前创建。实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v5lbpclc651otn"></i><span>c++</span><div class="collapse show" id="collapse-v5lbpclc651otn"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handle_ACK</span><span class="hljs-params">(LPVOID lpParam)</span> </span>{    packet rcvpkt;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-comment">//non-blocking rdt_rcv (if not rcv any packet it, it will return 0)</span>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">rdt_rcv</span>(rcvpkt) || <span class="hljs-built_in">corrupt</span>(rcvpkt) || !<span class="hljs-built_in">isACK</span>(rcvpkt)) {            <span class="hljs-comment">//the packet must be ACK and not corrupt to jump out of the loop</span>        }<span class="hljs-comment">//        base = get_ack_num(rcvpkt) + 1;</span>        acked[<span class="hljs-built_in">get_ack_num</span>(rcvpkt)] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }        cout &lt;&lt; <span class="hljs-string">"Received ACK "</span> + <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">get_ack_num</span>(rcvpkt)) + <span class="hljs-string">" "</span>;        <span class="hljs-built_in">print_window</span>();        <span class="hljs-keyword">if</span> (base == pkt_total) {            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-keyword">if</span> (base == nextseqnum) {            timer.<span class="hljs-built_in">stop_timer</span>();            <span class="hljs-keyword">continue</span>;        } <span class="hljs-keyword">else</span> {            timer.<span class="hljs-built_in">start_timer</span>();        }    }}</code></pre></div></div><p>这一部分助教思考的也非常深入：虽然实验环境下ACK不会丢失且能按序到达，但真实的网络环境下ACK也会丢失，且由于传输速度可能不一样快，ACK未必是按序到达的。这一点在上一次实验的握手建连部分考虑到了且有所叙述（接收方在确认握手成功后也有可能因为ACK丢失而收到发送方重发的握手包），但这一次实验囿于伪代码的惯性思维没有考虑周全，感谢助教提醒指正。</p><p>因此此处可参考后续SR的实现，移动时不能简单的移动到当前收到的序号+1，而是从base开始移动到按序收到的包序号之后，即：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qjol0glc651otn"></i><span>c++</span><div class="collapse show" id="collapse-qjol0glc651otn"><pre><code class="hljs c++"><span class="hljs-comment">//        base = get_ack_num(rcvpkt) + 1;</span>        acked[<span class="hljs-built_in">get_ack_num</span>(rcvpkt)] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }</code></pre></div></div><p>当然这也需要把收到包的状态保存为数组。此处的空间复杂度还可以优化，也即实际上我们只需要窗口内的ACK状态即可，但这样就伴随着较为费时的“移动”。因此此处直接将所有状态都保存了下来。</p><h5 id="接收端">接收端</h5><p>接收端的变化主要一个是将窗口通告给发送方。这个任务只需要修改<code>make_pkt</code>即可，不再赘述。</p><p>另外一个是接收发送方数据的逻辑。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213518957536_859_image-20221210123705619.png" alt="image-20221210123705619"><figcaption aria-hidden="true">image-20221210123705619</figcaption></figure><p>代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dxt1i9lc651otn"></i><span>C++</span><div class="collapse show" id="collapse-dxt1i9lc651otn"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasseqnum</span>(rcvpkt, expectedseqnum)) {            pkt_data_size = rcvpkt.head.data_size;            <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);            received_file_len += pkt_data_size;            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK,expectedseqnum);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(expectedseqnum), DEBUG);            expectedseqnum++;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//discard the packet and wait for the next one</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a out-of-order packet"</span>, WARNING);            <span class="hljs-keyword">continue</span>;        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (received_file_len == file_size) {        ...file received, writing file to the disk...    }}</code></pre></div></div><p>可以从状态机看到，我们只需要关注<code>expectedseqnum</code>对应的包即可，其他的包收到直接丢弃即可。这一部分并不复杂，对照状态机容易理解。</p><h4 id="sr">SR</h4><p>在这次实验中也额外实现了SR选择重传流水线协议。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213520764848_548_image-20221210200312667.png" alt="image-20221210200312667"><figcaption aria-hidden="true">image-20221210200312667</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213542209437_469_image-20221210201321172.png" alt="image-20221210201321172"><figcaption aria-hidden="true">image-20221210201321172</figcaption></figure><h5 id="发送端-1">发送端</h5><p>发送端相比GBN，需要为每一个分组都加入定时器。一开始是希望每一个包发出后都创建一个相同进程用于监听ACK并处理超时事件，但实践中发现由于，传入的<code>packet</code>地址会在发送过程中被修改，在线程中无法正确每个线程获取需要等待的分组的序号和内容。因此转而采用线程池的方式进行实现，每个线程维护自己的定时器和需要重发的分组。代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mpsihllc651otn"></i><span>C++</span><div class="collapse show" id="collapse-mpsihllc651otn"><pre><code class="hljs C++"><span class="hljs-comment">//wasted space but saved time for "shifting" sndpkt window</span><span class="hljs-type">clock_t</span> single_file_timer = <span class="hljs-built_in">clock</span>();<span class="hljs-keyword">while</span> (base &lt; pkt_total) {    <span class="hljs-comment">//send packets</span>    <span class="hljs-keyword">if</span> (nextseqnum &lt; base + N &amp;&amp; nextseqnum &lt; pkt_total) {        pkt_data_size = <span class="hljs-built_in">min</span>(MAX_SIZE, file_len - nextseqnum * MAX_SIZE);        sndpkt_buffer[nextseqnum] = <span class="hljs-built_in">make_pkt</span>(DATA, nextseqnum, pkt_data_size,                                             file_data + nextseqnum * MAX_SIZE);        <span class="hljs-built_in">udt_send</span>(sndpkt_buffer[nextseqnum]);        cout &lt;&lt; <span class="hljs-string">"Sent packet "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum) + <span class="hljs-string">" "</span>;        <span class="hljs-built_in">print_window</span>();        thread_pool[nextseqnum] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SR, &amp;sndpkt_buffer[nextseqnum], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        nextseqnum++;    }}</code></pre></div></div><p>其中<code>SR</code>线程的实现思路如下：</p><p><code>acked</code>数组中保存了当前分组确认的状态，和GBN中所叙述的类似。这个数组的内容由接收线程（与GBN相同，但只标记<code>acked</code>数组状态，不进行窗口滑动）进行修改。当第<code>wait_seq</code>个包对应的SR线程发现监听到了对应<code>acked</code>数组变化（即<code>接收ACK(n)</code>）判断是否进行窗口滑动。若超时，则重发对应的包，重启定时器。</p><p>下面是对应的代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sot13dlc651otn"></i><span>C++</span><div class="collapse show" id="collapse-sot13dlc651otn"><pre><code class="hljs C++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">SR</span><span class="hljs-params">(LPVOID lpParam)</span> </span>{    packet sndpkt = *<span class="hljs-built_in">reinterpret_cast</span>&lt;packet *&gt;(lpParam);    u_int wait_seq = sndpkt.head.seq;    <span class="hljs-type">int</span> resend_times = <span class="hljs-number">0</span>;    <span class="hljs-comment">//start a timer</span>    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();    <span class="hljs-keyword">while</span> (!acked[wait_seq]) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timeout</span>(start)) {            <span class="hljs-built_in">udt_send</span>(sndpkt);            start = <span class="hljs-built_in">clock</span>();            <span class="hljs-keyword">if</span> (resend_times &gt; MAX_RESEND_TIMES) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend times exceed the limit, there must be something wrong with the network"</span>, ERR);                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            } <span class="hljs-keyword">else</span> {                cout &lt;&lt; <span class="hljs-string">"Resend packet "</span> + <span class="hljs-built_in">to_string</span>(sndpkt.head.seq) + <span class="hljs-string">" "</span>;                <span class="hljs-built_in">print_window</span>();                resend_times++;            }        }    }    <span class="hljs-comment">//if reach here, the packet is ACKed</span>    <span class="hljs-keyword">if</span> (wait_seq == base) {        <span class="hljs-comment">//if the ACKed packet is the base, move the window to the first unACKed packet</span>        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><h5 id="接收端-1">接收端</h5><p>接收端比GBN的情况要复杂一些，因为需要缓存失序的包。实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-25ljwllc651otn"></i><span>C++</span><div class="collapse show" id="collapse-25ljwllc651otn"><pre><code class="hljs C++"><span class="hljs-comment">//"blocking receive" here</span><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        u_int pkt_seq = rcvpkt.head.seq;        <span class="hljs-keyword">if</span> (pkt_seq &gt;= rcv_base &amp;&amp; pkt_seq &lt; rcv_base + N) {            <span class="hljs-comment">//in the window</span>            <span class="hljs-keyword">if</span> (!acked[pkt_seq]) {                <span class="hljs-keyword">if</span> (pkt_seq == rcv_base) {                    <span class="hljs-comment">//the first packet in the window</span>                    pkt_data_size = rcvpkt.head.data_size;                    <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);                    acked[pkt_seq] = <span class="hljs-literal">true</span>;                    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base);                    <span class="hljs-built_in">udt_send</span>(sndpkt);                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);                    <span class="hljs-comment">//slide the window</span>                    <span class="hljs-keyword">while</span> (acked[rcv_base]) {                        rcv_base++;                    }                } <span class="hljs-keyword">else</span> {                    <span class="hljs-comment">//not the first packet in the window, cache it</span>                    pkt_data_size = rcvpkt.head.data_size;                    <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);                    acked[pkt_seq] = <span class="hljs-literal">true</span>;                    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);                    <span class="hljs-built_in">udt_send</span>(sndpkt);                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq)+<span class="hljs-string">", cached"</span>, DEBUG);                }            } <span class="hljs-keyword">else</span> {                <span class="hljs-comment">//already acked in the window, resend the ack</span>                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" again"</span>, WARNING);                <span class="hljs-comment">//send ack</span>                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);                <span class="hljs-built_in">udt_send</span>(sndpkt);                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent ack "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);            }        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pkt_seq &gt;= rcv_base - N) &amp;&amp; (pkt_seq &lt; rcv_base)) {            <span class="hljs-comment">//out of the window, but in the buffer</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" again"</span>, WARNING);            <span class="hljs-comment">//send ack</span>            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent ack "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//out of the window and buffer</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" out of the window"</span>, WARNING);            <span class="hljs-comment">//do nothing</span>        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (rcv_base * MAX_SIZE &gt;= file_size) {        ...file received, writing file to the disk...    }}</code></pre></div></div><p>虽然代码较长，但无非是区分了接收的分组在窗口内，窗口之前或者超出了缓冲区三种情况。</p><h2 id="程序演示">程序演示</h2><h3 id="建立连接">建立连接</h3><p>路由器设置：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213544187165_779_image-20221119185527966.png" alt="image-20221119185527966"><figcaption aria-hidden="true">image-20221119185527966</figcaption></figure><p>流程展示在上一次实验已经展示的比较完善。本次实验主要演示有丢包延时条件下的发送情况。</p><h3 id="gbn流水线协议">GBN流水线协议</h3><p>可以看到发送方当发现超时候会将<code>base</code>到<code>nextseqnum</code>之间的包全部重发。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213545630220_743_image-20221210212155885.png" alt="image-20221210212155885"><figcaption aria-hidden="true">image-20221210212155885</figcaption></figure><p>接收方也能判断失序的分组：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213547529597_432_image-20221210212321733.png" alt="image-20221210212321733"><figcaption aria-hidden="true">image-20221210212321733</figcaption></figure><h3 id="sr流水线协议">SR流水线协议</h3><p>在SN协议的实践中，发现发送方会经常由于超时重发接收方能够收到的包。猜测是由于接收方串行接收且接收的逻辑比发送方发送的逻辑复杂，导致了接收的速度跟不上发送的速度。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213549149283_237_image-20221210211645995.png" alt="image-20221210211645995"><figcaption aria-hidden="true">image-20221210211645995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213550895116_592_image-20221210211627874.png" alt="image-20221210211627874"><figcaption aria-hidden="true">image-20221210211627874</figcaption></figure><p>因此尝试略微调大超时时间（3*MAX_TIME）可以看到正常的接收发送过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213552672768_860_image-20221210211424408.png" alt="image-20221210211424408"><figcaption aria-hidden="true">image-20221210211424408</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213554281337_662_image-20221210211449133.png" alt="image-20221210211449133"><figcaption aria-hidden="true">image-20221210211449133</figcaption></figure><p>发送成功！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.2/20221210213555912889_771_image-20221210212403935.png" alt="image-20221210212403935"><figcaption aria-hidden="true">image-20221210212403935</figcaption></figure><p>GitHub:</p><p>https://github.com/Lunaticsky-tql/rdt_on_udp</p><p>GBN对应lab3.2分支，SR对应lab3.2-SR分支。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-上下文无关文法</title>
    <link href="/posts/44201/"/>
    <url>/posts/44201/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理-上下文无关文法">编译原理-上下文无关文法</h1><h2 id="cfg基本概念">CFG基本概念</h2><p><font color="Apricot">符号串集合！</font></p><p>CFG可以表示所有正则表达式的所能表达文法集合，反过来不成立</p><h3 id="cfg设计">CFG设计</h3><p>可以结合正则表达式设计，思路类似。</p><ul><li><p>最基本的一个例子：<span class="math inline">\(L=\{abb^{2n}|n≥0\}\)</span></p><p>S→b|aSbb</p></li><li><p>设计接受语言<span class="math inline">\({\{a^ib^ja^kb^l| i+j=k+l,i, j, k, l&gt;=0\}}\)</span>的上下文无关文法。</p><p>S→aSb | A | B | M</p><p>A→aAa | M</p><p>B→bBb | M</p><p>M→bMa | e</p><p>思路：两边对称，先构造中间，再对称的加a或b。特别注意，A，B只涵盖了“一边的情况，所以”S→aSb“是必须的。</p></li><li><p>设计接受C++数组声明语句的上下文无关文法，其中数组元素类型限定为int、char及它们的指针，数组维数可以是任意维。</p><p>D→T id M ;</p><p>T→int | char | T*</p><p>M→M [num] | [num]</p><p>注意：指针也可以套任意个</p></li><li><p>形如xy(x≠y)的01串</p><p><span class="math inline">\(S \rightarrow A B \mid B A\)</span> <span class="math inline">\(A \rightarrow X A X \mid 0\)</span> ( <span class="math inline">\(A\)</span> 是奇数长度, 中间为 0 的串) <span class="math inline">\(B \rightarrow X B X \mid 1\)</span> ( <span class="math inline">\(B\)</span> 是奇数长度, 中间为 1 的串) <span class="math inline">\(X \rightarrow 0 \mid 1\)</span></p></li><li><p>接受语言 <span class="math inline">\(\left\{a^i b^j a^k \midj=i+k, i&gt;=0, k&gt;=0\right\}\)</span> 的上下文无关文法。 答: <span class="math display">\[\begin{aligned}&amp;\mathbf{S} \rightarrow \mathbf{A B} \\&amp;\mathbf{A} \rightarrow \mathbf{a A b} \mid \varepsilon \\&amp;\mathbf{B} \rightarrow \mathbf{b B a} \mid \varepsilon\end{aligned}\]</span></p></li></ul><p>练习：</p><ol type="1"><li><p><span class="math inline">\(\quad\left\{0^i 1^j 0^k \mid j=2i+k\right\}\)</span></p><p>仿照最后一个题容易得到答案</p></li><li><p>无法写成 <span class="math inline">\(x x\)</span> 形式的 01串</p><p>仿照倒数第二个题，<span class="math inline">\(S \rightarrow A B \midB A \mid A \mid B \mid \varepsilon\)</span></p></li></ol><h3 id="nfa和cfg转换">NFA和CFG转换</h3><p>一一对应即可，非常简单</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20221201120121396547_551_image-20221115092857560.png" alt="image-20221115092857560"><figcaption aria-hidden="true">image-20221115092857560</figcaption></figure><p>注意别忘了终态的规则(替换空串)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20221201120122982777_294_image-20221115093159798.png" alt="image-20221115093159798"><figcaption aria-hidden="true">image-20221115093159798</figcaption></figure><p>“不包含子串011的01串，3显然不需要包含进CFG”</p><h2 id="cfg修改">CFG修改</h2><h3 id="消除二义性">消除二义性</h3><p>消除二义性没有固定的套路，建立在对文法理解的基础上。</p><figure><img src="/Users/tianjiaye/Library/Application%20Support/typora-user-images/image-20221201134248289.png" alt="image-20221201134248289"><figcaption aria-hidden="true">image-20221201134248289</figcaption></figure><h3 id="消除左递归">消除左递归</h3><p>消除直接左递归很简单，在龙书第二章有所讲述。下面一个消除间接左递归的例子：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20221201120126538302_916_image-20221115094108795.png" alt="image-20221115094108795" width="67%" height="67%"></p><h3 id="消除空字">消除空字</h3><p>消除空字需要注意的一点时一定要替换“干净”，即所有与含有空字的非终结符文法定义相关的条目都要考虑并替换</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20221201120128030368_860_image-20221115094610591.png" alt="image-20221115094610591"><figcaption aria-hidden="true">image-20221115094610591</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20221201120129388514_865_image-20221115094838176.png" alt="image-20221115094838176"><figcaption aria-hidden="true">image-20221115094838176</figcaption></figure><h3 id="消除回路">消除回路</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20221201120130871049_366_image-20221115095219937.png" alt="image-20221115095219937"><figcaption aria-hidden="true">image-20221115095219937</figcaption></figure><h3 id="左公因子提取">左公因子提取</h3><p><span class="math inline">\(A \rightarrow \alpha \beta_1 \mid \alpha\beta_2\)</span> 改写为： <span class="math inline">\(\mathrm{A}\rightarrow \alpha \mathrm{A}^{\prime}\)</span> <span class="math inline">\(A^{\prime} \rightarrow \beta_1 \mid\beta_2\)</span></p><p>例子：</p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{iEtS}|\mathrm{iEtSeS}| \mathrm{a}\)</span> <span class="math inline">\(\mathrm{E} \rightarrow \mathrm{b}\)</span> i <span class="math inline">\(\rightarrow\)</span> if, t$ $ then, e <span class="math inline">\(\rightarrow\)</span> else, E <span class="math inline">\(\rightarrow\)</span> 表达式, S <span class="math inline">\(\rightarrow\)</span> 语句 改写为: <span class="math inline">\(\mathrm{S} \rightarrow \mathrm{iEtSS}\)</span> ' |a <span class="math inline">\(\mathrm{S}^{\prime} \rightarrow\mathrm{eS} \mid \varepsilon\)</span> <span class="math inline">\(\mathrm{E} \rightarrow \mathrm{b}\)</span></p><h2 id="cfg无法描述的语言结构">CFG无法描述的语言结构</h2><p>(重在理解)</p><p>例1: <span class="math inline">\(\mathrm{L}_1=\left\{\mathrm{wcw}\mid \mathrm{w} \in(\mathrm{a} \mid \mathrm{b})^*\right\}\)</span></p><p>检查标识符(w)必须在使用之前定义</p><p>语义分析阶段才能完成的事情</p><p>例2: <span class="math inline">\(\mathrm{L}_2=\left\{a^{\mathrm{n}}b^m c^n d^m \mid n \geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.m \geqslant 1\right\}\)</span></p><p>检查函数的形参 (声明) 与实参 (调用)的数目是否匹配</p><p>语法定义一般不考虑参数数目</p><p>例3: <span class="math inline">\(\mathrm{L}_3=\left\{\mathrm{a}^{\mathrm{n}}b^{\mathrm{n}} \mathrm{c}^{\mathrm{n}} \mid \mathrm{n} \geq0\right\}\)</span></p><p>排版软件, 文本加下划线: <span class="math inline">\(\mathrm{n}\)</span> 个字符, <span class="math inline">\(\mathrm{n}\)</span> 个退格, <span class="math inline">\(\mathrm{n}\)</span> 个下划线</p><p><span class="math inline">\(\mathrm{a}^{\mathrm{n}}b^{\mathrm{n}}\)</span>容易描述(S→aSb)</p><p>另一种方式: 字符一退格一下划线三元 组序列, <span class="math inline">\((\mathrm{abc})^*\)</span>就可以描述了</p><p><strong>可以描述的类似文法：</strong></p><p><span class="math inline">\(\mathrm{L}_1{}^{\prime}=\left\{\mathrm{w} \mathrm{c}\mathrm{w}^{\mathrm{R}}\mathrm{w} \in(\mathrm{a} \mid \mathrm{b})^*,\mathrm{w}^{\mathrm{R}}\right.\)</span> 为<span class="math inline">\(\mathrm{w}\)</span>的反转 <span class="math inline">\(\}\)</span></p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{aSa}|\mathrm{bSb}| \mathrm{c}\)</span> <span class="math inline">\(\mathrm{L}_2{}^{\prime}=\left\{\mathrm{a}^{\mathrm{n}} \mathrm{b}^{\mathrm{m}}\mathrm{c}^{\mathrm{m}} \mathrm{d}^{\mathrm{n}} \mid \mathrm{n}\geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.\mathrm{m} \geqslant 1\right\}\)</span></p><p>和考试题类似，中心对称的，先处理中间</p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{aSd}|\mathrm{aAd} \quad \mathrm{A} \rightarrow \mathrm{bAc}|\mathrm{bc}\)</span></p><p><span class="math inline">\(\mathrm{L}_2{}^=\left\{\mathrm{a}^{\mathrm{n}} b^{\mathrm{n}}\mathrm{c}^{\mathrm{m}} \mathrm{d}^{\mathrm{m}} \mid \mathrm{n}\geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.m\geqslant 1\right\}\)</span></p><p>轴对称的，先处理两边</p><p><span class="math inline">\(\mathrm{S} \rightarrow \mathrm{AB} \quad\mathrm{A} \rightarrow \mathrm{aAb}|\mathrm{ab} \quad \mathrm{B}\rightarrow \mathrm{cBd}| \mathrm{cd}\)</span></p><p><span class="math inline">\(\mathrm{L}_3{}^{\prime}=\left\{\mathrm{a}^{\mathrm{n}} \mathrm{b}^{\mathrm{n}} \mid\mathrm{n} \geq 1\right\}\)</span></p><p><span class="math inline">\(\mathrm{S} \rightarrow \mathrm{aSb} \mid\mathrm{ab}\)</span></p><p>PS：证明<span class="math inline">\(\mathrm{L}_3{}^{\prime}\)</span>不能用正则表达式表示</p><p>可以考虑证明它不能使用DFA进行表示。证明的关键就是定义”DF“(确定，有穷):</p><p>假定存在DFA D接受 <span class="math inline">\(\mathrm{L}_3{}^{\prime}\)</span>, 其状态数为 <span class="math inline">\(k\)</span>(有穷)。 设状态 <span class="math inline">\(\mathrm{s}_0, \mathrm{~s}_1, \ldots,\mathrm{s}_{\mathrm{k}}\)</span> 为读入 <span class="math inline">\(\varepsilon, \mathrm{a}, \mathrm{aa}, \ldots,\mathrm{a}^{\mathrm{k}}\)</span> 后的状态 <span class="math inline">\(\Rightarrow \mathrm{s}_{\mathrm{i}}\)</span>为读入 <span class="math inline">\(\mathrm{i}\)</span> 个 <span class="math inline">\(\mathrm{a}\)</span> 达到的状态 <span class="math inline">\((0 \leqslant \mathrm{i} \leqslant\mathrm{k})\)</span> 总状态数 <span class="math inline">\(\mathrm{k}\rightarrow \mathrm{s}_0, \mathrm{~s}_1, \ldots,\mathrm{s}_{\mathrm{k}}\)</span> 中至少有两个相同状态, 不妨设为 <span class="math inline">\(s_i 、 s_j ， i&lt;j\)</span></p><p><span class="math inline">\(a^i b^i \in L_3 \rightarrow \Rightarrows_i\left(s_j\right)\)</span> 到终态路径标记为 <span class="math inline">\(b^i\)</span> <span class="math inline">\(\rightarrow\)</span> 初态 <span class="math inline">\(\rightarrow\)</span> 终态还有标为 <span class="math inline">\(a^i b^i\)</span> 的路径 <span class="math inline">\(\rightarrow D\)</span> 接受 <span class="math inline">\(a^i b^i\)</span>, 与”D(确定)“矛盾！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20221201120132392020_526_image-20221115103746485.png" alt="image-20221115103746485"><figcaption aria-hidden="true">image-20221115103746485</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MLP_BP反向传播</title>
    <link href="/posts/43013/"/>
    <url>/posts/43013/</url>
    
    <content type="html"><![CDATA[<h1 id="mlp_bp反向传播">MLP_BP反向传播</h1><p>写在前面：我觉得正确结果的形式可能不太应该这么复杂。仅供参考，也欢迎交流。</p><h2 id="实验要求">实验要求</h2><p>以三层感知机为例，使用反向传播算法更新MLP的权重和偏置项。</p><p>Define <span class="math inline">\(S_w\)</span> and <span class="math inline">\(S_b\)</span> as: <span class="math display">\[\begin{aligned}&amp;S_w=\sum_{c=1}^C \sum_{\boldsymbol{y}_i^M \inc}\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)^T\\&amp;S_b=\sum_{c=1}^Cn_c\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)^T\end{aligned}\]</span> where <span class="math inline">\(m_c^M\)</span> is the meanvector of <span class="math inline">\(\boldsymbol{y}_i^M\)</span> (theoutput of the <span class="math inline">\(i\)</span> th sample from thecth class), <span class="math inline">\(\boldsymbol{m}^M\)</span> is themean vector of the output <span class="math inline">\(\boldsymbol{y}_i^M\)</span> from all classes,<span class="math inline">\(n_c\)</span> is the number of samples fromthe cth class. Define the discriminative regularization term <span class="math inline">\(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\)</span>and incorporate it into the objective function of the MLP: <span class="math display">\[E=\sum_i \sum_j \frac{1}{2}\left(\boldsymbol{y}_{i,j}^M-\boldsymbol{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\right).\]</span></p><h2 id="符号说明">符号说明</h2><p>以经典的手写体识别任务为例，说明本次实验推导所用符号的含义：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20221124231353617444_705_image-20221124210535110.png" alt="image-20221124210535110"><figcaption aria-hidden="true">image-20221124210535110</figcaption></figure><p>其中<span class="math inline">\(\sigma\)</span>为激活函数，此处使用sigmoid函数即</p><p><span class="math display">\[\sigma(x)=\frac{1}{1+e^{-x}}\]</span> 导函数为 <span class="math display">\[\sigma^{\prime}(x)=\sigma(x)(1-\sigma(x))\]</span></p><h2 id="对正则项的理解">对正则项的理解</h2><p>首先我们看到，这个题目中的正则项不同于常见的L1正则项或者L2正则项。那么它代表什么含义，又是怎么起到正则化的作用的呢？</p><p>在了解了线性判别分析之后，发现这个正则项与线性判别分析中所谓的”类内散度矩阵“和”类问散度矩阵"非常相似。而线性判别分析的核心思想便是”类内方差小、类间间隔大“，在这里也是如此。<span class="math display">\[\begin{aligned}&amp;S_w=\sum_{c=1}^C \sum_{\boldsymbol{y}_i^M \inc}\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)^T\\&amp;S_b=\sum_{c=1}^Cn_c\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)^T\end{aligned}\]</span> <span class="math display">\[E=\sum_i \sum_j \frac{1}{2}\left(\boldsymbol{y}_{i,j}^M-\boldsymbol{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\right).\]</span></p><p>从损失函数可以看出，，我们希望让类内散度矩阵<span class="math inline">\(S_w\)</span>尽可能小，即同一类的样本尽量预测结果一致；同时<span class="math inline">\(S_b\)</span>是类间散度矩阵，我们希望让它尽可能大，以让模型更好的”区别“开不同的样本。</p><p>为了下面分析的方便，对损失函数进行拆解。</p><p>容易证明，对于两个阶数都是 <span class="math inline">\(m \timesn\)</span> 的矩阵 <span class="math inline">\(\boldsymbol{A}_{m \timesn}, \boldsymbol{B}_{m \times n}\)</span>, 其中一个矩阵乘以另一个矩阵的转置的迹, 本质是 <span class="math inline">\(\boldsymbol{A}_{m \times n}, \boldsymbol{B}_{m\times n}\)</span> 两个矩阵对应位置的元素相乘并相加,可以理解为向量的点积在矩阵上的推广, 即: <span class="math display">\[\begin{aligned}\operatorname{tr}\left(\boldsymbol{A} \boldsymbol{B}^T\right)&amp;=a_{11} b_{11}+a_{12} b_{12}+\cdots+a_{1 n} b_{1 n} \\&amp;+a_{21} b_{21}+a_{22} b_{22}+\cdots+a_{2 n} b_{2 n} \\&amp;+\cdots \\&amp;+a_{m 1} b_{m 1}+a_{m 2} b_{m 2}+\cdots+a_{m n} b_{m n}\end{aligned}\]</span>则对于题中的列向量也是如此，在损失函数中表现为各元素的平方和。</p><p>由此可以得到单个样本单个特征的损失函数: <span class="math display">\[E_{ij}=\frac{1}{2}\left({y}_{i, j}-{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left[\left({y}_{i,j}-{m}_{c,j}\right)^2-\left({m}_{c,j}-m_j\right)^2\right]\]</span></p><p>对此公式符号的含义进行如下直观解释:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20221124231357983833_279_image-20221124230019479.png" alt="image-20221124230019479"><figcaption aria-hidden="true">image-20221124230019479</figcaption></figure><p>注：上图所指<span class="math inline">\(j\)</span>也为<span class="math inline">\(3\)</span>；<span class="math inline">\(m_j\)</span>表示第<span class="math inline">\(j\)</span>类上的预测值在所有样本上的平均。 ##梯度下降求解</p><h3 id="目标">目标</h3><p>首先我们需要清楚反向传播的目的：我们希望根据模型在样本上的表现结果调节模型，最小化损失函数以让其其在训练集上的表现更好。</p><p>具体到神经网络，我们需要调节的是每一条边对应的权重或偏置，依据是损失函数对该层权重的偏导。直观一点说，偏导反映的是参数的微小变化对损失的影响。我们希望最小化损失函数，那么比如如果求出来对权重的偏导是正的，那么说明损失函数随权重增大而增大，那么就要让权重变小一点。</p><p>因此我们更新参数的方式如下： <span class="math display">\[\begin{aligned} W^{(l)} &amp;=W^{(l)}-\frac{\alpha}{d }\frac{\partialE}{\partial W^{(l)}}\\ \boldsymbol b^{(l)} &amp;=\boldsymbolb^{(l)}-\frac{\alpha}{d}\frac{\partial E}{\partial b^{(l)}}\end{aligned}\tag{1}\]</span> 其中<span class="math inline">\(l\)</span>是权重和偏置所在的层数，对于三层感知机<span class="math inline">\(l=1,2\)</span>。<span class="math inline">\(\alpha\)</span>为学习率。 <span class="math inline">\(d\)</span>为整个训练集大小，比如对于MNIST这个值为60000。</p><h3 id="偏导求解">偏导求解</h3><p>在上面定义了对于单个样本单个特征的损失函数。下面为简化叙述，采用逐样本进行偏导的求解。根据题目的含义我们应该是使用<strong>批量梯度下降法</strong>进行更新，此时将对每个样本求得的偏导加起来求得总的<span class="math inline">\(E\)</span>带入<span class="math inline">\((1)\)</span>中即可。</p><p>也就是 <span class="math display">\[E_i=\sum_{j=1}^{c} E_{ij}\\E=\sum_{i=1}^{d} E_{i}\]</span></p><p><span class="math inline">\(c\)</span>为类的个数，比如手写体识别中为10，数字<span class="math inline">\(j\)</span>对应于类<span class="math inline">\(j+1\)</span>。</p><p>阅读下面的求解过程时建议将下图固定在屏幕上。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20221124231401909241_717_image-20221124210539379.png" alt="image-20221124210539379"><figcaption aria-hidden="true">image-20221124210539379</figcaption></figure><h4 id="最后一层">最后一层</h4><p>从总体来看，对于最后一层的某个边<span class="math inline">\(w_{jk}\)</span>的权重更新是比较容易进行的。如图所示，<span class="math inline">\(j=1,2...c\)</span>，<span class="math inline">\(c\)</span>为类别的个数。<span class="math inline">\(k=1,2...h\)</span>，<span class="math inline">\(h\)</span>为隐层包含的神经元个数。</p><p>由链式法则，有：</p><p><span class="math display">\[\frac{\partial E_i}{\partial w_{jk}}=\frac{\partial z_{i,j}}{\partial w_{jk}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\]</span>由于符号定义中第三层的神经元能够比较好的和第二层的区别开，故省略了表示层数的上标；而<span class="math inline">\(z\)</span>和<span class="math inline">\(a\)</span>的取值与均与特定的样本有关，故都保留了表示样本的下角标<span class="math inline">\(i\)</span>。</p><p>我们仍旧可以直观的理解链式法则对应于参数更新的含义。我们要求的是损失函数<span class="math inline">\(E_i\)</span>对<span class="math inline">\(w_{jk}\)</span>的敏感程度，而<span class="math inline">\(w_{jk}\)</span>能够直接影响的是<span class="math inline">\(z_{ij}\)</span>，<span class="math inline">\(z_{i,j}\)</span>影响<span class="math inline">\(y_{ij}\)</span>，<span class="math inline">\(y_{i,j}\)</span>才直接影响到损失函数。因此需要借助链式法则将这个”影响链“串起来。</p><p><span class="math inline">\(z_{i,j}\)</span>取决于第二层所有神经元，但我们只需要关注与正在求偏导的边相关的节点：<span class="math display">\[z_{i,j}=\cdots+w_{j k} a_k+\cdots\]</span> 故有 <span class="math display">\[\frac{\partial z_{i,j}}{\partial w_{jk}}=a_{i,k}\]</span> <span class="math inline">\(y_{i,j}=\sigma\left(z_{ij}\right)\)</span>，因此<span class="math inline">\(\frac{\partial y_{i,j}}{\partial z_{i,j}}\)</span> 就等于激活函数的导数，即<span class="math inline">\({\sigma}’\left(z_{i,j}\right)\)</span>。重点是最后一项：<span class="math display">\[\frac{\partial E_i}{\partial y_{i,j}}=\frac{\partial{(\sum_{p=1}^{c}}E_{ip})}{\partial y_{i,j}}\]</span> 而 <span class="math display">\[E_{ip}=\frac{1}{2}\left({y}_{i,p}-{d}_{i, p}\right)^2+\frac{1}{2}\gamma\left[\left({y}_{i,p}-{m}_{c,p}\right)^2-\left({m}_{c,p}-m_p\right)^2\right]\]</span> <span class="math inline">\(E_{ip}\)</span>中包含<span class="math inline">\(E_{ij}\)</span>，而且我们只关心<span class="math inline">\(E_{ij}\)</span>。<span class="math inline">\(E_{ij}\)</span>里面自然有一个<span class="math inline">\(y_{ij}\)</span>。不仅如此，别忘了<span class="math inline">\({m}_{c,j}\)</span>和<span class="math inline">\(m_j\)</span>也都是与<span class="math inline">\(y_{ij}\)</span>相关的变量，比如 <span class="math display">\[{m}_{c,j}=\frac{1}{n_c}\sum_{N=1}^{n_c}{y}_{N,j}\]</span> <span class="math inline">\(c_N\)</span>是这个样本所属的类在训练集中的数目，比如这个样本实际上是个"3"，那么<span class="math inline">\(c_N\)</span>就是训练集中"3"的数目。</p><p><span class="math inline">\({y}_{i, j}\)</span>自然对应<span class="math inline">\({y}_{N, j}\)</span>中的某一个。因此 <span class="math display">\[\frac{\partial {m}_{c,j}}{\partial y_{ij}}=\frac{1}{n_c}\]</span></p><p>同样的， <span class="math display">\[{m}_{j}=\frac{1}{d}\sum_{N=1}^{d}{y}_{N, j}\\\frac{\partial {m}_{j}}{\partial y_{ij}}=\frac{1}{d}\]</span> <span class="math inline">\(d\)</span>是训练集中样本数目。</p><p>由此我们可以继续求解：</p><p><span class="math display">\[\begin{align}\frac{\partial E_i}{\partialy_{i,j}}&amp;=\frac{\partial{(\sum_{p=1}^{c} }E_{ip})}{\partialy_{ij}}=\frac{\partial{E_{ij} }}{\partial y_{ij}}\\&amp;={y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]    \end{align}\]</span></p><p>将上面求得的结果代入对<span class="math inline">\(w_{jk}\)</span>求偏导的式子中： <span class="math display">\[\begin{align}\frac{\partial E_i}{\partial w_{jk}}&amp;=\frac{\partial z_{i,j}}{\partial w_{jk}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\\&amp;=a_{i,k}\;{\sigma}’\left(z_{i,j}\right)\;\left \{ {y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]\right\}    \end{align}\]</span>最后，如果我们想要进行批量梯度下降，需要将所有训练集中样本的损失函数加起来求平均，进行一次更新：<span class="math display">\[\begin{align}\frac{\partial E}{\partial w_{jk}}&amp;=\sum_{i=1}^{d}\frac{\partial E_i}{\partial w_{jk}}\\&amp;=\sum_{i=1}^{d}a_{i,k}\;{\sigma}’\left(z_{i，j}\right)\;\left \{{y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]\right\}    \end{align}\]</span> 由于三个部分均与<span class="math inline">\(i\)</span>有关，所以没有可以提取的公因子，需要逐项累加。并且该式子与第<span class="math inline">\(i\)</span>个样本所属类有关，因此也要根据样本情况代入相应的的<span class="math inline">\(n_c\)</span>和</p><p><span class="math inline">\(m_{c,j}\)</span>。</p><p>此时我们就可以代入<span class="math inline">\((1)\)</span>式(更新参数的方式)中，进行每条权重边的更新了。</p><p>对于最后一层的<span class="math inline">\(b_j\)</span>对应偏置的边求解的方式和<span class="math inline">\(w_{jk}\)</span>类似。 <span class="math display">\[\frac{\partial E_i}{\partial b_{j}}=\frac{\partial z_{i,j}}{\partial b_{j}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\]</span> <span class="math inline">\(\frac{\partial z_{i,j}}{\partialb_{j}}=b^{(2)}\)</span>，<span class="math inline">\(\frac{\partialy_{i,j}}{\partial z_{i,j}}\)</span>和<span class="math inline">\(\frac{\partial E_i}{\partialy_{i,j}}\)</span>已经求得，代入即可。</p><h4 id="倒数第二层">倒数第二层</h4><p>倒数第二层某一条权重边记为<span class="math inline">\(w_{kn}\)</span>。 <span class="math display">\[\frac{\partial E_i}{\partial w_{kn}}=\frac{\partial z_{i,k}}{\partial w_{kn}}\frac{\partial a_{i,k}}{\partial z_{i,k}}\frac{\partial E_i}{\partial a_{i,k}}\]</span></p><p>重点是<span class="math inline">\(\frac{\partial E_i}{\partiala_{i,k}}\)</span>。它通过影响最后一层的所有节点去影响最终的损失函数。<span class="math display">\[\frac{\partial E_i}{\partial a_{i,k}}=\underbrace{\sum_{p=1}^{c}\frac{\partial z_{i,j}}{\partial a_{i,k}} \frac{\partialy_{i,j}}{\partial z_{i,j}} \frac{\partial E_i}{\partial y_{i,j}}}_{\text{Sum over the output layer }}\]</span> 不同于<span class="math inline">\(z_{i,k}\)</span>，<span class="math inline">\(z_{i,j}\)</span>自然是指最后一层的线性变换。</p><p><span class="math inline">\(\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\)</span>我们前面已经求得了。<span class="math inline">\(\frac{\partial z_{i,j}}{\partiala_{i,k}}=w_{jk}\)</span>。</p><p>根据递推关系其实也没有很复杂。</p><p>前面两项非常容易求得： <span class="math display">\[\frac{\partial a_{i,k}}{\partial z_{i,k}}=\sigma’\left(z_{i,k}\right)\\\frac{\partial z_{i,k}}{\partial w_{kn}}=x_{i,n}\]</span></p><p>同样的，各个样本上的偏导累加并求平均，然后设置学习率进行梯度下降更新参数即可。<span class="math display">\[\frac{\partial E_i}{\partial b_{k}}=\frac{\partial z_{i,k}}{\partial b_{k}}\frac{\partial a_{i,k}}{\partial z_{i,k}}\frac{\partial E_i}{\partial a_{i,k}}\]</span> <span class="math inline">\(\frac{\partial z_{i,k}}{\partialb_{k}}=b^{(1)}\)</span>，其余部分也都已经知道了，因此代入即可按同样的方式更新<span class="math inline">\(\boldsymbol b\)</span>。</p><p>至此，所有的权重和偏置项都已经更新完毕。</p><h2 id="思考">思考</h2><p>这个正则项与线性判别分析一样，思路很自然，数学表达也很严谨，确远不如L1或L2正则项用的广泛。虽然并没有基于此做过实验，但从推导的过程可以看到，相比L1或L2正则项直接对权重矩阵的范数求导，计算量明显要大的多。比如至少要预先把预测每一类对应的样本数和样本向量均值算出来，在求偏导时也要判断是属于哪一类，对性能肯定是有所损耗。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-书面作业1</title>
    <link href="/posts/54831/"/>
    <url>/posts/54831/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-书面作业1">计算机网络-书面作业1</h1><p>2013599_田佳业</p><h3 id="第一章问题">第一章问题</h3><p>网络结构如下图所示，主机A与主机B之间通过两段链路和一台转发设备R进行连接，每条链路的长度和传输速率已经在图中标出，R采用存储转发机制。主机A向主机B发送一个长度为10000字节的报文，请回答以下问题（设电磁波传播速度为2*108米/秒）</p><ol type="1"><li><p>如果采用报文交换，请计算端到端的最小时延，即从主机A传输报文的第一位开始，到主机B接收到报文的最后一位为止所用的时间。</p></li><li><p>如果将报文分成5个报文分组传输，请计算完成报文传输的最小端到端时延（忽略报文分组的封装开销）。</p></li></ol><p>在统计多路复用机制中，端到端的时延具有不确定性，请简要分析影响端到端时延的主要因素。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120095815944612_600_clip_image002.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p><span class="math display">\[\mathrm{Latency_1 = PROP + TRANSP}=\frac{(4+2)\times 10^3}{2 \times10^{8}}+\frac{10^{4} \times 8}{100\times 10^6}+\frac{10^{4} \times8}{10\times 10^6}\\=3\times 10^{-5}+8\times 10^{-4}+8\times 10^{-3}=8.83\times 10^{-3}\]</span> 可以看到传播速率主要取决于链路2的传输速度。</p></li><li></li></ol><p><span class="math display">\[\mathrm{Latency_2} =\mathrm{Latency_1}-\frac{4}{5}\frac{10^{4} \times8}{100\times 10^6}=8.19\times 10^{-3}\]</span>为什么可以这么算?因为中转路由器在接收所有分组后第一个分组还没有在链路2上传完，所以只能节省等四个分组的时间。</p><p>从这个问题可以看出，端到端时延的除了受链路长度客观限制影响以外，更多的不确定性来源于网络的拥塞程度，并且受瓶颈链路影响非常大。</p><h3 id="第二章问题">第二章问题</h3><h6 id="section">1.</h6><p>通过使用Windows命令行模式提供的nslookup命令查询www.baidu.com的IP地址，给出结果截图，并对返回的结果进行解释。同时，利用Wireshark捕获查询的交互过程，给出结果截图，并进行简要说明。</p><ol type="1"><li></li></ol><p>nslookup命令用于<strong>查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题</strong></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120095816836309_574_image-20221115205303473.png" alt="image-20221115205303473"><figcaption aria-hidden="true">image-20221115205303473</figcaption></figure><p>服务器为本机DNS服务器信息，Address表示的是 DNS 服务器地址。</p><p>非权威应答表示，非从域名的权威服务器获得结果，而是从本地DNS缓存中获取的结果</p><p>www.a.shifen.com是百度域名曾经的一个别名，<code>shifen.com</code>和<code>baidu.com</code>两台域服务器其实是同一台服务器。</p><p>下面的Address便是百度域名对应的ip地址。以第一个为例，搜索一下看看:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120095817744460_340_image-20221115210510064.png" alt="image-20221115210510064"><figcaption aria-hidden="true">image-20221115210510064</figcaption></figure><ol start="2" type="1"><li></li></ol><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120095840824680_626_image-20221115211104602.png" alt="image-20221115211104602"><figcaption aria-hidden="true">image-20221115211104602</figcaption></figure><p>输入dns进行过滤，可以看到解析百度时的报文发送和应答，对应左边灰色的箭头。</p><p>可以看出 ，DNS 为应用层协议 ，下层传输层采用 UDP ，再下层网络层是IPV4 协议 。</p><p>下面结合DNS报文格式进行分析:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120095842598552_479_image-20221115211202585.png" alt="image-20221115211202585"><figcaption aria-hidden="true">image-20221115211202585</figcaption></figure><p>本机(10.130.93.171是WLAN的IPv4地址)首先向服务器发出查询请求 ，然后服务器解析 IP 找到主机 ，做出响应 。接着 ，主机向服务器发送查询www.baidu.com信息的对应请求，服务器接受到请求后作出响应。并且可以看到回应的报文Answers区域报文包括的内容未必是等长，格式相同的。每一个回答反映一部分需要的信息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120095845117430_948_image-20221115211646689.png" alt="image-20221115211646689"><figcaption aria-hidden="true">image-20221115211646689</figcaption></figure><p>资源记录结构如下所示:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120100009402791_134_image-20221115220024906.png" alt="image-20221115220024906"><figcaption aria-hidden="true">image-20221115220024906</figcaption></figure><p>比如图中的A对应将名称对应到IPv4的32位地址。</p><h6 id="section-1">2.</h6><p>以反复解析为例，说明域名解析的基本工作过程（可以结合图例）。给出内容分发网络（CDN）中DNS重定向的基本方法，说明原始资源记录应该如何修改，并描述重定向过程。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120100010926561_580_image-20221115222340231.png" alt="image-20221115222340231" style="zoom: 67%;"></p><p>1.2.首先查本地缓存，如果没有记录，则以DNS客户的身份向根域名服务器发出解析请求(2)，如果有直接将IP地址返回请求主机(实验操作中的情况，对应图中的8)</p><p>3.根域名服务器收到请求后，判断该域名属于.com域，将对应的TLD(顶级域名服务器，此处为.com)的IP地址返回给本地域名服务器。4.本地域名服务器再次请求</p><p>5.TLD收到请求后，判断该域名属于baidu.com域，因此将对应的授权域名服务器baidu.com的IP地址返回给本地域名服务器。</p><p>6.向百度的顶级域名服务器baidu.com.请求www.baidu.com。</p><p>7.返回ip地址</p><p>8.本地域名服务器把结果返回客户机并缓存</p><p>当然对于百度这个例子，它发现这个www有别名叫www.a.shifen.com。</p><p>拿到www.baidu.com的别名www.a.shifen.com的时候，本来要重新到com域查找shifen.com的NS，又因为，两个域在同一台NS上，所以直接向本机(授权域名服务器)发起了shifen.com域的查找请求，把a.shifen.com的IP返回。</p><h6 id="section-2">3.</h6><p>在DNS域名系统中，域名解析时使用UDP协议提供的传输层服务（DNS服务器使用UDP的53端口），而UDP提供的是不可靠的传输层服务，请你解释DNS协议应如何保证可靠机制。</p><p>首先，查阅了解了为什么DNS使用UDP:其实感性上就可以理解，DNS并不需要TCP所提供的全部可靠性机制，而TCP会相比UDP耗费更多的资源。当然，其实DNS在设计之初就在区域传输中引入了 TCP 协议。</p><p>关于如何保证可靠性，主要有以下几个方面:</p><p>从DNS应用层本身来说，首先报文中问题的数量、回答的数量，就可以可以用来进行一定的校验，同时DNS也是有生存周期的，在生命周期过后会进行重新请求更新以保证数据的正确性.</p><p>从可用性上来说，DNS的权威服务器也是冗余支持的.</p><p>从安全性上来说，DNS脆弱性主要有两个可能的方面:一是课本中提到的DDoS攻击，当然由于缓存机制的存在很难造成实质性的危害;另外更常见的是针对缓存进行欺骗的所谓投毒攻击，现在也有DNS安全扩展 (<a href="https://cloud.google.com/dns/docs/dnssec?hl=zh-cn">DNSSEC</a>)对其进行保护。</p><p>当然以上几个方面和TCP从协议层面上保证的可靠性肯定不能等同而论，但足以满足实际应用是需求。</p><h6 id="捎带复习一下域名格式压缩">捎带复习一下域名格式压缩</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120100012567584_212_image-20221115230206425.png" alt="image-20221115230206425"><figcaption aria-hidden="true">image-20221115230206425</figcaption></figure><p>"11"指字节的前两位</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20221120100014215164_756_image-20221115230406295.png" alt="image-20221115230406295"><figcaption aria-hidden="true">image-20221115230406295</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.1-基于UDP服务设计可靠传输协议</title>
    <link href="/posts/24837/"/>
    <url>/posts/24837/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.1-基于udp服务设计可靠传输协议停等版本">计算机网络实验3.1-基于UDP服务设计可靠传输协议(停等版本)</h1><h2 id="实验要求">实验要求</h2><p>利用数据报套接字在用户空间实现面向连接的可靠数据传输，功能包括：建立连接、差错检测、确认重传等。流量控制采用停等机制，完成给定测试文件的传输。</p><h2 id="程序流程展示">程序流程展示</h2><h3 id="协议设计">协议设计</h3><p>在本次实验中采用基于rdt3.0的协议设计。</p><h4 id="报文结构">报文结构</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192011936961_320_image-20221119150328876.png" alt="image-20221119150328876"><figcaption aria-hidden="true">image-20221119150328876</figcaption></figure><p>如图所示，报文头长度共<code>128Bits</code>。下面介绍报文结构设计的思路。</p><p>首先，注意到我们的实验只需要从客户端到服务器单向传输数据，因此我们事实上整个实验只需要一个序列号字段即可满足需求。对于发送端对应<code>TCP</code>中的<code>seq</code>,接收端对应<code>TCP</code>中的<code>ack</code>。</p><p>下面是十六位校验和以及数据报字段长度，与<code>TCP</code>相同。</p><p>目前使用<code>u_short</code>来存放<code>flag</code>。其字段含义如下：</p><p><code>F</code>:<code>FIN</code></p><p><code>S</code>:<code>SYN</code></p><p><code>A</code>:<code>ACK</code></p><p><code>H</code>:<code>FILE_HEAD</code></p><p><code>FILE_HEAD</code>用于指示接收端此报文包含文件信息的字段。</p><p><code>window_size</code>本次实验还没有用到。</p><p><code>option</code>为可选字段，在本次实验中暂时用于存放文件名。</p><p><code>data</code>的最大长度可以调节，本次实验定义为1024字节。</p><p>此部分定义代码段如下;</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m73y9plb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-m73y9plb4jx62r"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 1024</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA 0x0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIN 0x1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYN 0x2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK 0x4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_SYN 0x6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_FIN 0x5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_HEAD 0x8</span><span class="hljs-comment">// datagram format:</span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet_head</span> {    u_int seq;    u_short check_sum;    u_short data_size;    u_short flag;    u_short window_size;    u_int option;    <span class="hljs-built_in">packet_head</span>() {        seq = <span class="hljs-number">0</span>;        check_sum = <span class="hljs-number">0</span>;        data_size = <span class="hljs-number">0</span>;        flag = <span class="hljs-number">0</span>;        window_size = <span class="hljs-number">0</span>;        option = <span class="hljs-number">0</span>;    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet</span> {    packet_head head;    <span class="hljs-type">char</span> data[MAX_SIZE]{};    <span class="hljs-built_in">packet</span>() {        <span class="hljs-built_in">packet_head</span>();        <span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0</span>, MAX_SIZE);    }};<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span></code></pre></div></div><p><code>#pragma pack(1)</code>用于指示结构体内容按1Byte对齐，以保证报文大小是我们期望的紧凑形式。</p><h4 id="建连和断连">建连和断连</h4><p>依然是注意到单向传输的特点，对握手和挥手的过程也进行了优化：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192018406166_865_image-20221119154308774.png" alt="image-20221119154308774"><figcaption aria-hidden="true">image-20221119154308774</figcaption></figure><p>左边是TCP三次握手的过程，右侧是我为本次实验设计的握手过程。</p><p>TCP第三次握手的目的是“server”需要知道“client”能够收到他的应答。这在server向client发送数据时是有必要的，而本次实验只要发送端知道接收端能发能收，就可以放心的向其发送文件，握手成功。</p><p>接收端在收到发送端的握手信息后就可以准备好接受文件了。此时接收端预料的应当是发送端发送文件信息。但是这时候如果发送端断线了，接收端显然不能干等着，否则在真实情景下完全可以发起类似SYN洪泛攻击的行为。因此我们需要设置定时器，如果在这段时间发送端没有任何信息发来，这时应当释放资源并退出。在此次实验中这个最大时间设置的是1min。</p><p>同时，虽然此次实验假设接收端向发送端发送数据丢包率为0，但是在实验中仍旧考虑了这种情况：如果接收端的ACK丢了，会发生什么情况？因此在接收端准备接受文件时，仍旧检查收到的是否是握手信息。如果是握手信息，那么重置上述提到的定时器，仍旧停留在等待文件信息的状态。</p><p>断连的过程和上述分析类似，也是只需要两次即可。</p><p>另外，不需要文件结束位的原因是因为接受者在得到文件信息的时候就知道文件大小，从而知道有几个数据包，什么时候结束。</p><h3 id="流程设计">流程设计</h3><p>程序支持一次建连发送多个文件。</p><h4 id="服务器">服务器</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192021770008_725_image-20221119162017409.png" alt="image-20221119162017409"><figcaption aria-hidden="true">image-20221119162017409</figcaption></figure><h4 id="客户端">客户端</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192117915929_703_image-20221119162044532.png" alt="image-20221119162044532"><figcaption aria-hidden="true">image-20221119162044532</figcaption></figure><p>发送文件数据时遵循rdt3.0的整个过程，也即，在这次实验中序列号暂时只用到0和1。</p><h2 id="程序代码解释">程序代码解释</h2><h3 id="文件发送过程">文件发送过程</h3><h5 id="发送端">发送端</h5><p>首先对照发送端的状态机进行分析： <img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192126693722_492_image-20221119162927049.png" alt="image-20221119162927049">程序中的函数名与状态机中名称基本一致，思路也非常清晰。主要的变动为把<code>waitACK0</code>和<code>waitACK1</code>合并到了函数中，而不是作为单独的状态出现。这样做的原因是由于握手和挥手阶段的等待过程和文件传输过程中完全一致，通过相同发代码能够将过程统一起来。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4akjv5lb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-4akjv5lb4jx62r"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(pkt_no&lt;pkt_total){    pkt_data_size=<span class="hljs-built_in">min</span>(MAX_SIZE,file_len-pkt_no*MAX_SIZE);    <span class="hljs-keyword">switch</span>(stage)    {        <span class="hljs-keyword">case</span> SEND0:        {            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(DATA, <span class="hljs-number">0</span>, pkt_data_size, file_data + pkt_no * MAX_SIZE);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_ACK0</span>(sndpkt)) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed when sending packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no), ERR);                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            }            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no)+<span class="hljs-string">" with seq 0"</span>, DEBUG);            pkt_no++;            stage = SEND1;            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">case</span> SEND1:        {            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(DATA, <span class="hljs-number">1</span>, pkt_data_size, file_data + pkt_no * MAX_SIZE);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_ACK1</span>(sndpkt)) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed when sending packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no), ERR);                <span class="hljs-keyword">break</span>;            }            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no)+<span class="hljs-string">" with seq 1"</span>, DEBUG);            pkt_no++;            stage=SEND0;            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;    }}</code></pre></div></div><p>下面是<code>waitACK</code>相关函数的实现，以<code>waitACK0</code>为例：</p><p>首先由于需要处理超时事件，发送端和接收端所有的·<code>socket</code>都是非阻塞状态的。对于发送端<code>while</code>条件中的<code>rdt_rcv</code>是非阻塞的，以便在循环内判断超时进行消息重发。当没有收到消息时返回0，收到消息时返回1。循环内的重发若超过一定次数（<code>MAX_RESEND_TIMES</code>,其值为10），便可认为接收端由于意外断连，不再向其发送消息，程序退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jqb8w8lb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-jqb8w8lb4jx62r"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait_ACK0</span><span class="hljs-params">(packet sndpkt)</span> </span>{    <span class="hljs-type">int</span> resend_times = <span class="hljs-number">0</span>;    <span class="hljs-comment">//start a timer</span>    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();    packet rcvpkt;    <span class="hljs-comment">//non-blocking receive here</span>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">rdt_rcv</span>(rcvpkt) || <span class="hljs-built_in">isACK</span>(rcvpkt, <span class="hljs-number">1</span>)||<span class="hljs-built_in">corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timeout</span>(start)) {            <span class="hljs-built_in">udt_send</span>(sndpkt);            start = <span class="hljs-built_in">clock</span>();            <span class="hljs-keyword">if</span> (resend_times &gt; MAX_RESEND_TIMES) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend times exceed the limit, there must be something wrong with the network"</span>, ERR);                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend packet with seq 0"</span>, WARNING);                resend_times++;            }        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isACK</span>(rcvpkt, <span class="hljs-number">1</span>)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received ACK1, discard it"</span>, DEBUG);        }    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</code></pre></div></div><p><code>rdt_rcv(rcvpkt)</code>实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1uvh2rlb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-1uvh2rlb4jx62r"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rdt_rcv</span><span class="hljs-params">(packet &amp;packet1)</span> </span>{    <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(addr_server);    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recvfrom</span>(socket_sender, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;len);    <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }    <span class="hljs-keyword">return</span> ret != <span class="hljs-number">0</span>;}</code></pre></div></div><h5 id="接收端">接收端</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192129767531_984_image-20221119163135874.png" alt="image-20221119163135874"><figcaption aria-hidden="true">image-20221119163135874</figcaption></figure><p>与发送端有所不同，这里的<code>rdt_rcv(rcvpkt)</code>是阻塞的，内含一个非阻塞的<code>recvfrom</code>进行循环接收。若超时（一分钟）仍未收到消息，认为发送端可能意外退出，跳出接收循环，并随后判断文件是否完整接收，以作退出之前的保存和清理工作。这样设计的原因也是在握手和挥手时不依赖其他条件的需要同样的操作，能够较好的统一起来。</p><p>其他部分与状态机中一致。在循环内部需要判断接收到的文件是否已经完全接受，若接受完毕保存文件并退出，准备继续接受下一个文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pvy9azlb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-pvy9azlb4jx62r"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq0</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (stage == WAIT0) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_no) + <span class="hljs-string">", with seq 0"</span>, DEBUG);                pkt_data_size = rcvpkt.head.data_size;                <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);                received_file_len += pkt_data_size;                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">0</span>);                <span class="hljs-built_in">udt_send</span>(sndpkt);                pkt_no++;                stage = WAIT1;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a packet with seq 0, but we are waiting for seq 1"</span>, WARNING);                <span class="hljs-keyword">continue</span>;            }        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq1</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (stage == WAIT1) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_no) + <span class="hljs-string">", with seq 1"</span>, DEBUG);                pkt_data_size = rcvpkt.head.data_size;                <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);                received_file_len += pkt_data_size;                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">1</span>);                <span class="hljs-built_in">udt_send</span>(sndpkt);                pkt_no++;                stage = WAIT0;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a packet with seq 1, but we are waiting for seq 0"</span>, WARNING);                <span class="hljs-keyword">continue</span>;            }        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (received_file_len == file_size) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received file successfully"</span>, SUC);        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Time used: "</span> + <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">clock</span>() - single_file_start) + <span class="hljs-string">"ms"</span>, INFO);        <span class="hljs-comment">//write the file to disk</span>        string file_path = <span class="hljs-built_in">get_file_path</span>(file_name);        <span class="hljs-function">ofstream <span class="hljs-title">file</span><span class="hljs-params">(file_path, ios::binary)</span></span>;        <span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">is_open</span>()) {            file.<span class="hljs-built_in">write</span>(file_buffer, file_size);            file.<span class="hljs-built_in">close</span>();            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File saved to "</span> + file_path, SUC);            new_file_received = <span class="hljs-literal">true</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed to open file "</span> + file_path, ERR);        }        <span class="hljs-keyword">break</span>;    }}</code></pre></div></div><p><code>rdt_rcv(rcvpkt)</code>的实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5f2119lb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-5f2119lb4jx62r"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rdt_rcv</span><span class="hljs-params">(packet &amp;packet1)</span> </span>{    <span class="hljs-type">clock_t</span> wait_file_start = <span class="hljs-built_in">clock</span>();    <span class="hljs-comment">//non-blocking receive here</span>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recvfrom</span>(socket_receiver, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;addr_len);    <span class="hljs-keyword">while</span> (ret == SOCKET_ERROR || ret == <span class="hljs-number">0</span>) {        <span class="hljs-comment">//no packet received</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">wait_file_timeout</span>(wait_file_start)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout, no packet received"</span>, ERR);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }        ret = <span class="hljs-built_in">recvfrom</span>(socket_receiver, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;addr_len);    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</code></pre></div></div><h3 id="握手和挥手过程">握手和挥手过程</h3><p>有了文件传输过程的分析，握手和挥手便很容易理解，因为实际上只是文件传输的特例。当然，由于握手和挥手的代码在传输之前完成，因此在编写代码时这一部分设计比较困难，后面完成传输过程时又对其进行了一些优化。</p><p>相比传输过程，握手和挥手主要是需要处理流程上的细节。</p><h4 id="握手">握手</h4><h5 id="发送端-1">发送端</h5><p>发送端握手很简单:把包发过去，等ACK，等不到就重发，重发多了就退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x7nd7clb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-x7nd7clb4jx62r"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">handshake</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//as the transmitting is single-direction, so we only need to "shake" two times</span>    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(SYN);    <span class="hljs-built_in">udt_send</span>(sndpkt);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">wait_SYN_ACK</span>();}</code></pre></div></div><h5 id="接收端-1">接收端</h5><p>接收端思路也很明确：“阻塞”等待发送端的握手信息（一分钟内等不到就退出），如果接收到就握手成功，收到错误的包（比如校验和错误）丢弃。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fptp0elb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-fptp0elb4jx62r"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">handshake</span><span class="hljs-params">()</span> </span>{    packet rcvpkt;    <span class="hljs-type">int</span> wrong_times = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Waiting for handshake"</span>, INFO);        <span class="hljs-comment">//blocking receive here</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSYN</span>(rcvpkt) &amp;&amp; <span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK_SYN);                <span class="hljs-built_in">udt_send</span>(sndpkt);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received wrong packet"</span>, ERR);                <span class="hljs-comment">//discard the packet and continue to wait</span>                <span class="hljs-keyword">if</span> (wrong_times &gt; MAX_WRONG_TIMES) {                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Wrong times exceed the limit, there must be something wrong with the network"</span>, ERR);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                } <span class="hljs-keyword">else</span> {                    wrong_times++;                    <span class="hljs-keyword">continue</span>;                }            }        }        <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//timeout</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    }}</code></pre></div></div><h4 id="挥手">挥手</h4><p>由上面的流程图所示，挥手过程仅应当发生在文件传输的间隔中。每次等待用户传送新文件时，用户有两种选择：传或不传。若传则发送文件信息，不传发送挥手信息。不管如何，这时接收端一定处在等待接收文件信息的阶段。</p><h5 id="发送端-2">发送端</h5><p>用户没有给出文件名或者选择放弃传送，仅以第一种调用情况为例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1q6ztnlb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-1q6ztnlb4jx62r"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (file_path.<span class="hljs-built_in">empty</span>()) {    <span class="hljs-comment">//close the connection</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bye_bye</span>();}</code></pre></div></div><p>挥手成功退出程序，流程结束。 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ffhpzmlb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-ffhpzmlb4jx62r"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bye_bye</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//send FIN</span>    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(FIN);    <span class="hljs-built_in">udt_send</span>(sndpkt);    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_FIN_ACK</span>()) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed to receive FIN ACK"</span>, ERR);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Connection closed elegantly, Task finished!"</span>, SUC);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }}</code></pre></div></div><p></p><h5 id="接收端-2">接收端</h5><p>首先需要介绍接收端等待文件信息的逻辑。如一开始的流程图所示，这发生在握手刚完成或文件传输间隙。如果此时无响应，说明发送端异常退出，接收端也应当退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ijvo19lb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-ijvo19lb4jx62r"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ready_for_file</span>(file_name, file_size)) {    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Exit because of no response"</span>,INFO);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>ready_for_file</code>的设计：</p><p>首先为了方便状态机设计，约定传送文件信息的报文序列是1。成功收到消息返回ACK。若收到握手消息，通过递归调用达到重置计时的作用。</p><p>在此过程中若发送方发送挥手消息，给予回应并退出程序，流程结束。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-emwjhtlb4jx62r"></i><span>C++</span><div class="collapse show" id="collapse-emwjhtlb4jx62r"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ready_for_file</span><span class="hljs-params">(string &amp;file_name, <span class="hljs-type">int</span> &amp;file_size)</span> </span>{    packet rcvpkt;    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Waiting for file info"</span>, INFO);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq1</span>(rcvpkt)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File name: "</span> + <span class="hljs-built_in">string</span>(rcvpkt.data), DEBUG);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File size: "</span> + <span class="hljs-built_in">to_string</span>(rcvpkt.head.option), DEBUG);            file_name = <span class="hljs-built_in">string</span>(rcvpkt.data);            file_size = rcvpkt.head.option;            string file_path = <span class="hljs-built_in">get_file_path</span>(file_name);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File will be saved to "</span> + file_path, DEBUG);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Ready to receive files"</span>, SUC);            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">1</span>);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSYN</span>(rcvpkt)) {            <span class="hljs-comment">//if the ack is lost, the sender will resend the SYN packet</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a SYN packet, reset the timer"</span>, WARNING);            <span class="hljs-comment">// wait for the file info again</span>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">ready_for_file</span>(file_name, file_size);        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFIN</span>(rcvpkt)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a FIN packet, close the connection"</span>, SUC);            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK_FIN);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a wrong packet"</span>, ERR);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout when waiting for file info"</span>, ERR);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }}</code></pre></div></div><h3 id="其他工具类">其他工具类</h3><h4 id="校验和">校验和</h4><p>由于此次实验并没有要求可变ip和端口号，因此不必加入伪首部的校验。编写代码如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kp1p5flb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-kp1p5flb4jx62r"><pre><code class="hljs c++"><span class="hljs-function">u_short <span class="hljs-title">check_sum</span><span class="hljs-params">(u_short *packet, <span class="hljs-type">int</span> packet_len)</span> </span>{    u_long sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// make 16 bit words adjacent</span>    <span class="hljs-type">int</span> count = (packet_len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">auto</span> *temp = <span class="hljs-keyword">new</span> u_short[count + <span class="hljs-number">1</span>];    <span class="hljs-built_in">memset</span>(temp, <span class="hljs-number">0</span>, count + <span class="hljs-number">1</span>);    <span class="hljs-built_in">memcpy</span>(temp, packet, packet_len);    <span class="hljs-keyword">while</span> (count--) {        sum += *temp++;        <span class="hljs-comment">//overflow carry</span>        <span class="hljs-keyword">if</span> (sum &amp; <span class="hljs-number">0xFFFF0000</span>) {            sum &amp;= <span class="hljs-number">0xFFFF</span>;            sum++;        }    }    <span class="hljs-comment">//complement</span>    <span class="hljs-keyword">return</span> ~(sum &amp; <span class="hljs-number">0xFFFF</span>);}</code></pre></div></div><p>校验方法： </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m0iaiglb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-m0iaiglb4jx62r"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">not_corrupt</span><span class="hljs-params">(packet &amp;p)</span> </span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">check_sum</span>((u_short *) &amp;p, HEAD_SIZE + p.head.data_size) == <span class="hljs-number">0</span>;}</code></pre></div></div><p></p><h4 id="创建数据包">创建数据包</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xxjlkclb4jx62r"></i><span>c++</span><div class="collapse show" id="collapse-xxjlkclb4jx62r"><pre><code class="hljs c++"><span class="hljs-function">packet <span class="hljs-title">make_pkt</span><span class="hljs-params">(u_int flag, u_int seq = <span class="hljs-number">0</span>, u_short data_size = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data = <span class="hljs-literal">nullptr</span>, u_short window_size = <span class="hljs-number">0</span>,</span></span><span class="hljs-params"><span class="hljs-function">                u_int option = <span class="hljs-number">0</span>)</span> </span>{    packet pkt;    pkt.head.flag = flag;    pkt.head.seq = seq;    pkt.head.window_size = window_size;    pkt.head.data_size = data_size;    pkt.head.option = option;    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) {        <span class="hljs-built_in">memcpy</span>(pkt.data, data, data_size);    }    pkt.head.check_sum = <span class="hljs-built_in">check_sum</span>((u_short *) &amp;pkt, PACKET_SIZE);    <span class="hljs-keyword">return</span> pkt;}</code></pre></div></div><h2 id="程序演示">程序演示</h2><h3 id="建立连接">建立连接</h3><p>路由器设置：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192132716638_161_image-20221119185527966.png" alt="image-20221119185527966"><figcaption aria-hidden="true">image-20221119185527966</figcaption></figure><p>接收端开启的稍微晚一些，可以看到发送端有一些重发的握手包：</p><p>发送端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192135114475_628_image-20221119184351874.png" alt="image-20221119184351874"><figcaption aria-hidden="true">image-20221119184351874</figcaption></figure><p>接收端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192137753520_483_image-20221119184414935.png" alt="image-20221119184414935"><figcaption aria-hidden="true">image-20221119184414935</figcaption></figure><p>发送端没有进行文件发送，接收端超时退出：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192140166643_147_image-20221119184511051.png" alt="image-20221119184511051"><figcaption aria-hidden="true">image-20221119184511051</figcaption></figure><p>异常丢包提示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192142733601_999_image-20221119184627493.png" alt="image-20221119184627493"><figcaption aria-hidden="true">image-20221119184627493</figcaption></figure><p>发送端文件发送完毕：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192145332007_368_image-20221119184759988.png" alt="image-20221119184759988"><figcaption aria-hidden="true">image-20221119184759988</figcaption></figure><p>多文件接收</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/2013599_%E7%94%B0%E4%BD%B3%E4%B8%9A_%E5%AE%9E%E9%AA%8C3.1/20221119192148152631_686_image-20221119185617149.png" alt="image-20221119185617149"><figcaption aria-hidden="true">image-20221119185617149</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>体系结构-cache</title>
    <link href="/posts/64660/"/>
    <url>/posts/64660/</url>
    
    <content type="html"><![CDATA[<h1 id="体系结构-cache经典题目">体系结构-cache经典题目</h1><p>这是计算机体系结构的课后习题。通过逆向的思维更深的理解了cache的结构和cache优化的方向，是一道挺有意思的题。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221107220133912940_232_image-20221107215520312.png" alt="image-20221107215520312"><figcaption aria-hidden="true">image-20221107215520312</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221107135836770239_118_BDE01ED506906D92EDDFF59FB5BA32D9.jpg" alt="BDE01ED506906D92EDDFF59FB5BA32D9"><figcaption aria-hidden="true">BDE01ED506906D92EDDFF59FB5BA32D9</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221110201157288967_934_image-20221110201142068.png" alt="image-20221110201142068"><figcaption aria-hidden="true">image-20221110201142068</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221107220136090940_467_image-20221107220004897.png" alt="image-20221107220004897"><figcaption aria-hidden="true">image-20221107220004897</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221107135841382575_356_74966D2A3FF6BD074F7A29C5CF3A4832.jpg" alt="74966D2A3FF6BD074F7A29C5CF3A4832"><figcaption aria-hidden="true">74966D2A3FF6BD074F7A29C5CF3A4832</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221107135842709137_738_36197BA4AFEF78EF89A0D8635CBFBEF7.jpg" alt="36197BA4AFEF78EF89A0D8635CBFBEF7"><figcaption aria-hidden="true">36197BA4AFEF78EF89A0D8635CBFBEF7</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221107135844032615_523_A025FDFE253E78CE2CDB8743D58DD963.jpg" alt="A025FDFE253E78CE2CDB8743D58DD963"><figcaption aria-hidden="true">A025FDFE253E78CE2CDB8743D58DD963</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221107220140271744_579_image-20221107220103032.png" alt="image-20221107220103032"><figcaption aria-hidden="true">image-20221107220103032</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20221107135848168421_297_5C5A1A71E12687C41E251DEF29A3AE6B.jpg" alt="8D44BC68FBC1F5D2361F564FDEC15B81"><figcaption aria-hidden="true">8D44BC68FBC1F5D2361F564FDEC15B81</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="/posts/6004/"/>
    <url>/posts/6004/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理-词法分析">编译原理-词法分析</h1><h2 id="正则表达式">正则表达式</h2><p>注意课上没提到的正则写法，仅作为了解</p><p><code>\w</code> 用于查找字母、数字和下划线</p><p><code>\W</code> 匹配除字母、数字和下划线之外的字符</p><p><code>\d</code> 仅用来匹配数字</p><p><code>\D</code>用来匹配数字之外的所有字符</p><p><code>\s</code> 仅匹配空白字符</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081612860400_768_image-20221105204422750.png" alt="image-20221105204422750" width="50%" height="50%"></p><p>首尾符号不同的a、b串</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6lr72alb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-6lr72alb4jx62s"><pre><code class="hljs c++">(<span class="hljs-built_in">a</span>(a*b)+) | (<span class="hljs-built_in">b</span>(b*a)+)或(<span class="hljs-built_in">a</span>(a|b)*b) | (<span class="hljs-built_in">b</span>(a|b)*a)</code></pre></div></div><p>首尾符号相同的a、b串 <strong>包括只有a或b的情况</strong></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lv8t4ylb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-lv8t4ylb4jx62s"><pre><code class="hljs c++">(<span class="hljs-built_in">a</span>(b*a)*)|(<span class="hljs-built_in">b</span>(a*b)*)</code></pre></div></div><h2 id="nfa设计">NFA设计</h2><p>不包含字串011的01串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081614097039_483_image-20221105211752301.png" alt="image-20221105211752301"><figcaption aria-hidden="true">image-20221105211752301</figcaption></figure><p>偶数个0，偶数个1的0/1串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081615829280_894_image-20221105212835393.png" alt="image-20221105212835393"><figcaption aria-hidden="true">image-20221105212835393</figcaption></figure><p>能被3整除的二进制串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081617166099_636_image-20221105213415355.png" alt="image-20221105213415355"><figcaption aria-hidden="true">image-20221105213415355</figcaption></figure><h2 id="正则-nfa">正则-NFA</h2><p><code>Thomson 构造法</code>。基本思想是递归：</p><ol type="1"><li><p>对于基本的 re，直接构造</p></li><li><p>对于复合的 re，递归构造</p></li></ol><p>具体构造方式比较简单，在此略去</p><p>以(0 | 1)*110(0 | 1)*为例：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081618854779_247_image-20221106093147221.png" alt="image-20221106093147221"><figcaption aria-hidden="true">image-20221106093147221</figcaption></figure><h3 id="nfa-dfa">NFA-DFA</h3><p><code>子集构造法</code></p><h4 id="算法理解">算法理解：</h4><p>递推的思想</p><p>最简单的符号串ε：NFA状态集合←→DFA 状态</p><p>长度为1的串a=εa，在自动机中可达的状态为：从c对应的状态经过标记为a的边可达的状态</p><p>长度为2的串...</p><h4 id="算法需要注意的地方">算法需要注意的地方：</h4><ol type="1"><li><p>DFA新的状态对应NFA状态集消耗一个字符，能够走到的状态集。所以很明显，这里要消耗，所以不能是ε，并且只能消耗一个。</p></li><li><p>得到步骤 1 中的状态集之后，还需要考虑，这里面的所有节点，通过 ε能走到的所有状态。注意，这里的每个状态，只要可以通过 ε走，就必须一直走下去，也就是所谓的<code>ε-闭包</code>。这一步得到状态集的就是最后的结果。</p></li><li><p>第二步需要格外注意的是别忘了检查克林顿闭包中往回返的边。</p></li><li><p>只要包含了NFA中的终态，在DFA中就作为终态出现。</p></li><li><p>直到检查某一个状态的ε-闭包不再产生新状态的时候，算法停止。</p></li></ol><h4 id="实例">实例</h4><p>上面的图进行一遍子集构造的过程(往年的期末考题，推导过程要比课上讲的例子长一些，小心出错)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081618854779_247_image-20221106093147221.png" alt="image-20221106093147221"><figcaption aria-hidden="true">image-20221106093147221</figcaption></figure><p>先考虑空串：</p><p>ε_closure({0})={0, 1, 2, 4, 7}=A</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081622072895_220_image-20221106113307803.png" alt="image-20221106113307803"><figcaption aria-hidden="true">image-20221106113307803</figcaption></figure><p>在DFA里加入开始状态A。</p><p>由于只有2有能够消耗0的边，因此下一步从这个状态指向的3开始考虑：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081623719225_876_image-20221106113154787.png" alt="image-20221106113154787"><figcaption aria-hidden="true">image-20221106113154787</figcaption></figure><p>ε_closure(δ(A, 0))=ε_closure({3})={3, 6, 7, 1, 2, 4}={1, 2, 3, 4, 6,7}=B</p><p>同理。不过这一次在A中4和7都能提供消耗1的边，因此要从5和8开始拓展两次ε_closure：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081625192588_768_image-20221106113520151.png" alt="image-20221106113520151"><figcaption aria-hidden="true">image-20221106113520151</figcaption></figure><p>ε_closure(δ(A, 1))=ε_closure({5,8})={5, 6, 7, 1, 2, 4, 8}={1, 2, 4,5, 6, 7, 8}=C</p><p>考虑了所有消耗一个字符的情况后，我们的DFA应当是这个样子：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081626891613_879_image-20221106095750761.png" alt="image-20221106095750761" width="67%" height="67%"></p><p>B状态消耗0的状态是{3}。而{3}的ε闭包我们已经求过，它就是B：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081627912947_486_image-20221106094657352.png" alt="image-20221106094657352"><figcaption aria-hidden="true">image-20221106094657352</figcaption></figure><p>ε_closure(δ(B, 0))=ε_closure({3})=B</p><p>同样的，B消耗1后为{5,8}，它的ε闭包我们也是知道的，是C。</p><p>ε_closure(δ(B, 1))=ε_closure({5,8})=C</p><p>那么有：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081629295837_152_image-20221106113947097.png" alt="image-20221106113947097" width="67%" height="67%"></p><p>再来考察C：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081630470656_164_image-20221106100409568.png" alt="image-20221106100409568"><figcaption aria-hidden="true">image-20221106100409568</figcaption></figure><p>ε_closure(δ(C, 0))=ε_closure({3})=B</p><p>ε_closure(δ(C, 1))=ε_closure({5,8,9})={5, 6, 7, 1, 2, 4, 8, 9}={1, 2,4, 5, 6, 7, 8, 9}=D</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081632830316_747_image-20221106100750517.png" alt="image-20221106100750517"><figcaption aria-hidden="true">image-20221106100750517</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081635290017_116_image-20221106114421614.png" alt="image-20221106114421614" width="67%" height="67%"></p><p>考察新状态D：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081636596912_786_image-20221106101039674.png" alt="image-20221106101039674"><figcaption aria-hidden="true">image-20221106101039674</figcaption></figure><p>ε_closure(δ(D, 0))=ε_closure({3,10})={3, 6, 7, 1, 2, 4, 10, 11, 12,14, 17}={1, 2, 3, 4, 6, 7, 10, 11, 12, 14, 17}=E</p><p>这一次覆盖的状态包含了终态17.因此在DFG中E就要加一个圈，表示终态。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081638049390_665_image-20221106101722642.png" alt="image-20221106101722642"><figcaption aria-hidden="true">image-20221106101722642</figcaption></figure><p>ε_closure(δ(D, 1))=ε_closure({4,7,8})=D</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081639688157_503_image-20221106114710326.png" alt="image-20221106114710326" width="67%" height="67%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081638049390_665_image-20221106101722642.png" alt="image-20221106101722642"><figcaption aria-hidden="true">image-20221106101722642</figcaption></figure><p>ε_closure(δ(E, 0))=ε_closure({3,13})={1, 2, 3, 4, 6, 7, 11, 12, 13,14, 16, 17}=F</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081642146138_964_image-20221106164356951.png" alt="image-20221106164356951"><figcaption aria-hidden="true">image-20221106164356951</figcaption></figure><p>ε_closure(δ(E, 1))=ε_closure({5,8,15})={ 1, 2, 4, 5, 6, 7, 8, 11, 12,14, 15, 16, 17}=G</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081643785412_875_image-20221106164315789.png" alt="image-20221106164315789"><figcaption aria-hidden="true">image-20221106164315789</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081645146555_627_image-20221106164515007.png" alt="image-20221106164515007" width="67%" height="67%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081642146138_964_image-20221106164356951.png" alt="image-20221106164356951"><figcaption aria-hidden="true">image-20221106164356951</figcaption></figure><p>ε_closure(δ(F, 0))=ε_closure({3,13})=F</p><p>ε_closure(δ(F, 1))=ε_closure({5,8,15})=G</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081643785412_875_image-20221106164315789.png" alt="image-20221106164315789"><figcaption aria-hidden="true">image-20221106164315789</figcaption></figure><p>ε_closure(δ(G, 0))=ε_closure({3,13})=F</p><p>ε_closure(δ(G, 1))= ε_closure({5,8,9,15})={ 1, 2, 4, 5, 6, 7, 8, 9,11, 12, 14, 15, 16, 17}=H</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081649213700_939_image-20221106164831871.png" alt="image-20221106164831871"><figcaption aria-hidden="true">image-20221106164831871</figcaption></figure><p>ε_closure(δ(H, 0))=ε_closure({3,10,13})={1, 2, 3, 4, 6, 7, 10, 11,12, 13, 14, 16, 17}=I</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081650544945_592_image-20221106165419438.png" alt="image-20221106165419438"><figcaption aria-hidden="true">image-20221106165419438</figcaption></figure><p>ε_closure(δ(H, 1))=H</p><p>ε_closure(δ(I, 0))=F</p><p>ε_closure(δ(I, 1))=G</p><p>发现I不再产生新的状态了，长舒一口气，终于可以结束了。</p><p>最终的DFA如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081651688510_197_image-20221106114818599.png" alt="image-20221106114818599"><figcaption aria-hidden="true">image-20221106114818599</figcaption></figure><p>做题技巧：做到后面可以连同记下求过的ε_closure。A⊆B则ε_closure(A)⊆ε_closure(B)</p><p>识别0111010过程：A →B →C →D →D →E →G →F</p><h2 id="dfa优化">DFA优化</h2><h4 id="优化思想">优化思想</h4><p>具有非ε的输出边的状态显然是NFA中的重要状态</p><p>δ(s，a)不空，当且仅当s是重要状态→决定了ε_closure(δ(T，a))的计算→子集构造法的核心</p><p>两个子集若具有相同的重要状态，且同时包含或同时不包含终态，则可看作等价</p><h4 id="算法理解-1">算法理解</h4><p>下面这一篇文章对正则到DFA和DFA最小化的思想和具体实现剖析的比较透彻。其中正则到DFA并非重点考察内容，但对理解DFA优化的思想有比较大的帮助。</p><p><a target="_blank" href="https://wangwangok.github.io/2019/10/28/compiler_regular2dfa/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">词法分析-正则表达式到DFA</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://wangwangok.github.io/2019/10/28/compiler_regular2dfa/</span></span></span></a></p><h4 id="实例-1">实例</h4><p>最小化上面求得的DFA：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081651688510_197_image-20221106114818599.png" alt="image-20221106114818599"><figcaption aria-hidden="true">image-20221106114818599</figcaption></figure><p>初始非终态{A, B, C, D}，终态{E, F, G, H, I}，</p><p>终态内部自己打转儿，不可再分</p><p>0将前者分裂为{A, B, C}和{D}，1将前者分裂为{A,B}和{C}，至此不可再分</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20221107081655357057_638_image-20221106175951220.png" alt="image-20221106175951220"><figcaption aria-hidden="true">image-20221106175951220</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索_系统评价</title>
    <link href="/posts/23422/"/>
    <url>/posts/23422/</url>
    
    <content type="html"><![CDATA[<h1 id="信息检索_系统评价">信息检索_系统评价</h1><h2 id="总思路">总思路</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181425241957_651_image-20221102140305383.png" alt="image-20221102140305383"><figcaption aria-hidden="true">image-20221102140305383</figcaption></figure><h2 id="单查询">单查询</h2><h3 id="无序检索结果集合的评价">无序检索结果集合的评价</h3><details><summary>回顾</summary><p>查准率 (Precision) : <span class="math inline">\(P=\frac{T P}{T P+FP}\)</span> 。预测正确的正例数据占预测为正例数据的比例。</p><p>召回率 (Recall) : <span class="math inline">\(R=\frac{TP}{TP+FN}\)</span> 。预测为正例的数据占实际为正例数据的比例。</p>F1值 (F1 score) : <span class="math display">\[F1=\frac{2}{\frac{1}{P}+\frac{1}{R}}=\frac{2 * P * R}{P+R}\nonumber\]</span></details><h3 id="有序检索结果集合的评价">有序检索结果集合的评价</h3><h4 id="p-r曲线的例子">P-R曲线的例子</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181427482098_652_image-20221102141151261.png" alt="image-20221102141151261"><figcaption aria-hidden="true">image-20221102141151261</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181431710114_302_image-20221102141322869.png" alt="image-20221102141322869" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181432975281_362_image-20221102142019252.png" alt="image-20221102142019252"><figcaption aria-hidden="true">image-20221102142019252</figcaption></figure><h4 id="平均正确率ap">平均正确率AP</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181435795246_414_image-20221102142247895.png" alt="image-20221102142247895"><figcaption aria-hidden="true">image-20221102142247895</figcaption></figure><h4 id="precisionn">Precision@N</h4><p>Precision@N：在第N个位置上的正确率，对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页的结果，因此，P@10，P@20对大规模搜索引擎来说是很好的评价指标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181437971719_189_image-20221102142715051.png" alt="image-20221102142715051"><figcaption aria-hidden="true">image-20221102142715051</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网-传输层</title>
    <link href="/posts/6389/"/>
    <url>/posts/6389/</url>
    
    <content type="html"><![CDATA[<h1 id="寄网-传输层">寄网-传输层</h1><h2 id="udp">UDP</h2><h3 id="特点">特点</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112829451012_857_image-20221019101254797.png" alt="image-20221019101254797"><figcaption aria-hidden="true">image-20221019101254797</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112833830874_553_image-20221019102904831.png" alt="image-20221019102904831"><figcaption aria-hidden="true">image-20221019102904831</figcaption></figure><blockquote><p>D</p></blockquote><h3 id="复用分用">复用分用</h3><div class="note note-info">如何理解复用和分用？</div><p>复用就是多个应用层进程汇聚成一个传输层进程（八车道变一车道）</p><p>分用就是反过来，传输层的多个进程相应的通向多个应用层进程（单车道变八车道）</p><p>通常复用针对发送，分用针对接收。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112836012813_910_image-20221019101337529.png" alt="image-20221019101337529"><figcaption aria-hidden="true">image-20221019101337529</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112841055514_461_image-20221019104559718.png" alt="image-20221019104559718"> &gt; B</p><h3 id="报文结构和校验">报文结构和校验</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112842251316_209_image-20221019102648654.png" alt="image-20221019102648654"><figcaption aria-hidden="true">image-20221019102648654</figcaption></figure><p><font color="Apricot">算校验和的时候别忘了进位</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112844925605_254_image-20221019101834126.png" alt="image-20221019101834126"><figcaption aria-hidden="true">image-20221019101834126</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112847899571_967_image-20221019102038599.png" alt="image-20221019102038599"><figcaption aria-hidden="true">image-20221019102038599</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112851148719_202_image-20221019101153691.png" alt="image-20221019101153691"><figcaption aria-hidden="true">image-20221019101153691</figcaption></figure><blockquote><p>B：长度包含头部，但不包含伪首部</p></blockquote><p>最重要的“为什么”部分：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112852360163_657_image-20221019102522221.png" alt="image-20221019102522221"><figcaption aria-hidden="true">image-20221019102522221</figcaption></figure><h3 id="应用">应用</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112854071267_984_image-20221019103901732.png" alt="image-20221019103901732"><figcaption aria-hidden="true">image-20221019103901732</figcaption></figure><h2 id="可靠数据传输">可靠数据传输</h2><h3 id="目标">目标</h3><p>左边是希望对上层达到的抽象，右边是实际的情况。<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112856140137_289_image-20221019161257579.png" alt="image-20221019161257579"></p><h3 id="设计思路">设计思路</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112857352548_948_image-20221019162323429.png" alt="image-20221019162323429"><figcaption aria-hidden="true">image-20221019162323429</figcaption></figure><h4 id="rdt1.0">rdt1.0</h4><p>考虑最简单的情况，即底层信道是完全可靠的：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112900136029_437_image-20221019162337067.png" alt="image-20221019162337067"><figcaption aria-hidden="true">image-20221019162337067</figcaption></figure><p>发送端：打包数据，直接调用底层信道进行传输；</p><p>接收端：拆包，将数据交给上层应用</p><h4 id="rdt2.0">rdt2.0</h4><p>下层通道可能造成某些位出现错误（如:1变0，0变1)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112902564743_320_image-20221019163254576.png" alt="image-20221019163254576"><figcaption aria-hidden="true">image-20221019163254576</figcaption></figure><p class="note note-secondary">缩写：ACKnowledge character；Not AcKnowledge character肯定确认和否定确认。 同时为简便直白，对于package的翻译，用包代替分组</p><h5 id="发送端">发送端：</h5><p>仅当接收到ACK并离开该状态时才能发生rdt_send()事件。因此，在发送方确信接收方已正确接收当前分组之前肯定不会发送新数据。由于这种行为，rdt2.0这样的协议被称为停等(stop-and-wait)协议。</p><h5 id="接收端">接收端：</h5><p>上面表示如果packet受损发送NAK，下面表示如果package正确向上层传送数据并发送ACK</p><h5 id="存在的问题">存在的问题：</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112906743219_237_image-20221019164147811.png" alt="image-20221019164147811"><figcaption aria-hidden="true">image-20221019164147811</figcaption></figure><h4 id="rdt2.1">rdt2.1</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112909502820_948_image-20221019165240189.png" alt="image-20221019165240189"><figcaption aria-hidden="true">image-20221019165240189</figcaption></figure><p>答案是只需要1bit。因为如果发送端交替发送01包，接收端只需要知道收到的包是最近收到的(序号没变)还是新的(序号变了)。</p><p>按照这样的思路状态机如下：</p><p>发送端就是每当收到正确且是ACK的包的时候就准备发下一个，否则收到的是受损包或NAK就重发。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112911602268_247_image-20221019170813474.png" alt="image-20221019170813474"><figcaption aria-hidden="true">image-20221019170813474</figcaption></figure><p>接收端：等待接受状态上面部分是发现包受损发NAK且等待，发现和上一次收到的包重复就发ACK(以让发送端发下一个包)，然后等待，也是什么也不做，不向下层传输信息(丢数据)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112913795898_163_image-20221019171058350.png" alt="image-20221019171058350"><figcaption aria-hidden="true">image-20221019171058350</figcaption></figure><p>还有，接受端收到受损包其实不需要发NAK，再发一次上一次正确接收的ACK，发送端发现收到了对同一个包的两个ACK就知道接收端没正确接收这个包。</p><p>这其实就是rdt2.2</p><h4 id="rdt2.2">rdt2.2</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112917959019_890_image-20221019171614203.png" alt="image-20221019171614203"><figcaption aria-hidden="true">image-20221019171614203</figcaption></figure><p>在前面的基础上，看懂这种情况下的状态机就不再困难了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112919789535_361_image-20221019183702448.png" alt="image-20221019183702448"><figcaption aria-hidden="true">image-20221019183702448</figcaption></figure><p>接收端的主要变化是：在ACk中添加最后收到的包的序列和号，对应<code>make_pkt</code>第二个参数。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112923670147_103_image-20221019184436444.png" alt="image-20221019184436444"><figcaption aria-hidden="true">image-20221019184436444</figcaption></figure><h4 id="rdt3.0">rdt3.0</h4><h5 id="方案">方案：</h5><p>解决的问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112929819897_715_image-20221019185155113.png" alt="image-20221019185155113"><figcaption aria-hidden="true">image-20221019185155113</figcaption></figure><p>添加了计时器的发送端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112931855615_706_image-20221019185225064.png" alt="image-20221019185225064"><figcaption aria-hidden="true">image-20221019185225064</figcaption></figure><p>接收端不需要改变。因为在2.3中已经实现了判断重复并丢弃了。</p><h5 id="实例">实例</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112933551292_417_image-20221019185429262.png" alt="image-20221019185429262"><figcaption aria-hidden="true">image-20221019185429262</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112937343229_422_image-20221019185440433.png" alt="image-20221019185440433"><figcaption aria-hidden="true">image-20221019185440433</figcaption></figure><p class="note note-primary">失序问题(二义性)是不能解决的，如下图所示</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112939258493_256_image-20221026092203952.png" alt="image-20221026092203952" width="67%" height="67%"></p><p>如果是上述情况，接收端不能辨别是重传的pkt1还是想要的pkt1.</p><p class="note note-primary">怎么解决？wifi用的是停等协议(和rdt3.0一样)，加入标志位表明是否是重传的包。如果接收端发现是接受过的，丢弃。但对于tcp性能优化后，就需要增加序号字段宽度</p><h3 id="流水线可靠数据传输">流水线可靠数据传输</h3><h4 id="停等协议的性能问题">停等协议的性能问题</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112941284045_123_image-20221019185844985.png" alt="image-20221019185844985"><figcaption aria-hidden="true">image-20221019185844985</figcaption></figure><p>发送时间相比传输时间是极短的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112942732666_577_image-20221019185852269.png" alt="image-20221019185852269"><figcaption aria-hidden="true">image-20221019185852269</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112946369564_281_image-20221019185917983.png" alt="image-20221019185917983"><figcaption aria-hidden="true">image-20221019185917983</figcaption></figure><h4 id="流水线协议">流水线协议</h4><h5 id="go-back-ngbn">Go-Back-N(GBN)</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112949459658_238_image-20221019190539995.png" alt="image-20221019190539995"><figcaption aria-hidden="true">image-20221019190539995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112952032314_240_image-20221019190656995.png" alt="image-20221019190656995"><figcaption aria-hidden="true">image-20221019190656995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112956234191_425_image-20221019190714367.png" alt="image-20221019190714367"><figcaption aria-hidden="true">image-20221019190714367</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113000887288_715_image-20221019190525409.png" alt="image-20221019190525409"><figcaption aria-hidden="true">image-20221019190525409</figcaption></figure><p>GBN协议看起来很浪费，因为它会丢弃一个正确接收（但失序）的包。但这样做是有道理的。因为数据必须按序交付。接收方可能缓存包n + 1，但是，根据 GBN 重传规则，如果包 n 丢失，则这个包及第n +1及之后的包迟早会再重传，所以，接收方只需要直接丢弃第n + 1个包即可。</p><p>这种方法的优点是<strong>接收方不需要缓存任何失序分组</strong>，<strong>唯一需要维护的信息就是下一个按序接收的分组的序号</strong>。缺点就是<strong>随后对该分组的重传也许会丢失或出错，进而引发更多的重传。</strong></p><h5 id="sr">SR</h5><p>与GBN的主要区别：</p><ul><li><p>发送端：</p><ul><li><p>每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个包。</p></li><li><p>记录收到的ACK(因为不再重复发送)，但仅当收到的ACK的序号等于基序号<code>base</code>时窗口才会移动，移动到最小的未确认分组处(接收到的最大ACK+1)</p></li></ul></li><li><p>接收端</p><ul><li><p>收到没收到过的包，在窗口口内，缓存并发ACK这个包的序号。(没收到的包在窗口外那肯定是接收端缓存放不下了)</p></li><li><p>收到已经收到过的包，也发这个包的ACK。</p></li></ul></li></ul><p class="note note-primary">第二种情况是什么情景？收到已经收到过的包，那么只有一种情况，那就是接收端的ACK丢失，发送端不知道接收端这个包已经接受了，认为是中途丢了，就会再发一次。为什么要返回 ACK？加入按照上图中所示的发送方和接收方的序号空间，如果分组 send_base 的 ACK没有从接收方传播回发送方，则发送方最终将重传分组send_base，即使显然接收方已经收了该分组。如果接收方不确认该分组，则发送方窗口将永远不能向前滑动。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113003951000_939_image-20221026102125865.png" alt="image-20221026102125865"><figcaption aria-hidden="true">image-20221026102125865</figcaption></figure><p>然而，SR还是没解决类似的失序问题(虽然产生原因不一样，但导致的后果是一样的，即二义性)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113005960023_920_image-20221026102907586.png" alt="image-20221026102907586"><figcaption aria-hidden="true">image-20221026102907586</figcaption></figure><p>我们能够直观的感觉到，只要<strong>序号空间应大于等于窗口大小的2倍</strong>，就能“错开”潜在的二义性区间。</p><h3 id="tcp">TCP</h3><h4 id="段格式">段格式</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113010320175_456_image-20221028201125789.png" alt="image-20221028201125789"><figcaption aria-hidden="true">image-20221028201125789</figcaption></figure><p class="note note-info">报头长度为20~60B，其中固定部分为20B。由于数据偏移字段的单位是4B，也就是说当偏移取最大时TCP首部长度为15×4=60B。</p><h4 id="连接管理">连接管理</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113012417879_161_image-20221028202938399.png" alt="image-20221028202938399"><figcaption aria-hidden="true">image-20221028202938399</figcaption></figure><blockquote><p>B</p></blockquote><p>关于连接的建立和释放(三次握手，四次挥手)等内容，在实验作业中有详细的阐述。</p><p><a target="_blank" href="https://lunaticsky-tql.github.io/posts/13596/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Wireshark分析交互过程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://lunaticsky-tql.github.io/posts/13596/</span></span></span></a></p><h4 id="传输过程">传输过程</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113015046715_418_image-20221028202640029.png" alt="image-20221028202640029"><figcaption aria-hidden="true">image-20221028202640029</figcaption></figure><p>对于某一端来说，seq表示发送的报文段中数据部分的第一个字节在其发送缓存区中的编号，<font color="Apricot">ack表示它期望收到的下一个报文段的数据部分的第一个字节在另一端的发送缓存区中的编号</font>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113021254308_149_image-20221028202202650.png" alt="image-20221028202202650"><figcaption aria-hidden="true">image-20221028202202650</figcaption></figure><blockquote><p>同一个TCP报文中的seq和ack的值是没有联系。在B发给A的报文（捎带确认）中，seq值应和A发向B的报文中的ack值相同，即201：ack值表示B期望下次收到A发出的报文段的第一个字节的编号，应是200+2=202。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113022900814_335_image-20221028203537641.png" alt="image-20221028203537641"><figcaption aria-hidden="true">image-20221028203537641</figcaption></figure><blockquote><p>D</p></blockquote><h4 id="重传场景">重传场景</h4><h5 id="超时重传">超时重传</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113025521130_952_image-20221102090515967.png" alt="image-20221102090515967"><figcaption aria-hidden="true">image-20221102090515967</figcaption></figure><h6 id="rto设置重要性">RTO设置重要性</h6><p>RTO设置过大，对于丢失的报文段重传等待的时间过长，对于应用来说会引入较大的时延</p><p>RTO设置过小，可能会提前超时，引入不必要的重传，浪费带宽资源</p><h6 id="算法思路">算法思路</h6><p>最新样本赋予的权值大于老样本的权值（老化算法）</p><p>越新的样本越能更好地反映网络的当前状况</p><p>不仅如此，在实际情况中，网络拥塞情况会对网络时延有很大影响(体现在下面的DevRTT中)</p><p>启发式算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113027424562_662_image-20221102090928397.png" alt="image-20221102090928397"><figcaption aria-hidden="true">image-20221102090928397</figcaption></figure><h5 id="快速重传">快速重传</h5><p>“事不过三”。如果收到重复ACK，至少说明客户端接收到的包失序了。如果一两个，可能只是包跑的不一样快，但多了就认为很有可能是丢了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113029523742_128_image-20221102091321589.png" alt="image-20221102091321589"><figcaption aria-hidden="true">image-20221102091321589</figcaption></figure><h4 id="流量控制">流量控制</h4><h5 id="滑动窗口">滑动窗口</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113031785988_286_image-20221102102355905.png" alt="image-20221102102355905"><figcaption aria-hidden="true">image-20221102102355905</figcaption></figure><p class="note note-primary">如果上图中黄×所在的ACK没收到咋办？会出现什么情况？如何解决？</p><p>服务器不知道</p><blockquote><p>TCP使用滑动窗口机制来进行流量控制，其窗口尺寸的设置很重要，如果滑动窗口值设置得太小，那么会产生过多的ACK(因为窗口大可以累积确认，因此会有更少的ACK)，影响网络吞吐率；如果设置得太大，那么又会由于传送的数据过多而使路由器变得拥挤，浪费主机的存储资源，导致主机可能丢失分组。</p></blockquote><h5 id="性能问题image-20221102100002266">性能问题<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113034340991_595_image-20221102100002266.png" alt="image-20221102100002266"></h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验二_Wireshark分析交互过程</title>
    <link href="/posts/13596/"/>
    <url>/posts/13596/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验二_wireshark分析交互过程">计算机网络实验二_Wireshark分析交互过程</h1><h2 id="实验要求">实验要求</h2><p>（1）搭建Web服务器（自由选择系统），并制作简单的Web页面，包含简单文本信息（至少包含专业、学号、姓名）和自己的LOGO。</p><p>（2）通过浏览器获取自己编写的Web页面，使用Wireshark捕获浏览器与Web服务器的交互过程，并进行简单的分析说明</p><ul><li>主要分析的是tcp握手、http请求应答、tcp挥手几个过程和相关问题</li></ul><h2 id="wireshark可以做什么"><a href="https://zhuanlan.zhihu.com/p/82498482">Wireshark可以做什么</a></h2><ul><li>网络管理员使用Wireshark检测网络问题</li><li>网安工程师用Wireshark检查信息安全相关问题</li><li>开发者使用Wireshark为新的通信协议调试</li><li>普通用户使用Wireshark学习网络协议相关知识</li><li>憨憨学生使用Wireshark应付TCP/IP课程要求(别骂了)</li></ul><h2 id="服务器搭建">服务器搭建</h2><p>在本次实验中我使用了本地服务器。我们可以使用Springboot，flask等在localhost上搭建Web服务器。不过最近恰好在研究博客搭建相关内容，这里通过使用Hexo搭建静态博客的比较“自动化”的方式在本机搭建Web服务器。</p><p>通过下面命令安装<code>hexo</code>环境。(其实还需要安装<code>npm</code>环境，不过在此就略去了)。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0cqaublb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-0cqaublb4jx62s"><pre><code class="hljs shell">sudo npm install -g hexo-cli</code></pre></div></div><p>新建博客目录结构如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7382ohlb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-7382ohlb4jx62s"><pre><code class="hljs shell">my_hexo_test_server.├── _config.yml├── db.json├── node_modules├──...├── package-lock.json├── package.json├── public├── scaffolds├── source│&nbsp;&nbsp; └── _posts└── themes    └── wireshark        ├── _config.yml        ├── layout        │&nbsp;&nbsp; ├── index.ejs        │&nbsp;&nbsp; ├── layout.ejs        │&nbsp;&nbsp; └── post.ejs        └── source            ├── css            ├── img            └── js</code></pre></div></div><p><code>_config.yml</code>中<code>theme</code>改为自定义的<code>wireshark</code>，在<code>index.ejs</code>中写入网页内容：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pzpq9mlb4jx62s"></i><span>html</span><div class="collapse show" id="collapse-pzpq9mlb4jx62s"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>this is layout.ejs<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> 2013599 田佳业<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>计算机科学与技术<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/test.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></div><p>在终端执行 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s6nzthlb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-s6nzthlb4jx62s"><pre><code class="hljs shell">(base) ➜  my_hexo_test_server hexo g(base) ➜  my_hexo_test_server hexo s</code></pre></div></div><p></p><p>可以看到生成网页如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232042709573_203_image-20221026200601767.png" alt="image-20221026200601767"><figcaption aria-hidden="true">image-20221026200601767</figcaption></figure><h2 id="wireshark-分析tcp连接过程">Wireshark 分析TCP连接过程</h2><p>由于服务器在本地，选择<code>Loopback:lo0</code>即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232044366413_373_image-20221026200751668.png" alt="image-20221026200751668"><figcaption aria-hidden="true">image-20221026200751668</figcaption></figure><p>首先我们需要尝试找到TCP建立连接三次握手的位置。刷新网页，并输入<code>http</code>进行过滤，以隐藏其他无关的数据包。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232045903947_824_image-20221028173616526.png" alt="image-20221028173616526">找到第一个<code>GET</code>数据包。右键选中，<code>Follow stream</code>——<code>TCPstream</code>，显示握手信息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232048121868_131_image-20221028174135897.png" alt="image-20221028174135897"><figcaption aria-hidden="true">image-20221028174135897</figcaption></figure><h3 id="三次握手">三次握手</h3><p>下面展示了三次握手的过程，并结合握手信息对照报文段进行分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232049728449_411_image-20221028175332107.png" alt="image-20221028175332107"><figcaption aria-hidden="true">image-20221028175332107</figcaption></figure><ul><li>第一次握手：建立连接时，客户端发送SYN包（Seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（SynchronizeSequence Numbers）。</li></ul><p>捕获的第一段报文如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232051494572_180_image-20221028174837176.png" alt="image-20221028174837176"><figcaption aria-hidden="true">image-20221028174837176</figcaption></figure><p>博客示例网页运行在<code>localhost:4000</code>，目的端口号匹配。同时可以看到Flag字段值为2，也即第二位SYN字段为1，其余全0。</p><ul><li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li></ul><p>第二段报文如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232054080895_215_image-20221028175454476.png" alt="image-20221028175454476"><figcaption aria-hidden="true">image-20221028175454476</figcaption></figure><p>从端口号可以看出，这是服务器发给客户的。Flag字段为ACK和SYN。这次我们注意一下确认序列号的值。从<a href="https://wiki.wireshark.org/TCP_Relative_Sequence_Numbers">WiresharkWiki</a>我们可以了解到，考虑到可读性其在列表中采用了相对序列号。在详细信息中可以看到原始(<code>raw</code>)序列号。我们可以看到：</p><p>第一次握手客户端<code>Sequence Number (raw):2932922641</code>（Seq=j）</p><p>第二次握手服务器端<code>Acknowledgment number (raw):2932922642</code>（ACK=j+1），与示意图中的握手过程的过程相符。</p><ul><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手，客户端与服务器开始传送数据。</li></ul><p>同样可以验证ACK(ack=k+1）。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232056001837_289_image-20221028180628702.png" alt="image-20221028180628702"><figcaption aria-hidden="true">image-20221028180628702</figcaption></figure><p>也可对照查看右侧的十六进制报文源码。</p><h4 id="过程理解">过程理解</h4><p class="note note-primary">为什么是三次握手？</p><p>需要以最小的代价验证会话双方的收发功能正常:</p><ul><li><p>第一次握手成功：说明客户端的数据可以被服务端收到，说明客户端的发功能可用，说明服务端的收功能可用。但客户端自己不知道数据是否被接收。</p></li><li><p>第二次握手成功：说明服务端的数据可以被客户端收到，说明服务端的发功能可用，说明客户端的收功能可用。同时客户端知道自己的数据已经正确到达服务端，自己的发功能正常。但是服务端自己不知道数据是否被接收。</p></li><li><p>第三次握手成功：说明服务端知道自己的数据已经正确到达客户端端，自己的发功能正常。至此服务成功建立。</p></li></ul><p class="note note-primary">为什么每次连接的序列号都不同？</p><p>避免新老连接混淆</p><h4 id="syn洪泛攻击">Syn洪泛攻击</h4><p>在 TCP 连接的三次握手过程中，我们假设发生以下情况：</p><p>一个用户向服务器发送了 Syn报文后突然死机或掉线, 则服务器在发出 SYN和ACK 应答报文后，客户端无法及时答复，导致服务器无法收到客户端的 ACK报文( 即第三次握手无法完成) 。</p><p>这种情况下服务器端一般会重试并等待一段时间后丢弃这个未完成的连接,称为<strong>半连接握手状态。</strong></p><p>攻击者只需要向服务端发送大量的TCP请求连接而不进行第三次回应，就会出现大量的这种半握手状态的连接,在服务器产生很多的请求队列,<strong>由于第一次握手时服务端就已经为客户端开辟了接收缓冲区</strong>，大量的请求最后的结果往往是堆栈溢出崩溃,服务器也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求,此时服务器失去了对客户端的响应, 从而达到SynFlood攻击的目的。</p><p><a href="https://zhuanlan.zhihu.com/p/457884093">DoS攻击之Syn洪泛攻击原理及防御</a></p><h3 id="四次挥手">四次挥手</h3><p>左边的实线连起来的表示同一次会话发生的各个阶段。沿着这条线走到最底端，可以看到四次挥手的过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232058311718_623_image-20221028181245513.png" alt="image-20221028181245513"><figcaption aria-hidden="true">image-20221028181245513</figcaption></figure><p>结合TCP连接关闭的过程，可以看到第81到84个报文是挥手的过程。分析方式与握手类似，在此不再赘述。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232100061679_207_image-20221028181501786.png" alt="image-20221028181501786"><figcaption aria-hidden="true">image-20221028181501786</figcaption></figure><p>另外，其实两端中的任何一个都可以主动提出关闭连接。只是通常情况下是客户端。</p><h4 id="过程理解-1">过程理解</h4><p class="note note-primary">第二次挥手和第三次挥手一定是紧挨着的吗？</p>不一定。这时候只是表示A不再发送数据。服务器仍可在这两次挥手中间发送一些数据。<p class="note note-primary">为什么第四次挥手后A不能立刻释放资源？</p>A并不知道B有没有正确的收到了A的ACK。正常情况下什么也不会发生。但如果没收到，B应当重传FIN，A得知道<p class="note note-primary">为什么要等两倍MSL？</p><p>无论是否正常，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。</p><p class="note note-primary">一定要四次挥手吗？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221102112611088782_354_image-20221102103437478.png" alt="image-20221102103437478"><figcaption aria-hidden="true">image-20221102103437478</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221102112614834681_752_image-20221102103222135.png" alt="image-20221102103222135"><figcaption aria-hidden="true">image-20221102103222135</figcaption></figure><p>客户端和服务端的生命周期总结如下：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232101334092_481_image-20221028181827531.png" alt="image-20221028181827531"><figcaption aria-hidden="true">image-20221028181827531</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232103339683_762_image-20221028181835974.png" alt="image-20221028181835974"><figcaption aria-hidden="true">image-20221028181835974</figcaption></figure><h3 id="传输窗口">传输窗口</h3><h4 id="tcp-window-scale">TCP Window Scale</h4><p>在TCP刚被发明的时候，全世界的网络带宽都很小，所以最大接收窗口被定义成65535字节。随着硬件的革命性进步，65535字节已经成为性能瓶颈了，怎么样才能扩展呢？TCP头中只给接收窗口值留了 16 bit，肯定是无法突破 65535 （<span class="math inline">\(2^{16} − 1\)</span>）的。 1992年的 RFC1323中提出了一个解决方案，就是在三次握手时，把自己的 WindowScale信息告知对方。由于 Window Scale放在 TCP头之外的Options中，所以不需要修改 TCP头的设计。 WindowScale的作用是向对方声明一个 Shift count，我们把它作为 2的指数，再乘以TCP头中定义的接收窗口，就得到真正的 TCP接收窗口了。</p><p>这对应于Wireshark中的Caculated window size，如下图所示。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232105453916_456_image-20221028184429901.png" alt="image-20221028184429901"><figcaption aria-hidden="true">image-20221028184429901</figcaption></figure><h2 id="http传输分析">Http传输分析</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232107541741_783_image-20221028190921283.png" alt="image-20221028190921283"><figcaption aria-hidden="true">image-20221028190921283</figcaption></figure><p>以下是前三个HTTP传输报文。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232109214457_454_image-20221028191110711.png" alt="image-20221028191110711"><figcaption aria-hidden="true">image-20221028191110711</figcaption></figure><p>查看第一次客户端向服务器发送GET请求，含有浏览器请求头以及请求行。GET方法没有请求体。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232111055813_462_image-20221028190632604.png" alt="image-20221028190632604"><figcaption aria-hidden="true">image-20221028190632604</figcaption></figure><p>从右边解析出的明文可以看出HTTP是采用ASCII码进行传输的。</p><p>之后请求成功，返回200状态码及HTML。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232113806376_581_image-20221028191208877.png" alt="image-20221028191208877"><figcaption aria-hidden="true">image-20221028191208877</figcaption></figure><p>分析文本的十六进制编码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yx4rajlb4jx62s"></i><span>apache</span><div class="collapse show" id="collapse-yx4rajlb4jx62s"><pre><code class="hljs apache"><span class="hljs-attribute">0000</span>   <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">3</span>c <span class="hljs-number">68</span> <span class="hljs-number">32</span> <span class="hljs-number">3</span>e <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">33</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span><span class="hljs-attribute">0010</span>   <span class="hljs-number">20</span> e7 <span class="hljs-number">94</span> b0 e4 bd b3 e4 b8 <span class="hljs-number">9</span>a <span class="hljs-number">3</span>c <span class="hljs-number">2</span>f <span class="hljs-number">68</span> <span class="hljs-number">32</span> <span class="hljs-number">3</span>e <span class="hljs-number">0</span>a</code></pre></div></div><p>第一行末尾可以看到是我的学号<code>2013599</code>的ASCII码。</p><p>中文采用的是Unicode编码。具体方式为：</p><blockquote><p>将需要转码的字符，按指定编码方式（默认使用UTF-8编码）转化为字节流，每个字节按16进制表示，并添加%组成一个percent编码。</p></blockquote><p>给第二行每个字节前加%后用UrlDecode解码，可以还原出我的名字。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232117064239_862_image-20221028193717733.png" alt="image-20221028193717733"><figcaption aria-hidden="true">image-20221028193717733</figcaption></figure><p>再之后请求图片：</p><p>同时我们可以看到图片信息也请求成功。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232118651904_458_image-20221028194251309.png" alt="image-20221028194251309"><figcaption aria-hidden="true">image-20221028194251309</figcaption></figure><blockquote><p>在 <code>vim</code> 内调用 <code>:%!xxd</code>命令，其实就是调用系统的 <code>xxd</code>命令，对打开的内容进行16进制转换。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++_基本语法和运算</title>
    <link href="/posts/64911/"/>
    <url>/posts/64911/</url>
    
    <content type="html"><![CDATA[<h2 id="c回顾复习">C++回顾复习</h2><div class="note note-info">注：此系列内容仅供应对C++程序设计基础笔试使用。</div><h3 id="认识c">认识C++</h3><h4 id="基本概念和词汇">基本概念和词汇</h4><p>main不是C++中的保留字。因此<code>int main;</code>在C++中合法。</p><div class="note note-secondary">下列哪个是C++语言的合法的字符常量 "0" '054’ ‘' ‘\092’</div><blockquote><p>A选项，双引号表示的是字符串常量；B选项054表示八进制整数，但是缺少转义符号；D选项是将其后的整数092表示八进制整数，但是八进制不存在9这个数。注意，单引号表示的字符常量，可以是整数，但必须带有转义符号，其字符常量为整数表示的ASC码对应的字符</p></blockquote><p>一个经常设坑的点：八进制表达中出现8或9</p><h4 id="枚举常量">枚举常量</h4><p><code>enum t1 {a1,a2=7,a3,a4=15}time;</code></p><p>则枚举常量<code>a1</code>和<code>a3</code>的值分别是0和8</p><p>枚举值对应的整数值可以是任意整数。</p><p>注意区分枚举类型定义和枚举类型变量定义。前者定义的数据类型，后者是定义变量。定义类型名时不应该有=</p><div class="note note-warning">因此 enum a=[one,two,three);是不对的</div><p>还可以这样写</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0l0r5nlbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-0l0r5nlbm8uzgl"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">team</span>{my, your=<span class="hljs-number">4</span>, his, her=his+<span class="hljs-number">10</span>};cout&lt;&lt;my&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;your&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;his&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;her&lt;&lt;endl;</code></pre></div></div><p>结果<code>0 4 5 15</code></p><h4 id="string">string</h4><p>关于字符串类型</p><p>使用<code>.length()</code>和<code>strlen()</code>时计算的字符串长度都不包含<code>\0</code></p><div class="note note-warning">注意:+不支持两个字符串字面常量的连接,如 string word4 "hello"+"world!";</div><h3 id="运算符和表达式">运算符和表达式</h3><h4 id="基本概念">基本概念</h4><p>在学习了编译原理之后，对这些概念以及对应的“奇特”写法应当已经见怪不怪。但为应对考试，仍记录以备复习。</p><h5 id="表达式">表达式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094522795684_122_image-20221013141835992.png" alt="image-20221013141835992"><figcaption aria-hidden="true">image-20221013141835992</figcaption></figure><p>注意，“表达式”不带分号，带了分号就是语句。</p><h4 id="优先级和结合性">优先级和结合性</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1wx313lbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-1wx313lbm8uzgl"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//test 1</span>    <span class="hljs-type">int</span> k, a, b, c;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> w = <span class="hljs-number">5</span>;    <span class="hljs-type">double</span> x = <span class="hljs-number">1.42</span>;<span class="hljs-comment">//    x%(-3); &lt;Invalid operands to binary expression ('double' and 'int')&gt;</span>    w += <span class="hljs-number">-2</span>; <span class="hljs-comment">// w=3</span>    k = (a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b); <span class="hljs-comment">// k=5</span>    c = k = a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b; <span class="hljs-comment">// c=5, k=2, a=2, b=3</span>    a += a -= (b = <span class="hljs-number">4</span>) * (a = <span class="hljs-number">3</span>); <span class="hljs-comment">// a=-18, b=4</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a=%d"</span>, a);    <span class="hljs-comment">//test 2</span>    <span class="hljs-type">int</span> d2i = <span class="hljs-string">'A'</span> + <span class="hljs-number">1.6</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a2=%d"</span>, d2i); <span class="hljs-comment">//'A'+1.6=66.6=66 (ASCII code of 'A' is 65)</span>    <span class="hljs-comment">//test3</span><span class="hljs-comment">/*    d=9+e+f=d+9;</span><span class="hljs-comment">    expression is a value, not a variable in the memory,so it is not assignable */</span>}</code></pre></div></div><p><a href="https://blog.csdn.net/zb_915574747/article/details/99704639">优先级和结合性一览</a></p><h4 id="赋值运算">赋值运算</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pcfwoulbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-pcfwoulbm8uzgl"><pre><code class="hljs c++">设有intx=<span class="hljs-number">11</span>：，则表达式(x++*<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)的值是</code></pre></div></div><p><span class="math inline">\(\lfloor 11*1/3 \rfloor=3\)</span></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094525768953_130_image-20221013142054782.png" alt="image-20221013142054782"><figcaption aria-hidden="true">image-20221013142054782</figcaption></figure><p>做题时容易犯的错误：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a61gn2lbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-a61gn2lbm8uzgl"><pre><code class="hljs c++">若d为<span class="hljs-type">double</span>型变量，则表达式d=<span class="hljs-number">1</span>，d+<span class="hljs-number">5</span>，d++的值是<span class="hljs-number">1</span>。d+<span class="hljs-number">5</span>不是d=d+<span class="hljs-number">5</span>。虽然很明显，做题的时候也需要有注意的意识</code></pre></div></div><h4 id="逻辑运算">逻辑运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094527376104_753_image-20221020095906292.png" alt="image-20221020095906292"><figcaption aria-hidden="true">image-20221020095906292</figcaption></figure><p>注意算术运算符优先于关系和除非以外的逻辑运算符！</p><p>短路运算举例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cds0c2lbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-cds0c2lbm8uzgl"><pre><code class="hljs c++">×=y=<span class="hljs-number">3</span>;t=++x||++y后，y的值是</code></pre></div></div><blockquote><p>3，因为后面不会被运算</p></blockquote><p>优先级只是起“加括号”的作用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jupt8tlbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-jupt8tlbm8uzgl"><pre><code class="hljs c++"><span class="hljs-type">int</span> c,h;std::cout&lt;&lt;((c=<span class="hljs-number">2</span>)&amp;&amp;(h=<span class="hljs-number">-2</span>));<span class="hljs-comment">//always true</span></code></pre></div></div><h4 id="位运算">位运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094529486139_294_image-20221020105755065.png" alt="image-20221020105755065"><figcaption aria-hidden="true">image-20221020105755065</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094532506509_144_image-20221020104858172.png" alt="image-20221020104858172"><figcaption aria-hidden="true">image-20221020104858172</figcaption></figure><p>注意位运算的“地位”不是平等的，不要想当然按顺序算</p><h4 id="条件和逗号运算符">条件和逗号运算符</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094533764720_298_image-20221020111433316.png" alt="image-20221020111433316"><figcaption aria-hidden="true">image-20221020111433316</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ce5d24lbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-ce5d24lbm8uzgl"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">{</span></span><span class="hljs-params"><span class="hljs-function">cout&lt;&lt;(<span class="hljs-number">0101</span>&amp;<span class="hljs-number">101</span>&gt;&gt;<span class="hljs-number">3</span>|<span class="hljs-number">101</span>&lt;&lt;<span class="hljs-number">3</span>^~<span class="hljs-number">0x10</span>)&lt;&lt;endl;</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span></span><span class="hljs-params"><span class="hljs-function">}</span></span><span class="hljs-params"><span class="hljs-function"></span></span></code></pre></div></div><blockquote><p>优先级按位取反~最高，先将0x10（十六进制）按位取反，得到结果1111111111111111 1111111111101111，其次优先级按位左移和按位右移运算符优先级相同，计算101&gt;&gt;3得到00000000 00000000 00000000 00001100，以及101&lt;&lt;3得到 0000000000000000 0000001100101000，接下来计算0101（八进制）按位与（101&gt;&gt;3）的结果，得到结果为0,0按位或一个数所得结果为原值。因此最终答案为(101&lt;&lt;3)按位异或(~0x10)的结果，其结果为1111111111111111 11111100 11000111，为负数，求补得到绝对值。特别需要注意的是取反的时候是对整个int取反，16变-17</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nrf0hhlbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-nrf0hhlbm8uzgl"><pre><code class="hljs c++">设intm=<span class="hljs-number">5</span>；<span class="hljs-type">float</span> x=<span class="hljs-number">3.5</span>；则表达式m+x+<span class="hljs-number">4.5</span>的结果应占据[填空]个字节。<span class="hljs-comment">//8.在隐式类型转换中转向了double</span></code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验一_socket聊天程序</title>
    <link href="/posts/54779/"/>
    <url>/posts/54779/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验一_socket聊天程序">计算机网络实验一_Socket聊天程序</h1><p>2013599 田佳业</p><h2 id="实验要求">实验要求</h2><p>使用流式Socket，设计一个两人聊天协议，要求聊天信息带有时间标签。请完整地说明交互消息的类型、语法、语义、时序等具体的消息处理方式。拓展实现功能（如群聊、多线程等）</p><h2 id="程序流程展示">程序流程展示</h2><h3 id="模块说明">模块说明</h3><p>此实验使用了Windows多线程的方式实现了多人聊天功能，流程和协议设计如下图所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193748648308_976_connect.png" alt="connect"><figcaption aria-hidden="true">connect</figcaption></figure><p>对于每一个用户的聊天过程，分为建连阶段和聊天阶段。</p><h3 id="建连阶段">建连阶段</h3><h4 id="流程设计">流程设计</h4><h5 id="服务器">服务器</h5><p>服务器主要做了以下工作：</p><ul><li><p>设置最大聊天人数并在接收连接前验证</p></li><li><p>建立socket，绑定ip和端口号，进入监听模式进行等待</p></li><li><p>客户端连接后，得到客户端输入的用户名，验证是否在已有用户列表，若否，为其单独创建线程并在<code>socket</code>池中为其分配<code>socket</code></p></li><li><p>连接成功，向其发送欢迎信息并通知在线的用户</p></li><li><p>每当用户连接成功后，服务器显示用户信息及连接时间。</p></li></ul><p>注：下图包含了一次客户端断开重连的过程，可以看到服务器能够正确的识别这一过程，且对在线人数进行更新。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193750618844_199_image-20221022211508575.png" alt="image-20221022211508575"><figcaption aria-hidden="true">image-20221022211508575</figcaption></figure><h5 id="客户端">客户端</h5><ul><li><p>由于程序默认在<code>localhost</code>上运行，因此客户端只需要手动选择正确的端口号与服务器进行连接，若连接失败，退出程序。</p></li><li><p>之后输入用户名，这里需要注意用户名不能与关键字(在该程序中为<code>quit</code>和<code>all</code>)。当然在本地验证即可。等待服务器确认信息后，建立两个线程：发送和接收线程，以防止阻塞。</p></li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193752409499_274_image-20221022211345244.png" alt="客户端"><figcaption aria-hidden="true">客户端</figcaption></figure><p>下面是上线通知的实现效果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193754614735_579_image-20221022211828762.png" alt="上线通知"><figcaption aria-hidden="true">上线通知</figcaption></figure><h4 id="协议设计">协议设计</h4><p>由于此部分界限明确，且不涉及与其他服务器的交互，为保证速度和效率，从简设计即可。只传输最需要的东西。并且由于这个过程顺序是且必须是确定的，串行执行共用端口不至混淆。</p><h3 id="聊天阶段">聊天阶段</h3><h4 id="流程设计-1">流程设计</h4><h5 id="服务器事件">服务器事件</h5><p>程序在调度设计中着重注意了一点：在整个聊天室中，服务器可以作为“管理员”向用户发送消息，而不仅仅实现转发功能。为了实现这一点，程序采用了子线程的方式。主线程除了创建socket便将与客户端建立连接的过程交给子线程去干，服务端负责转发的线程由子线程创建。主线程自己则进入等待输入的过程。</p><p>主线程有输入分一下两种情况：正常字符串和<code>exit</code>。正常字符串会即时群发给所有在线用户并标记为<code>SERVER</code>信息。若输入<code>exit</code>则退出服务器，并在退出之前向客户端群发通告，并同时退出客户端的程序。</p><p>以下两幅图片展示了客户端收到的对应的情况。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193756459285_459_image-20221022214111930.png" alt="image-20221022214111930"><figcaption aria-hidden="true">image-20221022214111930</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193758300289_769_image-20221022213615110.png" alt="image-20221022213615110"><figcaption aria-hidden="true">image-20221022213615110</figcaption></figure><h5 id="客户端事件">客户端事件</h5><p>按照同样的方式可以实现客户端离线群发功能。不再赘述。当然，断开后删除个人信息并更新计数也是必要的。</p><h5 id="私聊和群聊">私聊和群聊</h5><p>可以从上述图片中看出客户端命令行有两个参数：发送对象和消息。</p><p>从实现上，这两种方式没有本质的区别。稍微需要注意的一些细节主要是群发不需要发给请求方，但私发时如果选择发送给自己，自己仍然可以收到消息。</p><p>下图展示了私聊和群聊的结果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193759994557_881_image-20221022224632714.png" alt="image-20221022224632714"><figcaption aria-hidden="true">image-20221022224632714</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193801774887_602_image-20221022224533046.png" alt="image-20221022224533046"><figcaption aria-hidden="true">image-20221022224533046</figcaption></figure><h4 id="协议设计-1">协议设计</h4><p>协议设计中关注了一下几点：</p><ol type="1"><li><p>在线状况下，根据<code>socket ID</code>和用户信息表，可以知道是谁发的，因此传递报文时发送者只需要向服务器传递接受者是谁，服务器转发时将对应字段改为发送者姓名即可。这样虽然增加了服务器压力，但能够有效减少报文长度。</p></li><li><p>控制位仅需一个字节。当然这就像<code>HTTP</code>状态码一样，是建立在共识之上的。</p></li><li><p>消息中需要包含时间戳。因为聊天程序中的时间是需要以发送时间为准的。当然接收时间可以从系统获得，基于此也可以进行时延计算。</p></li></ol><p>以下是程序中关于协议中控制部分的宏定义：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-t23jidlb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-t23jidlb4jx62s"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW_C <span class="hljs-string">'N'</span> <span class="hljs-comment">// new client</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUB_C <span class="hljs-string">'P'</span> <span class="hljs-comment">// public message</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRI_C <span class="hljs-string">'R'</span>  <span class="hljs-comment">// private message</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUIT_C <span class="hljs-string">'Q'</span> <span class="hljs-comment">// quit</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_C <span class="hljs-string">'H'</span> <span class="hljs-comment">// hello message from server</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_C <span class="hljs-string">'T'</span> <span class="hljs-comment">// exit message from server (server is closed)</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERR_C <span class="hljs-string">'E'</span> <span class="hljs-comment">// error message from server</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_C <span class="hljs-string">'V'</span> <span class="hljs-comment">// normal server message</span></span></code></pre></div></div><h2 id="程序代码解释">程序代码解释</h2><p>具体代码的含义大多在程序中有注释。下面的文字叙述部分主要着眼函数和线程模块划分和功能实现上。</p><p>C++中对字符串的处理<code>char*</code>和<code>string</code>各有各的优势，有时也会出现各种奇怪的坑，在写代码时一度让人很头疼，因此也在某些地方会有一些不太优雅的写法。</p><h3 id="环境配置">环境配置</h3><p>在<code>cmake</code>项目中进行<code>socket</code>编程需要在CMakeLists中添加以下内容，否则不能正常编译：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nc0lzplb4jx62s"></i><span>cmake</span><div class="collapse show" id="collapse-nc0lzplb4jx62s"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.21</span>)<span class="hljs-keyword">project</span>(chatting)<span class="hljs-keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="hljs-string">"-static"</span>)<span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<span class="hljs-keyword">link_libraries</span>(ws2_32 wsock32)<span class="hljs-keyword">add_executable</span>(server server.cpp)<span class="hljs-keyword">add_executable</span>(client client.cpp)</code></pre></div></div><p>需额外包含的头文件：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ahm4lhlb4jx62s"></i><span>cmake</span><div class="collapse show" id="collapse-ahm4lhlb4jx62s"><pre><code class="hljs cmake"><span class="hljs-comment">#include &lt;windows.h&gt;</span><span class="hljs-comment">#include &lt;WinSock2.h&gt;</span><span class="hljs-comment">#pragma comment(lib, "ws2_32.lib")</span></code></pre></div></div><h3 id="工具类">工具类</h3><p><code>color.h</code>以及部分<code>helper.h</code>的代码主要定义了一些与控制台颜色以及格式化输出显示相关的宏及函数。</p><p><code>print_toggle</code>主要用来格式化打印控制台输出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x67vfdlb4jx62s"></i><span>reasonml</span><div class="collapse show" id="collapse-x67vfdlb4jx62s"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_toggle(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">type</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span> &amp;<span class="hljs-params">txt</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">time_str</span>=<span class="hljs-string">""</span>)</span></code></pre></div></div><p>第一个参数是打印格式，取值是下面的宏定义，决定了输出以怎样的颜色和格式进行。第二个参数是内容。并附带可选参数时间。</p><p>宏的定义如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5660molb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-5660molb4jx62s"><pre><code class="hljs c++"><span class="hljs-comment">//message datagram parameters</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_SIZE 12</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT_SIZE 125</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_SIZE 144</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIME_SIZE 6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT_PTR 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIME_PTR 126</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_PTR 132</span><span class="hljs-comment">//console line type parameters</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERR <span class="hljs-string">"E"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFO <span class="hljs-string">"I"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW <span class="hljs-string">"N"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG <span class="hljs-string">"L"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIP <span class="hljs-string">"T"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUC <span class="hljs-string">"S"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN <span class="hljs-string">"W"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER <span class="hljs-string">"V"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GONE <span class="hljs-string">"G"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DUL <span class="hljs-string">"D"</span> <span class="hljs-comment">// dulplicate name</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO <span class="hljs-string">"H"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUB <span class="hljs-string">"P"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRI <span class="hljs-string">"R"</span></span></code></pre></div></div><p>第一部分主要是方便对数据保处理时使用，第二部分则是在控制台上显示相关命令是需要的宏。</p><h3 id="初始化工作">初始化工作</h3><h4 id="服务器端">服务器端</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1m91i1lb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-1m91i1lb4jx62s"><pre><code class="hljs c++"><span class="hljs-comment">//initialize websocket</span>WSADATA wsaData;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"WSAStartup failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"WSAStartup success"</span>);SOCKET sock_server = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);SOCKADDR_IN server_addr;server_addr.sin_family = AF_INET;server_addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);server_addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(LOCALHOST);<span class="hljs-built_in">bind</span>(sock_server, (SOCKADDR *) &amp;server_addr, <span class="hljs-built_in">sizeof</span>(SOCKADDR));<span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock_server, <span class="hljs-number">5</span>) == SOCKET_ERROR) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"listen failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"listen success"</span>);</code></pre></div></div><h4 id="客户端-1">客户端：</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jus8qxlb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-jus8qxlb4jx62s"><pre><code class="hljs c++">WSADATA wsaData;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"WSAStartup failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"WSAStartup success"</span>);SOCKET sockClient = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"the chat room is on the localhost"</span>);<span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"please input port:"</span>);cin &gt;&gt; port;SOCKADDR_IN addrSrv;addrSrv.sin_family = AF_INET;addrSrv.sin_port = <span class="hljs-built_in">htons</span>(port);addrSrv.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(LOCALHOST);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockClient, (SOCKADDR *) &amp;addrSrv, <span class="hljs-built_in">sizeof</span>(SOCKADDR)) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"connect failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"connect success"</span>, <span class="hljs-built_in">get_time_str</span>());</code></pre></div></div><p>这一部分是服务器端创建<code>socket</code>和客户端连接<code>socket</code>必需的代码，课上也有讲述，此处不一一详细说明。</p><h3 id="服务器进程">服务器进程</h3><h4 id="主线程">主线程</h4><p>这一部分主要做的工作是初始化套接字池，并使用<code>client_manager</code>函数创建线程，以监听客户端连接。之后便监听输入以控制服务器群发消息或退出。另外，如果没有客户端连接，显然套接字池中所有套接字都不可用，什么也不用做。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9hdxrplb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-9hdxrplb4jx62s"><pre><code class="hljs c++">    <span class="hljs-comment">//initialize socket array</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> &amp;sock_connect: sock_connects) {        sock_connect = INVALID_SOCKET;    }    <span class="hljs-comment">//create a thread to handle new clients</span>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, client_manager, (LPVOID) &amp;sock_server, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (hThread == <span class="hljs-literal">nullptr</span>) {        <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"create thread failed"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-comment">//input "exit" to exit</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">char</span> input[<span class="hljs-number">100</span>];        cin.<span class="hljs-built_in">getline</span>(input, <span class="hljs-number">100</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(input, <span class="hljs-string">"exit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-comment">// tell all clients that the server is going to shut down</span>            <span class="hljs-type">char</span> msg[MSG_SIZE];            <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);            msg[<span class="hljs-number">0</span>] = EXIT_C;            string content = <span class="hljs-string">"server has shut down"</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                msg[TXT_PTR + i] = content[i];            }            <span class="hljs-built_in">broadcast</span>(msg, <span class="hljs-number">-1</span>);            <span class="hljs-comment">//stop the client_manager thread</span>            <span class="hljs-built_in">TerminateThread</span>(hThread, <span class="hljs-number">0</span>);            <span class="hljs-comment">//close server socket</span>            <span class="hljs-built_in">closesocket</span>(sock_server);            <span class="hljs-keyword">break</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//send msg to all clients</span>            <span class="hljs-type">char</span> msg[MSG_SIZE];            <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);            msg[<span class="hljs-number">0</span>] = SERVER_C;            <span class="hljs-type">char</span> txt[TXT_SIZE];            <span class="hljs-built_in">strcpy</span>(txt, input);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TXT_SIZE; j++) {                msg[j + TXT_PTR] = txt[j];            }            <span class="hljs-comment">//add time</span>            <span class="hljs-type">char</span> time[TIME_SIZE];            <span class="hljs-built_in">strcpy</span>(time, <span class="hljs-built_in">get_time_str</span>().<span class="hljs-built_in">c_str</span>());            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TIME_SIZE; j++)                msg[j + TIME_PTR] = time[j];            <span class="hljs-built_in">broadcast</span>(msg);        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>其中的<code>broadcast</code>函数便是群发消息所使用的是。下面看其实现：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-phndnelb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-phndnelb4jx62s"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">broadcast</span><span class="hljs-params">(<span class="hljs-type">char</span> msg[MSG_SIZE], <span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CLIENT; i++) {        <span class="hljs-keyword">if</span> (sock_connects[i] != INVALID_SOCKET &amp;&amp; i != id) {            <span class="hljs-comment">//we don't send the message to the sender</span>            <span class="hljs-built_in">send</span>(sock_connects[i], msg, MSG_SIZE, <span class="hljs-number">0</span>);        }    }}</code></pre></div></div><p>依次检查<code>socket</code>池，然后给有效且不是<code>id</code>对应的socket发送消息。</p><h4 id="客户端连接线程">客户端连接线程</h4><p><code>[[noreturn]]</code>表明这个函数自始至终监听新加入的<code>socket</code>。连接时服务器不提示，发送用户名时服务器进行第一次消息接收并根据情况发送欢迎信息或要求客户端重新输入用户名。每次接收消息循环结束，表示有客户端进入或离开，更新一次在线信息，并启动<code>handle_msg</code>线程进行消息转发。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6vwawwlb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-6vwawwlb4jx62s"><pre><code class="hljs c++">[[noreturn]] <span class="hljs-function">DWORD WINAPI <span class="hljs-title">client_manager</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-comment">//accept new clients</span>    <span class="hljs-keyword">auto</span> *sock_server = (SOCKET *) lparam;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; index &lt; MAX_CLIENT; index++) {            <span class="hljs-keyword">if</span> (sock_connects[index] == INVALID_SOCKET)                <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">if</span> (index == MAX_CLIENT) {            <span class="hljs-built_in">print_toggle</span>(WARN, <span class="hljs-string">"the server is full"</span>);            <span class="hljs-keyword">continue</span>;        }        SOCKADDR_IN addrClient;        <span class="hljs-type">int</span> lenAddr = <span class="hljs-built_in">sizeof</span>(SOCKADDR);        sock_connects[index] = <span class="hljs-built_in">accept</span>(*sock_server, (SOCKADDR *) &amp;addrClient, &amp;(lenAddr));        <span class="hljs-keyword">if</span> (sock_connects[index] == SOCKET_ERROR) {            <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"could not accept client!"</span>);            sock_connects[index] = INVALID_SOCKET;            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {            <span class="hljs-type">char</span> name[NAME_SIZE];            <span class="hljs-built_in">recv</span>(sock_connects[index], name, NAME_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (username_map.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">string</span>(name)) == username_map.<span class="hljs-built_in">end</span>()) {                username_map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">string</span>(name), index));                <span class="hljs-built_in">send</span>(sock_connects[index], HELLO, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                string new_client = <span class="hljs-string">"new client: "</span> + <span class="hljs-built_in">string</span>(name) + <span class="hljs-string">" entered the chat room"</span>;                string online = <span class="hljs-string">"online:"</span> + <span class="hljs-built_in">to_string</span>(username_map.<span class="hljs-built_in">size</span>());                <span class="hljs-comment">//get the id of the new client</span>                <span class="hljs-type">int</span> id = username_map[<span class="hljs-built_in">string</span>(name)];                <span class="hljs-built_in">print_toggle</span>(INFO, new_client,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">// broadcast</span>                <span class="hljs-type">char</span> msg[MSG_SIZE];                <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TXT_SIZE; j++)                    msg[j + TXT_PTR] = new_client.<span class="hljs-built_in">c_str</span>()[j];                msg[<span class="hljs-number">0</span>] = NEW_C;                <span class="hljs-comment">//add time</span>                <span class="hljs-type">char</span> time[TIME_SIZE];                <span class="hljs-built_in">strcpy</span>(time, <span class="hljs-built_in">get_time_str</span>().<span class="hljs-built_in">c_str</span>());                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TIME_SIZE; j++)                    msg[j + TIME_PTR] = time[j];                <span class="hljs-built_in">broadcast</span>(msg, id);                <span class="hljs-keyword">break</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">send</span>(sock_connects[index], DUL, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);            }        }        HANDLE h_thread_c=<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, handle_msg, (LPVOID) &amp;sock_connects[index], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        <span class="hljs-built_in">CloseHandle</span>(h_thread_c);        string online = <span class="hljs-string">"online: "</span> + <span class="hljs-built_in">to_string</span>(username_map.<span class="hljs-built_in">size</span>());        <span class="hljs-built_in">print_toggle</span>(INFO, online,<span class="hljs-built_in">get_time_str</span>());    }}</code></pre></div></div><h4 id="消息转发线程">消息转发线程</h4><p>消息转发线程主要根据收到的报文控制段对消息进行不同的处理并转发。同时在服务器端输出日志，如下图所示。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193803523871_125_image-20221022225008715.png" alt="image-20221022225008715"><figcaption aria-hidden="true">image-20221022225008715</figcaption></figure><p>在程序中除了根据姓名找<code>socket id</code>,也常常出现反着找的情况。</p><p>这一部分需要注意的点是在<code>PRI_C</code>即私密聊天情况下，如果客户端给出的姓名不在当前上线用户的范围之内，会单独给发送者提示。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v12y51lb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-v12y51lb4jx62s"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handle_msg</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CLIENT; i++) {        <span class="hljs-keyword">if</span> (sock_connects[i] == *socket) {            id = i;            <span class="hljs-keyword">break</span>;        }    }    <span class="hljs-comment">// listen to the message from the client</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">char</span> from_user[NAME_SIZE];        <span class="hljs-type">char</span> msg[MSG_SIZE];        <span class="hljs-type">char</span> content[TXT_SIZE];        <span class="hljs-built_in">memset</span>(from_user, <span class="hljs-number">0</span>, NAME_SIZE);        <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);        <span class="hljs-built_in">memset</span>(content, <span class="hljs-number">0</span>, TXT_SIZE);        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {            <span class="hljs-built_in">print_toggle</span>(WARN, <span class="hljs-string">"client closed unexpectedly"</span>);            <span class="hljs-built_in">closesocket</span>(*socket);            <span class="hljs-comment">//remove the socket from the list</span>            sock_connects[id] = INVALID_SOCKET;            <span class="hljs-comment">//remove the username from the ma according to the id</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = username_map.<span class="hljs-built_in">begin</span>(); it != username_map.<span class="hljs-built_in">end</span>(); it++) {                <span class="hljs-keyword">if</span> (it-&gt;second == id) {                    username_map.<span class="hljs-built_in">erase</span>(it);                    <span class="hljs-keyword">break</span>;                }            }            <span class="hljs-keyword">break</span>;        }        <span class="hljs-type">char</span> type = msg[<span class="hljs-number">0</span>];        <span class="hljs-comment">//get the username from the map</span>        string username;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: username_map) {            <span class="hljs-keyword">if</span> (item.second == id) {                username = item.first;                <span class="hljs-keyword">break</span>;            }        }        <span class="hljs-keyword">switch</span> (type) {            <span class="hljs-keyword">case</span> QUIT_C: {                <span class="hljs-comment">// close client through the client's receive thread</span>                <span class="hljs-type">char</span> msg_exit[MSG_SIZE];                <span class="hljs-built_in">memset</span>(msg_exit, <span class="hljs-number">0</span>, MSG_SIZE);                msg_exit[<span class="hljs-number">0</span>] = EXIT_C;                string exit_msg =<span class="hljs-string">"you have been moved out of the chat room"</span>;                <span class="hljs-built_in">send</span>(*socket, msg_exit, MSG_SIZE, <span class="hljs-number">0</span>);                <span class="hljs-built_in">closesocket</span>(*socket);                sock_connects[id] = <span class="hljs-number">0</span>;                username_map.<span class="hljs-built_in">erase</span>(username);                string gone_saying = username + <span class="hljs-string">" has quit the chat room at "</span>;                <span class="hljs-built_in">print_message</span>(GONE, gone_saying,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">//broadcast the quit message</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> sock_connect: sock_connects) {                    <span class="hljs-keyword">if</span> (sock_connect != <span class="hljs-number">0</span>) {                        <span class="hljs-comment">// attach the content to the message</span>                        <span class="hljs-type">char</span> msg_forwards[MSG_SIZE];                        <span class="hljs-built_in">memset</span>(msg_forwards, <span class="hljs-number">0</span>, MSG_SIZE);                        msg_forwards[<span class="hljs-number">0</span>] = QUIT_C;                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                            msg_forwards[TXT_PTR + i] = gone_saying[i];                        }                    }                }                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">case</span> PUB_C: {                <span class="hljs-comment">//get the username from the map</span>                string info=<span class="hljs-string">"received a public message from "</span>;                info+=username;                <span class="hljs-built_in">print_toggle</span>(LOG, info,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-built_in">broadcast</span>(msg, id);                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">case</span> PRI_C: {                <span class="hljs-comment">//get the username from the map</span>                string info=<span class="hljs-string">"received a public message from "</span>;                info+=username;                <span class="hljs-built_in">print_toggle</span>(LOG, info,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">//get the target user</span>                <span class="hljs-type">char</span> target_user[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++) {                    target_user[i] = msg[NAME_PTR + i];                }                <span class="hljs-function">string <span class="hljs-title">target_user_s</span><span class="hljs-params">(target_user)</span></span>;                <span class="hljs-comment">//check if the target user is online</span>                <span class="hljs-keyword">if</span> (username_map.<span class="hljs-built_in">find</span>(target_user) == username_map.<span class="hljs-built_in">end</span>()) {                    <span class="hljs-comment">//target user is not online</span>                    <span class="hljs-comment">// show log on the server</span>                    string error_msg = <span class="hljs-string">"the target user "</span>;                    error_msg.<span class="hljs-built_in">append</span>(target_user);                    error_msg.<span class="hljs-built_in">append</span>(<span class="hljs-string">" provided by "</span>);                    error_msg.<span class="hljs-built_in">append</span>(username);                    error_msg.<span class="hljs-built_in">append</span>(<span class="hljs-string">" is not online!"</span>);                    <span class="hljs-built_in">print_message</span>(LOG, error_msg);                    <span class="hljs-comment">//send the error message to the sender</span>                    <span class="hljs-type">char</span> msg_error[MSG_SIZE];                    <span class="hljs-built_in">memset</span>(msg_error, <span class="hljs-number">0</span>, MSG_SIZE);                    msg_error[<span class="hljs-number">0</span>] = ERR_C;                    string ree_msg_to_send = target_user_s + <span class="hljs-string">" is not online!"</span>;                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                        msg_error[TXT_PTR + i] = error_msg[i];                    }                    <span class="hljs-built_in">send</span>(*socket, msg_error, MSG_SIZE, <span class="hljs-number">0</span>);                } <span class="hljs-keyword">else</span> {                    string info_pri=<span class="hljs-string">"received a private message from "</span>;                    info_pri+=username;                    <span class="hljs-built_in">print_toggle</span>(LOG, info_pri,<span class="hljs-built_in">get_time_str</span>());                    <span class="hljs-comment">//target user is online</span>                    <span class="hljs-comment">//send the message to the target user</span>                    <span class="hljs-type">int</span> target_id = username_map[target_user];                    <span class="hljs-comment">// replace the target user's name with the sender's name</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++) {                        msg[NAME_PTR + i] = username[i];                    }                    <span class="hljs-built_in">send</span>(sock_connects[target_id], msg, MSG_SIZE, <span class="hljs-number">0</span>);                }                <span class="hljs-keyword">break</span>;            }        }    }}</code></pre></div></div><h3 id="客户端进程">客户端进程</h3><h4 id="主线程-1">主线程</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6vvwpqlb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-6vvwpqlb4jx62s"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockClient, (SOCKADDR *) &amp;addrSrv, <span class="hljs-built_in">sizeof</span>(SOCKADDR)) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"connect failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"connect success"</span>, <span class="hljs-built_in">get_time_str</span>());<span class="hljs-comment">// send username</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {    <span class="hljs-built_in">print_toggle</span>(SERVER, <span class="hljs-string">"please input your username:"</span>, <span class="hljs-built_in">get_time_str</span>());    cin &gt;&gt; user_name;    <span class="hljs-comment">// check if the name is "all" or "quit" that may cause conflict</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(user_name, <span class="hljs-string">"all"</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(user_name, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {        <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"the username cannot be set to system reserved words"</span>);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-built_in">send</span>(sockClient, user_name, NAME_SIZE, <span class="hljs-number">0</span>);    <span class="hljs-comment">//it must be a buffer, although it is only a char</span>    <span class="hljs-type">char</span> status[<span class="hljs-number">1</span>];    <span class="hljs-built_in">recv</span>(sockClient, status, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (status[<span class="hljs-number">0</span>] == HELLO_C) {        <span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"welcome to the chat room!"</span>);        <span class="hljs-keyword">break</span>;    }    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"the username has been used, please input another one"</span>);}HANDLE h_thread[<span class="hljs-number">2</span>];<span class="hljs-comment">// separate the sending and receiving thread to avoid blocking</span>h_thread[<span class="hljs-number">0</span>] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, handlerRec, (LPVOID) &amp;sockClient, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);h_thread[<span class="hljs-number">1</span>] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, handlerSend, (LPVOID) &amp;sockClient, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-built_in">WaitForMultipleObjects</span>(<span class="hljs-number">2</span>, h_thread, TRUE, INFINITE);<span class="hljs-built_in">CloseHandle</span>(h_thread[<span class="hljs-number">0</span>]);<span class="hljs-built_in">CloseHandle</span>(h_thread[<span class="hljs-number">1</span>]);<span class="hljs-built_in">closesocket</span>(sockClient);<span class="hljs-built_in">WSACleanup</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div></div><p>这一部分进行了用户信息发送以及创建了两个子线程用于发送和收取来自服务器的消息。之后阻塞等待线程结束。</p><h4 id="发送线程">发送线程</h4><p>首先将报文字段进行初始化，以便根据实际情况填入。循环等待用户输入，并在过程中两次检查是否需要退出。之后根据报文的控制段<code>TYPE</code>分别构建不同格式信息。注意在这一阶段并不是程报文中的每一个字段都一定用的到。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3jv2d1lb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-3jv2d1lb4jx62s"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handlerSend</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">char</span> to_user[NAME_SIZE];    <span class="hljs-type">char</span> msg[MSG_SIZE];    <span class="hljs-type">char</span> saying[TXT_SIZE];    <span class="hljs-built_in">memset</span>(to_user, <span class="hljs-number">0</span>, NAME_SIZE);    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);    <span class="hljs-built_in">memset</span>(saying, <span class="hljs-number">0</span>, TXT_SIZE);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"please input \"user message\", input 'all' to send to all users"</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, to_user);        <span class="hljs-comment">// if nothing is input, then continue to ask for input again</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(to_user) == <span class="hljs-number">0</span>) {            cout&lt;&lt;<span class="hljs-string">"please input something"</span>&lt;&lt;endl;            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-comment">//check quit</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(to_user, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"you chose to quit the chat room"</span>);            <span class="hljs-comment">//send quit message to server</span>            msg[<span class="hljs-number">0</span>] = QUIT_C;            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%[^\n]"</span>, saying);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(saying) == <span class="hljs-number">0</span>){            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-comment">//check quit</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(saying, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"you have quit the chat room"</span>);            <span class="hljs-comment">//send quit message to server</span>            msg[<span class="hljs-number">0</span>] = QUIT_C;            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-comment">//send message to server for forwarding</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(to_user, <span class="hljs-string">"all"</span>) == <span class="hljs-number">0</span>){            msg[<span class="hljs-number">0</span>] = PUB_C;            <span class="hljs-comment">//construct the message</span>            <span class="hljs-comment">//content</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++){                msg[i + TXT_PTR] = saying[i];            }            <span class="hljs-comment">// from user</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++){                msg[i + NAME_PTR] = user_name[i];            }            <span class="hljs-comment">//time stamp</span>            string time_stamp = <span class="hljs-built_in">get_time_str</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++){                msg[i + TIME_PTR] = time_stamp[i];            }            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        }<span class="hljs-keyword">else</span>{            msg[<span class="hljs-number">0</span>] = PRI_C;            <span class="hljs-comment">//construct the message</span>            <span class="hljs-comment">//content</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++){                msg[i + TXT_PTR] = saying[i];            }            <span class="hljs-comment">// to user</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++){                msg[i + NAME_PTR] = to_user[i];            }            <span class="hljs-comment">//time stamp</span>            string time_stamp = <span class="hljs-built_in">get_time_str</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++){                msg[i + TIME_PTR] = time_stamp[i];            }            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        }    }}</code></pre></div></div><h4 id="接收线程">接收线程</h4><p>接收线程是一个解析的过程，并往控制台进行不同格式输出。模式基本类似。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s24ua1lb4jx62s"></i><span>c++</span><div class="collapse show" id="collapse-s24ua1lb4jx62s"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handlerRec</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">char</span> msg[MSG_SIZE];    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">recv</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        <span class="hljs-type">char</span> type = msg[<span class="hljs-number">0</span>];        <span class="hljs-type">char</span> content[TXT_SIZE];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++)            content[i] = msg[i + TXT_PTR];        <span class="hljs-type">char</span> time[TIME_SIZE];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++)            time[i] = msg[i + TIME_PTR];        <span class="hljs-keyword">switch</span> (type) {            <span class="hljs-comment">// new server message</span>            <span class="hljs-keyword">case</span> NEW_C:                <span class="hljs-built_in">print_message</span>(NEW, content);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// typed "quit" and all resources are released, exit the program</span>            <span class="hljs-keyword">case</span> EXIT_C:                <span class="hljs-comment">// end of the program</span>                <span class="hljs-built_in">print_toggle</span>(WARN, content);                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);            <span class="hljs-comment">// public normal message</span>            <span class="hljs-keyword">case</span> PUB_C:                <span class="hljs-comment">// get the sender's name</span>                <span class="hljs-type">char</span> fromUser[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++)                    fromUser[i] = msg[i + NAME_PTR];                <span class="hljs-comment">// print the message</span>                <span class="hljs-built_in">print_message</span>(PUB, content, time, fromUser);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// handle message from server</span>            <span class="hljs-keyword">case</span> SERVER_C:                <span class="hljs-comment">//get the time from the message</span>                <span class="hljs-type">char</span> time_ser[TIME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++)                    time_ser[i] = msg[i + TIME_PTR];                <span class="hljs-built_in">print_message</span>(SERVER, content, time_ser);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// private message</span>            <span class="hljs-keyword">case</span> PRI_C:                <span class="hljs-comment">// get the sender's name</span>                <span class="hljs-type">char</span> from_user[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++)                    from_user[i] = msg[i + NAME_PTR];                <span class="hljs-comment">// print the message</span>                <span class="hljs-built_in">print_message</span>(PRI, content, time, from_user);                <span class="hljs-keyword">break</span>;        }    }}</code></pre></div></div><h2 id="思考">思考</h2><p>在Java程序设计课上，也编写过一个聊天程序。那时只是机械的学习API，虽然也大致了解TCP，UDP的概念，但对于协议的设计还是非常朴素的。虽然本次实验的协议设计也比较简单，但随着学习的深入也会对此有更新的认识。比如很明显的一个设计缺陷是把时间放到了数据段之后。如果把数据段放到最后，可以通过增加长度字段来支持变长数据的传输。其他的比如数据校验等方面也可以继续改进。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网-应用层</title>
    <link href="/posts/31769/"/>
    <url>/posts/31769/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章">第一章</h2><h3 id="一些基本概念">一些基本概念</h3><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090215966691_917_image-20220921102100658.png" alt="image-20220921102100658"> <span class="math display">\[\frac{640*480*3}{1024}=900\text{KB}\]</span></p><h3 id="internet边缘与核心">Internet边缘与核心</h3><h4 id="电路交换">电路交换</h4><h5 id="时分和频分多路复用">时分和频分多路复用</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090217080225_394_image-20220921091644435.png" alt="image-20220921091644435"><figcaption aria-hidden="true">image-20220921091644435</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090219745396_605_image-20220914113833784.png" alt="image-20220914113833784" width="50%" height="50%"></p><h5 id="报文分组交换">报文分组交换</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090222052725_480_image-20220921090426643.png" alt="image-20220921090426643"><figcaption aria-hidden="true">image-20220921090426643</figcaption></figure><p>”谁来用谁,满了就丢“（当然刚满的时候有临时缓存）</p><p class="note note-secondary">由于成本问题，广域网带宽往往比局域网小得多。</p><p>问题：因为有排队现象，延迟大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090236334011_832_image-20220921091804148.png" alt="image-20220921091804148"><figcaption aria-hidden="true">image-20220921091804148</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090239402715_311_image-20220921092457252.png" alt="image-20220921092457252"><figcaption aria-hidden="true">image-20220921092457252</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090242065298_766_image-20220921102342289.png" alt="image-20220921102342289"><figcaption aria-hidden="true">image-20220921102342289</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090244516116_167_image-20220921102115526.png" alt="image-20220921102115526"><figcaption aria-hidden="true">image-20220921102115526</figcaption></figure><p>题中是Mb不是MB。别忘了字节和bit的转换，正确答案是C。</p><h4 id="传输时延">传输时延</h4><p><font color="Apricot">别忘了RTP的定义</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090246765227_486_image-20221012101652816.png" alt="image-20221012101652816"><figcaption aria-hidden="true">image-20221012101652816</figcaption></figure><figure><img src="/Users/tianjiaye/Library/Application%20Support/typora-user-images/image-20221115202145242.png" alt="image-20221115202145242"><figcaption aria-hidden="true">image-20221115202145242</figcaption></figure><h3 id="web服务器访问示例">Web服务器访问示例</h3><p>网络体系结构概览，理解。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090248226957_689_image-20220921135514064.png" alt="image-20220921135514064"><figcaption aria-hidden="true">image-20220921135514064</figcaption></figure><h2 id="第二章">第二章</h2><h3 id="应用层协议和进程通信模型">应用层协议和进程通信模型</h3><h4 id="进程通信模型">进程通信模型</h4><p class="note note-primary"></p><p>进程之间如何通信？</p>1.管道 2.共享内存 3.消息队列<p></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090249957055_679_image-20220928093225868.png" alt="image-20220928093225868"><figcaption aria-hidden="true">image-20220928093225868</figcaption></figure><p class="note note-info">C/S模型的缺陷：如果访问量大的时候，会影响服务质量，甚至会导致中心服务器瘫痪P2P模型缺陷：不便于管理</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090255703101_824_image-20221012092450719.png" alt="image-20221012092450719"><figcaption aria-hidden="true">image-20221012092450719</figcaption></figure><p>D。客户机面向用户。其实主要注意C是对的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090257212133_865_image-20221012112533931.png" alt="image-20221012112533931"><figcaption aria-hidden="true">image-20221012112533931</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090258905463_489_image-20221012112556726.png" alt="image-20221012112556726"><figcaption aria-hidden="true">image-20221012112556726</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090300525887_688_image-20220928094631013.png" alt="image-20220928094631013"><figcaption aria-hidden="true">image-20220928094631013</figcaption></figure><h4 id="进程地址标识">进程地址标识</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090302563658_334_image-20220928101653200.png" alt="image-20220928101653200"><figcaption aria-hidden="true">image-20220928101653200</figcaption></figure><h4 id="应用层协议定义的内容">应用层协议定义的内容</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090304286709_112_image-20220928103019165.png" alt="image-20220928103019165"><figcaption aria-hidden="true">image-20220928103019165</figcaption></figure><h4 id="传输层">传输层</h4><p>作用：保证端到端服务的可靠性</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090306529509_443_image-20220928103725740.png" alt="image-20220928103725740"><figcaption aria-hidden="true">image-20220928103725740</figcaption></figure><p>UCP服务的不可靠是相对的，只是级别比较低。</p><p>UCP的优势：建立连接快，占用资源少，实现简单，不容易被监控</p><p class="note note-info">无论TCP还是UDP都没有提供任何加密机制，这就是说发送进程传进其套接字的数据，与经网络传送到目的进程的数据相同。因此，举例来说如果某发送进程以明文方式（即没有加密）发送了一个口令进入它的套接字，该明文口令将经过发送方与接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。因为隐私和其他安全问题对许多应用而言已经成为至关重要的问题，所以因特网界已经研制了TCP的加强版本，称为安全套接字层(SecureSocketsLayer，SSL)。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。</p><p>TCP/IP协议通常在操作系统的内核中实现</p><h4 id="socket">socket</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090312331202_111_image-20220928111844557.png" alt="image-20220928111844557"><figcaption aria-hidden="true">image-20220928111844557</figcaption></figure><p>TCP/UDP协议感性认识</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090313969554_614_image-20220928135917798.png" alt="image-20220928135917798" width="50%" height="50%"></p><h4 id="socket编程">socket编程</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090321048624_770_image-20221005095507884.png" alt="image-20221005095507884"><figcaption aria-hidden="true">image-20221005095507884</figcaption></figure><p>PowerPC采用大端序，其他CPU大多使用小端序。网络编程使用大端序。</p><h3 id="文件传输协议">文件传输协议</h3><p>FTP基于TCP的可靠服务</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090322840513_285_image-20221012093347724.png" alt="image-20221012093347724"><figcaption aria-hidden="true">image-20221012093347724</figcaption></figure><p>对应的，邮件传输是带内控制。</p><blockquote><p>FTP客户首先连接服务器的21号端口，建立控制连接（控制连接在整个会话期间一直保持打开)，然后建立数据连接，在数据传送完毕后，数据连接最先释放，控制连接最后释放。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090326097608_519_image-20221012095753630.png" alt="image-20221012095753630"><figcaption aria-hidden="true">image-20221012095753630</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090328651614_685_image-20221012095828837.png" alt="image-20221012095828837"><figcaption aria-hidden="true">image-20221012095828837</figcaption></figure><p>D</p><p class="note note-info">为什么FTP不适合共享读写文件？因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息是带外(Out-of-band)传送的？使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器，来回传送耗费很多时间。网络文件系统(NFS)采用另一种思路，它允许进程打开一个远程文件，并能在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p><blockquote><p>针对文件传输FTP，系统管理员建立了一个特殊的用户ID，名为anonymous，即匿名用户。Internet上的任何人在任何地方都可以使用该用户ID，只是在要求提供用户ID时必须输入anonymous，该用户ID的密码可以是任何字符串。</p></blockquote><p class="note note-info">为什么FTP要采用两个独立的连接？在FTP的实现中，客户与服务器之间采用了两条传输连接，其中控制连接用于传输各种FTP命令，而数据连接用于文件的传送。之所以这样设计，是因为使用两条独立的连接可使FTP变得更加简单、更容易实现、更有效率。同时在文件传输过程中，还可以利用控制连接控制传输过程，如客户可以请求终止、暂停传输等。</p><h3 id="web服务和http协议">Web服务和HTTP协议</h3><h4 id="最新最热http2.0">最新最热HTTP2.0</h4><h5 id="二进制分帧传输">二进制分帧传输</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090330394790_595_image-20221012105830716.png" alt="image-20221012105830716"><figcaption aria-hidden="true">image-20221012105830716</figcaption></figure><h5 id="tcp连接复用">TCP连接复用</h5><p>虽然想法很朴素，但确解决了为追求简单和仅适应文本传输的历史遗留问题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090332798519_644_image-20221012110140184.png" alt="image-20221012110140184"><figcaption aria-hidden="true">image-20221012110140184</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090334780017_529_image-20221012110329212.png" alt="image-20221012110329212"><figcaption aria-hidden="true">image-20221012110329212</figcaption></figure><h5 id="服务器推送和http头压缩">服务器推送和HTTP头压缩</h5><p>当然服务器推送也增加了服务器的压力，因为之前服务器并不需要关注传输的是什么内容</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090336747509_846_image-20221012110625529.png" alt="image-20221012110625529"><figcaption aria-hidden="true">image-20221012110625529</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090338868210_673_image-20221012111205235.png" alt="image-20221012111205235"><figcaption aria-hidden="true">image-20221012111205235</figcaption></figure><h4 id="cdn">CDN</h4><h4 id="dash">DASH</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090340524655_762_image-20221019092551081.png" alt="image-20221019092551081"><figcaption aria-hidden="true">image-20221019092551081</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090342143506_385_image-20221019092718918.png" alt="image-20221019092718918"><figcaption aria-hidden="true">image-20221019092718918</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090343857447_572_image-20221019092804145.png" alt="image-20221019092804145"><figcaption aria-hidden="true">image-20221019092804145</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile急速入门</title>
    <link href="/posts/23557/"/>
    <url>/posts/23557/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile-急速入门">Makefile 急速入门</h1><p>或许你和我一样在完全没有接触过<code>makefile</code>的时候看到相对复杂一点的项目依赖感到头大。这里从最简单的情况，到常见用法，快速把<code>makefile</code>的基本用法捋一遍。</p><h2 id="最小示例">最小示例</h2><p>下面的过程想必接触过linux平台下的编程都应该很熟悉：</p><p>新建一个示例程序<em>main.c</em>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h0ju8slbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-h0ju8slbm8uzgl"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>正常情况下，通过 <code>gcc</code>在命令行将其编译后产出相应文件，可执行文件或 object 文件等。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jeippnlbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-jeippnlbm8uzgl"><pre><code class="hljs shell">(base) ➜ gcc -o main.out main.c</code></pre></div></div><p>上面命令编译后运行 <code>main.out</code> 可执行文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0kqt44lbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-0kqt44lbm8uzgl"><pre><code class="hljs shell">(base) ➜ ./main.outhello world!</code></pre></div></div><h2 id="makefile-初步认知">Makefile 初步认知</h2><h3 id="从动手做开始">从动手做开始</h3><p>如果我们想用到中间代码联合编译/链接，或者有大量的源文件做不同的处理，那么敲一行一行的命令将是灾难级的。即使通过按上下箭头的方式回退命令也会浪费很多时间，这时<code>makefile</code>的作用便显现出来了。但是为了便于学习，从上面的最小示例开始，先动手做一下，有一个感性的认知：</p><p>在与<code>main.c</code>同目录下创建文件<code>makefile</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zvsw5jlbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-zvsw5jlbm8uzgl"><pre><code class="hljs shell">touch makefile</code></pre></div></div><p>填入以下内容：</p><p><em>Makefile</em></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-goatl4lbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-goatl4lbm8uzgl"><pre><code class="hljs makefile"><span class="hljs-section">all:main.out</span>  <span class="hljs-comment"># make all</span><span class="hljs-section">main.out: main.c</span><span class="hljs-comment"># test make</span>gcc -o main.out main.c<span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>上面的 Makefile 中定义了三个任务，调用时可通过<code>make &lt;target name&gt;</code> 形式来调用。</p><p>比如:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lw1bpklbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-lw1bpklbm8uzgl"><pre><code class="hljs shell">(base) ➜ make main.out<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">test</span> make</span>gcc -o main.out main.c</code></pre></div></div><p>默认情况下<code>makefile</code>会打印每条命令(包括注释)，然后再执行，也就是所谓的echoing。这是在基于在构建时需要了解当前在执行哪条命令的需要。</p><p>之后你会发现在目录下产生了<code>main.out</code> 文件。</p><p>如果想关闭回声，可以在命令的前面加上@。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0qqu9ylbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-0qqu9ylbm8uzgl"><pre><code class="hljs makefile"><span class="hljs-section">main.out: main.c</span>@<span class="hljs-comment"># test make</span>gcc -o main.out main.c</code></pre></div></div><p>习惯上<code>clean</code>任务被定义用于清除生成的目标构建文件。在这里试一下用<code>clean</code>把刚刚的<code>main.out</code>删掉：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ms4tgklbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-ms4tgklbm8uzgl"><pre><code class="hljs shell">(base) ➜ make cleanrm main.out</code></pre></div></div><p>如果<code>make</code>后面什么都不跟，会默认只执行第一个任务。因此我们通常会在第一行定义一个依赖(习惯上叫做<code>all</code>)来使<code>makefile</code>在我们输入<code>make</code>时能够将所有需要的目标都构建出来。</p><p>可以试一下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gv5u9plbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-gv5u9plbm8uzgl"><pre><code class="hljs shell">(base) ➜ makegcc -o main.out main.c<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span></code></pre></div></div><p>和所预料的一样。</p><h3 id="make-规则">Make 规则</h3><p>可以看到，通过 <code>make</code>命令，能将上面的编译进行有效自动化管理。通过将从输入文件到输出文件的编译规则编写成Makefile 脚本，Make 工具将自动处理文件间依赖及是否需要编译的检测。</p><p>定义任务的基本语法为：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1kyitylbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-1kyitylbm8uzgl"><pre><code class="hljs makefile">target [target2 ...]: [pre-req-1 pre-req-2 ...][command1 command2 ......]</code></pre></div></div><p>其中，</p><ul><li><code>target</code>为任务名或文件产出。从上面的例子可以看出，<code>target</code>可以是一个目标文件(如<code>main.out</code>)，也可以是一个执行文件，还可以是一个标签（如<code>all</code>，<code>clean</code>)等。</li><li><code>pre-req123...</code>这些是依赖项，即该任务所需要的外部输入，这些输入可以是已有的文件，也可以是其他任务产出的文件。</li><li><code>command</code> 为该任务具体需要执行的 shell 命令。</li></ul><p>因此简单的说，我们把想生成的文件或者想执行的命令名写到冒号前面，把生成的目标文件依赖文件写到冒号后面，下面<code>tab</code>对齐写想执行的命令就可以了。</p><h3 id="make是如何工作的">make是如何工作的</h3><p>现在来以输入<code>make</code>命令为例，简要分析make的工作过程。</p><p>首先在当前目录下找名字叫“makefile”的文件；</p><blockquote><p>事实上，执行make命令时，是按照GNUmakefile、makefile、Makefile的顺序依次尝试找到存在的文件并执行。</p></blockquote><p><code>make</code>执行第一条指令对应任务<code>all</code>；</p><p><code>all</code>发现其依赖<code>main.out</code>不存在，需要更新，转而去执行<code>main.out</code>对应的任务；</p><p><code>main.out</code>发现它所依赖的<code>main.c</code>不存在，需要更新，而且没有找到对应<code>main.c</code>任务，执行自己的<code>command</code>产生<code>main.c</code>；</p><p><code>main.out</code>执行完了，<code>all</code>继续执行自己的<code>command</code>把注释打印了出来。</p><h3 id="增量编译">增量编译</h3><p>其实上面说的还不是很严谨。准确的说，在执行任务时，它会先检查依赖项是否比需要产出的文件新，如果说依赖项更新(包括依赖项不存在)，则说明我们需要产出的目标文件属于过时的产物，需要重新生成。</p><p>什么意思。比如上面的示例，当执行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cbcxpdlbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-cbcxpdlbm8uzgl"><pre><code class="hljs shell">(base) ➜ make main.out</code></pre></div></div><p>试图生成 <code>main.out</code> 产出时，会检查这个任务的依赖文件<code>main.c</code> 是否有修改过。</p><p>前面我们已经执行过该任务产生过<code>main.out</code>。再次执行时，会得到如下提示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7x3km6lbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-7x3km6lbm8uzgl"><pre><code class="hljs shell">(base) ➜ make main.out make: Nothing to be done for 'main.out'.</code></pre></div></div><blockquote><p>有的版本的GNU make 提示的也可能是 make: 'main.out' is up to date.</p></blockquote><p>现在对输入文件 <code>main.c</code> 进行修改：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-illz67lbm8uzgl"></i><span>c++</span><div class="collapse show" id="collapse-illz67lbm8uzgl"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{-     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world!"</span>);+     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello ucore!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>再次执行 <code>make main.out</code>会发现任务正常执行并产生了新的输出，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r3p5axlbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-r3p5axlbm8uzgl"><pre><code class="hljs shell">(base) ➜ make main.outgcc -o main.out main.c(base) ➜ ./main.outhello ucore!⏎</code></pre></div></div><p>这里 <code>main.c</code> 修改后，它在文件上来说，就比<code>main.out</code> 更新了，所以我们说 <code>main.out</code>这个目标， <strong>过时（out-dated）</strong> 了。</p><p>过时的任务才会被重新执行，而未过时的会跳过，并输出相应信息。</p><p>Makefile 天然实现了增量编译的效果，这是使用 Makefile进行自动化编译的最大的方便之处。在大型项目下会节省不少编译时间，因为它只编译过期的任务。</p><h3 id="phony-类型任务的执行">Phony 类型任务的执行</h3><p>上面提到，<code>target</code>既可以是文件名，也可以是标签，那么<code>make</code>怎么知道到底是指哪一种情况？有疑惑就对了。我们还是通过实验来验证这个问题：</p><p>还是使用一开始的示例，这次钻一个牛角尖：在这个目录下创建一个名叫<code>clean</code>的文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4ewx5tlbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-4ewx5tlbm8uzgl"><pre><code class="hljs shell">touch clean</code></pre></div></div><p>然后再<code>make clean</code>一下，我们会看到：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7kygdelbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-7kygdelbm8uzgl"><pre><code class="hljs shell">(base) ➜ make cleanmake: Nothing to be done for 'clean'.</code></pre></div></div><p>也就是说，<code>make</code>会将其优先视作文件。那么我们如果只是希望将其用作标签，那么应该如何解决呢？</p><p>Makefile中，有一个<code>.PHONY</code>指令。<a href="https://www.bilibili.com/video/BV1ih411e7gn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=acb594007d0011f12244c20c5476e73d">Phony</a>的意思是伪造的，假的。可以理解为，在Makefile中，<code>.PHONY</code>后面的target表示的也是一个伪造的target,而不是真实存在的文件target。</p><p>因此，在头部加上一行<code>.PHONY: clean</code>就可以解决这样的二义性问题。</p><p>当然，即便不加<code>.PHONY</code>，将<code>target</code>用作标签的任务，也属于phony类型的任务，只是有潜在的二义性罢了。phony类型的任务永远都属于过时类型，即，每次 <code>make</code>都会执行。因为这种类型的任务它没有文件产出，就无所谓检查，它的主体只是调用了另外的命令而以。</p><p>拿这里的 <code>all</code> 来说，当我们连续两次执行 <code>make</code>或 <code>make all</code> 时，得到：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-eg90q3lbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-eg90q3lbm8uzgl"><pre><code class="hljs shell">(base) ➜ makegcc -o main.out main.c<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span>(base) ➜ make<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span></code></pre></div></div><p>可以看到，属于 phony 类型的任务 <code>all</code>每次都会执行其中定义的 <code>command</code>(在这里只是一行注释)，而非phony 类型的任务 <code>main.out</code> 则走了增量编译的逻辑。</p><h2 id="makefile-基本知识">Makefile 基本知识</h2><p>如果说通过上面的部分能够对<code>makefile</code>的工作方式和用途有了大概的理解，弄清楚下面的内容将能够看懂大部分<code>makefile</code>代码，并且尝试根据自己的实际情况添加或修改命令。</p><p>当然，如果要深入使用，还是离不开查阅文档。这里只是抛砖引玉，仅介绍部分最常用的语法和特性。</p><h3 id="变量宏">变量/宏</h3><p>Makefile 中可使用变量（宏）来让脚本更加灵活和减少冗余。</p><p>其中变量使用 <code>$</code>加圆括号或花括号的形式来使用，<code>$(VAR)</code>，定义时类似于 C中定义宏，所以变量也可叫 Makefile 中的宏，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rgpxyclbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-rgpxyclbm8uzgl"><pre><code class="hljs shell">CC=gcc</code></pre></div></div><p>这里定义 <code>CC</code> 表示 <code>gcc</code>编译工具。然后在后续编译命令中，就可以使用 <code>$(CC)</code> 代替<code>gcc</code> 来书写 shell 命令了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-60ttnmlbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-60ttnmlbm8uzgl"><pre><code class="hljs makefile">+ CC=gcc<span class="hljs-section">all:main.out</span><span class="hljs-section">main.out: main.c</span>-gcc -o main.out main.c+<span class="hljs-variable">$(CC)</span> -o main.out main.c<span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>这样做的好处是什么？因为编译工具可能随着平台或环境或需要编译的目标不同，而不同。比如<code>gcc</code> 只是用来编译 C 代码的，如果是 C++ 你可能要用<code>g++</code> 来编译。如果是编译 WebAssembly 则需要使用<code>emcc</code>。</p><p>无论怎样变，我们只需要修改定义在文件开头的 <code>CC</code>变量即可，无须修改其他地方。这当然只是其中一点好处。</p><h3 id="自动变量">自动变量</h3><p>自动变量是在编译规则匹配后工具进行设置的，具体包括：</p><ul><li><code>$@</code>：代表产出文件名</li><li><code>$*</code>：代表产出文件名不包括扩展名</li><li><code>$&lt;</code>：依赖项中第一个文件名</li><li><code>$^</code>：空格分隔的去重后的所有依赖项</li><li><code>$+</code>：同上，但没去重</li><li><code>$?</code>：同上，但只包含比产出更新的那些依赖</li></ul><p>这些变量都只有一个符号，区别于正常用字母命名的变量需要使用<code>$(VAL)</code> 的形式来使用，自动变量无需加括号。</p><p>利用自动变量，前面示例可改造成：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p4sjmrlbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-p4sjmrlbm8uzgl"><pre><code class="hljs makefile">CC=gccTARGET=main.out<span class="hljs-section">all:<span class="hljs-variable">$(TARGET)</span></span><span class="hljs-variable">$(TARGET)</span>: main.c<span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-section">clean:</span>rm <span class="hljs-variable">$(TARGET)</span></code></pre></div></div><p>减少了重复代码，更加易于维护，需要修改时，改动比较小。</p><p>自动变量特别是<code>$@</code>和<code>$^</code>在实际中用的比较多，建议熟记。</p><h3 id="vpath-vpath">VPATH &amp; vpath</h3><p>可通过 <code>VPATH</code> 指定依赖文件及产出文件的搜索目录。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-phjgtwlbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-phjgtwlbm8uzgl"><pre><code class="hljs makefile">VPATH = src <span class="hljs-keyword">include</span></code></pre></div></div><p>通过小写的 <code>vpath</code> 可指定具体的文件名及扩展名类型，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tq5s1tlbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-tq5s1tlbm8uzgl"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.c src<span class="hljs-keyword">vpath</span> %.h <span class="hljs-keyword">include</span></code></pre></div></div><p>此处 <code>%</code> 表示文件名。</p><h3 id="依赖原则和匹配规则">依赖原则和匹配规则</h3><p>只定义了产出与依赖没包含任务命令的规则，我们常称为依赖规则。像下面这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r9nw98lbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-r9nw98lbm8uzgl"><pre><code class="hljs makefile">Main.o : Main.h Test1.h Test2.hTest1.o : Test1.h Test2.hTest2.o : Test2.h</code></pre></div></div><p>这种规则可达到这种效果，即，右边任何文件有变更，左边的产出便成为过时的了。</p><p>区别于明确指定了产出与依赖，如果一条规则包含通配符，则称作匹配规则（PatternRules）。</p><p>比如，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w2lsiflbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-w2lsiflbm8uzgl"><pre><code class="hljs makefile"><span class="hljs-section">%.o: %.c</span>gcc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span></code></pre></div></div><p>上面定义了这么一条编译规则，将所有匹配到的 c 文件编译成 Object产出。</p><p>有什么用？</p><p>这种规则一般不是直接调用的，是被其他它规则触间接使用。比如上面的依赖规则。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hb29tmlbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-hb29tmlbm8uzgl"><pre><code class="hljs makefile">%.o : %.cppg++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Main.o : Main.h Test1.h Test2.hTest1.o : Test1.h Test2.hTest2.o : Test2.h</code></pre></div></div><p>当右侧这些头文件有变动时，左边的产出会在 <code>make</code>时被检测到过时，于是会被执行。当执行时匹配规则 <code>%.o</code>会被匹配到，所以匹配规则里面的命令会执行，从而将 <code>cpp</code>文件编译成相应 Object文件。达到了依赖更新后批量更新产出的目的，而不需要写成这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oz0pk4lbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-oz0pk4lbm8uzgl"><pre><code class="hljs makefile">Main.o : Main.h Test1.h Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Test1.o : Test1.h Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Test2.o : Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span></code></pre></div></div><h3 id="makefile-赋值">Makefile 赋值</h3><p><code>=</code> : <strong>最容易出错</strong> 的赋值等号</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fj68oslbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-fj68oslbm8uzgl"><pre><code class="hljs makefile">VIR_A = AVIR_B = <span class="hljs-variable">$(VIR_A)</span> BVIR_A = AA</code></pre></div></div><p>最后<code>VIR_B</code>的值是<code>AA B</code>，而不是<code>A B</code>。在make时，会把整个makefile展开，最后决定变量的值</p><p><code>?=</code> : 如果没有被赋值过，则赋值等号后面的操作</p><p><code>+=</code> : 追加(append)</p><p><code>:=</code> : <strong>“正常”</strong> 的赋值</p><p>以一个小例子进行说明：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wukn1klbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-wukn1klbm8uzgl"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> DEFINE_VARVAR = “Hello World!”<span class="hljs-keyword">else</span><span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,<span class="hljs-keyword">define</span>)VAR ?= “Hello World! First!”<span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,add)VAR += “Kelly!”<span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,recover)VAR := “Hello World! Again!”<span class="hljs-keyword">endif</span><span class="hljs-section">all:</span>@echo <span class="hljs-variable">$(VAR)</span></code></pre></div></div><p>测试这些命令：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y3u0unlbm8uzgl"></i><span>shell</span><div class="collapse show" id="collapse-y3u0unlbm8uzgl"><pre><code class="hljs shell">(base) ➜ make DEFINE_VAR=true OPT=define“Hello World!”(base) ➜ make DEFINE_VAR=true OPT=add“Hello World!” “Kelly!”(base) ➜ make DEFINE_VAR=true OPT=recover“Hello World! Again!”(base) ➜ make DEFINE_VAR= OPT=define“Hello World! First!”(base) ➜ make DEFINE_VAR= OPT=add“Kelly!”(base) ➜ make DEFINE_VAR= OPT=recover“Hello World! Again!”</code></pre></div></div><h3 id="makefile-函数">Makefile 函数</h3><p>函数主要分为两类：make内嵌函数和用户自定义函数。对于 GNUmake内嵌的函数，直接引用就可以了；对于用户自定义的函数，要通过make的call函数来间接调用。</p><h4 id="内置函数">内置函数</h4><h5 id="通配符函数">通配符函数</h5><p>当我们想要对文件名进行通配时，可以采用通配符*或%来进行，如上所述。但只能将其用于规则目标或依赖以及<code>shell</code>命令中：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-d12xq4lbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-d12xq4lbm8uzgl"><pre><code class="hljs makefile"><span class="hljs-section">test: *.o</span>gcc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-section">*.o: *.c    </span>gcc -c <span class="hljs-variable">$^</span></code></pre></div></div><p>但是其他情况比如如果我们想要获取某个目录下所有的C文件列表，可以使用扩展通配符函数<code>wildcard</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3coud0lbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-3coud0lbm8uzgl"><pre><code class="hljs makefile">SRC  = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span>HEAD = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.h)</span><span class="hljs-section">all:    </span>@echo <span class="hljs-string">"SRC = <span class="hljs-variable">$(SRC)</span>"</span>    @echo <span class="hljs-string">"HEAD = <span class="hljs-variable">$(HEAD)</span>"</span></code></pre></div></div><h5 id="文本处理函数">文本处理函数</h5><p>如果需要在makefile里进行文件名查找、替换、过滤等操作，则文本处理函数能够帮到忙。可以参阅<a href="https://www.zhaixue.cc/makefile/makefile-text-func.html">这个网站</a>的介绍。</p><h5 id="shell-函数">shell 函数</h5><p>用shell函数在<code>makefile</code>执行过程中使用shell命令。函数的参数就是命令，返回值是命令的执行结果。它和反引号`` 具有相同的功能。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tg6r85lbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-tg6r85lbm8uzgl"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span>current_path = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">all:    </span>@echo <span class="hljs-string">"current_path = <span class="hljs-variable">$(current_path)</span>"</span></code></pre></div></div><h5 id="addprefix">addprefix</h5><p>格式：$(addprefix <code>prefix</code>,<code>&lt;names...&gt;</code>)功能：为文件序列添加前缀</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4l4uk8lbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-4l4uk8lbm8uzgl"><pre><code class="hljs makefile">Variable := <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> src/,foo bar)</span><span class="hljs-comment"># Variable ==&gt; src/foo src/bar</span></code></pre></div></div><h5 id="addsuffix">addsuffix</h5><p>格式：$(addsuffix<code>addsuffix</code>,<code>&lt;names...&gt;</code>)功能：为文件序列添加后缀</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bbai2qlbm8uzgl"></i><span>gams</span><div class="collapse show" id="collapse-bbai2qlbm8uzgl"><pre><code class="hljs gams"><span class="hljs-keyword">Variable</span> := $(addsuffix <span class="hljs-comment">.c,foo bar)</span># <span class="hljs-keyword">Variable</span> <span class="hljs-comment">==&gt; foo.c bar.c</span></code></pre></div></div><h5 id="basename">basename</h5><p>格式：$(basename <code>&lt;names...&gt;</code>)功能：从文件名序列中取出各个文件名的前缀部分（除去扩展名后的剩余部分）</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cjco6plbm8uzgl"></i><span>gams</span><div class="collapse show" id="collapse-cjco6plbm8uzgl"><pre><code class="hljs gams"><span class="hljs-keyword">Variable</span> := $(basename <span class="hljs-comment">src</span>/foo.c src<span class="hljs-number">-1.0</span>/<span class="hljs-comment">bar.c hacks)</span># <span class="hljs-keyword">Variable</span> <span class="hljs-comment">==&gt; src</span>/foo src<span class="hljs-number">-1.0</span>/<span class="hljs-comment">bar hacks</span></code></pre></div></div><h4 id="用户自定义函数">用户自定义函数</h4><p>GNUmake提供了大量的内嵌函数，大大方便了makefile编写。但根据需要，我们也需要自定义一些函数，然后在makefile中引用它们：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hc0af3lbm8uzgl"></i><span>makefile</span><div class="collapse show" id="collapse-hc0af3lbm8uzgl"><pre><code class="hljs makefile"><span class="hljs-section">PHONY: all</span><span class="hljs-keyword">define</span> func    @echo <span class="hljs-string">"pram1 = $(0)"</span>    @echo <span class="hljs-string">"pram2 = $(1)"</span><span class="hljs-keyword">endef</span><span class="hljs-section">all:    </span><span class="hljs-variable">$(<span class="hljs-built_in">call</span> func, hello zhaixue.cc)</span></code></pre></div></div><p>用户自定义函以define开头，endef结束，给函数传递的参数在函数中使用$(0)、$(1)引用，分别表示第1个参数、第2个参数…调用时要使用call函数间接调用，各个参数之间使用空格隔开。</p><h2 id="参考链接">参考链接</h2><p>如果希望进行更深入的了解可以参阅：</p><p><a href="https://www.gnu.org/software/make/">GNU make官网</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html#zz-2.">GCCand Make Compiling, Linking and Building C/C++ Applications</a></p><p>以及中文教程：</p><p><a href="https://seisman.github.io/how-to-write-makefile/index.html">跟我一起写Makefile</a></p>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理一二章</title>
    <link href="/posts/34738/"/>
    <url>/posts/34738/</url>
    
    <content type="html"><![CDATA[<h2 id="编译原理概述">编译原理概述</h2><p class="note note-info">此部分对应于龙书第一二章</p><h3 id="lec1从代码到可执行文件">Lec1从代码到可执行文件</h3><h4 id="编译器要做哪些事情">编译器要做哪些事情？</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190733227216_229_image-20220929095525300.png" alt="image-20220929095525300"><figcaption aria-hidden="true">image-20220929095525300</figcaption></figure><h5 id="一些gcc编译选项">一些gcc编译选项</h5><h6 id="actions"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id6">Actions</a></h6><p>The action to perform on the input.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-an7t5olb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-an7t5olb4jx62s"><pre><code class="hljs shell">-E, --preprocessOnly run the preprocessor-S, --assembleOnly run preprocess and compilation steps-c, --compileOnly run preprocess, compile, and assemble steps-emit-llvmUse the LLVM representation for assembler and object files</code></pre></div></div><h6 id="compilation-flags"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id7">Compilationflags</a></h6><p>Flags controlling the behavior of Clang during compilation. Theseflags have no effect during actions that do not perform compilation.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5v2v4wlb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-5v2v4wlb4jx62s"><pre><code class="hljs shell">-Xassembler &lt;arg&gt;`Pass &lt;arg&gt; to the assembler-Xclang &lt;arg&gt;, -Xclang=&lt;arg&gt;Pass &lt;arg&gt; to clang -cc1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190735472529_960_image-20220920154109066.png" alt="image-20220920154109066"><figcaption aria-hidden="true">image-20220920154109066</figcaption></figure><p>上面是<strong>抽象语法树</strong>：简化，只包含程序中出现的单词</p><p>下面是<strong>语义分析树（具体语法树）</strong>：完整，还包含抽象出的语法概念</p><h5 id="对过程的相关理解">对过程的相关理解</h5><p class="note note-info">C++编译器检查相容类型计算是否合规是在语义分析阶段编译器识别出标识符是在词法分析阶段</p><p class="note note-warning">C++编译器过滤注释是在_<strong>阶段。答案是词法分析，但实践表明预处理阶段就已经过滤注释了。C++编译器检查数组下标越界是在</strong>_阶段 C++并不会检查数组下标越界。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190736776341_330_image-20220920162038518.png" alt="image-20220920162038518"><figcaption aria-hidden="true">image-20220920162038518</figcaption></figure><p>显然符号表中不会存变量值，因为变量值在运行时才会确定。</p><p class="note note-info">符号表是在词法分析阶段创建的。(习题)</p><p>但是据龙书：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190738941427_725_image-20221004193852281.png" alt="image-20221004193852281"><figcaption aria-hidden="true">image-20221004193852281</figcaption></figure><h3 id="lec2-构造一个简单的编译器">Lec2 构造一个简单的编译器</h3><h4 id="上下文无关文法">上下文无关文法</h4><h5 id="感性理解">感性理解</h5><p>BNF 是一种<strong>上下文无关文法</strong>，那什么是上下文相关文法(CSG呢？</p><p>CSG 在 CFG的基础上进一步放宽限制。</p><p>产生式的左手边也可以有终结符和非终结符。左手边的终结符就是“上下文”的来源。也就是说匹配的时候不能光看当前匹配到哪里了，还得看当前位置的左右到底有啥（也就是上下文是啥），上下文在这条规则应用的时候并不会被消耗掉，只是“看看”。</p><h5 id="形式化定义">形式化定义</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190740496671_209_image-20220927144906987.png" alt="image-20220927144906987"><figcaption aria-hidden="true">image-20220927144906987</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190741666990_453_image-20220927144926174.png" alt="image-20220927144926174"><figcaption aria-hidden="true">image-20220927144926174</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190742819758_795_image-20220927144938067.png" alt="image-20220927144938067"><figcaption aria-hidden="true">image-20220927144938067</figcaption></figure><p>对闭包的理解</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190743880629_933_image-20220927144950874.png" alt="image-20220927144950874"><figcaption aria-hidden="true">image-20220927144950874</figcaption></figure><p>正闭包也叫正则闭包</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190746344914_185_image-20220927145026025.png" alt="image-20220927145026025"><figcaption aria-hidden="true">image-20220927145026025</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190747551802_775_image-20221004164810301.png" alt="image-20221004164810301"><figcaption aria-hidden="true">image-20221004164810301</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190748466161_250_image-20220927150609696.png" alt="image-20220927150609696"><figcaption aria-hidden="true">image-20220927150609696</figcaption></figure><p>在词法分析阶段，所有的expr都是同等对待的，因此不需要加下标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190749626754_765_image-20220927150731839.png" alt="image-20220927150731839"><figcaption aria-hidden="true">image-20220927150731839</figcaption></figure><p>idlist也可用右递归表示。两种方式等价，但生成的语法分析树不一样。</p><p>另外一种设计方案</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190750857129_584_image-20220927155732458.png" alt="image-20220927155732458" width="50%" height="50%"></p><h5 id="二义性语法和非二义性语法">二义性语法和非二义性语法</h5><p>非二义性语法</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190751862164_535_image-20220927154102321.png" alt="image-20220927154102321"><figcaption aria-hidden="true">image-20220927154102321</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190753296213_768_image-20220927154131189.png" alt="image-20220927154131189" width="50%" height="50%"></p><p>采用二义性语法，则会产生歧义问题，同一段代码在不同编译器上产生不一样的结果，显然是我们不想看到的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190754314719_452_image-20220927154314035.png" alt="image-20220927154314035"><figcaption aria-hidden="true">image-20220927154314035</figcaption></figure><p>但是在一定的场合下，通过设计合理的语法分析算法，我们是容许一定的二义性的，因为可以减小语法分析树的复杂性。</p><p>文法左递归，体现出运算符左结合，右递归则是右结合。</p><p>一个右结合的例子</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190755524185_246_image-20220927155426816.png" alt="image-20220927155426816" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190756637988_463_image-20220927161055294.png" alt="image-20220927161055294"><figcaption aria-hidden="true">image-20220927161055294</figcaption></figure><p>注意：不要跳级！左结合的，且从左往右替换。</p><h5 id="练习">练习</h5><h6 id="推导练习">推导练习</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190758243317_959_image-20220927161040537.png" alt="image-20220927161040537"><figcaption aria-hidden="true">image-20220927161040537</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190759789619_359_image-20220928164050330.png" alt="image-20220928164050330"><figcaption aria-hidden="true">image-20220928164050330</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190801270074_244_image-20220928164220732.png" alt="image-20220928164220732"><figcaption aria-hidden="true">image-20220928164220732</figcaption></figure><ol type="1"><li>S -&gt; 0 S 1 | 0 1</li><li>S -&gt; + S S | - S S | a</li><li>S -&gt; S ( S ) S | ε</li><li>S -&gt; a S b S | b S a S | ε</li></ol><p>生成的语言：</p><ol type="1"><li><p>L = {0<sup>n</sup>1<sup>n</sup> | n&gt;=1}</p></li><li><p>L = {支持加法和减法的表达式的前缀表达形式}</p></li><li><p>L = {匹配括号的任意排列和嵌套的括号串，包括 ε}</p><p>()() (()())等</p><p>有二义性：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221025232537498298_547_2.2.3-3.png" alt="2.2.3-3"><figcaption aria-hidden="true">2.2.3-3</figcaption></figure></li><li><p>L = {数量相同的a和b组成的符号串，包括 ε}</p></li></ol><p class="note note-warning">一个文法有二义性不一定就有两个推导！但一定有两课语法树</p><p><a href="https://blog.csdn.net/severestcritic/article/details/109816062?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109816062-blog-88792616.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109816062-blog-88792616.pc_relevant_aa&amp;utm_relevant_index=1">证明语法具有二义性的方法</a></p><h6 id="构建练习">构建练习</h6><p>①</p><p>通常左递归对应左结合，右递归对应右结合。</p><p>比如对于标识符列表：</p><ol type="1"><li>list -&gt; list , id | id</li><li>list -&gt; id , list | id</li></ol><p>1是左结合的，2是右结合的。</p><p>②</p><ol type="1"><li><p>证明：用下面文法生成的所有二进制串的值都能被3整除。`</p><p>num -&gt; 11 | 1001 | num 0 | num num</p><p>符合该文法的二进制串一定是由任意数量的 11，1001 和 0组成的最左位不为0的序列</p><p>该序列的十进制和为： <span class="math display">\[sum =\Sigma_n\left(2^1+2^0\right) *2^n+\Sigma_m\left(2^3+2^0\right) *2^m\\=\Sigma_n 3*2^n+\Sigma_m 9 * 2^m\]</span></p><p>显然是能被3整除的</p></li><li><p>上面的文法是否能生成所有能被3整除的二进制串？</p><p>不能。二进制串10101，数值为21，可被3整除，但无法由文法推导出。</p></li></ol><h4 id="语法制导翻译">语法制导翻译</h4><p>构造翻译模式，中缀-&gt;后缀构造9-5+2的带语义动作的语法分析树，即输出其后缀表达式95-2+</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190802895392_835_image-20220927164002512.png" alt="image-20220927164002512"><figcaption aria-hidden="true">image-20220927164002512</figcaption></figure><p>按深度优先遍历即可打印（翻译）出后缀表达式</p><h4 id="语法分析">语法分析</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190804367395_700_image-20221004152318374.png" alt="image-20221004152318374"><figcaption aria-hidden="true">image-20221004152318374</figcaption></figure><h5 id="自顶向下构造">自顶向下构造</h5><h6 id="平凡算法扫描输入分析">平凡算法：扫描输入分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190808051693_827_image-20221004153229852.png" alt="image-20221004153229852"><figcaption aria-hidden="true">image-20221004153229852</figcaption></figure><h6 id="优化预测分析">优化：预测分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190811525061_463_image-20221004152448359.png" alt="image-20221004152448359"><figcaption aria-hidden="true">image-20221004152448359</figcaption></figure><p><span class="math inline">\(lookahead\)</span>在构造编译器的时候就可以完成。</p><p>实例分析</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190813022183_796_image-20221004152827769.png" alt="image-20221004152827769"><figcaption aria-hidden="true">image-20221004152827769</figcaption></figure><p>对于<span class="math inline">\(simple\)</span>类似构造方法。</p><p><span class="math inline">\(lookahead\)</span>怎么构造？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190816136501_201_image-20221004153753520.png" alt="image-20221004153753520"><figcaption aria-hidden="true">image-20221004153753520</figcaption></figure><p>总体思路是什么，还有什么问题？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190818280251_227_image-20221004154007046.png" alt="image-20221004154007046"><figcaption aria-hidden="true">image-20221004154007046</figcaption></figure><h5 id="左递归问题">左递归问题</h5><p>针对上面的预测分析法，我们发现：左递归会导致递归下降程序无限循环以及预测分析法的失效。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sylx5clb4jx62s"></i><span>c</span><div class="collapse show" id="collapse-sylx5clb4jx62s"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">switch</span>(lookahead){        <span class="hljs-keyword">case</span> a:            A();match(a);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> b:            match(b):<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            report(<span class="hljs-string">"syntax error"</span>)    }}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190819993463_865_image-20221004160548627.png" alt="image-20221004160548627"><figcaption aria-hidden="true">image-20221004160548627</figcaption></figure><p>怎么消除？</p><p>固定的算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190821656013_971_image-20221004160612826.png" alt="image-20221004160612826"><figcaption aria-hidden="true">image-20221004160612826</figcaption></figure><p>理解：<span class="math inline">\(A=\beta \alpha \alpha...\)</span></p><p>采用右递归进行翻译</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190823148967_751_image-20221004161628877.png" alt="image-20221004161628877"><figcaption aria-hidden="true">image-20221004161628877</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190827034211_692_image-20221004161643180.png" alt="image-20221004161643180"><figcaption aria-hidden="true">image-20221004161643180</figcaption></figure><h5 id="练习-1">练习</h5><p>构造 S -&gt; S ( S ) S | ε 的语法分析器</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4gqmjylb4jx62s"></i><span>python</span><div class="collapse show" id="collapse-4gqmjylb4jx62s"><pre><code class="hljs python"><span class="hljs-comment"># a program to test lookahead grammar analysis</span><span class="hljs-comment"># S -&gt; S ( S ) S | ε to match brackets</span><span class="hljs-comment"># it can be simplified to S -&gt; ( S ) S | ε</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matcher</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, string</span>):        self.string = string        self.index = <span class="hljs-number">0</span>        self.lookahead = self.string[self.index] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.string) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>        self.process = <span class="hljs-string">"S"</span>        self.lookaheads = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">self, char</span>):        <span class="hljs-keyword">if</span> char == <span class="hljs-string">''</span>:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">elif</span> char == self.lookahead:            self.index += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> self.index &lt; <span class="hljs-built_in">len</span>(self.string):                self.lookahead = self.string[self.index]            <span class="hljs-keyword">else</span>:                self.lookahead = <span class="hljs-string">""</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not matched"</span>)            exit(<span class="hljs-number">1</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">S</span>(<span class="hljs-params">self</span>):        self.lookaheads.append(self.lookahead)        <span class="hljs-keyword">if</span> self.lookahead == <span class="hljs-string">'('</span>:            self.process = self.process.replace(<span class="hljs-string">"S"</span>, <span class="hljs-string">"( S ) S"</span>, <span class="hljs-number">1</span>)            <span class="hljs-built_in">print</span>(self.process)            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">'('</span>)            self.S()            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">')'</span>)            self.S()        <span class="hljs-keyword">else</span>:            self.process = self.process.replace(<span class="hljs-string">"S"</span>, <span class="hljs-string">"ε"</span>, <span class="hljs-number">1</span>)            <span class="hljs-built_in">print</span>(self.process)            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">''</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self</span>):        self.S()        <span class="hljs-keyword">if</span> self.lookahead == <span class="hljs-string">''</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Matched"</span>)            <span class="hljs-built_in">print</span>(self.process)            <span class="hljs-built_in">print</span>(self.lookaheads)        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not matched,the lookahead now is"</span>, self.lookahead)            <span class="hljs-built_in">print</span>(self.process)            <span class="hljs-built_in">print</span>(self.lookaheads)            exit(<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Enter a string to match: "</span>)    target = <span class="hljs-built_in">input</span>()    matcher = Matcher(target)    matcher.main()</code></pre></div></div><p>运行结果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221025232547008661_894_image-20221009204230516.png" alt="image-20221009204230516"><figcaption aria-hidden="true">image-20221009204230516</figcaption></figure><h4 id="词法分析">词法分析</h4>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在mac上编写运行c++程序</title>
    <link href="/posts/51388/"/>
    <url>/posts/51388/</url>
    
    <content type="html"><![CDATA[<h2 id="如何在mac上编写运行c程序">如何在mac上编写运行c++程序</h2><p>有一部分同学买的电脑是mac，也有很多同学问怎么在mac上写c++代码。在这里解答一下。</p><h3 id="方案一使用clion">方案一：使用Clion</h3><h4 id="下载">下载</h4><p><a href="https://www.jetbrains.com/clion/download/#section=mac">下载网址</a></p><p>如果你的苹果电脑是M1/M2芯片，那么请选择Apple Sillcon，否则选Intel</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230752211301_738_image-20220927201026604.png" alt="image-20220927201026604"><figcaption aria-hidden="true">image-20220927201026604</figcaption></figure><p>然后打开dmg文件将其拖到applcation文件夹即可。</p><h4 id="激活">激活</h4><p>Clion并不是一个免费的软件。但是作为学生，可以向其申请免费使用。点击<a href="https://www.jetbrains.com/zh-cn/community/education/#students">这里</a>进入申请页面。正常情况下用你的学生邮箱就可以申请。申请之后会自动跳转到Clion，激活成功。</p><h4 id="创建第一个项目">创建第一个项目</h4><p>点击“新建项目”，选择默认的c++ excutable</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230754550529_520_image-20220927203943145.png" alt="image-20220927203943145"><figcaption aria-hidden="true">image-20220927203943145</figcaption></figure><p>在location处可以改变项目路径和名称。</p><p>如果之前你没写过代码，可能会提示</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230756221193_195_image-20220927204027175.png" alt="image-20220927204027175"><figcaption aria-hidden="true">image-20220927204027175</figcaption></figure><p>安装即可。可能需要等待亿些时间。（类似于visualstudio的工具链，可能会捆绑一些你可能其实用不到的东西）</p><p>然后安装完确认一下</p><p align="center"><img alt="image-20220927211547461" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230757928357_218_image-20220927211547461.png" width="50%"></p><p>项目配置没有报错</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230759316655_492_image-20220927211608280.png" alt="image-20220927211608280"><figcaption aria-hidden="true">image-20220927211608280</figcaption></figure><p>然后选中CMakeLists，点击2处的刷新符号，重新构建</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230801131735_750_image-20220927211726878.png" alt="image-20220927211726878"><figcaption aria-hidden="true">image-20220927211726878</figcaption></figure><p>你应当发现此处的项目配置发生了改变。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230802745480_349_image-20220927211737021.png" alt="image-20220927211737021"><figcaption aria-hidden="true">image-20220927211737021</figcaption></figure><p>此时点击运行，运行helloworld程序，成功</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230804052581_398_image-20220927211838631.png" alt="image-20220927211838631"><figcaption aria-hidden="true">image-20220927211838631</figcaption></figure><h4 id="简单了解cmake">简单了解Cmake</h4><p>如果你想要在这个项目下运行多个cpp文件，你有必要了解一下cmake。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230805695741_398_image-20220927212015622.png" alt="image-20220927212015622"><figcaption aria-hidden="true">image-20220927212015622</figcaption></figure><p>你会发现cmakelist变成了这样。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230808172534_771_image-20220927212042215.png" alt="image-20220927212042215"><figcaption aria-hidden="true">image-20220927212042215</figcaption></figure><p>然后你顺理成章的点击了main函数旁边的运行</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230809367068_211_image-20220927212255496.png" alt="image-20220927212255496"><figcaption aria-hidden="true">image-20220927212255496</figcaption></figure><p>报错了！查看倒数第三行的报错信息，你会发现出现了重复（duplicate）的符号。</p><p>你想到课上使用vs时讲的，一个项目只能使用一个main函数。你把另外一个main改成了main2。学着这样修改。你发现确实可以正常运行。</p><p><font color="Apricot">但有没有更优雅的解决方案呢？</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230811319016_339_image-20220927212700579.png" alt="image-20220927212700579"><figcaption aria-hidden="true">image-20220927212700579</figcaption></figure><p>你注意到了cmake中最后一行是add_executable，刚刚发生了变化。从含义可以推测出一定是它控制了程序的执行。</p><p>让它们各自生成各自的程序一定可以！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230812325537_398_image-20220927212920160.png" alt="image-20220927212920160"><figcaption aria-hidden="true">image-20220927212920160</figcaption></figure><p>点击Reload changes。你会发现项目构建出现了两个程序。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230813838131_522_image-20220927213032997.png" alt="image-20220927213032997"><figcaption aria-hidden="true">image-20220927213032997</figcaption></figure><p>然后你高兴的发现点击哪个程序运行，你就可以运行哪一个cpp文件！</p><p>事实上，你点击cmake_build_debug，你会发现add_excutable第一个参数正是生成程序的名称！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230815024257_502_image-20220927213245467.png" alt="image-20220927213245467"><figcaption aria-hidden="true">image-20220927213245467</figcaption></figure><p>在访达打开<img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230816481939_447_image-20220927213323515.png" alt="image-20220927213323515"></p><p>双击---helloworld出现了！它正是你刚刚编写的程序！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230818933782_519_image-20220927213343594.png" alt="image-20220927213343594"><figcaption aria-hidden="true">image-20220927213343594</figcaption></figure><p>Cmake在大型项目管理中有着重要的用途，其本身也是十分复杂的。但在课程中只需要了解这些即可。</p><p>同时Clion在windows下也可以使用。</p><h3 id="方案二使用xcode">方案二：使用xcode</h3><p>xcode是专为mac平台打造的全功能IDE（当然你要问我能不能写exe，只能说emmm）</p><p>xcode比较大，下载需要耐心等待。</p><h4 id="项目搭建">项目搭建</h4><p>点击新建项目</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230821620085_933_image-20220927213913046.png" alt="image-20220927213913046"><figcaption aria-hidden="true">image-20220927213913046</figcaption></figure><p>选择macOS控制台应用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230823254664_156_image-20220927213932265.png" alt="image-20220927213932265"><figcaption aria-hidden="true">image-20220927213932265</figcaption></figure><p>项目选项</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230824771816_210_image-20220927214102217.png" alt="image-20220927214102217"><figcaption aria-hidden="true">image-20220927214102217</figcaption></figure><p>注意组织名称写com，别的其实也行，但此处不作介绍。</p><p>语言选择c++。</p><p>选择项目位置后就可以愉快开发了！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230826057443_745_image-20220927214344955.png" alt="image-20220927214344955"><figcaption aria-hidden="true">image-20220927214344955</figcaption></figure><p>控制台在屏幕下方。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230827635084_833_image-20220927214423776.png" alt="image-20220927214423776"><figcaption aria-hidden="true">image-20220927214423776</figcaption></figure><h4 id="运行多个cpp">运行多个cpp</h4><p>这个时候已经创建了一个cpp-project的项目，里面包含了一个main.cpp文件如果这个时候想要在同一个工程里面创建第二个带main函数的c++文件并运行，就需要通过创建Target来实现</p><p>Project是一个工程项目，一个Project可以包含多个TargetTarget之间互相没有关系，Target于Project的关系是：Target的Setting一部分继承自Project的Setting</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230828821606_386_image-20220927214845054.png" alt="image-20220927214845054"><figcaption aria-hidden="true">image-20220927214845054</figcaption></figure><p>新建target，同样选择commandline tool，填写一个的名称</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230831064192_247_image-20220927215021382.png" alt="image-20220927215021382"><figcaption aria-hidden="true">image-20220927215021382</figcaption></figure><p>在上方，想运行哪一个target，选择对应的即可。</p><p align="center"><img alt="image-20220927215233319" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230832540286_682_image-20220927215233319.png" width="50%"></p><h3 id="方案三命令行方式">方案三：命令行方式</h3><p>安装homebrew（如果已经下载过xcode可以跳过，不过既然如此为什么不用xcode呢？）</p><p>在你的终端输入这行指令：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5iq0hxlb4jx62s"></i><span>awk</span><div class="collapse show" id="collapse-5iq0hxlb4jx62s"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>bash -c <span class="hljs-string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</span></code></pre></div></div><p>如果下载很慢一般是网络问题，请自行解决。</p><p>安装完成后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qpwvwplb4jx62s"></i><span>mipsasm</span><div class="collapse show" id="collapse-qpwvwplb4jx62s"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>g++</code></pre></div></div><p>任意位置新建cpp文件。</p><p>cpp文件可以用你喜欢的方式打开编辑。</p><p>按⌘（command）+ ⌥（option）+c复制当前文件夹路径</p><p>终端输入</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-e8g89elb4jx62s"></i><span>bash</span><div class="collapse show" id="collapse-e8g89elb4jx62s"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 刚才的路径</code></pre></div></div><p>然后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r8c8m0lb4jx62s"></i><span>aspectj</span><div class="collapse show" id="collapse-r8c8m0lb4jx62s"><pre><code class="hljs aspectj">g++ yourprogram.cpp -o <span class="hljs-keyword">target</span></code></pre></div></div><p>target 是生成的可执行文件的名字。</p><p>然后会发现生成了可执行文件，点击即可运行。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230833974800_101_image-20220927220347236.png" alt="image-20220927220347236"><figcaption aria-hidden="true">image-20220927220347236</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索_索引构建、压缩及查询支持</title>
    <link href="/posts/16720/"/>
    <url>/posts/16720/</url>
    
    <content type="html"><![CDATA[<h2 id="信息检索第一部分--索引构建">信息检索第一部分--索引构建</h2><h3 id="倒排索引构建">倒排索引构建</h3><p>六个步骤</p><p>序列化，语言预处理，分配DocID，排序，归并，添加频率标签</p><p class="note note-info">为什么要加文本频率？ 便于进行词频的排序，利于后续查询优化</p><h3 id="倒排索引布尔查询">倒排索引布尔查询</h3><p>略。并行课有涉及。比如当求交时可以先将短的链表求交。</p><h3 id="倒排索引优化改进">倒排索引优化改进</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143627586751_718_image-20220922093753305.png" alt="image-20220922093753305"><figcaption aria-hidden="true">image-20220922093753305</figcaption></figure><p>为了减少字符串所占用的内存，我们可以将键进行序列化。</p><p>Assume we have 1GB of text 800,000 documents 100 million tokens（Reuters-RCV1 collection）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143628933413_566_image-20220922094643439.png" alt="image-20220922094643439" width="50%" height="50%"></p><p>（假设是用int存docID）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143629914308_735_image-20220922095054178.png" alt="image-20220922095054178" width="50%" height="50%"></p><p>16*1.4</p><p>看上去很好。</p><p>然而，代价是必须要维护一张termID和字符串的映射表。</p><p>当需要处理的数据特别多时，由于排序，归并过程中所有的数据都需要这个表，就不得不一直将它放到内存里。</p><h4 id="bsbiblocked-sort-based-indexing">BSBI（Blocked Sort-BasedIndexing）</h4><p>仍然保留进行映射的策略</p><p>此算法的主要步骤如下：</p><p>1、将文档中的词进行id的映射，这里可以用hash的方法去构造</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143631068932_652_image-20220922100056227.png" alt="image-20220922100056227" width="50%" height="50%"></p><p>当然，可以先把全部文档读一遍构建映射，再分块构建倒排索引，也可以在构建每一块的倒排索引的时候边构建边映射。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143632700535_256_image-20220922101046446.png" alt="image-20220922101046446" width="50%" height="50%"></p><p>2、将文档分割成大小相等的部分。分治</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143634153162_211_image-20220922095854934.png" alt="image-20220922095854934" width="50%" height="50%"></p><p>3、将每部分按照词ID对上文档ID的方式进行排序（保证分块可以在内存里放下）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143635299312_759_image-20220922095946828.png" alt="image-20220922095946828" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143636457198_361_image-20220922100557902.png" alt="image-20220922100557902"><figcaption aria-hidden="true">image-20220922100557902</figcaption></figure><p>4、将每部分排序好后的结果进行合并，最后写出到磁盘中。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143637743125_385_image-20220922095721101.png" alt="image-20220922095721101" width="50%" height="50%"></p><p>归并的过程中也可以分治，比如内存中只能放100个词条的总倒排索引，可以在第100个的时候写出磁盘（因为已经确定是最后结果了），从101个再继续。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143639158715_536_image-20220922102146120.png" alt="image-20220922102146120" width="50%" height="50%"></p><h4 id="spimisingle-pass-in-memory-indexing">SPIMI（Single-PassIn-Memory Indexing）</h4><p>不作映射，其他与BSBI一样</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143640277003_250_image-20220922101959755.png" alt="image-20220922101959755" width="50%" height="50%"></p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143641398914_475_image-20220922102104189.png" alt="image-20220922102104189" width="50%" height="50%"></p><p>因为D显然要比T小的多</p><h4 id="分布式解决方案mapreduce">分布式解决方案MapReduce</h4><p>大数据实训有涉及，略。</p><h3 id="在线索引构建">在线索引构建</h3><h4 id="朴素方案">朴素方案</h4><h5 id="朴素方案一重建索引">朴素方案一：重建索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143642866848_892_image-20220928141323699.png" alt="image-20220928141323699"><figcaption aria-hidden="true">image-20220928141323699</figcaption></figure><h5 id="朴素方案二辅助索引">朴素方案二：辅助索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143644019596_168_image-20220928141427687.png" alt="image-20220928141427687"><figcaption aria-hidden="true">image-20220928141427687</figcaption></figure><p>使用辅助索引的话，一个很简便的思路是一个词建一个文档，归并便变为两个文档的合并。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143645445454_230_image-20220928141820357.png" alt="image-20220928141820357"><figcaption aria-hidden="true">image-20220928141820357</figcaption></figure><p>有什么缺陷？文件大小可能差距很大，且大量小文件不便于存储和对索引的快速读写（存储系统的问题）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143646682137_270_image-20220928142759774.png" alt="image-20220928142759774"><figcaption aria-hidden="true">image-20220928142759774</figcaption></figure><p>更大的问题，随着文档的数量变大，归并会越来越慢！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143647947499_639_image-20220928142854979.png" alt="image-20220928142854979"><figcaption aria-hidden="true">image-20220928142854979</figcaption></figure><p>合并时termID是有序的，归并时类似于归并排序，最坏复杂度是较大的那个索引的termID个数。而单个倒排索引合并只需要把新的list放到旧的后面就可以了，因为新的list中的docID肯定会比旧的大（就像上面图上所示）<span class="math display">\[O\left(n+2n+\ldots+\frac{T}{n}\right)=O\left(\frac{T^2}{n}\right)\]</span></p><h4 id="文档删除怎么操作">文档删除怎么操作？</h4><p>无效向量</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143649321808_563_image-20220928142307585.png" alt="image-20220928142307585"><figcaption aria-hidden="true">image-20220928142307585</figcaption></figure><h3 id="倒排索引压缩">倒排索引压缩</h3><h4 id="一些朴素的偷懒方法">一些朴素的偷懒方法</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143650616612_634_image-20220928155207922.png" alt="image-20220928155207922"><figcaption aria-hidden="true">image-20220928155207922</figcaption></figure><p>但是现代检索系统一般不会这么做，因为会导致一些信息的丢失。</p><h4 id="词典压缩">词典压缩</h4><h5 id="方法一使用数组">方法一：使用数组</h5><p>是一种很蠢的方法</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143654714754_145_image-20220928152210011.png" alt="image-20220928152210011" width="50%" height="50%"></p><h5 id="方法二指针">方法二：指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143655839716_271_image-20220928151740804.png" alt="image-20220928151740804"><figcaption aria-hidden="true">image-20220928151740804</figcaption></figure><h5 id="方法二的优化分段指针">方法二的优化：分段指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143657755792_576_image-20220928152418457.png" alt="image-20220928152418457"><figcaption aria-hidden="true">image-20220928152418457</figcaption></figure><p>当然，找termID对应的词项会慢一些。</p><h5 id="采用前缀的方式">采用前缀的方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143659531464_413_image-20220928153011321.png" alt="image-20220928153011321"><figcaption aria-hidden="true">image-20220928153011321</figcaption></figure><h4 id="索引表压缩">索引表压缩</h4><h5 id="encoding-gaps">Encoding gaps</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143700905497_456_image-20220928153421273.png" alt="image-20220928153421273"><figcaption aria-hidden="true">image-20220928153421273</figcaption></figure><h5 id="variable-length-codings">Variable length codings</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143702089613_543_image-20220928153533933.png" alt="image-20220928153533933"><figcaption aria-hidden="true">image-20220928153533933</figcaption></figure><p>例子：可变长UTF-8</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143703419174_526_image-20220928153849498.png" alt="image-20220928153849498"><figcaption aria-hidden="true">image-20220928153849498</figcaption></figure><p>UTF-8 的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的Unicode 码。</p><p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p><p></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ajh6a1lb4jx62s"></i><span>asciidoc</span><div class="collapse show" id="collapse-ajh6a1lb4jx62s"><pre><code class="hljs asciidoc">Unicode符号范围     |        UTF-8编码方式<span class="hljs-section">(十六进制)        |              （二进制）</span><span class="hljs-section">-------------------+---------------------------------------------</span>0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre></div></div><p></p><p>根据上表，解读 UTF-8编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>下面，以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p><p><code>严</code>的 Unicode是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的UTF-8编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的UTF-8编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p><h5 id="gamma-encoding">Gamma Encoding</h5><p>根据<a href="https://en.wikipedia.org/wiki/Elias_gamma_coding">维基百科</a>所述，gamma编码过程如下图所示。虽具体过程与课上讲述稍有不同，但原理是一样的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143704774266_595_image-20220930155723916.png" alt="image-20220930155723916"><figcaption aria-hidden="true">image-20220930155723916</figcaption></figure><p>编码具体案例和解码过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143706251591_500_image-20220930155802505.png" alt="image-20220930155802505"><figcaption aria-hidden="true">image-20220930155802505</figcaption></figure><h3 id="查询优化">查询优化</h3><h4 id="倒排索引数据结构优化">倒排索引数据结构优化</h4><h5 id="跳表">“跳表”</h5><p>动机</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143708733468_476_image-20221005150319520.png" alt="image-20221005150319520"><figcaption aria-hidden="true">image-20221005150319520</figcaption></figure><p>怎么选取间隔？“摔瓶子”。开根号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143710120784_928_image-20221005150404678.png" alt="image-20221005150404678"><figcaption aria-hidden="true">image-20221005150404678</figcaption></figure><p>实例：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143711476304_852_image-20221005150523460.png" alt="image-20221005150523460"><figcaption aria-hidden="true">image-20221005150523460</figcaption></figure><p class="note note-info">为什么是先跳再判断，如果跳过了再倒回去，而不是比较之后再跳？后者比较次数太多，开销大，且慢。</p><h4 id="词项数据结构">词项数据结构</h4><h5 id="哈希表">哈希表</h5><p>优点：快</p><p>缺点：不支持模糊查询</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143713258991_492_image-20221005152131580.png" alt="image-20221005152131580"><figcaption aria-hidden="true">image-20221005152131580</figcaption></figure><h5 id="b树">B树</h5><p>实际使用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143716445073_262_image-20221005152231798.png" alt="image-20221005152231798"><figcaption aria-hidden="true">image-20221005152231798</figcaption></figure><h4 id="通配符查询支持">通配符查询支持</h4><p>前缀：B树天然支持</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143718721740_938_image-20221005153943805.png" alt="image-20221005153943805"><figcaption aria-hidden="true">image-20221005153943805</figcaption></figure><p>后缀：对逆序建B树</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143720264162_261_image-20221005154022485.png" alt="image-20221005154022485"><figcaption aria-hidden="true">image-20221005154022485</figcaption></figure><p>中间的？好像有点问题。。。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143721509249_850_image-20221012140726185.png" alt="image-20221012140726185" width="50%" height="50%"></p><h4 id="轮排索引">轮排索引</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143722646249_170_image-20221012141847402.png" alt="image-20221012141847402"><figcaption aria-hidden="true">image-20221012141847402</figcaption></figure><p>采用B树。但通常这种方法产生的B树会非常大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143723834048_694_image-20221012143335531.png" alt="image-20221012143335531"><figcaption aria-hidden="true">image-20221012143335531</figcaption></figure><h4 id="k-gram">K-gram</h4><p>一定程度上的优化</p><p>在一定长度的字串上建索引</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143725269033_823_image-20221012143730369.png" alt="image-20221012143730369"><figcaption aria-hidden="true">image-20221012143730369</figcaption></figure><p>查$co,ter,er$,$代表起始和结束符号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143726834159_151_image-20221012144353569.png" alt="image-20221012144353569"><figcaption aria-hidden="true">image-20221012144353569</figcaption></figure><h3 id="拼写检查支持">拼写检查支持</h3><h4 id="动态规划编辑距离">动态规划：编辑距离</h4><p>动态规划求字符串距离？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143728315657_544_image-20221012150059012.png" alt="image-20221012150059012"><figcaption aria-hidden="true">image-20221012150059012</figcaption></figure><p>词项太多，算法显得有些复杂，慢</p><h4 id="在k-gram基础上进行">在K-gram基础上进行</h4><p>Jaccard distance判断相似度</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143729475948_696_image-20221012151057155.png" alt="image-20221012151057155"><figcaption aria-hidden="true">image-20221012151057155</figcaption></figure><p>求并集的小trick</p><p>#query term's k-grams +#found term's k-grams-#intersection</p><h4 id="上下文相关检查">上下文相关检查</h4><p>利用搜索历史，启发式</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_进程与线程模型</title>
    <link href="/posts/30463/"/>
    <url>/posts/30463/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统--进程与线程">操作系统--进程与线程</h2><h3 id="进程概念">进程概念</h3><h4 id="从并发开始">从并发开始</h4><p>串行排队</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110755222583_746_image-20220926142304076.png" alt="image-20220926142304076"><figcaption aria-hidden="true">image-20220926142304076</figcaption></figure><p>分时调用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110756926120_483_image-20220926142216136.png" alt="image-20220926142216136"><figcaption aria-hidden="true">image-20220926142216136</figcaption></figure><p>“但是并发除了会让脑子更乱以外并不会让事情变得更好”</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110758632298_262_image-20220926151301063.png" alt="image-20220926151301063"><figcaption aria-hidden="true">image-20220926151301063</figcaption></figure><p>尽管如此，并发确实可以提高CPU的利用率。当然可能会带来设备（慢操作）延迟。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110801392732_151_image-20221018192004694.png" alt="image-20221018192004694"><figcaption aria-hidden="true">image-20221018192004694</figcaption></figure><p>C</p><p><strong>进程就是为了“保存”和“恢复”一个程序的执行过程，以实现并发的目标</strong></p><h4 id="进程和程序的区别">进程和程序的区别</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110803473763_292_image-20221016200649356.png" alt="image-20221016200649356"><figcaption aria-hidden="true">image-20221016200649356</figcaption></figure><h3 id="进程和线程的区别">进程和线程的区别</h3><ul><li><p>进程作为分配资源的基本单位，线程作为独立运行和独立调度的基本单位(注意：在多线程OS 中，进程不是一个可执行的实体)</p></li><li><p>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</p></li></ul><h3 id="进程的数据结构--pcb">进程的数据结构--PCB</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110805822552_826_image-20220926152249647.png" alt="image-20220926152249647"><figcaption aria-hidden="true">image-20220926152249647</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110807671323_383_image-20221018191442452.png" alt="image-20221018191442452"><figcaption aria-hidden="true">image-20221018191442452</figcaption></figure><h3 id="进程的组织">进程的组织</h3><h4 id="进程状态和切换">进程状态和切换</h4><p class="note note-primary">对于某一个进程： 为什么被暂停了？ 为什么选它来运行？为什么选择这个时机进行切换？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110809885582_767_image-20221018191551669.png" alt="image-20221018191551669"><figcaption aria-hidden="true">image-20221018191551669</figcaption></figure><p>操作系统可以将会触发慢操作的状态记录下来。</p><p class="note note-primary">“把printf的汇编代码放到自己的程序中，并且把控制休眠的指令注释掉，会不会能正常运行？”</p><p>不能。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110811863911_528_image-20220926161106287.png" alt="image-20220926161106287" width="50%" height="50%"></p><h5 id="五状态进程模型">五状态进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110813764309_930_image-20221014152546893.png" alt="image-20221014152546893"><figcaption aria-hidden="true">image-20221014152546893</figcaption></figure><p>关于进程的创建：</p><p>在一个进程被新建时它并非绝对会被调入内存，通常是分两步，首先创建该进程的PCB，并与之关联，但是此时可能面临内存不足或者操作系统限制了最大进程数导致这个进程还无法被调入进程，因此该进程被暂时留在新建态，在这个状态的进程PCB已经创建并且加载进内存，但是进程的代码和数据往往还留在外存中等待加载。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110816170775_715_image-20221018205252597.png" alt="image-20221018205252597"><figcaption aria-hidden="true">image-20221018205252597</figcaption></figure><p>关于进程的撤销(结束)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110817967015_206_image-20221016192515282.png" alt="image-20221016192515282"><figcaption aria-hidden="true">image-20221016192515282</figcaption></figure><blockquote><p>B。进程有它的生命周期，不会一直存在于系统中，也不一定需要用户显式地撒销。进程在时间片结束时只是就绪，而不是撤销。阻塞和唤醒是进程生存期的中间状态。进程可在完成时撤销，或在出现内存错误等时撤销。</p></blockquote><p>关于进程的阻塞</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110819440912_574_image-20221018192631681.png" alt="image-20221018192631681"><figcaption aria-hidden="true">image-20221018192631681</figcaption></figure><p>阻塞态完了会进就绪队列</p><p><a target="_blank" href="https://houbb.github.io/2020/10/04/os-04-sync" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">关于临界资源及其同步和互斥</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://houbb.github.io/2020/10/04/os-04-sync</span></span></span></a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110821096921_713_image-20221018214846546.png" alt="image-20221018214846546"><figcaption aria-hidden="true">image-20221018214846546</figcaption></figure><blockquote><p>B 可以共享一部分资源，但不共享虚拟地址空间</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110822817914_214_image-20221018214339806.png" alt="image-20221018214339806"><figcaption aria-hidden="true">image-20221018214339806</figcaption></figure><blockquote><p>C</p></blockquote><h5 id="添加了挂起状态的进程模型">添加了挂起状态的进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110824611329_729_image-20220926162706586.png" alt="image-20220926162706586"><figcaption aria-hidden="true">image-20220926162706586</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110826436181_342_image-20221014151453508.png" alt="image-20221014151453508"><figcaption aria-hidden="true">image-20221014151453508</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110828695748_821_image-20221018192900616.png" alt="image-20221018192900616"><figcaption aria-hidden="true">image-20221018192900616</figcaption></figure><p>A</p><p class="note note-info">不同操作系统中进程状态设置区别很大。</p><h5 id="进程调度方式">进程调度方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110830191623_314_image-20220926162928685.png" alt="image-20220926162928685"><figcaption aria-hidden="true">image-20220926162928685</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110832168851_702_image-20220926163633315.png" alt="image-20220926163633315"><figcaption aria-hidden="true">image-20220926163633315</figcaption></figure><p>现在的操作系统都是可抢占系统。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110834324423_859_image-20221018205406513.png" alt="image-20221018205406513"><figcaption aria-hidden="true">image-20221018205406513</figcaption></figure><blockquote><p>A。BC应该将优先级，D时机不合适。</p><p>此部分将在进程调度中详细介绍。</p></blockquote><h4 id="进程通信">进程通信</h4><p>共享存储，消息传递，管道通信</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110836886804_366_image-20221018211857840.png" alt="image-20221018211857840"><figcaption aria-hidden="true">image-20221018211857840</figcaption></figure><p><a href="https://zhuanlan.zhihu.com/p/58489873">linux中的管道通信</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110839761934_452_image-20221018211911941.png" alt="image-20221018211911941"><figcaption aria-hidden="true">image-20221018211911941</figcaption></figure><blockquote><p>A得俩。B容量是一个页的大小(4KB)。管道是一个文件，任何两个不相关的进程当然都可以通过这个管道文件进行通信</p></blockquote><h4 id="进程和线程的设计模型">进程和线程的设计模型</h4><h5 id="线程实现方式">线程实现方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110841591537_254_image-20221018194121923.png" alt="image-20221018194121923"><figcaption aria-hidden="true">image-20221018194121923</figcaption></figure><h6 id="ultuser-level-thread">ULT(User Level Thread)</h6><p>需要注意的是在这种模式下调度仍是以进程为单位进行的</p><p>优势:</p><p>1.线程切换不需要内核模式特权.</p><p>2.线程调用可以是应用程序级的,根据需要可改变调度算法,但不会影响底层的操作系统调度程序.</p><p>3.ULT管理模式可以在任何操作系统中运行,不需要修改系统内核,线程库是提供应用的实用程序。</p><p>劣势:</p><p>1.系统调用(慢操作，如输入输出)会引起进程阻塞，而且进程内的所有线程都被阻塞。(内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行)</p><p>2.不利于使用多处理器并行</p><h6 id="klt">KLT</h6><p>优势：灵活，线程切换快</p><p>劣势：需要用户态到内核态的切换，代价高</p><p>线程库：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110843340452_876_image-20221018193551401.png" alt="image-20221018193551401"><figcaption aria-hidden="true">image-20221018193551401</figcaption></figure><figure><img src="/Users/tianjiaye/Library/Application%20Support/typora-user-images/image-20221031161210652.png" alt="image-20221031161210652"><figcaption aria-hidden="true">image-20221031161210652</figcaption></figure><figure><img src="/Users/tianjiaye/Library/Application%20Support/typora-user-images/image-20221031161504084.png" alt="image-20221031161504084"><figcaption aria-hidden="true">image-20221031161504084</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110847145883_201_image-20221018205754448.png" alt="image-20221018205754448"><figcaption aria-hidden="true">image-20221018205754448</figcaption></figure><blockquote><p>D.其他线程对此不可见</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110848853722_394_image-20221018214600427.png" alt="image-20221018214600427"><figcaption aria-hidden="true">image-20221018214600427</figcaption></figure><blockquote><p>B只有在KLT中才会这么做</p></blockquote><h5 id="轻权进程"><a href="https://en.wikipedia.org/wiki/Light-weight_process#cite_note-Vah96-1">轻权进程</a></h5><p>类似于一种折衷的方案。但是问题是太复杂</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110850808418_676_image-20221018234308117.png" alt="image-20221018234308117"><figcaption aria-hidden="true">image-20221018234308117</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-模型评估与选择</title>
    <link href="/posts/4810/"/>
    <url>/posts/4810/</url>
    
    <content type="html"><![CDATA[<h2 id="模型评估与选择">模型评估与选择</h2><h3 id="模型评估方法">模型评估方法</h3><p>书后习题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234157710423_473_image-20220930231043281.png" alt="image-20220930231043281"><figcaption aria-hidden="true">image-20220930231043281</figcaption></figure><h3 id="经验误差和泛化误差">经验误差和泛化误差</h3><h4 id="定义">定义</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234159328307_660_image-20220930140833923.png" alt="image-20220930140833923"><figcaption aria-hidden="true">image-20220930140833923</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234200690193_368_image-20220930141041690.png" alt="image-20220930141041690"><figcaption aria-hidden="true">image-20220930141041690</figcaption></figure><h4 id="解决过拟合现象正则化">解决过拟合现象：正则化</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234202870906_724_image-20220930141142762.png" alt="image-20220930141142762"><figcaption aria-hidden="true">image-20220930141142762</figcaption></figure><h3 id="性能度量">性能度量</h3><h4 id="基本概念">基本概念</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234204833875_372_image-20220930163038120.png" alt="image-20220930163038120"><figcaption aria-hidden="true">image-20220930163038120</figcaption></figure><h4 id="p-r曲线和roc曲线">P-R曲线和ROC曲线</h4><h5 id="实例">实例</h5><p><a href="https://zhuanlan.zhihu.com/p/92218196">知乎</a>上有一个案例对这些曲线描述的比较形象。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234208101296_478_image-20220930194835021.png" alt="image-20220930194835021"><figcaption aria-hidden="true">image-20220930194835021</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234209475943_307_image-20220930194858579.png" alt="image-20220930194858579"><figcaption aria-hidden="true">image-20220930194858579</figcaption></figure><p>TPR真阳性，FPR假阳性</p><p>一个表现平平的分类器(表现是指分类标准能否将两种样本有效的分开，而threshold是指划分标准更倾向于查全率或准确率)</p><p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234211807031_249_norm.gif" width=""></p>一个更好一些的分类器<p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234215190380_315_norm2.gif" width=""></p><p>F1计算</p><p align="center"><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234218188978_486_F1.gif" width="" hight=""></p><h5 id="用途">用途</h5><p>基于P-R曲线可以大致评判机器学习模型的好坏</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234219845677_195_image-20220930224302678.png" alt="image-20220930224302678"><figcaption aria-hidden="true">image-20220930224302678</figcaption></figure><p>ROC也是如此。</p><p>从定义可知， AUC 可 通过对 ROC 曲 线下各部分的面积 求和而得.</p><p>形式化地看， AUC 考虑的是样本预测的排序质量。</p><p>习题：若学习器A的F1值比学习器B高，试析A的BEP值是否也比B高</p><p>二者是不同维度的指标。当然在达到BEP的条件时(P=R)，F1的值和BEP相等。</p><h4 id="roc代价曲线">ROC代价曲线</h4><p>参考<a href="https://www.zhihu.com/question/63492375">知乎答案</a></p><p>首先, 横坐标是 <span class="math inline">\(\mathrm{P}(+)\)</span>,由公式3可以知道, 当 <span class="math inline">\(\mathrm{P}(+)=0\)</span>时, <span class="math inline">\({c o s t}_{n o rm}=\mathrm{FPR}\)</span>; 当 <span class="math inline">\(\mathrm{P}(+)=1\)</span> 时, <span class="math inline">\(\operatorname{cost}_{n o rm}=\mathrm{FNR}_{\circ}\)</span> 直白含义：当我用来检测模型好坏的样本全是负例(即 $(+)=0 $)，那我模型产生的错误就只有负例被错误的预测 为正例这一种情况, 就是 <span class="math inline">\((0, F P R)\)</span> 。 同样,当我用来检测模型好坏的样本全都是正例（即 $(+)=1 $)，那我模型产生的错误就只有正例被错 误的预测为负例的情况这一种情况，就是<span class="math inline">\((1, \mathrm{FNR})\)</span>两个连线中间的情况, 用来检测模型的样本有正例也有负例的时候, 也就是 <span class="math inline">\(P(+)=0 . x\)</span>, 这时候 <span class="math inline">\(\operatorname{cost}_{n o r m}\)</span>的取值就会同时受到FPR和FNR的影响。</p><p>很像高中化学读图题的定性分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234221742723_477_image-20220930222355725.png" alt="image-20220930222355725"><figcaption aria-hidden="true">image-20220930222355725</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234223625316_668_image-20220930222637642.png" alt="image-20220930222637642"><figcaption aria-hidden="true">image-20220930222637642</figcaption></figure><p>就像做核酸”粉饰太平“一样( <span class="math display">\[P(+)=\frac{p \cdot \cos _{0 \mid 1}}{p \cdot \operatorname{cost}_{0 \mid1}+(1-p) \cdot \operatorname{cost}_{1 \mid 0}}\]</span> <span class="math inline">\(\operatorname{cost}_{0 \mid1}\)</span> 表示: 实际为正类, 而错判成负类的代价, <span class="math inline">\(\operatorname{cost}_{1 \mid 0}\)</span> 表示:实际为负类, 而错判成正类类Q 的代价。 举例说明, 当我们认为,正例错判为负例的代价与负例错判为正例的代价相同时, <span class="math inline">\(P^1(+)=p\)</span>当我们认为把正类判定为负类会造成更大的损失时(比如假设核酸检测瞒报比误报代价更大),此时 <span class="math inline">\(\operatorname{cost}_{1 \mid 0}&gt;;\cost_{0 \mid 1}\)</span>, 带入正例代价公式 得 <span class="math inline">\(P^2(+)\)</span>, 这时候就有 <span class="math inline">\(P^2(+)&gt;;P^1(+)\)</span> 。 对应到ROC代价图,正例概率 <span class="math inline">\(P(+)\)</span> 就会往左移动,对应的阈值就会减小, 模型对负类的判断就会更谨慎(比如下调CT值)。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234224685263_266_image-20220930142416369.png" alt="image-20220930142416369"><figcaption aria-hidden="true">image-20220930142416369</figcaption></figure><p><span class="math inline">\(\beta\)</span>&gt;1时查全率有更大影响；<span class="math inline">\(\beta\)</span>&lt;1时查准率有更大影响。</p><p>(核酸检测评价假设偏向减少瞒报，则<span class="math inline">\(\beta&gt;1\)</span>)</p><h3 id="比较检验">比较检验</h3><p>单边t检验和成对t检验可以分别用于评价单个学习器的错误率和比较两个学习器的性能。</p><p>对二分类问题，使用留出法不仅可估计出学习器 A 和 B的测试错误率，还可获得两学习器分类结果的差别，使用McNemar检验可以做到。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234226080145_532_image-20220930233428713.png" alt="image-20220930233428713"><figcaption aria-hidden="true">image-20220930233428713</figcaption></figure><p>$Min-max$规范化优点：1、计算相对简单一点。2、当新样本进来时，只有在新样本大于原最大值或者小于原最小值时，才需要重新计算规范化之后的值。缺点在于：1、容易受高杠杆点和离群点影响。</p><p><span class="math inline">\(z-score\)</span>规范化优点：1、对异常值敏感低。缺点在于：1、计算更负责。2、每次新样本进来都需要重新计算规范化。</p><h3 id="偏差方差分解">偏差方差分解</h3><p>用途：解释算法泛化性能来源的手段 <span class="math display">\[E(f ;D)=\operatorname{bias}^2(\boldsymbol{x})+\operatorname{var}(\boldsymbol{x})+\varepsilon^2,\]</span> 也就是说, 泛化误差可分解为偏差、方差与噪声之和。</p><p>注意这个式子的推导，详见南瓜书。</p><ul><li><strong>「偏差」</strong>度量了学习算法的期望预测与真实结果的偏离程度，即<strong>「刻画了学习算法本身的拟合能力」</strong>；</li><li><strong>「方差」</strong>度量了同样大小的训练集的变动所导致的学习性能的变化，即<strong>「刻画了数据扰动所造成的影响」</strong>;</li><li><strong>「噪声」</strong>则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即<strong>「刻画了学习问题本身的难度」</strong>.</li></ul><p>偏差一方差分解说明，泛化性能是由<strong>「学习算法的能力」</strong>、<strong>「数据的充分性」</strong>以及<strong>「学习任务本身的难度所共同决定」</strong>的。</p><p align="center"><img alt="image-20220930230353084" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234228241789_843_image-20220930230353084.png" width="50%"></p><p>随训练强度，偏差减小，方差增大，即学习的越充分，但受数据影响越大，可能出现过拟合现象。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统期末工程作业设计</title>
    <link href="/posts/30344/"/>
    <url>/posts/30344/</url>
    
    <content type="html"><![CDATA[<h3 id="期末工程作业">期末工程作业</h3><p class="note note-info">本文暂只提供相关设计思路，不提供最终实现代码。实现方面前端flask或swing上手较为快速，也可尝试其他框架。后端使用mysql数据库，关于连接数据库方式网上很容易搜到，不再赘述。</p><h4 id="需求描述">1. 需求描述</h4><p>疫情期间，学校的润美超市（虚构）需要对商品物资做更详细的管理。为防止供应链出现问题，对商品的供货商需要进行详细的记录，并对顾客的购买记录进行管理。当然，也需要对商品本身和超市内工作人员进行常规的管理。作为典型的数据库应用场景，引入合适的数据管理系统能够更好的落实疫情防控要求，并让超市具有更好的营业效果。</p><p>1.商品根据名称和供应商整理，通过编号标识，记录其价格。同时对于食品还需记录其保质期，以免过期未处理。</p><p>2.进货数据需要包含商品编号、进货价，进货时间等。</p><p>3.超市内有若干工作人员，需要对其个人信息和销售商品所得薪水进行储存。</p><p>4.需要对顾客信息进行储存。并对应购买时间和商品，形成销售日志。</p><h4 id="概念模型er图">2.1 概念模型ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004325018293_610_image-20220919004148336.png" alt="image-20220919004148336"><figcaption aria-hidden="true">image-20220919004148336</figcaption></figure><h4 id="关系模式转换">2.2 关系模式转换</h4><p>注：1.普通商品采用使用空值的方式，food与goods共用一张表</p><p>​ 2.斜体代表外键</p><p>goods（<u>goods_id</u>, goods_name, supplier_id, price, good_num,<em>shelf_no</em>)</p><p>//food（<u>goods_id</u>, goods_name, supplier_id, price,shelf_life)</p><p>supplier（<u>sp_id</u>, sp_name, phone, address)</p><p>supply（<u><em>sp_id</em></u>, <u><em>goods_id</em></u>, enter_time,costs)</p><p>employee（<u>emp_no</u>, <u>emp_name</u>, salary)</p><p>customer（<u>cu_id</u>, cu_name)</p><p>buy(<u><em>cu_id</em></u>, <u><em>goods_id</em></u>, buy_time,buy_costs)</p><p>shelf(<u>shelf_id</u>, goods_num_on_shelf)</p><p>sell (<u><em>emp_no</em></u>, <em><u>goods_id</u></em>)</p><h4 id="sql创建关系模式">2.3 SQL创建关系模式</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gqjha3lb4jx62s"></i><span>sql</span><div class="collapse show" id="collapse-gqjha3lb4jx62s"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div></div><h4 id="查询语句样例">2.4 查询语句样例</h4><p>1.单表查询</p><p>查询单价为10元的商品名称</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9vvvn7lb4jx62s"></i><span>sql</span><div class="collapse show" id="collapse-9vvvn7lb4jx62s"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name <span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> price<span class="hljs-operator">=</span><span class="hljs-number">10</span></code></pre></div></div><p>2.多表连接查询</p><p>查询每个厂商生产商品的平均价格</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qnod3hlb4jx62s"></i><span>SQL</span><div class="collapse show" id="collapse-qnod3hlb4jx62s"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> sp_id,<span class="hljs-built_in">avg</span>(price)<span class="hljs-keyword">from</span> supply <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sp_id</code></pre></div></div><p>3.4多表嵌套查询和exist查询</p><p>查询只有一种商品的货架，返回这种商品的名称和货架id</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fkt79qlb4jx62s"></i><span>sql</span><div class="collapse show" id="collapse-fkt79qlb4jx62s"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name,shelf_id<span class="hljs-keyword">from</span> goods,shelf<span class="hljs-keyword">where</span> goods.shelf_id<span class="hljs-operator">=</span>shelf.shelf_id <span class="hljs-keyword">and</span> goods.goods_num<span class="hljs-operator">=</span>shelf.goods_num_on_shelf</code></pre></div></div><p>也可以只在goods表中查</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ccb1cxlb4jx62s"></i><span>sql</span><div class="collapse show" id="collapse-ccb1cxlb4jx62s"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name<span class="hljs-keyword">from</span> goods g1<span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span><span class="hljs-operator">*</span><span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> shelf.id<span class="hljs-operator">=</span>e1.shelf.id <span class="hljs-keyword">and</span>goods_name<span class="hljs-operator">&amp;</span>lt;<span class="hljs-operator">&amp;</span>gt;e1.goods_name);</code></pre></div></div><p>5.聚合查询</p><p>有10种以上商品的货架，以及拥有的商品种类数</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3b40jmlb4jx62s"></i><span>sql</span><div class="collapse show" id="collapse-3b40jmlb4jx62s"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> shelf_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">from</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> shef_id<span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&amp;</span>gt; <span class="hljs-number">10</span>;</code></pre></div></div><h4 id="powerdesigner-绘制er图">3.1 PowerDesigner 绘制ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004326633367_468_image-20220415222750452.png" alt="image-20220415222750452"><figcaption aria-hidden="true">image-20220415222750452</figcaption></figure><h4 id="转为关系模型">3.2 转为关系模型</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004327928426_899_image-20220415222820109.png" alt="image-20220415222820109"><figcaption aria-hidden="true">image-20220415222820109</figcaption></figure><h4 id="生成sql语句">3.3 生成SQL语句</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8z1qialb4jx62s"></i><span>sql</span><div class="collapse show" id="collapse-8z1qialb4jx62s"><pre><code class="hljs sql"><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* DBMS name:      Sybase SQL Anywhere 12                       */</span><span class="hljs-comment">/* Created on:     2022/4/15 22:28:49                           */</span><span class="hljs-comment">/*==============================================================*/</span>if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY_CUSTOMER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY_CUSTOMER<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_GOODS_ON_SHELF'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_GOODS_ON_SHELF<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL_EMPLOYEE'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL_EMPLOYEE<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY2_SUPPLIER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY2_SUPPLIER<span class="hljs-keyword">end</span> if;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> buy;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> customer.customer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> customer;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> employee.emplyer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> employee;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.on_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.goods_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> goods;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> sell;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> shelf.shelf_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> shelf;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supplier.supplier_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supplier;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supply;<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: buy                                                   */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_PK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index buy_PK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_FK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy_FK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy2_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy2_FK <span class="hljs-keyword">on</span> buy (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: customer                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: customer_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index customer_PK <span class="hljs-keyword">on</span> customer (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: employee                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: emplyer_PK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index emplyer_PK <span class="hljs-keyword">on</span> employee (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: goods                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: goods_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index goods_PK <span class="hljs-keyword">on</span> goods (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: on_FK                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index on_FK <span class="hljs-keyword">on</span> goods (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: sell                                                  */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_PK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index sell_PK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell_FK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell2_FK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell2_FK <span class="hljs-keyword">on</span> sell (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: shelf                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: shelf_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index shelf_PK <span class="hljs-keyword">on</span> shelf (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supplier                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supplier_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index supplier_PK <span class="hljs-keyword">on</span> supplier (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supply                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_PK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index supply_PK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>,sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_FK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply_FK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply2_FK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply2_FK <span class="hljs-keyword">on</span> supply (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY2_SUPPLIER <span class="hljs-keyword">foreign</span> key (sp_id)      <span class="hljs-keyword">references</span> supplier (sp_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div></div><h4 id="分析差异">4.1 分析差异</h4><p>有差异。PowerDesigner会事先判断外键约束、索引以及表本身是否存在，若存在会删除。同时也会对表建立索引。但是基本逻辑是一致的，在总体的设计上不会造成影响。</p><h4 id="语句特点">4.2 语句特点</h4><p>从4.1的分析可以看出，PowerDesigner生成的语句更严谨。当然，语句顺序比如外键约束声明的位置也有不同。这些附加语句的作用是防止特殊情况的发生导致无法正常建立表。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ucore Lab0 on Apple Silicon Mac</title>
    <link href="/posts/23191/"/>
    <url>/posts/23191/</url>
    
    <content type="html"><![CDATA[<h2 id="ucore-lab0-on-apple-silicon-mac">Ucore Lab0 on Apple SiliconMac</h2><h3 id="介绍">介绍</h3><p>M1芯片是2020年之后推出的全新适配于Macbook的Arm64芯片。因为底层的指令集与x86_64不同，因此面临着很多兼容性的问题。在ucore的编译，运行和调试的环境配置中也因此踩了一些坑。当然最终得以能够优雅的在这台具有独特架构的PC上探索实现操作系统的魅力。</p><p>现在将其记录下来，以供参考。</p><h3 id="qemu安装">qemu安装</h3><p>qemu是非常成熟的虚拟化解决方案，通过软件的方式逐条将目标文件的二进制指令翻译成目标架构支持的二进制指令，虽然效率不高，但是使用方便，对M1芯片支持也比较完善，足够用来调试ucore了。</p><p>指导书中针对linux给出了使用包管理工具的安装方案。在mac上这个过程也同样比较简单。安装<code>homebrew</code>包管理工具后只需要</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zi0v8klb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-zi0v8klb4jx62s"><pre><code class="hljs shell">brew install qemu</code></pre></div></div><p>即可。当然为了保证是最新版本，安装之前可以更新一下homebrew：<code>brew update</code>。</p><h3 id="i386-elf-gcc和i386-elf-gdb安装">i386-elf-gcc和i386-elf-gdb安装</h3><p>按照网上的解决方案，我安装了<code>macport</code>，并</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1ec36ilb4jx62s"></i><span>elm</span><div class="collapse show" id="collapse-1ec36ilb4jx62s"><pre><code class="hljs elm"><span class="hljs-title">sudo</span> <span class="hljs-keyword">port</span> -v selfupdatesudo <span class="hljs-keyword">port</span> install i386-elf-gcc</code></pre></div></div><p>但是发现它安装过程中构建失败了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231400206876_223_image-20221003224714488.png" alt="image-20221003224714488"><figcaption aria-hidden="true">image-20221003224714488</figcaption></figure><p>查看发现果然是架构问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231401953713_177_image-20221003224809467.png" alt="image-20221003224809467"><figcaption aria-hidden="true">image-20221003224809467</figcaption></figure><p>查看报错信息。谷歌后从<a href="https://github.com/riscv-collab/riscv-gnu-toolchain/issues/800">githubissue</a>中得知是有支持apple silicon版本的最新i386-elf-gcc的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231403860364_202_image-20221003225239013.png" alt="image-20221003225239013"><figcaption aria-hidden="true">image-20221003225239013</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231405125684_549_image-20221003225245971.png" alt="image-20221003225245971"><figcaption aria-hidden="true">image-20221003225245971</figcaption></figure><p>有希望！但是按官网命令安装问题也没有解决，所谓补丁也不起效。后来尝试用homebrew安装：<code>brew install i386-elf-gdb</code>，但没有安装成功。提示</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g2p67glb4jx62s"></i><span>awk</span><div class="collapse show" id="collapse-g2p67glb4jx62s"><pre><code class="hljs awk">fatal: not <span class="hljs-keyword">in</span> a git directory Error: Command failed with <span class="hljs-keyword">exit</span> <span class="hljs-number">128</span>: git</code></pre></div></div><p>又经过一番谷歌找到了<a href="https://www.jianshu.com/p/07243d214abd">解决方法</a>。执行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dfiosvlb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-dfiosvlb4jx62s"><pre><code class="hljs shell">git config --global --add safe.directory 报错信息中homebrew-core路径git config --global --add safe.directory 报错信息中homebrew-cask路径</code></pre></div></div><p>即可。</p><p>然后需要添加一下环境变量。</p><p>这时尝试qemu生成ucore的dmg，发现提示<code>i386-elf-gcc</code>找不到。这才注意到通过homebrew下载的是<code>x86_64-elf-gcc</code>。</p><p>经过搜索，得知在make时需要添加<code>make GCCPREFIX=x86_64-elf-</code>指定交叉编译工具。这时可以高兴的看到控制台闪烁，执行也很顺利。</p><h3 id="执行">执行</h3><p>然后<code>make qemu</code>执行的过程也比较顺利。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231407841829_266_image-20221003230427926.png" alt="image-20221003230427926"><figcaption aria-hidden="true">image-20221003230427926</figcaption></figure><h3 id="调试">调试</h3><p>首先，ARM架构的Mac目前是不能使用<code>gdb</code>进行程序的调试的，默认的调试工具是<code>lldb</code>。然而经过查阅，对于交叉编译反而可以使用实验中对应的<code>gdb</code>工具：运行<code>brew install i386-elf-gdb</code>安装即可。</p><p>以调试lab1中的BIOS的执行为例。</p><p>下面的过程与指导书中“使用远程调试”部分类似。除此之外，额外将运行的汇编指令保存在q.log中。</p><p>在一个终端先执行：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uc34j2lb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-uc34j2lb4jx62s"><pre><code class="hljs shell">qemu-system-i386 -S -s -d in_asm -D bin/q.log -monitor stdio -hda bin/ucore.img</code></pre></div></div><p>后在另一个终端执行:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6w4puflb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-6w4puflb4jx62s"><pre><code class="hljs shell">i386-elf-gdb</code></pre></div></div><p>进入gdb调试界面。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-snytahlb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-snytahlb4jx62s"><pre><code class="hljs shell">(gdb) file bin/kernelReading symbols from bin/kernel...(gdb) target remote :1234Remote debugging using :12340x0000fff0 in ?? ()</code></pre></div></div><p>上述的过程相比原来<code>makrfile</code>中提供的<code>make debug</code>主要有两个好处：一是能够重定向到<code>q.log</code>方便进行对比；二是可以绕开<code>make</code>中的<code>TERMINAL:=gnome-terminal</code>(<code>gnome-terminal</code>仅在linux下可使用)</p><p>查看 CS:EIP 由于此时在实际模式下 CPU 在加电后执行的第一条指令的地址为0xf000:0xfff0 =&gt; 0xffff0</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-24od2mlb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-24od2mlb4jx62s"><pre><code class="hljs shell">(gdb) x/i $cs0xf000:add    %al,(%eax)(gdb) x/i $eip0xfff0:add    %al,(%eax)</code></pre></div></div><p>再来看看这个地址的指令是什么 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qhqf6zlb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-qhqf6zlb4jx62s"><pre><code class="hljs shell">(gdb) x/2i 0xffff0   0xffff0:ljmp   $0x3630,$0xf000e05b   0xffff7:das</code></pre></div></div><p></p><p>可以看到 第一条指令执行完以后 会跳转到<code>0xf000e05b</code>也就是说BIOS 开始的地址是 <code>0xfe05b</code>。</p><p>打上断点</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5x6fj1lb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-5x6fj1lb4jx62s"><pre><code class="hljs shell">(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.Breakpoint 1, 0x00007c00 in ?? ()</code></pre></div></div><p>一开始为了方便后续在终端中配置了永久别名：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jul7r8lb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-jul7r8lb4jx62s"><pre><code class="hljs shell">alias makeq="make GCCPREFIX=x86_64-elf-"</code></pre></div></div><p>当然更优雅的方法其实是修改make中的宏：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xbrczdlb4jx62s"></i><span>makefile</span><div class="collapse show" id="collapse-xbrczdlb4jx62s"><pre><code class="hljs makefile"><span class="hljs-comment"># try to infer the correct GCCPREFX</span><span class="hljs-keyword">ifndef</span> GCCPREFIX<span class="hljs-comment"># GCCPREFIX := $(shell if i386-elf-objdump -i 2&gt;&amp;1 | </span><span class="hljs-comment">#...comment the original shell function</span><span class="hljs-comment"># echo "***" 1&gt;&amp;2; exit 1; fi)</span>GCCPREFIX := x86_64-elf-<span class="hljs-keyword">endif</span></code></pre></div></div><p>但是，由于<code>makefile</code>里默认认为调试工具一定叫<code>gdb</code>，且mac里没有gdb对应的command，因此这时候用永久别名是比较合适的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a4dqnnlb4jx62s"></i><span>shell</span><div class="collapse show" id="collapse-a4dqnnlb4jx62s"><pre><code class="hljs shell">alias gdb="i386-elf-gdb"</code></pre></div></div><p>这时候也可以修改make来达到自动化调试的目的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gpfzirlb4jx62s"></i><span>makefile</span><div class="collapse show" id="collapse-gpfzirlb4jx62s"><pre><code class="hljs makefile">WORKING_DIR=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(QEMU)</span> -S -s -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null &amp;<span class="hljs-variable">$(V)</span>sleep 2<span class="hljs-variable">$(V)</span> osascript -e 'tell application <span class="hljs-string">"Terminal"</span> to do script <span class="hljs-string">"cd <span class="hljs-variable">$(WORKING_DIR)</span>; gdb -q -x tools/gdbinit"</span>'</code></pre></div></div><p>其中最后一句是为了产生一个在当前工作目录的新终端。</p><h3 id="总结">总结</h3><p>前前后后也花了相当长的时间来应对环境的不同。后续的内容其实更吸引着我们去深入探索。</p><h3 id="后续">后续</h3><p>已知问题: lab1的<code>chellenge</code>无法正常切换<code>user_mode</code>，初步排查发现是出现了操作数异常，可能是<code>%esp</code>未正确赋值，但目前还没有找到方案。如果对此部分有较深研究，也欢迎交流。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221130222055575294_180_image-20221130221829874.png" alt="image-20221130221829874"><figcaption aria-hidden="true">image-20221130221829874</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221130222057952350_733_image-20221130221851517.png" alt="image-20221130221851517"><figcaption aria-hidden="true">image-20221130221851517</figcaption></figure><p>chellenge以外的部分以及后两个实验均可正确得到结果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221130222100838376_161_image-20221130222030887.png" alt="image-20221130222030887"><figcaption aria-hidden="true">image-20221130222030887</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能导论</title>
    <link href="/posts/46759/"/>
    <url>/posts/46759/</url>
    
    <content type="html"><![CDATA[<p>人工智能导论</p><p>逻辑推理</p><p align="center"><img alt="image-20220831205211237" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221103884501_923_image-20220831205211237.png" width="50%"></p><p align="center"><img alt="image-20220831205344502" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221111633086_904_image-20220831205344502.png" width="50%"></p><p align="center"><img alt="image-20220831205448441" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221120315099_386_image-20220831205448441.png" width="50%"></p><p>任意对析取，存在对合取都是蕴含关系，分开的条件强于合起来的（举个例子就明白了）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221127063207_401_image-20220831210345470.png" alt="image-20220831210345470"><figcaption aria-hidden="true">image-20220831210345470</figcaption></figure><p align="center"><img alt="image-20220831210404798" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221128281126_946_image-20220831210404798.png" width="50%"></p><p>只与新加入的直接相关</p><p align="center"><img alt="image-20220831211022710" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221129758335_145_image-20220831211022710.png" width="50%"></p><p align="center"><img alt="image-20220831211029655" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221130984768_647_image-20220831211029655.png" width="50%"></p><p align="center"><img alt="image-20220831211350521" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221132416550_481_image-20220831211350521.png" width="50%"></p><p>因果分析三层次：关联，介入，反事实</p><p>因果图三种形式：链，分连，汇连（chain，fork，collider)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221134366409_448_image-20220831212134887.png" alt="image-20220831212134887"><figcaption aria-hidden="true">image-20220831212134887</figcaption></figure><p>做法：联合概率分布由每个节点与其父节点之间的条件概率得出。根节点是外生变量，其他的是内生</p><hr><p align="center"><img alt="image-20220831212713182" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221135899101_136_image-20220831212713182.png" width="50%"></p><p>深搜可能会陷入无限循环</p><p align="center"><img alt="image-20220831213452142" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221137133557_194_image-20220831213452142.png" width="50%"></p><p align="center"><img alt="image-20220831213527818" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221139012135_477_image-20220831213527818.png" width="50%"></p><p align="center"><img alt="image-20220831213624058" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221140593318_530_image-20220831213624058.png" width="50%"></p><p>有环路的图会使贪婪最佳优先算法不完备。</p><p>判断：启发函数满足可容性则一定能保证算法最优性x</p><p>树搜索是这样法，图不一定</p><p>判断：启发函数恒为0一定满足可容性x</p><p>启发函数不一定要是正数。</p><p>满足一致性可保证A*搜索算法最优</p><p>启发函数不会过高估计从当前节点到目标结点之间的实际代价。x</p><p>满足可容性的启发函数才有这样的性质。</p><p>MinMax的适用条件：两人博弈，信息透明，零和博弈</p><p align="center"><img alt="image-20220831215141822" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221142369023_436_image-20220831215141822.png" width="50%"></p><p>注意，没有规定必须要公平。D违反了零和博弈</p><p align="center"><img alt="image-20220831220640110" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221144124086_686_image-20220831220640110.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221145565187_669_image-20220831220659274.png" alt="image-20220831220659274"><figcaption aria-hidden="true">image-20220831220659274</figcaption></figure><p>这个做法是不对的，根据课本上的过程，A*算法会考虑所有可达的评价函数，每次从边缘集合拓展的节点并非总是当前节点的后继节点。fn评价函数是唯一标准如果发现有更小的，会倒回去。</p><p align="center"><img alt="image-20220831220818630" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221146871853_388_image-20220831220818630.png" width="50%"></p><p>而且贪婪最佳优先搜索也是启发式算法，优先选择启发函数最小的后继节点拓展。</p><p align="center"><img alt="image-20220831222502968" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221148285550_794_image-20220831222502968.png" width="50%"></p><p align="center"><img alt="image-20220831222848019" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221149618933_986_image-20220831222848019.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221152879301_392_image-20220831223950629.png" alt="image-20220831223950629"><figcaption aria-hidden="true">image-20220831223950629</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221155537145_635_image-20220831223959591.png" alt="image-20220831223959591"><figcaption aria-hidden="true">image-20220831223959591</figcaption></figure><p>记住蒙特卡洛树UCB的公式，明白反向传播的过程。 <span class="math display">\[U C B=\bar{X}_j+C \times \sqrt{\frac{2 \ln n}{n_j}}\]</span> <strong>上限置信区间</strong> <strong>(Upper Confidence Bound,UCB)</strong></p><hr><p>监督学习中经验风险和期望风险的概念</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221157700882_480_image-20220831224734326.png" alt="image-20220831224734326"><figcaption aria-hidden="true">image-20220831224734326</figcaption></figure><p align="center"><img alt="image-20220831224903093" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221159350035_550_image-20220831224903093.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221201393460_662_image-20220831224941130.png" alt="image-20220831224941130"><figcaption aria-hidden="true">image-20220831224941130</figcaption></figure><p align="center"><img alt="image-20220831224941224" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221201393460_662_image-20220831224941130.png" width="50%"></p><p>​常用的正则项方法包括L1正则项和L2正则项：其中L1使权重稀疏，L2使权重平滑。一句话总结就是：L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。</p><p>怎么记：1比2小，生成的特征少</p><p align="center"><img alt="image-20220831225522763" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221204366868_381_image-20220831225522763.png" width="50%"></p><p align="center"><img alt="image-20220831225535198" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221206081717_192_image-20220831225535198.png" width="50%"></p><p>考法：判断哪些算法是判别模型，哪些是生成模型。大部分典型机器学习算法都是判别模型。贝叶斯方法，隐马科代夫链式生成模型</p><p align="center"><img alt="image-20220831230142515" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221207951204_832_image-20220831230142515.png" width="50%"></p><p>信息熵小，信息稳定，单一，纯度高；信息熵大，信息不稳定，纯度低。</p><p align="center"><img alt="image-20220831230645025" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221209692239_698_image-20220831230645025.png" width="50%"></p><p>决策树是在干什么呢？选择最佳属性对样本进行划分，得到最大的“纯度”</p><p>同时注意决策树是有监督学习。</p><p><strong>线性区别分析</strong> <strong>(</strong>linear discriminantanalysis, LDA<strong>)</strong></p><p>线性判别分析的核心：类内方差小，类间间隔大。“君子和而不同，小人同而不和”，是一种降为方法</p><p>#请判断下面说法是否正确：线性判别分析是在最大化类间方差和类内方差的比值(√)</p><p>#在一个监督学习任务中，每个数据样本有4个属性和一个类别标签，每种属性分别有3、2、2和2种可能的取值，类别标签有3种不同的取值。请问可能有多少种不同的样本？（注意，并不是在某个数据集中最多有多少种不同的样本，而是考虑所有可能的样本)()</p><p>乘起来就可以。72</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221224036219_753_image-20220831232017771.png" alt="image-20220831232017771"><figcaption aria-hidden="true">image-20220831232017771</figcaption></figure><p>记住就可以</p><p>重点：</p><p align="center"><img alt="image-20220831231843333" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221225672479_673_image-20220831231843333.png" width="50%"></p><p align="center"><img alt="image-20220831232347725" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221227106679_945_image-20220831232347725.png" width="50%"></p><p align="center"><img alt="image-20220831233241581" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221229085668_716_image-20220831233241581.png" width="50%"></p><p>ada boosting</p><p><span class="math inline">\(Z_m=\sum_{i=1}^N w_{m, i}\mathrm{e}^{-\alpha_m y G_i\left(x_i\right) \text { 。 }}\)</span>可以把对第 <span class="math inline">\(i\)</span>个训练样本更新后的分布权重写为如下分段函数形式: <span class="math display">\[w_{m+1, i}= \begin{cases}\frac{w_{m, i}}{Z_m} \mathrm{e}^{-\alpha_m},&amp;amp; G_m\left(x_i\right)=y_i \\ \frac{w_{m, i}}{Z_m}\mathrm{e}^{\alpha_m}, &amp;amp; G_m\left(x_i\right) \neq y_i\end{cases}\]</span> 可见, 如果第 <span class="math inline">\(i\)</span>个训练样本无法被第 <span class="math inline">\(m\)</span> 个弱分类器<span class="math inline">\(G_m(x)\)</span> 分类成功,则需要增大该样本权重, 否则减少该样本权重。这样, 被错误分类样本会在训练第 <span class="math inline">\(m+1\)</span> 个弱分类器 <span class="math inline">\(G_{m+1}(x)\)</span> 时被 “重点关注”。</p><p>在第 <span class="math inline">\(m\)</span> 次迭代中, Ada Boosting总是趋向于将具有<font color="Apricot">最小误差的学习模型</font>（err最小的）选做本轮次生成的弱分类器<span class="math inline">\(G_m\)</span>, 促使累积误差快速下降。</p><hr><p>无监督学习</p><p>K-means往往找都是一个局部最优</p><p>聚类迭代满足如下任意一个条件，则聚类停止：</p><p>•已经达到了迭代次数上限</p><p>•前后两次迭代中，聚类质心基本保持不变</p><p align="center"><img alt="image-20220831234829916" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221230319204_134_image-20220831234829916.png" width="50%"></p><p align="center"><img alt="image-20220831234856133" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221232576761_180_image-20220831234856133.png" width="50%"></p><p>应当是尽量“不相关”</p><p>•<strong>主成分分析是将𝑛维特征数据映射到𝑙维空间</strong>(<strong>n≫l</strong>)<strong>，去除原始数据之间的冗余性（通过去除相关性手段达到这一目的）。</strong>每一维的样本方差尽可能大</p><p>•<strong>特征人脸方法是一种应用主成份分析来实现人脸图像降维的方法，其本质是用一种称为“特征人脸(eigenface)”的特征向量（而不是像素）按照线性组合形式来表达每一张原始人脸图像，进而实现人脸识别。</strong></p><p>每一个特征人脸的维数与原始人脸图像的维数一样大x 会变小</p><p>特征人脸之间的相关度要尽可能大√</p><p>为了使算法更高效采用了奇异值分解的方法</p><hr><p align="center"><img alt="image-20220901002546496" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221234267125_288_image-20220901002546496.png" width="50%"></p><p>批量梯度下降算法是在整个训练集上计算损失误差C()。如果数据集较大，则会因内存容量不足而无法完成，同时这一方法收敛速度较慢。随机梯度下降算法是使用训练集中每个训练样本计算所得C()来分别更新参数。虽然，随机梯度下降收敛速度会快一些，但可能出现所优化目标函数震荡不稳定现象。</p><p align="center"><img alt="image-20220901004646914" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221236054772_109_image-20220901004646914.png" width="50%"></p><p><span class="math display">\[f(x)=\frac{1}{1+\mathrm{e}^{-x}}\]</span> 选取 sigmoid函数作为激活函数, 因为其具有如下优点: (1)概率形式输出, sigmoid函数值域为 <span class="math inline">\((0,1)\)</span>, 因此使 sigmoid函数输出可视为概率值; (2) 单调递增, sigmoid函数对输人 <span class="math inline">\(x\)</span> 取值范围没有限制, 但当 <span class="math inline">\(x\)</span> 大 于一定值后, 函数输出无限趋近于 1 ,而小于一定数值后, 函数输出无限趋近于 0 , 特别地, 当 <span class="math inline">\(x=0\)</span> 时, 函数输出为 <span class="math inline">\(0.5\)</span>; (3) 非线性变化, <span class="math inline">\(x\)</span> 取 值在 0 附近时,函数输出值的变化幅度比较大 (函数值变化陡峭), 意味 着函数在 0附近容易被激活且是非线性变化, 当 <span class="math inline">\(x\)</span>取值很大或很小时, 函数输出值几乎不变, 这是基于概率的一种认识与需要。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012351440"><figcaption aria-hidden="true">image-20220901012351440</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012412558"><figcaption aria-hidden="true">image-20220901012412558</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221245033698_681_image-20220901012437001.png" alt="image-20220901012437001"><figcaption aria-hidden="true">image-20220901012437001</figcaption></figure><p align="center"><img alt="image-20220901012512732" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221246660573_722_image-20220901012512732.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221248004240_176_image-20220901012559806.png" alt="image-20220901012559806"><figcaption aria-hidden="true">image-20220901012559806</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221249466398_422_image-20220901012619080.png" alt="image-20220901012619080"><figcaption aria-hidden="true">image-20220901012619080</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221251026834_417_image-20220901012639822.png" alt="image-20220901012639822"><figcaption aria-hidden="true">image-20220901012639822</figcaption></figure><hr><p>强化学习的特征</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221252634813_271_image-20220901082606079.png" alt="image-20220901082606079"><figcaption aria-hidden="true">image-20220901082606079</figcaption></figure><p align="center"><img alt="image-20220901082635583" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221254174712_770_image-20220901082635583.png" width="50%"></p><p>一个随机过程实际上是一列随时间变化的随机变量。当时间是离散 量时,一个随机过程可以表示为 <span class="math inline">\(\left\{X_t\right\}_{t=0,1,2, \cdots}\)</span>,这里每个 <span class="math inline">\(X_t\)</span> 都是一个随机变量,这被称为离散随机过程。为了方便分析和求解,通常要求通过合理的问题定义使得一个随机过程满足马尔可夫性 (Markovproperty), 即满足如下性质: <span class="math display">\[P\left(X_{t+1}=x_{t+1} \mid X_0=x_0, X_1=x_1, \cdots,X_t=x_t\right)=P\left(X_{t+1}=x_{t+1} \mid X_t=x_t\right) \text {(式7.1) }\]</span> 这个公式的直观解释为: 下一刻的状态 <span class="math inline">\(X_{t+1}\)</span> 只由当前状态 <span class="math inline">\(X_t\)</span> 决定(而与更早的所有状态均无关)。满足马尔可夫性的离散随机过程被称为马尔可夫链 (Markov chain)。</p><p align="center"><img alt="image-20220901083631487" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221255863567_937_image-20220901083631487.png" width="50%"></p><ul><li>动作 <span class="math inline">\(-\)</span> 价值函数 (action-valuefunction): <span class="math inline">\(q: S \times A \mapsto\mathbb{R}\)</span>, 其中 <span class="math inline">\(q_\pi(s,a)=\mathbb{E}_\pi\left[G_t \mid S_t=s, A_t=a\right]\)</span>,表示智能体在时刻 <span class="math inline">\(t\)</span> 处于状态 <span class="math inline">\(s\)</span> 时, 选择 了动作 <span class="math inline">\(a\)</span> 后，在 <span class="math inline">\(t\)</span> 时刻后根据策略 <span class="math inline">\(\pi\)</span> 采取行动所获得回报的期望。价值函数和动作 <span class="math inline">\(-\)</span>价值函数反映了智能体在某一策略下所对应状态 序列获得回报的期望,它比回报本身更加准确地刻画了智能体的目标。 注意, 价值函数和动作 <span class="math inline">\(-\)</span> 价值函数的定义之所以能够成立,离不开决策 过程所具有的马尔可夫性, 即当位于当前状态 <span class="math inline">\(s\)</span> 时, 无论当前时刻 <span class="math inline">\(t\)</span> 的取值是多少,一个策略回报值的期望是一定的 (当前状态只与前一状态有关，与时间无关）。（所以不是<span class="math inline">\(q_\pi(s,a,t)\)</span>） 至此, 强化学习可以转化为一个策略学习问题, 其定义为:给定一 个马尔可夫决策过程 <span class="math inline">\(M D P=(S, A, P, R,\gamma)\)</span>, 学习一个最优策略 <span class="math inline">\(\pi^*\)</span>, 对任 意 <span class="math inline">\(s \in S\)</span> 使得 <span class="math inline">\(V_{\pi^*}(s)\)</span> 值最大。</li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221257340897_656_image-20220901083736614.png" alt="image-20220901083736614"><figcaption aria-hidden="true">image-20220901083736614</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221258558310_351_image-20220901083803818.png" alt="image-20220901083803818"><figcaption aria-hidden="true">image-20220901083803818</figcaption></figure><hr><p align="center"><img alt="image-20220901090535698" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221300893504_791_image-20220901090535698.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221302843487_985_image-20220901090816141.png" alt="image-20220901090816141"><figcaption aria-hidden="true">image-20220901090816141</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理习题讲解部分勘误</title>
    <link href="/posts/23086/"/>
    <url>/posts/23086/</url>
    
    <content type="html"><![CDATA[<p>4.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150014727108_816_image-20220822231146713.png" alt="image-20220822231146713"><figcaption aria-hidden="true">image-20220822231146713</figcaption></figure><p>流水线周期取决于耗时最长的阶段。此处忘记了IF的时钟周期仍为150ps。</p><p>5.6</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150016592317_276_image-20220821230253484.png" alt="image-20220821230253484"><figcaption aria-hidden="true">image-20220821230253484</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150018066044_526_image-20220821230543233.png" alt="image-20220821230543233"><figcaption aria-hidden="true">image-20220821230543233</figcaption></figure><p>第三问的讲解如上图所示。此处p1和p2的CPI计算有误。原因是未考虑指令缺失造成的代价。<span class="math display">\[CPI=1+平均每条指令阻塞始终周期数\\=1+指令缺失阻塞时钟周期数+数据缺失阻塞时钟周期数\]</span></p><p><span class="math display">\[指令缺失阻塞时钟周期数=\texttt{cache}缺失率*指令缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p><span class="math display">\[数据缺失阻塞时钟周期数=\texttt{cache}缺失率*访存指令占比*数据缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p>得到两个CPI分别约为12.54和7.35</p><p>5.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150019552299_178_image-20220822230445847.png" alt="image-20220822230445847"><figcaption aria-hidden="true">image-20220822230445847</figcaption></figure><p>第三小问关于反置页表。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150020954753_868_image-20220822231114457.png" alt="image-20220822231114457"><figcaption aria-hidden="true">image-20220822231114457</figcaption></figure><p>在反置页表中是为每一个物理块设置一个页表项的，视频中也有所阐述,但在计算时依旧是使用的虚拟地址。此处应为$$ PTE= \</p><span class="math display">\[\begin{aligned}&amp;=\frac{\text { Size of physical memory }}{\text { Page size }}\\&amp;=\frac{16 \mathrm{GiB}}{4 \mathrm{KiB}} \\&amp;=\frac{2^{34}}{2^{12}} \\&amp;=2^{22}\end{aligned}\]</span><p>$$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
