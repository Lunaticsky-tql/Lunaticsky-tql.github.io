<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c++拾遗-基本语法和运算</title>
    <link href="/posts/43168/"/>
    <url>/posts/43168/</url>
    
    <content type="html"><![CDATA[<h2 id="c回顾复习">C++回顾复习</h2><h3 id="认识c">认识C++</h3><h4 id="基本概念和词汇">基本概念和词汇</h4><p>main不是C++中的保留字。因此<code>int main;</code>在C++中合法。</p><p>下列哪个是C++语言的合法的字符常量 "0" '054’ ‘' ‘\092’</p><blockquote><p>A选项，双引号表示的是字符串常量；B选项054表示八进制整数，但是缺少转义符号；D选项是将其后的整数092表示八进制整数，但是八进制不存在9这个数。注意，单引号表示的字符常量，可以是整数，但必须带有转义符号，其字符常量为整数表示的ASC码对应的字符</p></blockquote><p>一个经常设坑的点：八进制表达中出现8或9</p><h4 id="枚举常量">枚举常量</h4><p><code>enum t1 {a1,a2=7,a3,a4=15}time;</code></p><p>则枚举常量<code>a1</code>和<code>a3</code>的值分别是0和8</p><p>枚举值对应的整数值可以是任意整数。</p><p>注意区分枚举类型定义和枚举类型变量定义。前者定义的数据类型，后者是定义变量。定义类型名时不应该有=</p><p class="note note-warning">因此 enum a=[one,two,three);是不对的</p><p>还可以这样写</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">team</span>{my, your=<span class="hljs-number">4</span>, his, her=his+<span class="hljs-number">10</span>};cout&lt;&lt;my&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;your&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;his&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;her&lt;&lt;endl;</code></pre></div><p>结果<code>0 4 5 15</code></p><h4 id="string">string</h4><p>关于字符串类型</p><p>使用<code>.length()</code>和<code>strlen()</code>时计算的字符串长度都不包含<code>\0</code></p><p class="note note-warning">注意:+不支持两个字符串字面常量的连接,如 string word4 "hello"+"world!";</p><h3 id="运算符和表达式">运算符和表达式</h3><h4 id="基本概念">基本概念</h4><p>在学习了编译原理之后，对这些概念以及对应的“奇特”写法应当已经见怪不怪。但为应对考试，仍记录以备复习。</p><h5 id="表达式">表达式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201307860409_128_image-20221013141835992.png" alt="image-20221013141835992"><figcaption aria-hidden="true">image-20221013141835992</figcaption></figure><p>注意，“表达式”不带分号，带了分号就是语句。</p><h4 id="优先级和结合性">优先级和结合性</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//test 1</span>    <span class="hljs-type">int</span> k, a, b, c;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> w = <span class="hljs-number">5</span>;    <span class="hljs-type">double</span> x = <span class="hljs-number">1.42</span>;<span class="hljs-comment">//    x%(-3); &lt;Invalid operands to binary expression ('double' and 'int')&gt;</span>    w += <span class="hljs-number">-2</span>; <span class="hljs-comment">// w=3</span>    k = (a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b); <span class="hljs-comment">// k=5</span>    c = k = a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b; <span class="hljs-comment">// c=5, k=2, a=2, b=3</span>    a += a -= (b = <span class="hljs-number">4</span>) * (a = <span class="hljs-number">3</span>); <span class="hljs-comment">// a=-18, b=4</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a=%d"</span>, a);    <span class="hljs-comment">//test 2</span>    <span class="hljs-type">int</span> d2i = <span class="hljs-string">'A'</span> + <span class="hljs-number">1.6</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a2=%d"</span>, d2i); <span class="hljs-comment">//'A'+1.6=66.6=66 (ASCII code of 'A' is 65)</span>    <span class="hljs-comment">//test3</span><span class="hljs-comment">/*    d=9+e+f=d+9;</span><span class="hljs-comment">    expression is a value, not a variable in the memory,so it is not assignable */</span>}</code></pre></div><p><a href="https://blog.csdn.net/zb_915574747/article/details/99704639">优先级和结合性一览</a></p><h4 id="赋值运算">赋值运算</h4><div class="code-wrapper"><pre><code class="hljs c++">设有intx=<span class="hljs-number">11</span>：，则表达式(x++*<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)的值是</code></pre></div><p><span class="math inline">\(\lfloor 11*1/3 \rfloor=3\)</span></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201309887843_159_image-20221013142054782.png" alt="image-20221013142054782"><figcaption aria-hidden="true">image-20221013142054782</figcaption></figure><p>做题时容易犯的错误：</p><div class="code-wrapper"><pre><code class="hljs c++">若d为<span class="hljs-type">double</span>型变量，则表达式d=<span class="hljs-number">1</span>，d+<span class="hljs-number">5</span>，d++的值是<span class="hljs-number">1</span>。d+<span class="hljs-number">5</span>不是d=d+<span class="hljs-number">5</span>。虽然很明显，做题的时候也需要有注意的意识</code></pre></div><h4 id="逻辑运算">逻辑运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201311747149_485_image-20221020095906292.png" alt="image-20221020095906292"><figcaption aria-hidden="true">image-20221020095906292</figcaption></figure><p>注意算术运算符优先于关系和除非以外的逻辑运算符！</p><p>短路运算举例：</p><div class="code-wrapper"><pre><code class="hljs c++">×=y=<span class="hljs-number">3</span>;t=++x||++y后，y的值是</code></pre></div><blockquote><p>3，因为后面不会被运算</p></blockquote><p>优先级只是起“加括号”的作用。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> c,h;std::cout&lt;&lt;((c=<span class="hljs-number">2</span>)&amp;&amp;(h=<span class="hljs-number">-2</span>));<span class="hljs-comment">//always true</span></code></pre></div><h4 id="位运算">位运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201313889596_775_image-20221020105755065.png" alt="image-20221020105755065"><figcaption aria-hidden="true">image-20221020105755065</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201315728635_334_image-20221020104858172.png" alt="image-20221020104858172"><figcaption aria-hidden="true">image-20221020104858172</figcaption></figure><p>注意位运算的“地位”不是平等的，不要想当然按顺序算</p><h4 id="条件和逗号运算符">条件和逗号运算符</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201317368932_518_image-20221020111433316.png" alt="image-20221020111433316"><figcaption aria-hidden="true">image-20221020111433316</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">{</span></span><span class="hljs-params"><span class="hljs-function">cout&lt;&lt;(<span class="hljs-number">0101</span>&amp;<span class="hljs-number">101</span>&gt;&gt;<span class="hljs-number">3</span>|<span class="hljs-number">101</span>&lt;&lt;<span class="hljs-number">3</span>^~<span class="hljs-number">0x10</span>)&lt;&lt;endl;</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span></span><span class="hljs-params"><span class="hljs-function">}</span></span><span class="hljs-params"><span class="hljs-function"></span></span></code></pre></div><blockquote><p>优先级按位取反~最高，先将0x10（十六进制）按位取反，得到结果1111111111111111 1111111111101111，其次优先级按位左移和按位右移运算符优先级相同，计算101&gt;&gt;3得到00000000 00000000 00000000 00001100，以及101&lt;&lt;3得到 0000000000000000 0000001100101000，接下来计算0101（八进制）按位与（101&gt;&gt;3）的结果，得到结果为0,0按位或一个数所得结果为原值。因此最终答案为(101&lt;&lt;3)按位异或(~0x10)的结果，其结果为1111111111111111 11111100 11000111，为负数，求补得到绝对值。特别需要注意的是取反的时候是对整个int取反，16变-17</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++">设intm=<span class="hljs-number">5</span>；<span class="hljs-type">float</span> x=<span class="hljs-number">3.5</span>；则表达式m+x+<span class="hljs-number">4.5</span>的结果应占据[填空]个字节。<span class="hljs-comment">//8.在隐式类型转换中转向了double</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理一二章</title>
    <link href="/posts/34739/"/>
    <url>/posts/34739/</url>
    
    <content type="html"><![CDATA[<h2 id="编译原理一二章">编译原理一二章</h2><h3 id="lec1从代码到可执行文件">Lec1从代码到可执行文件</h3><h4 id="编译器要做哪些事情">编译器要做哪些事情？</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190733227216_229_image-20220929095525300.png" alt="image-20220929095525300"><figcaption aria-hidden="true">image-20220929095525300</figcaption></figure><h5 id="一些gcc编译选项">一些gcc编译选项</h5><h6 id="actions"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id6">Actions</a></h6><p>The action to perform on the input.</p><div class="code-wrapper"><pre><code class="hljs shell">-E, --preprocessOnly run the preprocessor-S, --assembleOnly run preprocess and compilation steps-c, --compileOnly run preprocess, compile, and assemble steps-emit-llvmUse the LLVM representation for assembler and object files</code></pre></div><h6 id="compilation-flags"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id7">Compilationflags</a></h6><p>Flags controlling the behavior of Clang during compilation. Theseflags have no effect during actions that do not perform compilation.</p><div class="code-wrapper"><pre><code class="hljs shell">-Xassembler &lt;arg&gt;`Pass &lt;arg&gt; to the assembler-Xclang &lt;arg&gt;, -Xclang=&lt;arg&gt;Pass &lt;arg&gt; to clang -cc1</code></pre></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190735472529_960_image-20220920154109066.png" alt="image-20220920154109066"><figcaption aria-hidden="true">image-20220920154109066</figcaption></figure><p>上面是<strong>抽象语法树</strong>：简化，只包含程序中出现的单词</p><p>下面是<strong>语义分析树（具体语法树）</strong>：完整，还包含抽象出的语法概念</p><h5 id="对过程的相关理解">对过程的相关理解</h5><p class="note note-info">C++编译器检查相容类型计算是否合规是在语义分析阶段编译器识别出标识符是在词法分析阶段</p><p class="note note-warning">C++编译器过滤注释是在_<strong>阶段。答案是词法分析，但实践表明预处理阶段就已经过滤注释了。C++编译器检查数组下标越界是在</strong>_阶段 C++并不会检查数组下标越界。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190736776341_330_image-20220920162038518.png" alt="image-20220920162038518"><figcaption aria-hidden="true">image-20220920162038518</figcaption></figure><p>显然符号表中不会存变量值，因为变量值在运行时才会确定。</p><p class="note note-info">符号表是在词法分析阶段创建的。(习题)</p><p>但是据龙书：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190738941427_725_image-20221004193852281.png" alt="image-20221004193852281"><figcaption aria-hidden="true">image-20221004193852281</figcaption></figure><h3 id="lec2-构造一个简单的编译器">Lec2 构造一个简单的编译器</h3><h4 id="上下文无关文法">上下文无关文法</h4><h5 id="感性理解">感性理解</h5><p>BNF 是一种<strong>上下文无关文法</strong>，举个例子就是，人类的语言就是一种上下文<strong>有关</strong>文法，我随时都可以讲一句“以上说的都是废话”，改变我所说的话的涵义。</p><h5 id="形式化定义">形式化定义</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190740496671_209_image-20220927144906987.png" alt="image-20220927144906987"><figcaption aria-hidden="true">image-20220927144906987</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190741666990_453_image-20220927144926174.png" alt="image-20220927144926174"><figcaption aria-hidden="true">image-20220927144926174</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190742819758_795_image-20220927144938067.png" alt="image-20220927144938067"><figcaption aria-hidden="true">image-20220927144938067</figcaption></figure><p>对闭包的理解</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190743880629_933_image-20220927144950874.png" alt="image-20220927144950874"><figcaption aria-hidden="true">image-20220927144950874</figcaption></figure><p>正闭包也叫正则闭包</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190746344914_185_image-20220927145026025.png" alt="image-20220927145026025"><figcaption aria-hidden="true">image-20220927145026025</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190747551802_775_image-20221004164810301.png" alt="image-20221004164810301"><figcaption aria-hidden="true">image-20221004164810301</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190748466161_250_image-20220927150609696.png" alt="image-20220927150609696"><figcaption aria-hidden="true">image-20220927150609696</figcaption></figure><p>在词法分析阶段，所有的expr都是同等对待的，因此不需要加下标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190749626754_765_image-20220927150731839.png" alt="image-20220927150731839"><figcaption aria-hidden="true">image-20220927150731839</figcaption></figure><p>idlist也可用右递归表示。两种方式等价，但生成的语法分析树不一样。</p><p>另外一种设计方案</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190750857129_584_image-20220927155732458.png" alt="image-20220927155732458" style="zoom:50%;"></p><h5 id="二义性语法和非二义性语法">二义性语法和非二义性语法</h5><p>非二义性语法</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190751862164_535_image-20220927154102321.png" alt="image-20220927154102321"><figcaption aria-hidden="true">image-20220927154102321</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190753296213_768_image-20220927154131189.png" alt="image-20220927154131189" style="zoom:50%;"></p><p>采用二义性语法，则会产生歧义问题，同一段代码在不同编译器上产生不一样的结果，显然是我们不想看到的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190754314719_452_image-20220927154314035.png" alt="image-20220927154314035"><figcaption aria-hidden="true">image-20220927154314035</figcaption></figure><p>但是在一定的场合下，通过设计合理的语法分析算法，我们是容许一定的二义性的，因为可以减小语法分析树的复杂性。</p><p>文法左递归，体现出运算符左结合，右递归则是右结合。</p><p>一个右结合的例子</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190755524185_246_image-20220927155426816.png" alt="image-20220927155426816" style="zoom:50%;"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190756637988_463_image-20220927161055294.png" alt="image-20220927161055294"><figcaption aria-hidden="true">image-20220927161055294</figcaption></figure><p>注意：不要跳级！左结合的，且从左往右替换。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190758243317_959_image-20220927161040537.png" alt="image-20220927161040537"><figcaption aria-hidden="true">image-20220927161040537</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190759789619_359_image-20220928164050330.png" alt="image-20220928164050330"><figcaption aria-hidden="true">image-20220928164050330</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190801270074_244_image-20220928164220732.png" alt="image-20220928164220732"><figcaption aria-hidden="true">image-20220928164220732</figcaption></figure><h4 id="翻译模式">翻译模式</h4><p>构造翻译模式，中缀-&gt;后缀构造9-5+2的带语义动作的语法分析树，即输出其后缀表达式95-2+</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190802895392_835_image-20220927164002512.png" alt="image-20220927164002512"><figcaption aria-hidden="true">image-20220927164002512</figcaption></figure><p>按后序遍历即可打印（翻译）出后缀表达式</p><h4 id="yacc">Yacc</h4><p>见实验</p><h4 id="语法分析">语法分析</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190804367395_700_image-20221004152318374.png" alt="image-20221004152318374"><figcaption aria-hidden="true">image-20221004152318374</figcaption></figure><h5 id="自顶向下">自顶向下</h5><h6 id="平凡算法扫描输入分析">平凡算法：扫描输入分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190808051693_827_image-20221004153229852.png" alt="image-20221004153229852"><figcaption aria-hidden="true">image-20221004153229852</figcaption></figure><h6 id="优化预测分析">优化：预测分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190811525061_463_image-20221004152448359.png" alt="image-20221004152448359"><figcaption aria-hidden="true">image-20221004152448359</figcaption></figure><p><span class="math inline">\(lookahead\)</span>在构造编译器的时候就可以完成。</p><p>实例分析</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190813022183_796_image-20221004152827769.png" alt="image-20221004152827769"><figcaption aria-hidden="true">image-20221004152827769</figcaption></figure><p>对于<span class="math inline">\(simple\)</span>类似构造方法。</p><p><span class="math inline">\(lookahead\)</span>怎么构造？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190816136501_201_image-20221004153753520.png" alt="image-20221004153753520"><figcaption aria-hidden="true">image-20221004153753520</figcaption></figure><p>总体思路是什么，还有什么问题？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190818280251_227_image-20221004154007046.png" alt="image-20221004154007046"><figcaption aria-hidden="true">image-20221004154007046</figcaption></figure><h5 id="左递归问题">左递归问题</h5><p>针对上面的预测分析法，我们发现：左递归会导致递归下降程序无限循环，还会导致</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190819993463_865_image-20221004160548627.png" alt="image-20221004160548627"><figcaption aria-hidden="true">image-20221004160548627</figcaption></figure><p>怎么消除？</p><p>固定的算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190821656013_971_image-20221004160612826.png" alt="image-20221004160612826"><figcaption aria-hidden="true">image-20221004160612826</figcaption></figure><p>理解：<span class="math inline">\(A=\beta \alpha \alpha...\)</span></p><p>采用右递归进行翻译</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190823148967_751_image-20221004161628877.png" alt="image-20221004161628877"><figcaption aria-hidden="true">image-20221004161628877</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190827034211_692_image-20221004161643180.png" alt="image-20221004161643180"><figcaption aria-hidden="true">image-20221004161643180</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索_索引构建、压缩及查询支持</title>
    <link href="/posts/16720/"/>
    <url>/posts/16720/</url>
    
    <content type="html"><![CDATA[<h2 id="信息检索第一部分--索引构建">信息检索第一部分--索引构建</h2><h3 id="倒排索引构建">倒排索引构建</h3><p>六个步骤</p><p>序列化，语言预处理，分配DocID，排序，归并，添加频率标签</p><p class="note note-info">为什么要加文本频率？ 便于进行词频的排序，利于后续查询优化</p><h3 id="倒排索引布尔查询">倒排索引布尔查询</h3><p>略。并行课有涉及。比如当求交时可以先将短的链表求交。</p><h3 id="倒排索引优化改进">倒排索引优化改进</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143627586751_718_image-20220922093753305.png" alt="image-20220922093753305"><figcaption aria-hidden="true">image-20220922093753305</figcaption></figure><p>为了减少字符串所占用的内存，我们可以将键进行序列化。</p><p>Assume we have 1GB of text 800,000 documents 100 million tokens（Reuters-RCV1 collection）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143628933413_566_image-20220922094643439.png" alt="image-20220922094643439" width="50%" height="50%"></p><p>（假设是用int存docID）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143629914308_735_image-20220922095054178.png" alt="image-20220922095054178" width="50%" height="50%"></p><p>16*1.4</p><p>看上去很好。</p><p>然而，代价是必须要维护一张termID和字符串的映射表。</p><p>当需要处理的数据特别多时，由于排序，归并过程中所有的数据都需要这个表，就不得不一直将它放到内存里。</p><h4 id="bsbiblocked-sort-based-indexing">BSBI（Blocked Sort-BasedIndexing）</h4><p>仍然保留进行映射的策略</p><p>此算法的主要步骤如下：</p><p>1、将文档中的词进行id的映射，这里可以用hash的方法去构造</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143631068932_652_image-20220922100056227.png" alt="image-20220922100056227" width="50%" height="50%"></p><p>当然，可以先把全部文档读一遍构建映射，再分块构建倒排索引，也可以在构建每一块的倒排索引的时候边构建边映射。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143632700535_256_image-20220922101046446.png" alt="image-20220922101046446" width="50%" height="50%"></p><p>2、将文档分割成大小相等的部分。分治</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143634153162_211_image-20220922095854934.png" alt="image-20220922095854934" width="50%" height="50%"></p><p>3、将每部分按照词ID对上文档ID的方式进行排序（保证分块可以在内存里放下）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143635299312_759_image-20220922095946828.png" alt="image-20220922095946828" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143636457198_361_image-20220922100557902.png" alt="image-20220922100557902"><figcaption aria-hidden="true">image-20220922100557902</figcaption></figure><p>4、将每部分排序好后的结果进行合并，最后写出到磁盘中。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143637743125_385_image-20220922095721101.png" alt="image-20220922095721101" width="50%" height="50%"></p><p>归并的过程中也可以分治，比如内存中只能放100个词条的总倒排索引，可以在第100个的时候写出磁盘（因为已经确定是最后结果了），从101个再继续。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143639158715_536_image-20220922102146120.png" alt="image-20220922102146120" width="50%" height="50%"></p><h4 id="spimisingle-pass-in-memory-indexing">SPIMI（Single-PassIn-Memory Indexing）</h4><p>不作映射，其他与BSBI一样</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143640277003_250_image-20220922101959755.png" alt="image-20220922101959755" width="50%" height="50%"></p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143641398914_475_image-20220922102104189.png" alt="image-20220922102104189" width="50%" height="50%"></p><p>因为D显然要比T小的多</p><h4 id="分布式解决方案mapreduce">分布式解决方案MapReduce</h4><p>大数据实训有涉及，略。</p><h3 id="在线索引构建">在线索引构建</h3><h4 id="朴素方案">朴素方案</h4><h5 id="朴素方案一重建索引">朴素方案一：重建索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143642866848_892_image-20220928141323699.png" alt="image-20220928141323699"><figcaption aria-hidden="true">image-20220928141323699</figcaption></figure><h5 id="朴素方案二辅助索引">朴素方案二：辅助索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143644019596_168_image-20220928141427687.png" alt="image-20220928141427687"><figcaption aria-hidden="true">image-20220928141427687</figcaption></figure><p>使用辅助索引的话，一个很简便的思路是一个词建一个文档，归并便变为两个文档的合并。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143645445454_230_image-20220928141820357.png" alt="image-20220928141820357"><figcaption aria-hidden="true">image-20220928141820357</figcaption></figure><p>有什么缺陷？文件大小可能差距很大，且大量小文件不便于存储和对索引的快速读写（存储系统的问题）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143646682137_270_image-20220928142759774.png" alt="image-20220928142759774"><figcaption aria-hidden="true">image-20220928142759774</figcaption></figure><p>更大的问题，随着文档的数量变大，归并会越来越慢！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143647947499_639_image-20220928142854979.png" alt="image-20220928142854979"><figcaption aria-hidden="true">image-20220928142854979</figcaption></figure><p>合并时termID是有序的，归并时类似于归并排序，最坏复杂度是较大的那个索引的termID个数。而单个倒排索引合并只需要把新的list放到旧的后面就可以了，因为新的list中的docID肯定会比旧的大（就像上面图上所示）<span class="math display">\[O\left(n+2n+\ldots+\frac{T}{n}\right)=O\left(\frac{T^2}{n}\right)\]</span></p><h4 id="文档删除怎么操作">文档删除怎么操作？</h4><p>无效向量</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143649321808_563_image-20220928142307585.png" alt="image-20220928142307585"><figcaption aria-hidden="true">image-20220928142307585</figcaption></figure><h3 id="倒排索引压缩">倒排索引压缩</h3><h4 id="一些朴素的偷懒方法">一些朴素的偷懒方法</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143650616612_634_image-20220928155207922.png" alt="image-20220928155207922"><figcaption aria-hidden="true">image-20220928155207922</figcaption></figure><p>但是现代检索系统一般不会这么做，因为会导致一些信息的丢失。</p><h4 id="词典压缩">词典压缩</h4><h5 id="方法一使用数组">方法一：使用数组</h5><p>是一种很蠢的方法</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143654714754_145_image-20220928152210011.png" alt="image-20220928152210011" width="50%" height="50%"></p><h5 id="方法二指针">方法二：指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143655839716_271_image-20220928151740804.png" alt="image-20220928151740804"><figcaption aria-hidden="true">image-20220928151740804</figcaption></figure><h5 id="方法二的优化分段指针">方法二的优化：分段指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143657755792_576_image-20220928152418457.png" alt="image-20220928152418457"><figcaption aria-hidden="true">image-20220928152418457</figcaption></figure><p>当然，找termID对应的词项会慢一些。</p><h5 id="采用前缀的方式">采用前缀的方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143659531464_413_image-20220928153011321.png" alt="image-20220928153011321"><figcaption aria-hidden="true">image-20220928153011321</figcaption></figure><h4 id="索引表压缩">索引表压缩</h4><h5 id="encoding-gaps">Encoding gaps</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143700905497_456_image-20220928153421273.png" alt="image-20220928153421273"><figcaption aria-hidden="true">image-20220928153421273</figcaption></figure><h5 id="variable-length-codings">Variable length codings</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143702089613_543_image-20220928153533933.png" alt="image-20220928153533933"><figcaption aria-hidden="true">image-20220928153533933</figcaption></figure><p>例子：可变长UTF-8</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143703419174_526_image-20220928153849498.png" alt="image-20220928153849498"><figcaption aria-hidden="true">image-20220928153849498</figcaption></figure><p>UTF-8 的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的Unicode 码。</p><p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p><p></p><div class="code-wrapper"><pre><code class="hljs asciidoc">Unicode符号范围     |        UTF-8编码方式<span class="hljs-section">(十六进制)        |              （二进制）</span><span class="hljs-section">-------------------+---------------------------------------------</span>0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre></div><p></p><p>根据上表，解读 UTF-8编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>下面，以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p><p><code>严</code>的 Unicode是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的UTF-8编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的UTF-8编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p><h5 id="gamma-encoding">Gamma Encoding</h5><p>根据<a href="https://en.wikipedia.org/wiki/Elias_gamma_coding">维基百科</a>所述，gamma编码过程如下图所示。虽具体过程与课上讲述稍有不同，但原理是一样的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143704774266_595_image-20220930155723916.png" alt="image-20220930155723916"><figcaption aria-hidden="true">image-20220930155723916</figcaption></figure><p>编码具体案例和解码过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143706251591_500_image-20220930155802505.png" alt="image-20220930155802505"><figcaption aria-hidden="true">image-20220930155802505</figcaption></figure><h3 id="查询优化">查询优化</h3><h4 id="倒排索引数据结构优化">倒排索引数据结构优化</h4><h5 id="跳表">“跳表”</h5><p>动机</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143708733468_476_image-20221005150319520.png" alt="image-20221005150319520"><figcaption aria-hidden="true">image-20221005150319520</figcaption></figure><p>怎么选取间隔？“摔瓶子”。开根号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143710120784_928_image-20221005150404678.png" alt="image-20221005150404678"><figcaption aria-hidden="true">image-20221005150404678</figcaption></figure><p>实例：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143711476304_852_image-20221005150523460.png" alt="image-20221005150523460"><figcaption aria-hidden="true">image-20221005150523460</figcaption></figure><p class="note note-info">为什么是先跳再判断，如果跳过了再倒回去，而不是比较之后再跳？后者比较次数太多，开销大，且慢。</p><h4 id="词项数据结构">词项数据结构</h4><h5 id="哈希表">哈希表</h5><p>优点：快</p><p>缺点：不支持模糊查询</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143713258991_492_image-20221005152131580.png" alt="image-20221005152131580"><figcaption aria-hidden="true">image-20221005152131580</figcaption></figure><h5 id="b树">B树</h5><p>实际使用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143716445073_262_image-20221005152231798.png" alt="image-20221005152231798"><figcaption aria-hidden="true">image-20221005152231798</figcaption></figure><h4 id="通配符查询支持">通配符查询支持</h4><p>前缀：B树天然支持</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143718721740_938_image-20221005153943805.png" alt="image-20221005153943805"><figcaption aria-hidden="true">image-20221005153943805</figcaption></figure><p>后缀：对逆序建B树</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143720264162_261_image-20221005154022485.png" alt="image-20221005154022485"><figcaption aria-hidden="true">image-20221005154022485</figcaption></figure><p>中间的？好像有点问题。。。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143721509249_850_image-20221012140726185.png" alt="image-20221012140726185" width="50%" height="50%"></p><h4 id="轮排索引">轮排索引</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143722646249_170_image-20221012141847402.png" alt="image-20221012141847402"><figcaption aria-hidden="true">image-20221012141847402</figcaption></figure><p>采用B树。但通常这种方法产生的B树会非常大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143723834048_694_image-20221012143335531.png" alt="image-20221012143335531"><figcaption aria-hidden="true">image-20221012143335531</figcaption></figure><h4 id="k-gram">K-gram</h4><p>一定程度上的优化</p><p>在一定长度的字串上建索引</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143725269033_823_image-20221012143730369.png" alt="image-20221012143730369"><figcaption aria-hidden="true">image-20221012143730369</figcaption></figure><p>查$co,ter,er$,$代表起始和结束符号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143726834159_151_image-20221012144353569.png" alt="image-20221012144353569"><figcaption aria-hidden="true">image-20221012144353569</figcaption></figure><h3 id="拼写检查支持">拼写检查支持</h3><h4 id="动态规划编辑距离">动态规划：编辑距离</h4><p>动态规划求字符串距离？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143728315657_544_image-20221012150059012.png" alt="image-20221012150059012"><figcaption aria-hidden="true">image-20221012150059012</figcaption></figure><p>词项太多，算法显得有些复杂，慢</p><h4 id="在k-gram基础上进行">在K-gram基础上进行</h4><p>Jaccard distance判断相似度</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143729475948_696_image-20221012151057155.png" alt="image-20221012151057155"><figcaption aria-hidden="true">image-20221012151057155</figcaption></figure><p>求并集的小trick</p><p>#query term's k-grams +#found term's k-grams-#intersection</p><h4 id="上下文相关检查">上下文相关检查</h4><p>利用搜索历史，启发式</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在mac上编写运行c++程序</title>
    <link href="/posts/51388/"/>
    <url>/posts/51388/</url>
    
    <content type="html"><![CDATA[<h2 id="如何在mac上编写运行c程序">如何在mac上编写运行c++程序</h2><p>有一部分同学买的电脑是mac，也有很多同学问怎么在mac上写c++代码。在这里解答一下。</p><h3 id="方案一使用clion">方案一：使用Clion</h3><h4 id="下载">下载</h4><p><a href="https://www.jetbrains.com/clion/download/#section=mac">下载网址</a></p><p>如果你的苹果电脑是M1/M2芯片，那么请选择Apple Sillcon，否则选Intel</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230752211301_738_image-20220927201026604.png" alt="image-20220927201026604"><figcaption aria-hidden="true">image-20220927201026604</figcaption></figure><p>然后打开dmg文件将其拖到applcation文件夹即可。</p><h4 id="激活">激活</h4><p>Clion并不是一个免费的软件。但是作为学生，可以向其申请免费使用。点击<a href="https://www.jetbrains.com/zh-cn/community/education/#students">这里</a>进入申请页面。正常情况下用你的学生邮箱就可以申请。申请之后会自动跳转到Clion，激活成功。</p><h4 id="创建第一个项目">创建第一个项目</h4><p>点击“新建项目”，选择默认的c++ excutable</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230754550529_520_image-20220927203943145.png" alt="image-20220927203943145"><figcaption aria-hidden="true">image-20220927203943145</figcaption></figure><p>在location处可以改变项目路径和名称。</p><p>如果之前你没写过代码，可能会提示</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230756221193_195_image-20220927204027175.png" alt="image-20220927204027175"><figcaption aria-hidden="true">image-20220927204027175</figcaption></figure><p>安装即可。可能需要等待亿些时间。（类似于visualstudio的工具链，可能会捆绑一些你可能其实用不到的东西）</p><p>然后安装完确认一下</p><p align="center"><img alt="image-20220927211547461" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230757928357_218_image-20220927211547461.png" width="50%"></p><p>项目配置没有报错</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230759316655_492_image-20220927211608280.png" alt="image-20220927211608280"><figcaption aria-hidden="true">image-20220927211608280</figcaption></figure><p>然后选中CMakeLists，点击2处的刷新符号，重新构建</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230801131735_750_image-20220927211726878.png" alt="image-20220927211726878"><figcaption aria-hidden="true">image-20220927211726878</figcaption></figure><p>你应当发现此处的项目配置发生了改变。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230802745480_349_image-20220927211737021.png" alt="image-20220927211737021"><figcaption aria-hidden="true">image-20220927211737021</figcaption></figure><p>此时点击运行，运行helloworld程序，成功</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230804052581_398_image-20220927211838631.png" alt="image-20220927211838631"><figcaption aria-hidden="true">image-20220927211838631</figcaption></figure><h4 id="简单了解cmake">简单了解Cmake</h4><p>如果你想要在这个项目下运行多个cpp文件，你有必要了解一下cmake。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230805695741_398_image-20220927212015622.png" alt="image-20220927212015622"><figcaption aria-hidden="true">image-20220927212015622</figcaption></figure><p>你会发现cmakelist变成了这样。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230808172534_771_image-20220927212042215.png" alt="image-20220927212042215"><figcaption aria-hidden="true">image-20220927212042215</figcaption></figure><p>然后你顺理成章的点击了main函数旁边的运行</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230809367068_211_image-20220927212255496.png" alt="image-20220927212255496"><figcaption aria-hidden="true">image-20220927212255496</figcaption></figure><p>报错了！查看倒数第三行的报错信息，你会发现出现了重复（duplicate）的符号。</p><p>你想到课上使用vs时讲的，一个项目只能使用一个main函数。你把另外一个main改成了main2。学着这样修改。你发现确实可以正常运行。</p><p><font color="Apricot">但有没有更优雅的解决方案呢？</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230811319016_339_image-20220927212700579.png" alt="image-20220927212700579"><figcaption aria-hidden="true">image-20220927212700579</figcaption></figure><p>你注意到了cmake中最后一行是add_executable，刚刚发生了变化。从含义可以推测出一定是它控制了程序的执行。</p><p>让它们各自生成各自的程序一定可以！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230812325537_398_image-20220927212920160.png" alt="image-20220927212920160"><figcaption aria-hidden="true">image-20220927212920160</figcaption></figure><p>点击Reload changes。你会发现项目构建出现了两个程序。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230813838131_522_image-20220927213032997.png" alt="image-20220927213032997"><figcaption aria-hidden="true">image-20220927213032997</figcaption></figure><p>然后你高兴的发现点击哪个程序运行，你就可以运行哪一个cpp文件！</p><p>事实上，你点击cmake_build_debug，你会发现add_excutable第一个参数正是生成程序的名称！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230815024257_502_image-20220927213245467.png" alt="image-20220927213245467"><figcaption aria-hidden="true">image-20220927213245467</figcaption></figure><p>在访达打开<img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230816481939_447_image-20220927213323515.png" alt="image-20220927213323515"></p><p>双击---helloworld出现了！它正是你刚刚编写的程序！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230818933782_519_image-20220927213343594.png" alt="image-20220927213343594"><figcaption aria-hidden="true">image-20220927213343594</figcaption></figure><p>Cmake在大型项目管理中有着重要的用途，其本身也是十分复杂的。但在课程中只需要了解这些即可。</p><p>同时Clion在windows下也可以使用。</p><h3 id="方案二使用xcode">方案二：使用xcode</h3><p>xcode是专为mac平台打造的全功能IDE（当然你要问我能不能写exe，只能说emmm）</p><p>xcode比较大，下载需要耐心等待。</p><h4 id="项目搭建">项目搭建</h4><p>点击新建项目</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230821620085_933_image-20220927213913046.png" alt="image-20220927213913046"><figcaption aria-hidden="true">image-20220927213913046</figcaption></figure><p>选择macOS控制台应用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230823254664_156_image-20220927213932265.png" alt="image-20220927213932265"><figcaption aria-hidden="true">image-20220927213932265</figcaption></figure><p>项目选项</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230824771816_210_image-20220927214102217.png" alt="image-20220927214102217"><figcaption aria-hidden="true">image-20220927214102217</figcaption></figure><p>注意组织名称写com，别的其实也行，但此处不作介绍。</p><p>语言选择c++。</p><p>选择项目位置后就可以愉快开发了！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230826057443_745_image-20220927214344955.png" alt="image-20220927214344955"><figcaption aria-hidden="true">image-20220927214344955</figcaption></figure><p>控制台在屏幕下方。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230827635084_833_image-20220927214423776.png" alt="image-20220927214423776"><figcaption aria-hidden="true">image-20220927214423776</figcaption></figure><h4 id="运行多个cpp">运行多个cpp</h4><p>这个时候已经创建了一个cpp-project的项目，里面包含了一个main.cpp文件如果这个时候想要在同一个工程里面创建第二个带main函数的c++文件并运行，就需要通过创建Target来实现</p><p>Project是一个工程项目，一个Project可以包含多个TargetTarget之间互相没有关系，Target于Project的关系是：Target的Setting一部分继承自Project的Setting</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230828821606_386_image-20220927214845054.png" alt="image-20220927214845054"><figcaption aria-hidden="true">image-20220927214845054</figcaption></figure><p>新建target，同样选择commandline tool，填写一个的名称</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230831064192_247_image-20220927215021382.png" alt="image-20220927215021382"><figcaption aria-hidden="true">image-20220927215021382</figcaption></figure><p>在上方，想运行哪一个target，选择对应的即可。</p><p align="center"><img alt="image-20220927215233319" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230832540286_682_image-20220927215233319.png" width="50%"></p><h3 id="方案三命令行方式">方案三：命令行方式</h3><p>安装homebrew（如果已经下载过xcode可以跳过，不过既然如此为什么不用xcode呢？）</p><p>在你的终端输入这行指令：</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>bash -c <span class="hljs-string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</span></code></pre></div><p>如果下载很慢一般是网络问题，请自行解决。</p><p>安装完成后</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>g++</code></pre></div><p>任意位置新建cpp文件。</p><p>cpp文件可以用你喜欢的方式打开编辑。</p><p>按⌘（command）+ ⌥（option）+c复制当前文件夹路径</p><p>终端输入</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 刚才的路径</code></pre></div><p>然后</p><div class="code-wrapper"><pre><code class="hljs aspectj">g++ yourprogram.cpp -o <span class="hljs-keyword">target</span></code></pre></div><p>target 是生成的可执行文件的名字。</p><p>然后会发现生成了可执行文件，点击即可运行。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230833974800_101_image-20220927220347236.png" alt="image-20220927220347236"><figcaption aria-hidden="true">image-20220927220347236</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_进程与线程模型</title>
    <link href="/posts/30463/"/>
    <url>/posts/30463/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统--进程与线程">操作系统--进程与线程</h2><h3 id="进程概念">进程概念</h3><h4 id="从并发开始">从并发开始</h4><p>串行排队</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110755222583_746_image-20220926142304076.png" alt="image-20220926142304076"><figcaption aria-hidden="true">image-20220926142304076</figcaption></figure><p>分时调用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110756926120_483_image-20220926142216136.png" alt="image-20220926142216136"><figcaption aria-hidden="true">image-20220926142216136</figcaption></figure><p>“但是并发除了会让脑子更乱以外并不会让事情变得更好”</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110758632298_262_image-20220926151301063.png" alt="image-20220926151301063"><figcaption aria-hidden="true">image-20220926151301063</figcaption></figure><p>尽管如此，并发确实可以提高CPU的利用率。当然可能会带来设备（慢操作）延迟。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110801392732_151_image-20221018192004694.png" alt="image-20221018192004694"><figcaption aria-hidden="true">image-20221018192004694</figcaption></figure><p>C</p><p><strong>进程就是为了“保存”和“恢复”一个程序的执行过程，以实现并发的目标</strong></p><h4 id="进程和程序的区别">进程和程序的区别</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110803473763_292_image-20221016200649356.png" alt="image-20221016200649356"><figcaption aria-hidden="true">image-20221016200649356</figcaption></figure><h3 id="进程和线程的区别">进程和线程的区别</h3><ul><li><p>进程作为分配资源的基本单位，线程作为独立运行和独立调度的基本单位(注意：在多线程OS 中，进程不是一个可执行的实体)</p></li><li><p>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</p></li></ul><h3 id="进程的数据结构--pcb">进程的数据结构--PCB</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110805822552_826_image-20220926152249647.png" alt="image-20220926152249647"><figcaption aria-hidden="true">image-20220926152249647</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110807671323_383_image-20221018191442452.png" alt="image-20221018191442452"><figcaption aria-hidden="true">image-20221018191442452</figcaption></figure><h3 id="进程的组织">进程的组织</h3><h4 id="进程状态和切换">进程状态和切换</h4><p class="note note-primary">对于某一个进程： 为什么被暂停了？ 为什么选它来运行？为什么选择这个时机进行切换？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110809885582_767_image-20221018191551669.png" alt="image-20221018191551669"><figcaption aria-hidden="true">image-20221018191551669</figcaption></figure><p>操作系统可以将会触发慢操作的状态记录下来。</p><p class="note note-primary">“把printf的汇编代码放到自己的程序中，并且把控制休眠的指令注释掉，会不会能正常运行？”</p><p>不能。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110811863911_528_image-20220926161106287.png" alt="image-20220926161106287" width="50%" height="50%"></p><h5 id="五状态进程模型">五状态进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110813764309_930_image-20221014152546893.png" alt="image-20221014152546893"><figcaption aria-hidden="true">image-20221014152546893</figcaption></figure><p>关于进程的创建：</p><p>在一个进程被新建时它并非绝对会被调入内存，通常是分两步，首先创建该进程的PCB，并与之关联，但是此时可能面临内存不足或者操作系统限制了最大进程数导致这个进程还无法被调入进程，因此该进程被暂时留在新建态，在这个状态的进程PCB已经创建并且加载进内存，但是进程的代码和数据往往还留在外存中等待加载。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110816170775_715_image-20221018205252597.png" alt="image-20221018205252597"><figcaption aria-hidden="true">image-20221018205252597</figcaption></figure><p>关于进程的撤销(结束)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110817967015_206_image-20221016192515282.png" alt="image-20221016192515282"><figcaption aria-hidden="true">image-20221016192515282</figcaption></figure><blockquote><p>B。进程有它的生命周期，不会一直存在于系统中，也不一定需要用户显式地撒销。进程在时间片结束时只是就绪，而不是撤销。阻塞和唤醒是进程生存期的中间状态。进程可在完成时撤销，或在出现内存错误等时撤销。</p></blockquote><p>关于进程的阻塞</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110819440912_574_image-20221018192631681.png" alt="image-20221018192631681"><figcaption aria-hidden="true">image-20221018192631681</figcaption></figure><p>阻塞态完了会进就绪队列</p><p><a target="_blank" href="https://houbb.github.io/2020/10/04/os-04-sync" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">关于临界资源及其同步和互斥</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://houbb.github.io/2020/10/04/os-04-sync</span></span></span></a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110821096921_713_image-20221018214846546.png" alt="image-20221018214846546"><figcaption aria-hidden="true">image-20221018214846546</figcaption></figure><blockquote><p>B 可以共享一部分资源，但不共享虚拟地址空间</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110822817914_214_image-20221018214339806.png" alt="image-20221018214339806"><figcaption aria-hidden="true">image-20221018214339806</figcaption></figure><blockquote><p>C</p></blockquote><h5 id="添加了挂起状态的进程模型">添加了挂起状态的进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110824611329_729_image-20220926162706586.png" alt="image-20220926162706586"><figcaption aria-hidden="true">image-20220926162706586</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110826436181_342_image-20221014151453508.png" alt="image-20221014151453508"><figcaption aria-hidden="true">image-20221014151453508</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110828695748_821_image-20221018192900616.png" alt="image-20221018192900616"><figcaption aria-hidden="true">image-20221018192900616</figcaption></figure><p>A</p><p class="note note-info">不同操作系统中进程状态设置区别很大。</p><h5 id="进程调度方式">进程调度方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110830191623_314_image-20220926162928685.png" alt="image-20220926162928685"><figcaption aria-hidden="true">image-20220926162928685</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110832168851_702_image-20220926163633315.png" alt="image-20220926163633315"><figcaption aria-hidden="true">image-20220926163633315</figcaption></figure><p>现在的操作系统都是可抢占系统。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110834324423_859_image-20221018205406513.png" alt="image-20221018205406513"><figcaption aria-hidden="true">image-20221018205406513</figcaption></figure><blockquote><p>A。BC应该将优先级，D时机不合适。</p><p>此部分将在进程调度中详细介绍。</p></blockquote><h4 id="进程通信">进程通信</h4><p>共享存储，消息传递，管道通信</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110836886804_366_image-20221018211857840.png" alt="image-20221018211857840"><figcaption aria-hidden="true">image-20221018211857840</figcaption></figure><p><a href="https://zhuanlan.zhihu.com/p/58489873">linux中的管道通信</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110839761934_452_image-20221018211911941.png" alt="image-20221018211911941"><figcaption aria-hidden="true">image-20221018211911941</figcaption></figure><blockquote><p>A得俩。B容量是一个页的大小(4KB)。管道是一个文件，任何两个不相关的进程当然都可以通过这个管道文件进行通信</p></blockquote><h4 id="进程和线程的设计模型">进程和线程的设计模型</h4><h5 id="线程实现方式">线程实现方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110841591537_254_image-20221018194121923.png" alt="image-20221018194121923"><figcaption aria-hidden="true">image-20221018194121923</figcaption></figure><h6 id="ult">ULT</h6><p>需要注意的是在这种模式下调度仍是以进程为单位进行的</p><p>优势:</p><p>1.线程切换不需要内核模式特权.</p><p>2.线程调用可以是应用程序级的,根据需要可改变调度算法,但不会影响底层的操作系统调度程序.</p><p>3.ULT管理模式可以在任何操作系统中运行,不需要修改系统内核,线程库是提供应用的实用程序。</p><p>劣势:</p><p>系统调用会引起进程阻塞</p><p>这种线程不利于使用多处理器并行</p><p>程被阻塞，而且进程内的所有线程都被阻塞。(内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行)</p><h6 id="klt">KLT</h6><p>优势：灵活，线程切换快</p><p>劣势：需要用户态到内核态的切换，代价高</p><p>线程库：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110843340452_876_image-20221018193551401.png" alt="image-20221018193551401"><figcaption aria-hidden="true">image-20221018193551401</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110845328702_264_image-20221018192401379.png" alt="image-20221018192401379"><figcaption aria-hidden="true">image-20221018192401379</figcaption></figure><blockquote><p>C。这个显然只需要一个线程就够了</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110847145883_201_image-20221018205754448.png" alt="image-20221018205754448"><figcaption aria-hidden="true">image-20221018205754448</figcaption></figure><blockquote><p>D.其他线程对此不可见</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110848853722_394_image-20221018214600427.png" alt="image-20221018214600427"><figcaption aria-hidden="true">image-20221018214600427</figcaption></figure><blockquote><p>B只有在KLT中才会这么做</p></blockquote><h5 id="轻权进程"><a href="https://en.wikipedia.org/wiki/Light-weight_process#cite_note-Vah96-1">轻权进程</a></h5><p>类似于一种折衷的方案</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110850808418_676_image-20221018234308117.png" alt="image-20221018234308117"><figcaption aria-hidden="true">image-20221018234308117</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网第一二章</title>
    <link href="/posts/47623/"/>
    <url>/posts/47623/</url>
    
    <content type="html"><![CDATA[<h2 id="寄网">寄网</h2><h3 id="第一章">第一章</h3><h4 id="一些基本概念">一些基本概念</h4><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140244969763_823_image-20220921102100658.png" alt="image-20220921102100658"> <span class="math display">\[\frac{640*480*3}{1024}=900\text{KB}\]</span></p><h4 id="internet边缘与核心">Internet边缘与核心</h4><p>时分和频分多路复用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140246164281_313_image-20220921091644435.png" alt="image-20220921091644435"><figcaption aria-hidden="true">image-20220921091644435</figcaption></figure><p align="center"><img alt="image-20220914113833784" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140247918940_123_image-20220914113833784.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140249637000_165_image-20220921090426643.png" alt="image-20220921090426643"><figcaption aria-hidden="true">image-20220921090426643</figcaption></figure><p>”谁来用谁,满了就丢“（当然刚满的时候有临时缓存）</p><p class="note note-secondary">由于成本问题，广域网带宽往往比局域网小得多。</p><p>问题：因为有排队现象，延迟大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140251667625_745_image-20220921091804148.png" alt="image-20220921091804148"><figcaption aria-hidden="true">image-20220921091804148</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140254211234_437_image-20220921092457252.png" alt="image-20220921092457252"><figcaption aria-hidden="true">image-20220921092457252</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140256515520_955_image-20220921102342289.png" alt="image-20220921102342289"><figcaption aria-hidden="true">image-20220921102342289</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140258270940_747_image-20220921102115526.png" alt="image-20220921102115526"><figcaption aria-hidden="true">image-20220921102115526</figcaption></figure><p>别忘了字节和bit的转换</p><h4 id="web服务器访问示例">Web服务器访问示例</h4><p>网络体系结构概览，理解。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140259958997_827_image-20220921135514064.png" alt="image-20220921135514064"><figcaption aria-hidden="true">image-20220921135514064</figcaption></figure><h3 id="第二章">第二章</h3><h4 id="应用层协议和进程通信模型">应用层协议和进程通信模型</h4><h5 id="进程通信">进程通信</h5><p class="note note-primary"></p><p>进程之间如何通信？</p>1.管道 2.共享内存 3.消息队列<p></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140301954282_880_image-20220928093225868.png" alt="image-20220928093225868"><figcaption aria-hidden="true">image-20220928093225868</figcaption></figure><p class="note note-info">C/S模型的缺陷：如果访问量大的时候，会影响服务质量，甚至会导致中心服务器瘫痪P2P模型缺陷：不便于管理</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140304191029_856_image-20220928094631013.png" alt="image-20220928094631013"><figcaption aria-hidden="true">image-20220928094631013</figcaption></figure><h5 id="进程地址标识">进程地址标识</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140306050316_256_image-20220928101653200.png" alt="image-20220928101653200"><figcaption aria-hidden="true">image-20220928101653200</figcaption></figure><h5 id="应用层协议定义的内容">应用层协议定义的内容</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140307775494_627_image-20220928103019165.png" alt="image-20220928103019165"><figcaption aria-hidden="true">image-20220928103019165</figcaption></figure><h4 id="传输层">传输层</h4><p>作用：保证端到端服务的可靠性</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140309649551_638_image-20220928103725740.png" alt="image-20220928103725740"><figcaption aria-hidden="true">image-20220928103725740</figcaption></figure><p>UCP服务的不可靠是相对的，只是级别比较低。</p><p>UCP的优势：建立连接快，占用资源少，实现简单，不容易被监控</p><p class="note note-info">无论TCP还是UDP都没有提供任何加密机制，这就是说发送进程传进其套接字的数据，与经网络传送到目的进程的数据相同。因此，举例来说如果某发送进程以明文方式（即没有加密）发送了一个口令进入它的套接字，该明文口令将经过发送方与接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。因为隐私和其他安全问题对许多应用而言已经成为至关重要的问题，所以因特网界已经研制了TCP的加强版本，称为安全套接字层(SecureSocketsLayer，SSL)。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。</p><p>TCP/IP协议通常在操作系统的内核中实现</p><h5 id="socket">socket</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140312104068_654_image-20220928111844557.png" alt="image-20220928111844557"><figcaption aria-hidden="true">image-20220928111844557</figcaption></figure><p>TCP/UDP协议感性认识</p><p align="center"><img alt="image-20220928135917798" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%AF%84%E7%BD%91/20220928140313787528_278_image-20220928135917798.png" width="50%"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-模型评估与选择</title>
    <link href="/posts/4810/"/>
    <url>/posts/4810/</url>
    
    <content type="html"><![CDATA[<h2 id="模型评估与选择">模型评估与选择</h2><h3 id="模型评估方法">模型评估方法</h3><p>书后习题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234157710423_473_image-20220930231043281.png" alt="image-20220930231043281"><figcaption aria-hidden="true">image-20220930231043281</figcaption></figure><h3 id="经验误差和泛化误差">经验误差和泛化误差</h3><h4 id="定义">定义</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234159328307_660_image-20220930140833923.png" alt="image-20220930140833923"><figcaption aria-hidden="true">image-20220930140833923</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234200690193_368_image-20220930141041690.png" alt="image-20220930141041690"><figcaption aria-hidden="true">image-20220930141041690</figcaption></figure><h4 id="解决过拟合现象正则化">解决过拟合现象：正则化</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234202870906_724_image-20220930141142762.png" alt="image-20220930141142762"><figcaption aria-hidden="true">image-20220930141142762</figcaption></figure><h3 id="性能度量">性能度量</h3><h4 id="基本概念">基本概念</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234204833875_372_image-20220930163038120.png" alt="image-20220930163038120"><figcaption aria-hidden="true">image-20220930163038120</figcaption></figure><h4 id="p-r曲线和roc曲线">P-R曲线和ROC曲线</h4><h5 id="实例">实例</h5><p><a href="https://zhuanlan.zhihu.com/p/92218196">知乎</a>上有一个案例对这些曲线描述的比较形象。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234208101296_478_image-20220930194835021.png" alt="image-20220930194835021"><figcaption aria-hidden="true">image-20220930194835021</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234209475943_307_image-20220930194858579.png" alt="image-20220930194858579"><figcaption aria-hidden="true">image-20220930194858579</figcaption></figure><p>TPR真阳性，FPR假阳性</p><p>一个表现平平的分类器(表现是指分类标准能否将两种样本有效的分开，而threshold是指划分标准更倾向于查全率或准确率)</p><p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234211807031_249_norm.gif" width=""></p>一个更好一些的分类器<p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234215190380_315_norm2.gif" width=""></p><p>F1计算</p><p align="center"><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234218188978_486_F1.gif" width="" hight=""></p><h5 id="用途">用途</h5><p>基于P-R曲线可以大致评判机器学习模型的好坏</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234219845677_195_image-20220930224302678.png" alt="image-20220930224302678"><figcaption aria-hidden="true">image-20220930224302678</figcaption></figure><p>ROC也是如此。</p><p>从定义可知， AUC 可 通过对 ROC 曲 线下各部分的面积 求和而得.</p><p>形式化地看， AUC 考虑的是样本预测的排序质量。</p><p>习题：若学习器A的F1值比学习器B高，试析A的BEP值是否也比B高</p><p>二者是不同维度的指标。当然在达到BEP的条件时(P=R)，F1的值和BEP相等。</p><h4 id="roc代价曲线">ROC代价曲线</h4><p>参考<a href="https://www.zhihu.com/question/63492375">知乎答案</a></p><p>首先, 横坐标是 <span class="math inline">\(\mathrm{P}(+)\)</span>,由公式3可以知道, 当 <span class="math inline">\(\mathrm{P}(+)=0\)</span>时, <span class="math inline">\({c o s t}_{n o rm}=\mathrm{FPR}\)</span>; 当 <span class="math inline">\(\mathrm{P}(+)=1\)</span> 时, <span class="math inline">\(\operatorname{cost}_{n o rm}=\mathrm{FNR}_{\circ}\)</span> 直白含义：当我用来检测模型好坏的样本全是负例(即 $(+)=0 $)，那我模型产生的错误就只有负例被错误的预测 为正例这一种情况, 就是 <span class="math inline">\((0, F P R)\)</span> 。 同样,当我用来检测模型好坏的样本全都是正例（即 $(+)=1 $)，那我模型产生的错误就只有正例被错 误的预测为负例的情况这一种情况，就是<span class="math inline">\((1, \mathrm{FNR})\)</span>两个连线中间的情况, 用来检测模型的样本有正例也有负例的时候, 也就是 <span class="math inline">\(P(+)=0 . x\)</span>, 这时候 <span class="math inline">\(\operatorname{cost}_{n o r m}\)</span>的取值就会同时受到FPR和FNR的影响。</p><p>很像高中化学读图题的定性分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234221742723_477_image-20220930222355725.png" alt="image-20220930222355725"><figcaption aria-hidden="true">image-20220930222355725</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234223625316_668_image-20220930222637642.png" alt="image-20220930222637642"><figcaption aria-hidden="true">image-20220930222637642</figcaption></figure><p>就像做核酸”粉饰太平“一样( <span class="math display">\[P(+)=\frac{p \cdot \cos _{0 \mid 1}}{p \cdot \operatorname{cost}_{0 \mid1}+(1-p) \cdot \operatorname{cost}_{1 \mid 0}}\]</span> <span class="math inline">\(\operatorname{cost}_{0 \mid1}\)</span> 表示: 实际为正类, 而错判成负类的代价, <span class="math inline">\(\operatorname{cost}_{1 \mid 0}\)</span> 表示:实际为负类, 而错判成正类类Q 的代价。 举例说明, 当我们认为,正例错判为负例的代价与负例错判为正例的代价相同时, <span class="math inline">\(P^1(+)=p\)</span>当我们认为把正类判定为负类会造成更大的损失时(比如假设核酸检测瞒报比误报代价更大),此时 <span class="math inline">\(\operatorname{cost}_{1 \mid 0}&gt;;\cost_{0 \mid 1}\)</span>, 带入正例代价公式 得 <span class="math inline">\(P^2(+)\)</span>, 这时候就有 <span class="math inline">\(P^2(+)&gt;;P^1(+)\)</span> 。 对应到ROC代价图,正例概率 <span class="math inline">\(P(+)\)</span> 就会往左移动,对应的阈值就会减小, 模型对负类的判断就会更谨慎(比如下调CT值)。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234224685263_266_image-20220930142416369.png" alt="image-20220930142416369"><figcaption aria-hidden="true">image-20220930142416369</figcaption></figure><p><span class="math inline">\(\beta\)</span>&gt;1时查全率有更大影响；<span class="math inline">\(\beta\)</span>&lt;1时查准率有更大影响。</p><p>(核酸检测评价假设偏向减少瞒报，则<span class="math inline">\(\beta&gt;1\)</span>)</p><h3 id="比较检验">比较检验</h3><p>单边t检验和成对t检验可以分别用于评价单个学习器的错误率和比较两个学习器的性能。</p><p>对二分类问题，使用留出法不仅可估计出学习器 A 和 B的测试错误率，还可获得两学习器分类结果的差别，使用McNemar检验可以做到。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234226080145_532_image-20220930233428713.png" alt="image-20220930233428713"><figcaption aria-hidden="true">image-20220930233428713</figcaption></figure><p>$Min-max$规范化优点：1、计算相对简单一点。2、当新样本进来时，只有在新样本大于原最大值或者小于原最小值时，才需要重新计算规范化之后的值。缺点在于：1、容易受高杠杆点和离群点影响。</p><p><span class="math inline">\(z-score\)</span>规范化优点：1、对异常值敏感低。缺点在于：1、计算更负责。2、每次新样本进来都需要重新计算规范化。</p><h3 id="偏差方差分解">偏差方差分解</h3><p>用途：解释算法泛化性能来源的手段 <span class="math display">\[E(f ;D)=\operatorname{bias}^2(\boldsymbol{x})+\operatorname{var}(\boldsymbol{x})+\varepsilon^2,\]</span> 也就是说, 泛化误差可分解为偏差、方差与噪声之和。</p><p>注意这个式子的推导，详见南瓜书。</p><ul><li><strong>「偏差」</strong>度量了学习算法的期望预测与真实结果的偏离程度，即<strong>「刻画了学习算法本身的拟合能力」</strong>；</li><li><strong>「方差」</strong>度量了同样大小的训练集的变动所导致的学习性能的变化，即<strong>「刻画了数据扰动所造成的影响」</strong>;</li><li><strong>「噪声」</strong>则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即<strong>「刻画了学习问题本身的难度」</strong>.</li></ul><p>偏差一方差分解说明，泛化性能是由<strong>「学习算法的能力」</strong>、<strong>「数据的充分性」</strong>以及<strong>「学习任务本身的难度所共同决定」</strong>的。</p><p align="center"><img alt="image-20220930230353084" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234228241789_843_image-20220930230353084.png" width="50%"></p><p>随训练强度，偏差减小，方差增大，即学习的越充分，但受数据影响越大，可能出现过拟合现象。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统期末工程作业设计</title>
    <link href="/posts/30344/"/>
    <url>/posts/30344/</url>
    
    <content type="html"><![CDATA[<h3 id="期末工程作业">期末工程作业</h3><p class="note note-info">本文暂只提供相关设计思路，不提供最终实现代码。实现方面前端flask或swing上手较为快速，也可尝试其他框架。后端使用mysql数据库，关于连接数据库方式网上很容易搜到，不再赘述。</p><h4 id="需求描述">1. 需求描述</h4><p>疫情期间，学校的润美超市（虚构）需要对商品物资做更详细的管理。为防止供应链出现问题，对商品的供货商需要进行详细的记录，并对顾客的购买记录进行管理。当然，也需要对商品本身和超市内工作人员进行常规的管理。作为典型的数据库应用场景，引入合适的数据管理系统能够更好的落实疫情防控要求，并让超市具有更好的营业效果。</p><p>1.商品根据名称和供应商整理，通过编号标识，记录其价格。同时对于食品还需记录其保质期，以免过期未处理。</p><p>2.进货数据需要包含商品编号、进货价，进货时间等。</p><p>3.超市内有若干工作人员，需要对其个人信息和销售商品所得薪水进行储存。</p><p>4.需要对顾客信息进行储存。并对应购买时间和商品，形成销售日志。</p><h4 id="概念模型er图">2.1 概念模型ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004325018293_610_image-20220919004148336.png" alt="image-20220919004148336"><figcaption aria-hidden="true">image-20220919004148336</figcaption></figure><h4 id="关系模式转换">2.2 关系模式转换</h4><p>注：1.普通商品采用使用空值的方式，food与goods共用一张表</p><p>​ 2.斜体代表外键</p><p>goods（<u>goods_id</u>, goods_name, supplier_id, price, good_num,<em>shelf_no</em>)</p><p>//food（<u>goods_id</u>, goods_name, supplier_id, price,shelf_life)</p><p>supplier（<u>sp_id</u>, sp_name, phone, address)</p><p>supply（<u><em>sp_id</em></u>, <u><em>goods_id</em></u>, enter_time,costs)</p><p>employee（<u>emp_no</u>, <u>emp_name</u>, salary)</p><p>customer（<u>cu_id</u>, cu_name)</p><p>buy(<u><em>cu_id</em></u>, <u><em>goods_id</em></u>, buy_time,buy_costs)</p><p>shelf(<u>shelf_id</u>, goods_num_on_shelf)</p><p>sell (<u><em>emp_no</em></u>, <em><u>goods_id</u></em>)</p><h4 id="sql创建关系模式">2.3 SQL创建关系模式</h4><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div><h4 id="查询语句样例">2.4 查询语句样例</h4><p>1.单表查询</p><p>查询单价为10元的商品名称</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name <span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> price<span class="hljs-operator">=</span><span class="hljs-number">10</span></code></pre></div><p>2.多表连接查询</p><p>查询每个厂商生产商品的平均价格</p><div class="code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> sp_id,<span class="hljs-built_in">avg</span>(price)<span class="hljs-keyword">from</span> supply <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sp_id</code></pre></div><p>3.4多表嵌套查询和exist查询</p><p>查询只有一种商品的货架，返回这种商品的名称和货架id</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name,shelf_id<span class="hljs-keyword">from</span> goods,shelf<span class="hljs-keyword">where</span> goods.shelf_id<span class="hljs-operator">=</span>shelf.shelf_id <span class="hljs-keyword">and</span> goods.goods_num<span class="hljs-operator">=</span>shelf.goods_num_on_shelf</code></pre></div><p>也可以只在goods表中查</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name<span class="hljs-keyword">from</span> goods g1<span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span><span class="hljs-operator">*</span><span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> shelf.id<span class="hljs-operator">=</span>e1.shelf.id <span class="hljs-keyword">and</span>goods_name<span class="hljs-operator">&amp;</span>lt;<span class="hljs-operator">&amp;</span>gt;e1.goods_name);</code></pre></div><p>5.聚合查询</p><p>有10种以上商品的货架，以及拥有的商品种类数</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> shelf_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">from</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> shef_id<span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&amp;</span>gt; <span class="hljs-number">10</span>;</code></pre></div><h4 id="powerdesigner-绘制er图">3.1 PowerDesigner 绘制ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004326633367_468_image-20220415222750452.png" alt="image-20220415222750452"><figcaption aria-hidden="true">image-20220415222750452</figcaption></figure><h4 id="转为关系模型">3.2 转为关系模型</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004327928426_899_image-20220415222820109.png" alt="image-20220415222820109"><figcaption aria-hidden="true">image-20220415222820109</figcaption></figure><h4 id="生成sql语句">3.3 生成SQL语句</h4><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* DBMS name:      Sybase SQL Anywhere 12                       */</span><span class="hljs-comment">/* Created on:     2022/4/15 22:28:49                           */</span><span class="hljs-comment">/*==============================================================*/</span>if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY_CUSTOMER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY_CUSTOMER<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_GOODS_ON_SHELF'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_GOODS_ON_SHELF<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL_EMPLOYEE'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL_EMPLOYEE<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY2_SUPPLIER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY2_SUPPLIER<span class="hljs-keyword">end</span> if;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> buy;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> customer.customer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> customer;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> employee.emplyer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> employee;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.on_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.goods_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> goods;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> sell;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> shelf.shelf_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> shelf;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supplier.supplier_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supplier;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supply;<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: buy                                                   */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_PK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index buy_PK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_FK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy_FK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy2_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy2_FK <span class="hljs-keyword">on</span> buy (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: customer                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: customer_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index customer_PK <span class="hljs-keyword">on</span> customer (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: employee                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: emplyer_PK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index emplyer_PK <span class="hljs-keyword">on</span> employee (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: goods                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: goods_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index goods_PK <span class="hljs-keyword">on</span> goods (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: on_FK                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index on_FK <span class="hljs-keyword">on</span> goods (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: sell                                                  */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_PK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index sell_PK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell_FK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell2_FK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell2_FK <span class="hljs-keyword">on</span> sell (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: shelf                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: shelf_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index shelf_PK <span class="hljs-keyword">on</span> shelf (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supplier                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supplier_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index supplier_PK <span class="hljs-keyword">on</span> supplier (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supply                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_PK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index supply_PK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>,sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_FK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply_FK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply2_FK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply2_FK <span class="hljs-keyword">on</span> supply (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY2_SUPPLIER <span class="hljs-keyword">foreign</span> key (sp_id)      <span class="hljs-keyword">references</span> supplier (sp_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div><h4 id="分析差异">4.1 分析差异</h4><p>有差异。PowerDesigner会事先判断外键约束、索引以及表本身是否存在，若存在会删除。同时也会对表建立索引。但是基本逻辑是一致的，在总体的设计上不会造成影响。</p><h4 id="语句特点">4.2 语句特点</h4><p>从4.1的分析可以看出，PowerDesigner生成的语句更严谨。当然，语句顺序比如外键约束声明的位置也有不同。这些附加语句的作用是防止特殊情况的发生导致无法正常建立表。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ucore Lab0 on Apple Silicon Mac</title>
    <link href="/posts/34966/"/>
    <url>/posts/34966/</url>
    
    <content type="html"><![CDATA[<h2 id="ucore-lab0-on-apple-silicon-mac">Ucore Lab0 on Apple SiliconMac</h2><h3 id="介绍">介绍</h3><p>M1芯片是2020年之后推出的全新适配于Macbook的Arm64芯片。因为底层的指令集与x86_64不同，因此面临着很多兼容性的问题。在ucore的编译，运行和调试的环境配置中也因此踩了一些坑。当然最终得以能够优雅的在这台具有独特架构的PC上探索实现操作系统的魅力。</p><p>现在将其记录下来，以供参考。</p><h3 id="qemu安装">qemu安装</h3><p>qemu是非常成熟的虚拟化解决方案，通过软件的方式逐条将目标文件的二进制指令翻译成目标架构支持的二进制指令，虽然效率不高，但是使用方便，对M1芯片支持也比较完善，足够用来调试ucore了。</p><p>指导书中针对linux给出了使用包管理工具的安装方案。在mac上这个过程也同样比较简单。安装<code>homebrew</code>包管理工具后只需要</p><div class="code-wrapper"><pre><code class="hljs shell">brew install qemu</code></pre></div><p>即可。当然为了保证是最新版本，安装之前可以更新一下homebrew：<code>brew update</code>。</p><h3 id="i386-elf-gcc和i386-elf-gdb安装">i386-elf-gcc和i386-elf-gdb安装</h3><p>按照网上的解决方案，我安装了<code>macport</code>，并</p><div class="code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">sudo</span> <span class="hljs-keyword">port</span> -v selfupdatesudo <span class="hljs-keyword">port</span> install i386-elf-gcc</code></pre></div><p>但是发现它安装过程中构建失败了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231400206876_223_image-20221003224714488.png" alt="image-20221003224714488"><figcaption aria-hidden="true">image-20221003224714488</figcaption></figure><p>查看发现果然是架构问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231401953713_177_image-20221003224809467.png" alt="image-20221003224809467"><figcaption aria-hidden="true">image-20221003224809467</figcaption></figure><p>查看报错信息。谷歌后从<a href="https://github.com/riscv-collab/riscv-gnu-toolchain/issues/800">githubissue</a>中得知是有支持apple silicon版本的最新i386-elf-gcc的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231403860364_202_image-20221003225239013.png" alt="image-20221003225239013"><figcaption aria-hidden="true">image-20221003225239013</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231405125684_549_image-20221003225245971.png" alt="image-20221003225245971"><figcaption aria-hidden="true">image-20221003225245971</figcaption></figure><p>有希望！但是按官网命令安装问题也没有解决，所谓补丁也不起效。后来尝试用homebrew安装：<code>brew install i386-elf-gdb</code>，但没有安装成功。提示</p><div class="code-wrapper"><pre><code class="hljs awk">fatal: not <span class="hljs-keyword">in</span> a git directory Error: Command failed with <span class="hljs-keyword">exit</span> <span class="hljs-number">128</span>: git</code></pre></div><p>又经过一番谷歌找到了<a href="https://www.jianshu.com/p/07243d214abd">解决方法</a>。执行</p><div class="code-wrapper"><pre><code class="hljs shell">git config --global --add safe.directory 报错信息中homebrew-core路径git config --global --add safe.directory 报错信息中homebrew-cask路径</code></pre></div><p>即可。</p><p>然后需要添加一下环境变量。</p><p>这时尝试qemu生成ucore的dmg，发现提示<code>i386-elf-gcc</code>找不到。这才注意到通过homebrew下载的是<code>x86_64-elf-gcc</code>。</p><p>经过搜索，得知在make时需要添加<code>make GCCPREFIX=x86_64-elf-</code>指定交叉编译工具。这时可以高兴的看到控制台闪烁，执行也很顺利。</p><h3 id="执行">执行</h3><p>然后<code>make qemu</code>执行的过程也比较顺利。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231407841829_266_image-20221003230427926.png" alt="image-20221003230427926"><figcaption aria-hidden="true">image-20221003230427926</figcaption></figure><h3 id="调试">调试</h3><p>首先，ARM架构的Mac目前是不能使用<code>gdb</code>进行程序的调试的，默认的调试工具是<code>lldb</code>。然而经过查阅，对于交叉编译反而可以使用实验中对应的<code>gdb</code>工具：运行<code>brew install i386-elf-gdb</code>安装即可。</p><p>以调试lab1中的BIOS的执行为例。</p><p>下面的过程与指导书中“使用远程调试”部分类似。除此之外，额外将运行的汇编指令保存在q.log中。</p><p>在一个终端先执行：</p><div class="code-wrapper"><pre><code class="hljs shell">qemu-system-i386 -S -s -d in_asm -D bin/q.log -monitor stdio -hda bin/ucore.img</code></pre></div><p>后在另一个终端执行:</p><div class="code-wrapper"><pre><code class="hljs shell">i386-elf-gdb</code></pre></div><p>进入gdb调试界面。</p><div class="code-wrapper"><pre><code class="hljs shell">(gdb) file bin/kernelReading symbols from bin/kernel...(gdb) target remote :1234Remote debugging using :12340x0000fff0 in ?? ()</code></pre></div><p>上述的过程相比原来<code>makrfile</code>中提供的<code>make debug</code>主要有两个好处：一是能够重定向到<code>q.log</code>方便进行对比；二是可以绕开<code>make</code>中的<code>TERMINAL:=gnome-terminal</code>(<code>gnome-terminal</code>仅在linux下可使用)</p><p>查看 CS:EIP 由于此时在实际模式下 CPU 在加电后执行的第一条指令的地址为0xf000:0xfff0 =&gt; 0xffff0</p><div class="code-wrapper"><pre><code class="hljs shell">(gdb) x/i $cs0xf000:add    %al,(%eax)(gdb) x/i $eip0xfff0:add    %al,(%eax)</code></pre></div><p>再来看看这个地址的指令是什么 </p><div class="code-wrapper"><pre><code class="hljs shell">(gdb) x/2i 0xffff0   0xffff0:ljmp   $0x3630,$0xf000e05b   0xffff7:das</code></pre></div><p></p><p>可以看到 第一条指令执行完以后 会跳转到<code>0xf000e05b</code>也就是说BIOS 开始的地址是 <code>0xfe05b</code>。</p><p>打上断点</p><div class="code-wrapper"><pre><code class="hljs shell">(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.Breakpoint 1, 0x00007c00 in ?? ()</code></pre></div><p>一开始为了方便后续在终端中配置了永久别名：</p><div class="code-wrapper"><pre><code class="hljs shell">alias makeq="make GCCPREFIX=x86_64-elf-"</code></pre></div><p>当然更优雅的方法其实是修改make中的宏：</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># try to infer the correct GCCPREFX</span><span class="hljs-keyword">ifndef</span> GCCPREFIX<span class="hljs-comment"># GCCPREFIX := $(shell if i386-elf-objdump -i 2&gt;&amp;1 | </span><span class="hljs-comment">#...comment the original shell function</span><span class="hljs-comment"># echo "***" 1&gt;&amp;2; exit 1; fi)</span>GCCPREFIX := x86_64-elf-<span class="hljs-keyword">endif</span></code></pre></div><p>但是，由于<code>makefile</code>里默认认为调试工具一定叫<code>gdb</code>，且mac里没有gdb对应的command，因此这时候用永久别名是比较合适的。</p><div class="code-wrapper"><pre><code class="hljs shell">alias gdb="i386-elf-gdb"</code></pre></div><p>这时候也可以修改make来达到自动化调试的目的：</p><div class="code-wrapper"><pre><code class="hljs makefile">WORKING_DIR=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(QEMU)</span> -S -s -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null &amp;<span class="hljs-variable">$(V)</span>sleep 2<span class="hljs-variable">$(V)</span> osascript -e 'tell application <span class="hljs-string">"Terminal"</span> to do script <span class="hljs-string">"cd <span class="hljs-variable">$(WORKING_DIR)</span>; gdb -q -x tools/gdbinit"</span>'</code></pre></div><p>其中最后一句是为了产生一个在当前工作目录的新终端。</p><h3 id="总结">总结</h3><p>前前后后也花了相当长的时间来应对环境的不同。后续的内容其实更吸引着我们去深入探索。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能导论</title>
    <link href="/posts/46759/"/>
    <url>/posts/46759/</url>
    
    <content type="html"><![CDATA[<p>人工智能导论</p><p>逻辑推理</p><p align="center"><img alt="image-20220831205211237" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221103884501_923_image-20220831205211237.png" width="50%"></p><p align="center"><img alt="image-20220831205344502" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221111633086_904_image-20220831205344502.png" width="50%"></p><p align="center"><img alt="image-20220831205448441" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221120315099_386_image-20220831205448441.png" width="50%"></p><p>任意对析取，存在对合取都是蕴含关系，分开的条件强于合起来的（举个例子就明白了）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221127063207_401_image-20220831210345470.png" alt="image-20220831210345470"><figcaption aria-hidden="true">image-20220831210345470</figcaption></figure><p align="center"><img alt="image-20220831210404798" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221128281126_946_image-20220831210404798.png" width="50%"></p><p>只与新加入的直接相关</p><p align="center"><img alt="image-20220831211022710" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221129758335_145_image-20220831211022710.png" width="50%"></p><p align="center"><img alt="image-20220831211029655" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221130984768_647_image-20220831211029655.png" width="50%"></p><p align="center"><img alt="image-20220831211350521" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221132416550_481_image-20220831211350521.png" width="50%"></p><p>因果分析三层次：关联，介入，反事实</p><p>因果图三种形式：链，分连，汇连（chain，fork，collider)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221134366409_448_image-20220831212134887.png" alt="image-20220831212134887"><figcaption aria-hidden="true">image-20220831212134887</figcaption></figure><p>做法：联合概率分布由每个节点与其父节点之间的条件概率得出。根节点是外生变量，其他的是内生</p><hr><p align="center"><img alt="image-20220831212713182" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221135899101_136_image-20220831212713182.png" width="50%"></p><p>深搜可能会陷入无限循环</p><p align="center"><img alt="image-20220831213452142" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221137133557_194_image-20220831213452142.png" width="50%"></p><p align="center"><img alt="image-20220831213527818" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221139012135_477_image-20220831213527818.png" width="50%"></p><p align="center"><img alt="image-20220831213624058" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221140593318_530_image-20220831213624058.png" width="50%"></p><p>有环路的图会使贪婪最佳优先算法不完备。</p><p>判断：启发函数满足可容性则一定能保证算法最优性x</p><p>树搜索是这样法，图不一定</p><p>判断：启发函数恒为0一定满足可容性x</p><p>启发函数不一定要是正数。</p><p>满足一致性可保证A*搜索算法最优</p><p>启发函数不会过高估计从当前节点到目标结点之间的实际代价。x</p><p>满足可容性的启发函数才有这样的性质。</p><p>MinMax的适用条件：两人博弈，信息透明，零和博弈</p><p align="center"><img alt="image-20220831215141822" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221142369023_436_image-20220831215141822.png" width="50%"></p><p>注意，没有规定必须要公平。D违反了零和博弈</p><p align="center"><img alt="image-20220831220640110" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221144124086_686_image-20220831220640110.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221145565187_669_image-20220831220659274.png" alt="image-20220831220659274"><figcaption aria-hidden="true">image-20220831220659274</figcaption></figure><p>这个做法是不对的，根据课本上的过程，A*算法会考虑所有可达的评价函数，每次从边缘集合拓展的节点并非总是当前节点的后继节点。fn评价函数是唯一标准如果发现有更小的，会倒回去。</p><p align="center"><img alt="image-20220831220818630" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221146871853_388_image-20220831220818630.png" width="50%"></p><p>而且贪婪最佳优先搜索也是启发式算法，优先选择启发函数最小的后继节点拓展。</p><p align="center"><img alt="image-20220831222502968" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221148285550_794_image-20220831222502968.png" width="50%"></p><p align="center"><img alt="image-20220831222848019" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221149618933_986_image-20220831222848019.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221152879301_392_image-20220831223950629.png" alt="image-20220831223950629"><figcaption aria-hidden="true">image-20220831223950629</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221155537145_635_image-20220831223959591.png" alt="image-20220831223959591"><figcaption aria-hidden="true">image-20220831223959591</figcaption></figure><p>记住蒙特卡洛树UCB的公式，明白反向传播的过程。 <span class="math display">\[U C B=\bar{X}_j+C \times \sqrt{\frac{2 \ln n}{n_j}}\]</span> <strong>上限置信区间</strong> <strong>(Upper Confidence Bound,UCB)</strong></p><hr><p>监督学习中经验风险和期望风险的概念</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221157700882_480_image-20220831224734326.png" alt="image-20220831224734326"><figcaption aria-hidden="true">image-20220831224734326</figcaption></figure><p align="center"><img alt="image-20220831224903093" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221159350035_550_image-20220831224903093.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221201393460_662_image-20220831224941130.png" alt="image-20220831224941130"><figcaption aria-hidden="true">image-20220831224941130</figcaption></figure><p align="center"><img alt="image-20220831224941224" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221201393460_662_image-20220831224941130.png" width="50%"></p><p>​常用的正则项方法包括L1正则项和L2正则项：其中L1使权重稀疏，L2使权重平滑。一句话总结就是：L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。</p><p>怎么记：1比2小，生成的特征少</p><p align="center"><img alt="image-20220831225522763" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221204366868_381_image-20220831225522763.png" width="50%"></p><p align="center"><img alt="image-20220831225535198" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221206081717_192_image-20220831225535198.png" width="50%"></p><p>考法：判断哪些算法是判别模型，哪些是生成模型。大部分典型机器学习算法都是判别模型。贝叶斯方法，隐马科代夫链式生成模型</p><p align="center"><img alt="image-20220831230142515" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221207951204_832_image-20220831230142515.png" width="50%"></p><p>信息熵小，信息稳定，单一，纯度高；信息熵大，信息不稳定，纯度低。</p><p align="center"><img alt="image-20220831230645025" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221209692239_698_image-20220831230645025.png" width="50%"></p><p>决策树是在干什么呢？选择最佳属性对样本进行划分，得到最大的“纯度”</p><p>同时注意决策树是有监督学习。</p><p><strong>线性区别分析</strong> <strong>(</strong>linear discriminantanalysis, LDA<strong>)</strong></p><p>线性判别分析的核心：类内方差小，类间间隔大。“君子和而不同，小人同而不和”，是一种降为方法</p><p>#请判断下面说法是否正确：线性判别分析是在最大化类间方差和类内方差的比值(√)</p><p>#在一个监督学习任务中，每个数据样本有4个属性和一个类别标签，每种属性分别有3、2、2和2种可能的取值，类别标签有3种不同的取值。请问可能有多少种不同的样本？（注意，并不是在某个数据集中最多有多少种不同的样本，而是考虑所有可能的样本)()</p><p>乘起来就可以。72</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221224036219_753_image-20220831232017771.png" alt="image-20220831232017771"><figcaption aria-hidden="true">image-20220831232017771</figcaption></figure><p>记住就可以</p><p>重点：</p><p align="center"><img alt="image-20220831231843333" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221225672479_673_image-20220831231843333.png" width="50%"></p><p align="center"><img alt="image-20220831232347725" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221227106679_945_image-20220831232347725.png" width="50%"></p><p align="center"><img alt="image-20220831233241581" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221229085668_716_image-20220831233241581.png" width="50%"></p><p>ada boosting</p><p><span class="math inline">\(Z_m=\sum_{i=1}^N w_{m, i}\mathrm{e}^{-\alpha_m y G_i\left(x_i\right) \text { 。 }}\)</span>可以把对第 <span class="math inline">\(i\)</span>个训练样本更新后的分布权重写为如下分段函数形式: <span class="math display">\[w_{m+1, i}= \begin{cases}\frac{w_{m, i}}{Z_m} \mathrm{e}^{-\alpha_m},&amp;amp; G_m\left(x_i\right)=y_i \\ \frac{w_{m, i}}{Z_m}\mathrm{e}^{\alpha_m}, &amp;amp; G_m\left(x_i\right) \neq y_i\end{cases}\]</span> 可见, 如果第 <span class="math inline">\(i\)</span>个训练样本无法被第 <span class="math inline">\(m\)</span> 个弱分类器<span class="math inline">\(G_m(x)\)</span> 分类成功,则需要增大该样本权重, 否则减少该样本权重。这样, 被错误分类样本会在训练第 <span class="math inline">\(m+1\)</span> 个弱分类器 <span class="math inline">\(G_{m+1}(x)\)</span> 时被 “重点关注”。</p><p>在第 <span class="math inline">\(m\)</span> 次迭代中, Ada Boosting总是趋向于将具有<font color="Apricot">最小误差的学习模型</font>（err最小的）选做本轮次生成的弱分类器<span class="math inline">\(G_m\)</span>, 促使累积误差快速下降。</p><hr><p>无监督学习</p><p>K-means往往找都是一个局部最优</p><p>聚类迭代满足如下任意一个条件，则聚类停止：</p><p>•已经达到了迭代次数上限</p><p>•前后两次迭代中，聚类质心基本保持不变</p><p align="center"><img alt="image-20220831234829916" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221230319204_134_image-20220831234829916.png" width="50%"></p><p align="center"><img alt="image-20220831234856133" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221232576761_180_image-20220831234856133.png" width="50%"></p><p>应当是尽量“不相关”</p><p>•<strong>主成分分析是将𝑛维特征数据映射到𝑙维空间</strong>(<strong>n≫l</strong>)<strong>，去除原始数据之间的冗余性（通过去除相关性手段达到这一目的）。</strong>每一维的样本方差尽可能大</p><p>•<strong>特征人脸方法是一种应用主成份分析来实现人脸图像降维的方法，其本质是用一种称为“特征人脸(eigenface)”的特征向量（而不是像素）按照线性组合形式来表达每一张原始人脸图像，进而实现人脸识别。</strong></p><p>每一个特征人脸的维数与原始人脸图像的维数一样大x 会变小</p><p>特征人脸之间的相关度要尽可能大√</p><p>为了使算法更高效采用了奇异值分解的方法</p><hr><p align="center"><img alt="image-20220901002546496" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221234267125_288_image-20220901002546496.png" width="50%"></p><p>批量梯度下降算法是在整个训练集上计算损失误差C()。如果数据集较大，则会因内存容量不足而无法完成，同时这一方法收敛速度较慢。随机梯度下降算法是使用训练集中每个训练样本计算所得C()来分别更新参数。虽然，随机梯度下降收敛速度会快一些，但可能出现所优化目标函数震荡不稳定现象。</p><p align="center"><img alt="image-20220901004646914" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221236054772_109_image-20220901004646914.png" width="50%"></p><p><span class="math display">\[f(x)=\frac{1}{1+\mathrm{e}^{-x}}\]</span> 选取 sigmoid函数作为激活函数, 因为其具有如下优点: (1)概率形式输出, sigmoid函数值域为 <span class="math inline">\((0,1)\)</span>, 因此使 sigmoid函数输出可视为概率值; (2) 单调递增, sigmoid函数对输人 <span class="math inline">\(x\)</span> 取值范围没有限制, 但当 <span class="math inline">\(x\)</span> 大 于一定值后, 函数输出无限趋近于 1 ,而小于一定数值后, 函数输出无限趋近于 0 , 特别地, 当 <span class="math inline">\(x=0\)</span> 时, 函数输出为 <span class="math inline">\(0.5\)</span>; (3) 非线性变化, <span class="math inline">\(x\)</span> 取 值在 0 附近时,函数输出值的变化幅度比较大 (函数值变化陡峭), 意味 着函数在 0附近容易被激活且是非线性变化, 当 <span class="math inline">\(x\)</span>取值很大或很小时, 函数输出值几乎不变, 这是基于概率的一种认识与需要。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012351440"><figcaption aria-hidden="true">image-20220901012351440</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012412558"><figcaption aria-hidden="true">image-20220901012412558</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221245033698_681_image-20220901012437001.png" alt="image-20220901012437001"><figcaption aria-hidden="true">image-20220901012437001</figcaption></figure><p align="center"><img alt="image-20220901012512732" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221246660573_722_image-20220901012512732.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221248004240_176_image-20220901012559806.png" alt="image-20220901012559806"><figcaption aria-hidden="true">image-20220901012559806</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221249466398_422_image-20220901012619080.png" alt="image-20220901012619080"><figcaption aria-hidden="true">image-20220901012619080</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221251026834_417_image-20220901012639822.png" alt="image-20220901012639822"><figcaption aria-hidden="true">image-20220901012639822</figcaption></figure><hr><p>强化学习的特征</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221252634813_271_image-20220901082606079.png" alt="image-20220901082606079"><figcaption aria-hidden="true">image-20220901082606079</figcaption></figure><p align="center"><img alt="image-20220901082635583" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221254174712_770_image-20220901082635583.png" width="50%"></p><p>一个随机过程实际上是一列随时间变化的随机变量。当时间是离散 量时,一个随机过程可以表示为 <span class="math inline">\(\left\{X_t\right\}_{t=0,1,2, \cdots}\)</span>,这里每个 <span class="math inline">\(X_t\)</span> 都是一个随机变量,这被称为离散随机过程。为了方便分析和求解,通常要求通过合理的问题定义使得一个随机过程满足马尔可夫性 (Markovproperty), 即满足如下性质: <span class="math display">\[P\left(X_{t+1}=x_{t+1} \mid X_0=x_0, X_1=x_1, \cdots,X_t=x_t\right)=P\left(X_{t+1}=x_{t+1} \mid X_t=x_t\right) \text {(式7.1) }\]</span> 这个公式的直观解释为: 下一刻的状态 <span class="math inline">\(X_{t+1}\)</span> 只由当前状态 <span class="math inline">\(X_t\)</span> 决定(而与更早的所有状态均无关)。满足马尔可夫性的离散随机过程被称为马尔可夫链 (Markov chain)。</p><p align="center"><img alt="image-20220901083631487" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221255863567_937_image-20220901083631487.png" width="50%"></p><ul><li>动作 <span class="math inline">\(-\)</span> 价值函数 (action-valuefunction): <span class="math inline">\(q: S \times A \mapsto\mathbb{R}\)</span>, 其中 <span class="math inline">\(q_\pi(s,a)=\mathbb{E}_\pi\left[G_t \mid S_t=s, A_t=a\right]\)</span>,表示智能体在时刻 <span class="math inline">\(t\)</span> 处于状态 <span class="math inline">\(s\)</span> 时, 选择 了动作 <span class="math inline">\(a\)</span> 后，在 <span class="math inline">\(t\)</span> 时刻后根据策略 <span class="math inline">\(\pi\)</span> 采取行动所获得回报的期望。价值函数和动作 <span class="math inline">\(-\)</span>价值函数反映了智能体在某一策略下所对应状态 序列获得回报的期望,它比回报本身更加准确地刻画了智能体的目标。 注意, 价值函数和动作 <span class="math inline">\(-\)</span> 价值函数的定义之所以能够成立,离不开决策 过程所具有的马尔可夫性, 即当位于当前状态 <span class="math inline">\(s\)</span> 时, 无论当前时刻 <span class="math inline">\(t\)</span> 的取值是多少,一个策略回报值的期望是一定的 (当前状态只与前一状态有关，与时间无关）。（所以不是<span class="math inline">\(q_\pi(s,a,t)\)</span>） 至此, 强化学习可以转化为一个策略学习问题, 其定义为:给定一 个马尔可夫决策过程 <span class="math inline">\(M D P=(S, A, P, R,\gamma)\)</span>, 学习一个最优策略 <span class="math inline">\(\pi^*\)</span>, 对任 意 <span class="math inline">\(s \in S\)</span> 使得 <span class="math inline">\(V_{\pi^*}(s)\)</span> 值最大。</li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221257340897_656_image-20220901083736614.png" alt="image-20220901083736614"><figcaption aria-hidden="true">image-20220901083736614</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221258558310_351_image-20220901083803818.png" alt="image-20220901083803818"><figcaption aria-hidden="true">image-20220901083803818</figcaption></figure><hr><p align="center"><img alt="image-20220901090535698" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221300893504_791_image-20220901090535698.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221302843487_985_image-20220901090816141.png" alt="image-20220901090816141"><figcaption aria-hidden="true">image-20220901090816141</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理习题讲解部分勘误</title>
    <link href="/posts/23086/"/>
    <url>/posts/23086/</url>
    
    <content type="html"><![CDATA[<p>4.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150014727108_816_image-20220822231146713.png" alt="image-20220822231146713"><figcaption aria-hidden="true">image-20220822231146713</figcaption></figure><p>流水线周期取决于耗时最长的阶段。此处忘记了IF的时钟周期仍为150ps。</p><p>5.6</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150016592317_276_image-20220821230253484.png" alt="image-20220821230253484"><figcaption aria-hidden="true">image-20220821230253484</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150018066044_526_image-20220821230543233.png" alt="image-20220821230543233"><figcaption aria-hidden="true">image-20220821230543233</figcaption></figure><p>第三问的讲解如上图所示。此处p1和p2的CPI计算有误。原因是未考虑指令缺失造成的代价。<span class="math display">\[CPI=1+平均每条指令阻塞始终周期数\\=1+指令缺失阻塞时钟周期数+数据缺失阻塞时钟周期数\]</span></p><p><span class="math display">\[指令缺失阻塞时钟周期数=\texttt{cache}缺失率*指令缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p><span class="math display">\[数据缺失阻塞时钟周期数=\texttt{cache}缺失率*访存指令占比*数据缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p>得到两个CPI分别约为12.54和7.35</p><p>5.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150019552299_178_image-20220822230445847.png" alt="image-20220822230445847"><figcaption aria-hidden="true">image-20220822230445847</figcaption></figure><p>第三小问关于反置页表。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150020954753_868_image-20220822231114457.png" alt="image-20220822231114457"><figcaption aria-hidden="true">image-20220822231114457</figcaption></figure><p>在反置页表中是为每一个物理块设置一个页表项的，视频中也有所阐述,但在计算时依旧是使用的虚拟地址。此处应为$$ PTE= \</p><span class="math display">\[\begin{aligned}&amp;=\frac{\text { Size of physical memory }}{\text { Page size }}\\&amp;=\frac{16 \mathrm{GiB}}{4 \mathrm{KiB}} \\&amp;=\frac{2^{34}}{2^{12}} \\&amp;=2^{22}\end{aligned}\]</span><p>$$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
