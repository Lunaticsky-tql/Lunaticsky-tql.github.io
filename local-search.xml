<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>信息检索_系统评价</title>
    <link href="/posts/23422/"/>
    <url>/posts/23422/</url>
    
    <content type="html"><![CDATA[<h1 id="信息检索_系统评价">信息检索_系统评价</h1><h2 id="总思路">总思路</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181425241957_651_image-20221102140305383.png" alt="image-20221102140305383"><figcaption aria-hidden="true">image-20221102140305383</figcaption></figure><h2 id="单查询">单查询</h2><h3 id="无序检索结果集合的评价">无序检索结果集合的评价</h3><details><summary>回顾</summary><p>查准率 (Precision) : <span class="math inline">\(P=\frac{T P}{T P+FP}\)</span> 。预测正确的正例数据占预测为正例数据的比例。</p><p>召回率 (Recall) : <span class="math inline">\(R=\frac{TP}{TP+FN}\)</span> 。预测为正例的数据占实际为正例数据的比例。</p>F1值 (F1 score) : <span class="math display">\[F1=\frac{2}{\frac{1}{P}+\frac{1}{R}}=\frac{2 * P * R}{P+R}\nonumber\]</span></details><h3 id="有序检索结果集合的评价">有序检索结果集合的评价</h3><h4 id="p-r曲线的例子">P-R曲线的例子</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181427482098_652_image-20221102141151261.png" alt="image-20221102141151261"><figcaption aria-hidden="true">image-20221102141151261</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181431710114_302_image-20221102141322869.png" alt="image-20221102141322869" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181432975281_362_image-20221102142019252.png" alt="image-20221102142019252"><figcaption aria-hidden="true">image-20221102142019252</figcaption></figure><h4 id="平均正确率ap">平均正确率AP</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181435795246_414_image-20221102142247895.png" alt="image-20221102142247895"><figcaption aria-hidden="true">image-20221102142247895</figcaption></figure><h4 id="precisionn">Precision@N</h4><p>Precision@N：在第N个位置上的正确率，对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页的结果，因此，P@10，P@20对大规模搜索引擎来说是很好的评价指标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20221102181437971719_189_image-20221102142715051.png" alt="image-20221102142715051"><figcaption aria-hidden="true">image-20221102142715051</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网-传输层</title>
    <link href="/posts/6389/"/>
    <url>/posts/6389/</url>
    
    <content type="html"><![CDATA[<h1 id="寄网-传输层">寄网-传输层</h1><h2 id="udp">UDP</h2><h3 id="特点">特点</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112829451012_857_image-20221019101254797.png" alt="image-20221019101254797"><figcaption aria-hidden="true">image-20221019101254797</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112833830874_553_image-20221019102904831.png" alt="image-20221019102904831"><figcaption aria-hidden="true">image-20221019102904831</figcaption></figure><blockquote><p>D</p></blockquote><h3 id="复用分用">复用分用</h3><p class="note note-info"></p><p>复用就是多个应用层进程汇聚成一个传输层进程（八车道变一车道）</p><p>分用就是反过来，传输层的多个进程相应的通向多个应用层进程（单车道变八车道）</p>通常复用针对发送，分用针对接收。<p></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112836012813_910_image-20221019101337529.png" alt="image-20221019101337529"><figcaption aria-hidden="true">image-20221019101337529</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112841055514_461_image-20221019104559718.png" alt="image-20221019104559718"> &gt; B</p><h3 id="报文结构和校验">报文结构和校验</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112842251316_209_image-20221019102648654.png" alt="image-20221019102648654"><figcaption aria-hidden="true">image-20221019102648654</figcaption></figure><p><font color="Apricot">算校验和的时候别忘了进位</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112844925605_254_image-20221019101834126.png" alt="image-20221019101834126"><figcaption aria-hidden="true">image-20221019101834126</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112847899571_967_image-20221019102038599.png" alt="image-20221019102038599"><figcaption aria-hidden="true">image-20221019102038599</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112851148719_202_image-20221019101153691.png" alt="image-20221019101153691"><figcaption aria-hidden="true">image-20221019101153691</figcaption></figure><blockquote><p>B：长度包含头部，但不包含伪首部</p></blockquote><p>最重要的“为什么”部分：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112852360163_657_image-20221019102522221.png" alt="image-20221019102522221"><figcaption aria-hidden="true">image-20221019102522221</figcaption></figure><h3 id="应用">应用</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112854071267_984_image-20221019103901732.png" alt="image-20221019103901732"><figcaption aria-hidden="true">image-20221019103901732</figcaption></figure><h2 id="可靠数据传输">可靠数据传输</h2><h3 id="目标">目标</h3><p>左边是希望对上层达到的抽象，右边是实际的情况。<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112856140137_289_image-20221019161257579.png" alt="image-20221019161257579"></p><h3 id="设计思路">设计思路</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112857352548_948_image-20221019162323429.png" alt="image-20221019162323429"><figcaption aria-hidden="true">image-20221019162323429</figcaption></figure><h4 id="rdt1.0">rdt1.0</h4><p>考虑最简单的情况，即底层信道是完全可靠的：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112900136029_437_image-20221019162337067.png" alt="image-20221019162337067"><figcaption aria-hidden="true">image-20221019162337067</figcaption></figure><p>发送，打包/拆包，交给下层发送</p><h4 id="rdt2.0">rdt2.0</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112902564743_320_image-20221019163254576.png" alt="image-20221019163254576"><figcaption aria-hidden="true">image-20221019163254576</figcaption></figure><p class="note note-secondary">缩写：ACKnowledge character；Not AcKnowledge character肯定确认和否定确认 为简便直白，对于package的翻译，用包代替分组</p><h5 id="发送端">发送端：</h5><p>仅当接收到ACK并离开该状态时才能发生rdt_send()事件。因此，在发送方确信接收方已正确接收当前分组之前肯定不会发送新数据。由于这种行为，rdt2.0这样的协议被称为停等(stop-and-wait)协议。</p><h5 id="接收端">接收端：</h5><p>上面表示如果packet受损发送NAK，下面表示如果package正确向上层传送数据并发送ACK</p><h5 id="存在的问题">存在的问题：</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112906743219_237_image-20221019164147811.png" alt="image-20221019164147811"><figcaption aria-hidden="true">image-20221019164147811</figcaption></figure><h4 id="rdt2.1">rdt2.1</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112909502820_948_image-20221019165240189.png" alt="image-20221019165240189"><figcaption aria-hidden="true">image-20221019165240189</figcaption></figure><p>答案是只需要1bit。因为如果发送端交替发送01包，接收端只需要知道收到的包是最近收到的(序号没变)还是新的(序号变了)。</p><p>按照这样的思路状态机如下：</p><p>发送端就是每当收到正确且是ACK的包的时候就准备发下一个，否则收到的是受损包或NAK就重发。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112911602268_247_image-20221019170813474.png" alt="image-20221019170813474"><figcaption aria-hidden="true">image-20221019170813474</figcaption></figure><p>接收端：等待接受状态上面部分是发现包受损发NAK且等待，发现和上一次收到的包重复就发ACK(以让发送端发下一个包)，然后等待，也是什么也不做，不向下层传输信息(丢数据)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112913795898_163_image-20221019171058350.png" alt="image-20221019171058350"><figcaption aria-hidden="true">image-20221019171058350</figcaption></figure><p>还有，接受端收到受损包其实不需要发NAK，再发一次上一次正确接收的ACK，发送端发现收到了对同一个包的两个ACK就知道接收端没正确接收这个包。</p><p>这其实就是rdt2.2</p><h4 id="rdt2.2">rdt2.2</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112917959019_890_image-20221019171614203.png" alt="image-20221019171614203"><figcaption aria-hidden="true">image-20221019171614203</figcaption></figure><p>在前面的基础上，看懂这种情况下的状态机就不再困难了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112919789535_361_image-20221019183702448.png" alt="image-20221019183702448"><figcaption aria-hidden="true">image-20221019183702448</figcaption></figure><p>接收端的主要变化是：在ACk中添加最后收到的包的序列和号，对应<code>make_pkt第二个参数</code>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112923670147_103_image-20221019184436444.png" alt="image-20221019184436444"><figcaption aria-hidden="true">image-20221019184436444</figcaption></figure><h4 id="rdt3.0">rdt3.0</h4><h5 id="方案">方案：</h5><p>解决的问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112929819897_715_image-20221019185155113.png" alt="image-20221019185155113"><figcaption aria-hidden="true">image-20221019185155113</figcaption></figure><p>添加了计时器的发送端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112931855615_706_image-20221019185225064.png" alt="image-20221019185225064"><figcaption aria-hidden="true">image-20221019185225064</figcaption></figure><p>接收端不需要改变。因为在2.3中已经实现了判断重复并丢弃了。</p><h5 id="实例">实例</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112933551292_417_image-20221019185429262.png" alt="image-20221019185429262"><figcaption aria-hidden="true">image-20221019185429262</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112937343229_422_image-20221019185440433.png" alt="image-20221019185440433"><figcaption aria-hidden="true">image-20221019185440433</figcaption></figure><p class="note note-primary">失序问题(二义性)是不能解决的，如下图所示</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112939258493_256_image-20221026092203952.png" alt="image-20221026092203952" width="67%" height="67%"></p><p>如果是上述情况，接收端不能辨别是重传的pkt1还是想要的pkt1.</p><p class="note note-primary">怎么解决？wifi用的是停等协议(和rdt3.0一样)，加入标志位表明是否是重传的包。如果接收端发现是接受过的，丢弃。但对于tcp性能优化后，就需要增加序号字段宽度</p><h3 id="流水线可靠数据传输">流水线可靠数据传输</h3><h4 id="停等协议的性能问题">停等协议的性能问题</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112941284045_123_image-20221019185844985.png" alt="image-20221019185844985"><figcaption aria-hidden="true">image-20221019185844985</figcaption></figure><p>发送时间相比传输时间是极短的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112942732666_577_image-20221019185852269.png" alt="image-20221019185852269"><figcaption aria-hidden="true">image-20221019185852269</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112946369564_281_image-20221019185917983.png" alt="image-20221019185917983"><figcaption aria-hidden="true">image-20221019185917983</figcaption></figure><h4 id="流水线协议">流水线协议</h4><h5 id="go-back-ngbn">Go-Back-N(GBN)</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112949459658_238_image-20221019190539995.png" alt="image-20221019190539995"><figcaption aria-hidden="true">image-20221019190539995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112952032314_240_image-20221019190656995.png" alt="image-20221019190656995"><figcaption aria-hidden="true">image-20221019190656995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102112956234191_425_image-20221019190714367.png" alt="image-20221019190714367"><figcaption aria-hidden="true">image-20221019190714367</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113000887288_715_image-20221019190525409.png" alt="image-20221019190525409"><figcaption aria-hidden="true">image-20221019190525409</figcaption></figure><p>GBN协议看起来很浪费，因为它会丢弃一个正确接收（但失序）的包。但这样做是有道理的。因为数据必须按序交付。接收方可能缓存包n + 1，但是，根据 GBN 重传规则，如果包 n 丢失，则这个包及第n +1及之后的包迟早会再重传，所以，接收方只需要直接丢弃第n + 1个包即可。</p><p>这种方法的优点是<strong>接收方不需要缓存任何失序分组</strong>，<strong>唯一需要维护的信息就是下一个按序接收的分组的序号</strong>。缺点就是<strong>随后对该分组的重传也许会丢失或出错，进而引发更多的重传。</strong></p><h5 id="sr">SR</h5><p>与GBN的主要区别：</p><ul><li><p>发送端：</p><ul><li><p>每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个包。</p></li><li><p>记录收到的ACK(因为不再重复发送)，但仅当收到的ACK的序号等于基序号<code>base</code>时窗口才会移动，移动到最小的未确认分组处(接收到的最大ACK+1)</p></li></ul></li><li><p>接收端</p><ul><li><p>收到没收到过的包，在窗口口内，缓存并发ACK这个包的序号。(没收到的包在窗口外那肯定是接收端缓存放不下了)</p></li><li><p>收到已经收到过的包，也发这个包的ACK。</p></li></ul></li></ul><p class="note note-primary">第二种情况是什么情景？收到已经收到过的包，那么只有一种情况，那就是接收端的ACK丢失，发送端不知道接收端这个包已经接受了，认为是中途丢了，就会再发一次。为什么要返回 ACK？加入按照上图中所示的发送方和接收方的序号空间，如果分组 send_base 的 ACK没有从接收方传播回发送方，则发送方最终将重传分组send_base，即使显然接收方已经收了该分组。如果接收方不确认该分组，则发送方窗口将永远不能向前滑动。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113003951000_939_image-20221026102125865.png" alt="image-20221026102125865"><figcaption aria-hidden="true">image-20221026102125865</figcaption></figure><p>然而，SR还是没解决类似的失序问题(虽然产生原因不一样，但导致的后果是一样的，即二义性)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113005960023_920_image-20221026102907586.png" alt="image-20221026102907586"><figcaption aria-hidden="true">image-20221026102907586</figcaption></figure><p>我们能够直观的感觉到，只要<strong>序号空间应大于等于窗口大小的2倍</strong>，就能“错开”潜在的二义性区间。</p><h3 id="tcp">TCP</h3><h4 id="段格式">段格式</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113010320175_456_image-20221028201125789.png" alt="image-20221028201125789"><figcaption aria-hidden="true">image-20221028201125789</figcaption></figure><p class="note note-info">报头长度为20~60B，其中固定部分为20B。由于数据偏移字段的单位是4B，也就是说当偏移取最大时TCP首部长度为15×4=60B。</p><h4 id="连接管理">连接管理</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113012417879_161_image-20221028202938399.png" alt="image-20221028202938399"><figcaption aria-hidden="true">image-20221028202938399</figcaption></figure><blockquote><p>B</p></blockquote><p>关于连接的建立和释放(三次握手，四次挥手)等内容，在实验作业中有详细的阐述。</p><p><a target="_blank" href="https://lunaticsky-tql.github.io/posts/13596/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Wireshark分析交互过程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://lunaticsky-tql.github.io/posts/13596/</span></span></span></a></p><h4 id="传输过程">传输过程</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113015046715_418_image-20221028202640029.png" alt="image-20221028202640029"><figcaption aria-hidden="true">image-20221028202640029</figcaption></figure><p>对于某一端来说，seq表示发送的报文段中数据部分的第一个字节在其发送缓存区中的编号，<font color="Apricot">ack表示它期望收到的下一个报文段的数据部分的第一个字节在另一端的发送缓存区中的编号</font>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113021254308_149_image-20221028202202650.png" alt="image-20221028202202650"><figcaption aria-hidden="true">image-20221028202202650</figcaption></figure><blockquote><p>同一个TCP报文中的seq和ack的值是没有联系。在B发给A的报文（捎带确认）中，seq值应和A发向B的报文中的ack值相同，即201：ack值表示B期望下次收到A发出的报文段的第一个字节的编号，应是200+2=202。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113022900814_335_image-20221028203537641.png" alt="image-20221028203537641"><figcaption aria-hidden="true">image-20221028203537641</figcaption></figure><blockquote><p>D</p></blockquote><h4 id="重传场景">重传场景</h4><h5 id="超时重传">超时重传</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113025521130_952_image-20221102090515967.png" alt="image-20221102090515967"><figcaption aria-hidden="true">image-20221102090515967</figcaption></figure><h6 id="rto设置重要性">RTO设置重要性</h6><p>RTO设置过大，对于丢失的报文段重传等待的时间过长，对于应用来说会引入较大的时延</p><p>RTO设置过小，可能会提前超时，引入不必要的重传，浪费带宽资源</p><h6 id="算法思路">算法思路</h6><p>最新样本赋予的权值大于老样本的权值（老化算法）</p><p>越新的样本越能更好地反映网络的当前状况</p><p>不仅如此，在实际情况中，网络拥塞情况会对网络时延有很大影响(体现在下面的DevRTT中)</p><p>启发式算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113027424562_662_image-20221102090928397.png" alt="image-20221102090928397"><figcaption aria-hidden="true">image-20221102090928397</figcaption></figure><h5 id="快速重传">快速重传</h5><p>“事不过三”。如果收到重复ACK，至少说明客户端接收到的包失序了。如果一两个，可能只是包跑的不一样快，但多了就认为很有可能是丢了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113029523742_128_image-20221102091321589.png" alt="image-20221102091321589"><figcaption aria-hidden="true">image-20221102091321589</figcaption></figure><h4 id="流量控制">流量控制</h4><h5 id="滑动窗口">滑动窗口</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113031785988_286_image-20221102102355905.png" alt="image-20221102102355905"><figcaption aria-hidden="true">image-20221102102355905</figcaption></figure><p class="note note-primary">如果上图中黄×所在的ACK没收到咋办？会出现什么情况？如何解决？</p><p>服务器不知道</p><blockquote><p>TCP使用滑动窗口机制来进行流量控制，其窗口尺寸的设置很重要，如果滑动窗口值设置得太小，那么会产生过多的ACK(因为窗口大可以累积确认，因此会有更少的ACK)，影响网络吞吐率；如果设置得太大，那么又会由于传送的数据过多而使路由器变得拥挤，浪费主机的存储资源，导致主机可能丢失分组。</p></blockquote><h5 id="性能问题image-20221102100002266">性能问题<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20221102113034340991_595_image-20221102100002266.png" alt="image-20221102100002266"></h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验二_Wireshark分析交互过程</title>
    <link href="/posts/13596/"/>
    <url>/posts/13596/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验二_wireshark分析交互过程">计算机网络实验二_Wireshark分析交互过程</h1><h2 id="实验要求">实验要求</h2><p>（1）搭建Web服务器（自由选择系统），并制作简单的Web页面，包含简单文本信息（至少包含专业、学号、姓名）和自己的LOGO。</p><p>（2）通过浏览器获取自己编写的Web页面，使用Wireshark捕获浏览器与Web服务器的交互过程，并进行简单的分析说明</p><ul><li>主要分析的是tcp握手、http请求应答、tcp挥手几个过程和相关问题</li></ul><h2 id="wireshark可以做什么"><a href="https://zhuanlan.zhihu.com/p/82498482">Wireshark可以做什么</a></h2><ul><li>网络管理员使用Wireshark检测网络问题</li><li>网安工程师用Wireshark检查信息安全相关问题</li><li>开发者使用Wireshark为新的通信协议调试</li><li>普通用户使用Wireshark学习网络协议相关知识</li><li>憨憨学生使用Wireshark应付TCP/IP课程要求(别骂了)</li></ul><h2 id="服务器搭建">服务器搭建</h2><p>在本次实验中我使用了本地服务器。我们可以使用Springboot，flask等在localhost上搭建Web服务器。不过最近恰好在研究博客搭建相关内容，这里通过使用Hexo搭建静态博客的比较“自动化”的方式在本机搭建Web服务器。</p><p>通过下面命令安装<code>hexo</code>环境。(其实还需要安装<code>npm</code>环境，不过在此就略去了)。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4ch93el9znqyr0"></i><span>shell</span><div class="collapse show" id="collapse-4ch93el9znqyr0"><pre><code class="hljs shell">sudo npm install -g hexo-cli</code></pre></div></div><p>新建博客目录结构如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zfn0zul9znqyr0"></i><span>shell</span><div class="collapse show" id="collapse-zfn0zul9znqyr0"><pre><code class="hljs shell">my_hexo_test_server.├── _config.yml├── db.json├── node_modules├──...├── package-lock.json├── package.json├── public├── scaffolds├── source│&nbsp;&nbsp; └── _posts└── themes    └── wireshark        ├── _config.yml        ├── layout        │&nbsp;&nbsp; ├── index.ejs        │&nbsp;&nbsp; ├── layout.ejs        │&nbsp;&nbsp; └── post.ejs        └── source            ├── css            ├── img            └── js</code></pre></div></div><p><code>_config.yml</code>中<code>theme</code>改为自定义的<code>wireshark</code>，在<code>index.ejs</code>中写入网页内容：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nwnv47l9znqyr0"></i><span>html</span><div class="collapse show" id="collapse-nwnv47l9znqyr0"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>this is layout.ejs<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> 2013599 田佳业<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>计算机科学与技术<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/test.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></div><p>在终端执行 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-npaz3el9znqyr0"></i><span>shell</span><div class="collapse show" id="collapse-npaz3el9znqyr0"><pre><code class="hljs shell">(base) ➜  my_hexo_test_server hexo g(base) ➜  my_hexo_test_server hexo s</code></pre></div></div><p></p><p>可以看到生成网页如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232042709573_203_image-20221026200601767.png" alt="image-20221026200601767"><figcaption aria-hidden="true">image-20221026200601767</figcaption></figure><h2 id="wireshark-分析tcp连接过程">Wireshark 分析TCP连接过程</h2><p>由于服务器在本地，选择<code>Loopback:lo0</code>即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232044366413_373_image-20221026200751668.png" alt="image-20221026200751668"><figcaption aria-hidden="true">image-20221026200751668</figcaption></figure><p>首先我们需要尝试找到TCP建立连接三次握手的位置。刷新网页，并输入<code>http</code>进行过滤，以隐藏其他无关的数据包。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232045903947_824_image-20221028173616526.png" alt="image-20221028173616526">找到第一个<code>GET</code>数据包。右键选中，<code>Follow stream</code>——<code>TCPstream</code>，显示握手信息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232048121868_131_image-20221028174135897.png" alt="image-20221028174135897"><figcaption aria-hidden="true">image-20221028174135897</figcaption></figure><h3 id="三次握手">三次握手</h3><p>下面展示了三次握手的过程，并结合握手信息对照报文段进行分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232049728449_411_image-20221028175332107.png" alt="image-20221028175332107"><figcaption aria-hidden="true">image-20221028175332107</figcaption></figure><ul><li>第一次握手：建立连接时，客户端发送SYN包（Seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（SynchronizeSequence Numbers）。</li></ul><p>捕获的第一段报文如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232051494572_180_image-20221028174837176.png" alt="image-20221028174837176"><figcaption aria-hidden="true">image-20221028174837176</figcaption></figure><p>博客示例网页运行在<code>localhost:4000</code>，目的端口号匹配。同时可以看到Flag字段值为2，也即第二位SYN字段为1，其余全0。</p><ul><li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li></ul><p>第二段报文如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232054080895_215_image-20221028175454476.png" alt="image-20221028175454476"><figcaption aria-hidden="true">image-20221028175454476</figcaption></figure><p>从端口号可以看出，这是服务器发给客户的。Flag字段为ACK和SYN。这次我们注意一下确认序列号的值。从<a href="https://wiki.wireshark.org/TCP_Relative_Sequence_Numbers">WiresharkWiki</a>我们可以了解到，考虑到可读性其在列表中采用了相对序列号。在详细信息中可以看到原始(<code>raw</code>)序列号。我们可以看到：</p><p>第一次握手客户端<code>Sequence Number (raw):2932922641</code>（Seq=j）</p><p>第二次握手服务器端<code>Acknowledgment number (raw):2932922642</code>（ACK=j+1），与示意图中的握手过程的过程相符。</p><ul><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手，客户端与服务器开始传送数据。</li></ul><p>同样可以验证ACK(ack=k+1）。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232056001837_289_image-20221028180628702.png" alt="image-20221028180628702"><figcaption aria-hidden="true">image-20221028180628702</figcaption></figure><p>也可对照查看右侧的十六进制报文源码。</p><h4 id="过程理解">过程理解</h4><p class="note note-primary">为什么是三次握手？</p><p>需要以最小的代价验证会话双方的收发功能正常:</p><ul><li><p>第一次握手成功：说明客户端的数据可以被服务端收到，说明客户端的发功能可用，说明服务端的收功能可用。但客户端自己不知道数据是否被接收。</p></li><li><p>第二次握手成功：说明服务端的数据可以被客户端收到，说明服务端的发功能可用，说明客户端的收功能可用。同时客户端知道自己的数据已经正确到达服务端，自己的发功能正常。但是服务端自己不知道数据是否被接收。</p></li><li><p>第三次握手成功：说明服务端知道自己的数据已经正确到达客户端端，自己的发功能正常。至此服务成功建立。</p></li></ul><p class="note note-primary">为什么每次连接的序列号都不同？</p><p>避免新老连接混淆</p><h4 id="syn洪泛攻击">Syn洪泛攻击</h4><p>在 TCP 连接的三次握手过程中，我们假设发生以下情况：</p><p>一个用户向服务器发送了 Syn报文后突然死机或掉线, 则服务器在发出 SYN和ACK 应答报文后，客户端无法及时答复，导致服务器无法收到客户端的 ACK报文( 即第三次握手无法完成) 。</p><p>这种情况下服务器端一般会重试并等待一段时间后丢弃这个未完成的连接,称为<strong>半连接握手状态。</strong></p><p>攻击者只需要向服务端发送大量的TCP请求连接而不进行第三次回应，就会出现大量的这种半握手状态的连接,在服务器产生很多的请求队列,<strong>由于第一次握手时服务端就已经为客户端开辟了接收缓冲区</strong>，大量的请求最后的结果往往是堆栈溢出崩溃,服务器也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求,此时服务器失去了对客户端的响应, 从而达到SynFlood攻击的目的。</p><p><a href="https://zhuanlan.zhihu.com/p/457884093">DoS攻击之Syn洪泛攻击原理及防御</a></p><h3 id="四次挥手">四次挥手</h3><p>左边的实线连起来的表示同一次会话发生的各个阶段。沿着这条线走到最底端，可以看到四次挥手的过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232058311718_623_image-20221028181245513.png" alt="image-20221028181245513"><figcaption aria-hidden="true">image-20221028181245513</figcaption></figure><p>结合TCP连接关闭的过程，可以看到第81到84个报文是挥手的过程。分析方式与握手类似，在此不再赘述。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232100061679_207_image-20221028181501786.png" alt="image-20221028181501786"><figcaption aria-hidden="true">image-20221028181501786</figcaption></figure><p>另外，其实两端中的任何一个都可以主动提出关闭连接。只是通常情况下是客户端。</p><h4 id="过程理解-1">过程理解</h4><p class="note note-primary">第二次挥手和第三次挥手一定是紧挨着的吗？</p>不一定。这时候只是表示A不再发送数据。服务器仍可在这两次挥手中间发送一些数据。<p class="note note-primary">为什么第四次挥手后A不能立刻释放资源？</p>A并不知道B有没有正确的收到了A的ACK。正常情况下什么也不会发生。但如果没收到，B应当重传FIN，A得知道<p class="note note-primary">为什么要等两倍MSL？</p><p>无论是否正常，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。</p><p class="note note-primary">一定要四次挥手吗？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221102112611088782_354_image-20221102103437478.png" alt="image-20221102103437478"><figcaption aria-hidden="true">image-20221102103437478</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221102112614834681_752_image-20221102103222135.png" alt="image-20221102103222135"><figcaption aria-hidden="true">image-20221102103222135</figcaption></figure><p>客户端和服务端的生命周期总结如下：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232101334092_481_image-20221028181827531.png" alt="image-20221028181827531"><figcaption aria-hidden="true">image-20221028181827531</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232103339683_762_image-20221028181835974.png" alt="image-20221028181835974"><figcaption aria-hidden="true">image-20221028181835974</figcaption></figure><h3 id="传输窗口">传输窗口</h3><h4 id="tcp-window-scale">TCP Window Scale</h4><p>在TCP刚被发明的时候，全世界的网络带宽都很小，所以最大接收窗口被定义成65535字节。随着硬件的革命性进步，65535字节已经成为性能瓶颈了，怎么样才能扩展呢？TCP头中只给接收窗口值留了 16 bit，肯定是无法突破 65535 （<span class="math inline">\(2^{16} − 1\)</span>）的。 1992年的 RFC1323中提出了一个解决方案，就是在三次握手时，把自己的 WindowScale信息告知对方。由于 Window Scale放在 TCP头之外的Options中，所以不需要修改 TCP头的设计。 WindowScale的作用是向对方声明一个 Shift count，我们把它作为 2的指数，再乘以TCP头中定义的接收窗口，就得到真正的 TCP接收窗口了。</p><p>这对应于Wireshark中的Caculated window size，如下图所示。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232105453916_456_image-20221028184429901.png" alt="image-20221028184429901"><figcaption aria-hidden="true">image-20221028184429901</figcaption></figure><h2 id="http传输分析">Http传输分析</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232107541741_783_image-20221028190921283.png" alt="image-20221028190921283"><figcaption aria-hidden="true">image-20221028190921283</figcaption></figure><p>以下是前三个HTTP传输报文。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232109214457_454_image-20221028191110711.png" alt="image-20221028191110711"><figcaption aria-hidden="true">image-20221028191110711</figcaption></figure><p>查看第一次客户端向服务器发送GET请求，含有浏览器请求头以及请求行。GET方法没有请求体。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232111055813_462_image-20221028190632604.png" alt="image-20221028190632604"><figcaption aria-hidden="true">image-20221028190632604</figcaption></figure><p>从右边解析出的明文可以看出HTTP是采用ASCII码进行传输的。</p><p>之后请求成功，返回200状态码及HTML。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232113806376_581_image-20221028191208877.png" alt="image-20221028191208877"><figcaption aria-hidden="true">image-20221028191208877</figcaption></figure><p>分析文本的十六进制编码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cfibt2l9znqyr0"></i><span>apache</span><div class="collapse show" id="collapse-cfibt2l9znqyr0"><pre><code class="hljs apache"><span class="hljs-attribute">0000</span>   <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">3</span>c <span class="hljs-number">68</span> <span class="hljs-number">32</span> <span class="hljs-number">3</span>e <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">33</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span><span class="hljs-attribute">0010</span>   <span class="hljs-number">20</span> e7 <span class="hljs-number">94</span> b0 e4 bd b3 e4 b8 <span class="hljs-number">9</span>a <span class="hljs-number">3</span>c <span class="hljs-number">2</span>f <span class="hljs-number">68</span> <span class="hljs-number">32</span> <span class="hljs-number">3</span>e <span class="hljs-number">0</span>a</code></pre></div></div><p>第一行末尾可以看到是我的学号<code>2013599</code>的ASCII码。</p><p>中文采用的是Unicode编码。具体方式为：</p><blockquote><p>将需要转码的字符，按指定编码方式（默认使用UTF-8编码）转化为字节流，每个字节按16进制表示，并添加%组成一个percent编码。</p></blockquote><p>给第二行每个字节前加%后用UrlDecode解码，可以还原出我的名字。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232117064239_862_image-20221028193717733.png" alt="image-20221028193717733"><figcaption aria-hidden="true">image-20221028193717733</figcaption></figure><p>再之后请求图片：</p><p>同时我们可以看到图片信息也请求成功。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20221028232118651904_458_image-20221028194251309.png" alt="image-20221028194251309"><figcaption aria-hidden="true">image-20221028194251309</figcaption></figure><blockquote><p>在 <code>vim</code> 内调用 <code>:%!xxd</code>命令，其实就是调用系统的 <code>xxd</code>命令，对打开的内容进行16进制转换。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++_基本语法和运算</title>
    <link href="/posts/64911/"/>
    <url>/posts/64911/</url>
    
    <content type="html"><![CDATA[<h2 id="c回顾复习">C++回顾复习</h2><h3 id="认识c">认识C++</h3><h4 id="基本概念和词汇">基本概念和词汇</h4><p>main不是C++中的保留字。因此<code>int main;</code>在C++中合法。</p><p class="note note-secondary">下列哪个是C++语言的合法的字符常量 "0" '054’ ‘' ‘\092’</p><blockquote><p>A选项，双引号表示的是字符串常量；B选项054表示八进制整数，但是缺少转义符号；D选项是将其后的整数092表示八进制整数，但是八进制不存在9这个数。注意，单引号表示的字符常量，可以是整数，但必须带有转义符号，其字符常量为整数表示的ASC码对应的字符</p></blockquote><p>一个经常设坑的点：八进制表达中出现8或9</p><h4 id="枚举常量">枚举常量</h4><p><code>enum t1 {a1,a2=7,a3,a4=15}time;</code></p><p>则枚举常量<code>a1</code>和<code>a3</code>的值分别是0和8</p><p>枚举值对应的整数值可以是任意整数。</p><p>注意区分枚举类型定义和枚举类型变量定义。前者定义的数据类型，后者是定义变量。定义类型名时不应该有=</p><p class="note note-warning">因此 enum a=[one,two,three);是不对的</p><p>还可以这样写</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ebbebkl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-ebbebkl9znqyqz"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">team</span>{my, your=<span class="hljs-number">4</span>, his, her=his+<span class="hljs-number">10</span>};cout&lt;&lt;my&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;your&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;his&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;her&lt;&lt;endl;</code></pre></div></div><p>结果<code>0 4 5 15</code></p><h4 id="string">string</h4><p>关于字符串类型</p><p>使用<code>.length()</code>和<code>strlen()</code>时计算的字符串长度都不包含<code>\0</code></p><p class="note note-warning">注意:+不支持两个字符串字面常量的连接,如 string word4 "hello"+"world!";</p><h3 id="运算符和表达式">运算符和表达式</h3><h4 id="基本概念">基本概念</h4><p>在学习了编译原理之后，对这些概念以及对应的“奇特”写法应当已经见怪不怪。但为应对考试，仍记录以备复习。</p><h5 id="表达式">表达式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094522795684_122_image-20221013141835992.png" alt="image-20221013141835992"><figcaption aria-hidden="true">image-20221013141835992</figcaption></figure><p>注意，“表达式”不带分号，带了分号就是语句。</p><h4 id="优先级和结合性">优先级和结合性</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gln5ucl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-gln5ucl9znqyqz"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//test 1</span>    <span class="hljs-type">int</span> k, a, b, c;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> w = <span class="hljs-number">5</span>;    <span class="hljs-type">double</span> x = <span class="hljs-number">1.42</span>;<span class="hljs-comment">//    x%(-3); &lt;Invalid operands to binary expression ('double' and 'int')&gt;</span>    w += <span class="hljs-number">-2</span>; <span class="hljs-comment">// w=3</span>    k = (a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b); <span class="hljs-comment">// k=5</span>    c = k = a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b; <span class="hljs-comment">// c=5, k=2, a=2, b=3</span>    a += a -= (b = <span class="hljs-number">4</span>) * (a = <span class="hljs-number">3</span>); <span class="hljs-comment">// a=-18, b=4</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a=%d"</span>, a);    <span class="hljs-comment">//test 2</span>    <span class="hljs-type">int</span> d2i = <span class="hljs-string">'A'</span> + <span class="hljs-number">1.6</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a2=%d"</span>, d2i); <span class="hljs-comment">//'A'+1.6=66.6=66 (ASCII code of 'A' is 65)</span>    <span class="hljs-comment">//test3</span><span class="hljs-comment">/*    d=9+e+f=d+9;</span><span class="hljs-comment">    expression is a value, not a variable in the memory,so it is not assignable */</span>}</code></pre></div></div><p><a href="https://blog.csdn.net/zb_915574747/article/details/99704639">优先级和结合性一览</a></p><h4 id="赋值运算">赋值运算</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0sjkjgl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-0sjkjgl9znqyqz"><pre><code class="hljs c++">设有intx=<span class="hljs-number">11</span>：，则表达式(x++*<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)的值是</code></pre></div></div><p><span class="math inline">\(\lfloor 11*1/3 \rfloor=3\)</span></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094525768953_130_image-20221013142054782.png" alt="image-20221013142054782"><figcaption aria-hidden="true">image-20221013142054782</figcaption></figure><p>做题时容易犯的错误：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xbzzspl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-xbzzspl9znqyqz"><pre><code class="hljs c++">若d为<span class="hljs-type">double</span>型变量，则表达式d=<span class="hljs-number">1</span>，d+<span class="hljs-number">5</span>，d++的值是<span class="hljs-number">1</span>。d+<span class="hljs-number">5</span>不是d=d+<span class="hljs-number">5</span>。虽然很明显，做题的时候也需要有注意的意识</code></pre></div></div><h4 id="逻辑运算">逻辑运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094527376104_753_image-20221020095906292.png" alt="image-20221020095906292"><figcaption aria-hidden="true">image-20221020095906292</figcaption></figure><p>注意算术运算符优先于关系和除非以外的逻辑运算符！</p><p>短路运算举例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wiee7vl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-wiee7vl9znqyqz"><pre><code class="hljs c++">×=y=<span class="hljs-number">3</span>;t=++x||++y后，y的值是</code></pre></div></div><blockquote><p>3，因为后面不会被运算</p></blockquote><p>优先级只是起“加括号”的作用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tfmn9el9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-tfmn9el9znqyqz"><pre><code class="hljs c++"><span class="hljs-type">int</span> c,h;std::cout&lt;&lt;((c=<span class="hljs-number">2</span>)&amp;&amp;(h=<span class="hljs-number">-2</span>));<span class="hljs-comment">//always true</span></code></pre></div></div><h4 id="位运算">位运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094529486139_294_image-20221020105755065.png" alt="image-20221020105755065"><figcaption aria-hidden="true">image-20221020105755065</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094532506509_144_image-20221020104858172.png" alt="image-20221020104858172"><figcaption aria-hidden="true">image-20221020104858172</figcaption></figure><p>注意位运算的“地位”不是平等的，不要想当然按顺序算</p><h4 id="条件和逗号运算符">条件和逗号运算符</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221027094533764720_298_image-20221020111433316.png" alt="image-20221020111433316"><figcaption aria-hidden="true">image-20221020111433316</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8nr33ul9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-8nr33ul9znqyqz"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">{</span></span><span class="hljs-params"><span class="hljs-function">cout&lt;&lt;(<span class="hljs-number">0101</span>&amp;<span class="hljs-number">101</span>&gt;&gt;<span class="hljs-number">3</span>|<span class="hljs-number">101</span>&lt;&lt;<span class="hljs-number">3</span>^~<span class="hljs-number">0x10</span>)&lt;&lt;endl;</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span></span><span class="hljs-params"><span class="hljs-function">}</span></span><span class="hljs-params"><span class="hljs-function"></span></span></code></pre></div></div><blockquote><p>优先级按位取反~最高，先将0x10（十六进制）按位取反，得到结果1111111111111111 1111111111101111，其次优先级按位左移和按位右移运算符优先级相同，计算101&gt;&gt;3得到00000000 00000000 00000000 00001100，以及101&lt;&lt;3得到 0000000000000000 0000001100101000，接下来计算0101（八进制）按位与（101&gt;&gt;3）的结果，得到结果为0,0按位或一个数所得结果为原值。因此最终答案为(101&lt;&lt;3)按位异或(~0x10)的结果，其结果为1111111111111111 11111100 11000111，为负数，求补得到绝对值。特别需要注意的是取反的时候是对整个int取反，16变-17</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-csywk0l9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-csywk0l9znqyqz"><pre><code class="hljs c++">设intm=<span class="hljs-number">5</span>；<span class="hljs-type">float</span> x=<span class="hljs-number">3.5</span>；则表达式m+x+<span class="hljs-number">4.5</span>的结果应占据[填空]个字节。<span class="hljs-comment">//8.在隐式类型转换中转向了double</span></code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验一_socket聊天程序</title>
    <link href="/posts/54779/"/>
    <url>/posts/54779/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验一_socket聊天程序">计算机网络实验一_Socket聊天程序</h1><p>2013599 田佳业</p><h2 id="实验要求">实验要求</h2><p>使用流式Socket，设计一个两人聊天协议，要求聊天信息带有时间标签。请完整地说明交互消息的类型、语法、语义、时序等具体的消息处理方式。拓展实现功能（如群聊、多线程等）</p><h2 id="程序流程展示">程序流程展示</h2><h3 id="模块说明">模块说明</h3><p>此实验使用了Windows多线程的方式实现了多人聊天功能，流程和协议设计如下图所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193748648308_976_connect.png" alt="connect"><figcaption aria-hidden="true">connect</figcaption></figure><p>对于每一个用户的聊天过程，分为建连阶段和聊天阶段。</p><h3 id="建连阶段">建连阶段</h3><h4 id="流程设计">流程设计</h4><h5 id="服务器">服务器</h5><p>服务器主要做了以下工作：</p><ul><li><p>设置最大聊天人数并在接收连接前验证</p></li><li><p>建立socket，绑定ip和端口号，进入监听模式进行等待</p></li><li><p>客户端连接后，得到客户端输入的用户名，验证是否在已有用户列表，若否，为其单独创建线程并在<code>socket</code>池中为其分配<code>socket</code></p></li><li><p>连接成功，向其发送欢迎信息并通知在线的用户</p></li><li><p>每当用户连接成功后，服务器显示用户信息及连接时间。</p></li></ul><p>注：下图包含了一次客户端断开重连的过程，可以看到服务器能够正确的识别这一过程，且对在线人数进行更新。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193750618844_199_image-20221022211508575.png" alt="image-20221022211508575"><figcaption aria-hidden="true">image-20221022211508575</figcaption></figure><h5 id="客户端">客户端</h5><ul><li><p>由于程序默认在<code>localhost</code>上运行，因此客户端只需要手动选择正确的端口号与服务器进行连接，若连接失败，退出程序。</p></li><li><p>之后输入用户名，这里需要注意用户名不能与关键字(在该程序中为<code>quit</code>和<code>all</code>)。当然在本地验证即可。等待服务器确认信息后，建立两个线程：发送和接收线程，以防止阻塞。</p></li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193752409499_274_image-20221022211345244.png" alt="客户端"><figcaption aria-hidden="true">客户端</figcaption></figure><p>下面是上线通知的实现效果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193754614735_579_image-20221022211828762.png" alt="上线通知"><figcaption aria-hidden="true">上线通知</figcaption></figure><h4 id="协议设计">协议设计</h4><p>由于此部分界限明确，且不涉及与其他服务器的交互，为保证速度和效率，从简设计即可。只传输最需要的东西。并且由于这个过程顺序是且必须是确定的，串行执行共用端口不至混淆。</p><h3 id="聊天阶段">聊天阶段</h3><h4 id="流程设计-1">流程设计</h4><h5 id="服务器事件">服务器事件</h5><p>程序在调度设计中着重注意了一点：在整个聊天室中，服务器可以作为“管理员”向用户发送消息，而不仅仅实现转发功能。为了实现这一点，程序采用了子线程的方式。主线程除了创建socket便将与客户端建立连接的过程交给子线程去干，服务端负责转发的线程由子线程创建。主线程自己则进入等待输入的过程。</p><p>主线程有输入分一下两种情况：正常字符串和<code>exit</code>。正常字符串会即时群发给所有在线用户并标记为<code>SERVER</code>信息。若输入<code>exit</code>则退出服务器，并在退出之前向客户端群发通告，并同时退出客户端的程序。</p><p>以下两幅图片展示了客户端收到的对应的情况。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193756459285_459_image-20221022214111930.png" alt="image-20221022214111930"><figcaption aria-hidden="true">image-20221022214111930</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193758300289_769_image-20221022213615110.png" alt="image-20221022213615110"><figcaption aria-hidden="true">image-20221022213615110</figcaption></figure><h5 id="客户端事件">客户端事件</h5><p>按照同样的方式可以实现客户端离线群发功能。不再赘述。当然，断开后删除个人信息并更新计数也是必要的。</p><h5 id="私聊和群聊">私聊和群聊</h5><p>可以从上述图片中看出客户端命令行有两个参数：发送对象和消息。</p><p>从实现上，这两种方式没有本质的区别。稍微需要注意的一些细节主要是群发不需要发给请求方，但私发时如果选择发送给自己，自己仍然可以收到消息。</p><p>下图展示了私聊和群聊的结果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193759994557_881_image-20221022224632714.png" alt="image-20221022224632714"><figcaption aria-hidden="true">image-20221022224632714</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193801774887_602_image-20221022224533046.png" alt="image-20221022224533046"><figcaption aria-hidden="true">image-20221022224533046</figcaption></figure><h4 id="协议设计-1">协议设计</h4><p>协议设计中关注了一下几点：</p><ol type="1"><li><p>在线状况下，根据<code>socket ID</code>和用户信息表，可以知道是谁发的，因此传递报文时发送者只需要向服务器传递接受者是谁，服务器转发时将对应字段改为发送者姓名即可。这样虽然增加了服务器压力，但能够有效减少报文长度。</p></li><li><p>控制位仅需一个字节。当然这就像<code>HTTP</code>状态码一样，是建立在共识之上的。</p></li><li><p>消息中需要包含时间戳。因为聊天程序中的时间是需要以发送时间为准的。当然接收时间可以从系统获得，基于此也可以进行时延计算。</p></li></ol><p>以下是程序中关于协议中控制部分的宏定义：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oucyesl9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-oucyesl9znqyr0"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW_C <span class="hljs-string">'N'</span> <span class="hljs-comment">// new client</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUB_C <span class="hljs-string">'P'</span> <span class="hljs-comment">// public message</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRI_C <span class="hljs-string">'R'</span>  <span class="hljs-comment">// private message</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUIT_C <span class="hljs-string">'Q'</span> <span class="hljs-comment">// quit</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_C <span class="hljs-string">'H'</span> <span class="hljs-comment">// hello message from server</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_C <span class="hljs-string">'T'</span> <span class="hljs-comment">// exit message from server (server is closed)</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERR_C <span class="hljs-string">'E'</span> <span class="hljs-comment">// error message from server</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_C <span class="hljs-string">'V'</span> <span class="hljs-comment">// normal server message</span></span></code></pre></div></div><h2 id="程序代码解释">程序代码解释</h2><p>具体代码的含义大多在程序中有注释。下面的文字叙述部分主要着眼函数和线程模块划分和功能实现上。</p><p>C++中对字符串的处理<code>char*</code>和<code>string</code>各有各的优势，有时也会出现各种奇怪的坑，在写代码时一度让人很头疼，因此也在某些地方会有一些不太优雅的写法。</p><h3 id="环境配置">环境配置</h3><p>在<code>cmake</code>项目中进行<code>socket</code>编程需要在CMakeLists中添加以下内容，否则不能正常编译：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z3wwdjl9znqyr0"></i><span>cmake</span><div class="collapse show" id="collapse-z3wwdjl9znqyr0"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.21</span>)<span class="hljs-keyword">project</span>(chatting)<span class="hljs-keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="hljs-string">"-static"</span>)<span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<span class="hljs-keyword">link_libraries</span>(ws2_32 wsock32)<span class="hljs-keyword">add_executable</span>(server server.cpp)<span class="hljs-keyword">add_executable</span>(client client.cpp)</code></pre></div></div><p>需额外包含的头文件：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qe0lgel9znqyr0"></i><span>cmake</span><div class="collapse show" id="collapse-qe0lgel9znqyr0"><pre><code class="hljs cmake"><span class="hljs-comment">#include &lt;windows.h&gt;</span><span class="hljs-comment">#include &lt;WinSock2.h&gt;</span><span class="hljs-comment">#pragma comment(lib, "ws2_32.lib")</span></code></pre></div></div><h3 id="工具类">工具类</h3><p><code>color.h</code>以及部分<code>helper.h</code>的代码主要定义了一些与控制台颜色以及格式化输出显示相关的宏及函数。</p><p><code>print_toggle</code>主要用来格式化打印控制台输出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xa3r8ml9znqyr0"></i><span>reasonml</span><div class="collapse show" id="collapse-xa3r8ml9znqyr0"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_toggle(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">type</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span> &amp;<span class="hljs-params">txt</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">time_str</span>=<span class="hljs-string">""</span>)</span></code></pre></div></div><p>第一个参数是打印格式，取值是下面的宏定义，决定了输出以怎样的颜色和格式进行。第二个参数是内容。并附带可选参数时间。</p><p>宏的定义如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-99vd8wl9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-99vd8wl9znqyr0"><pre><code class="hljs c++"><span class="hljs-comment">//message datagram parameters</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_SIZE 12</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT_SIZE 125</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_SIZE 144</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIME_SIZE 6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT_PTR 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIME_PTR 126</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_PTR 132</span><span class="hljs-comment">//console line type parameters</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERR <span class="hljs-string">"E"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFO <span class="hljs-string">"I"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW <span class="hljs-string">"N"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG <span class="hljs-string">"L"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIP <span class="hljs-string">"T"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUC <span class="hljs-string">"S"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN <span class="hljs-string">"W"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER <span class="hljs-string">"V"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GONE <span class="hljs-string">"G"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DUL <span class="hljs-string">"D"</span> <span class="hljs-comment">// dulplicate name</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO <span class="hljs-string">"H"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUB <span class="hljs-string">"P"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRI <span class="hljs-string">"R"</span></span></code></pre></div></div><p>第一部分主要是方便对数据保处理时使用，第二部分则是在控制台上显示相关命令是需要的宏。</p><h3 id="初始化工作">初始化工作</h3><h4 id="服务器端">服务器端</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-03ojiml9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-03ojiml9znqyr0"><pre><code class="hljs c++"><span class="hljs-comment">//initialize websocket</span>WSADATA wsaData;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"WSAStartup failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"WSAStartup success"</span>);SOCKET sock_server = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);SOCKADDR_IN server_addr;server_addr.sin_family = AF_INET;server_addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);server_addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(LOCALHOST);<span class="hljs-built_in">bind</span>(sock_server, (SOCKADDR *) &amp;server_addr, <span class="hljs-built_in">sizeof</span>(SOCKADDR));<span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock_server, <span class="hljs-number">5</span>) == SOCKET_ERROR) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"listen failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"listen success"</span>);</code></pre></div></div><h4 id="客户端-1">客户端：</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y5dsyql9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-y5dsyql9znqyr0"><pre><code class="hljs c++">WSADATA wsaData;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"WSAStartup failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"WSAStartup success"</span>);SOCKET sockClient = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"the chat room is on the localhost"</span>);<span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"please input port:"</span>);cin &gt;&gt; port;SOCKADDR_IN addrSrv;addrSrv.sin_family = AF_INET;addrSrv.sin_port = <span class="hljs-built_in">htons</span>(port);addrSrv.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(LOCALHOST);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockClient, (SOCKADDR *) &amp;addrSrv, <span class="hljs-built_in">sizeof</span>(SOCKADDR)) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"connect failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"connect success"</span>, <span class="hljs-built_in">get_time_str</span>());</code></pre></div></div><p>这一部分是服务器端创建<code>socket</code>和客户端连接<code>socket</code>必需的代码，课上也有讲述，此处不一一详细说明。</p><h3 id="服务器进程">服务器进程</h3><h4 id="主线程">主线程</h4><p>这一部分主要做的工作是初始化套接字池，并使用<code>client_manager</code>函数创建线程，以监听客户端连接。之后便监听输入以控制服务器群发消息或退出。另外，如果没有客户端连接，显然套接字池中所有套接字都不可用，什么也不用做。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ubz2ssl9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-ubz2ssl9znqyr0"><pre><code class="hljs c++">    <span class="hljs-comment">//initialize socket array</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> &amp;sock_connect: sock_connects) {        sock_connect = INVALID_SOCKET;    }    <span class="hljs-comment">//create a thread to handle new clients</span>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, client_manager, (LPVOID) &amp;sock_server, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (hThread == <span class="hljs-literal">nullptr</span>) {        <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"create thread failed"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-comment">//input "exit" to exit</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">char</span> input[<span class="hljs-number">100</span>];        cin.<span class="hljs-built_in">getline</span>(input, <span class="hljs-number">100</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(input, <span class="hljs-string">"exit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-comment">// tell all clients that the server is going to shut down</span>            <span class="hljs-type">char</span> msg[MSG_SIZE];            <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);            msg[<span class="hljs-number">0</span>] = EXIT_C;            string content = <span class="hljs-string">"server has shut down"</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                msg[TXT_PTR + i] = content[i];            }            <span class="hljs-built_in">broadcast</span>(msg, <span class="hljs-number">-1</span>);            <span class="hljs-comment">//stop the client_manager thread</span>            <span class="hljs-built_in">TerminateThread</span>(hThread, <span class="hljs-number">0</span>);            <span class="hljs-comment">//close server socket</span>            <span class="hljs-built_in">closesocket</span>(sock_server);            <span class="hljs-keyword">break</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//send msg to all clients</span>            <span class="hljs-type">char</span> msg[MSG_SIZE];            <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);            msg[<span class="hljs-number">0</span>] = SERVER_C;            <span class="hljs-type">char</span> txt[TXT_SIZE];            <span class="hljs-built_in">strcpy</span>(txt, input);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TXT_SIZE; j++) {                msg[j + TXT_PTR] = txt[j];            }            <span class="hljs-comment">//add time</span>            <span class="hljs-type">char</span> time[TIME_SIZE];            <span class="hljs-built_in">strcpy</span>(time, <span class="hljs-built_in">get_time_str</span>().<span class="hljs-built_in">c_str</span>());            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TIME_SIZE; j++)                msg[j + TIME_PTR] = time[j];            <span class="hljs-built_in">broadcast</span>(msg);        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>其中的<code>broadcast</code>函数便是群发消息所使用的是。下面看其实现：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rm6legl9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-rm6legl9znqyr0"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">broadcast</span><span class="hljs-params">(<span class="hljs-type">char</span> msg[MSG_SIZE], <span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CLIENT; i++) {        <span class="hljs-keyword">if</span> (sock_connects[i] != INVALID_SOCKET &amp;&amp; i != id) {            <span class="hljs-comment">//we don't send the message to the sender</span>            <span class="hljs-built_in">send</span>(sock_connects[i], msg, MSG_SIZE, <span class="hljs-number">0</span>);        }    }}</code></pre></div></div><p>依次检查<code>socket</code>池，然后给有效且不是<code>id</code>对应的socket发送消息。</p><h4 id="客户端连接线程">客户端连接线程</h4><p><code>[[noreturn]]</code>表明这个函数自始至终监听新加入的<code>socket</code>。连接时服务器不提示，发送用户名时服务器进行第一次消息接收并根据情况发送欢迎信息或要求客户端重新输入用户名。每次接收消息循环结束，表示有客户端进入或离开，更新一次在线信息，并启动<code>handle_msg</code>线程进行消息转发。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jdgu11l9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-jdgu11l9znqyr0"><pre><code class="hljs c++">[[noreturn]] <span class="hljs-function">DWORD WINAPI <span class="hljs-title">client_manager</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-comment">//accept new clients</span>    <span class="hljs-keyword">auto</span> *sock_server = (SOCKET *) lparam;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; index &lt; MAX_CLIENT; index++) {            <span class="hljs-keyword">if</span> (sock_connects[index] == INVALID_SOCKET)                <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">if</span> (index == MAX_CLIENT) {            <span class="hljs-built_in">print_toggle</span>(WARN, <span class="hljs-string">"the server is full"</span>);            <span class="hljs-keyword">continue</span>;        }        SOCKADDR_IN addrClient;        <span class="hljs-type">int</span> lenAddr = <span class="hljs-built_in">sizeof</span>(SOCKADDR);        sock_connects[index] = <span class="hljs-built_in">accept</span>(*sock_server, (SOCKADDR *) &amp;addrClient, &amp;(lenAddr));        <span class="hljs-keyword">if</span> (sock_connects[index] == SOCKET_ERROR) {            <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"could not accept client!"</span>);            sock_connects[index] = INVALID_SOCKET;            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {            <span class="hljs-type">char</span> name[NAME_SIZE];            <span class="hljs-built_in">recv</span>(sock_connects[index], name, NAME_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (username_map.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">string</span>(name)) == username_map.<span class="hljs-built_in">end</span>()) {                username_map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">string</span>(name), index));                <span class="hljs-built_in">send</span>(sock_connects[index], HELLO, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                string new_client = <span class="hljs-string">"new client: "</span> + <span class="hljs-built_in">string</span>(name) + <span class="hljs-string">" entered the chat room"</span>;                string online = <span class="hljs-string">"online:"</span> + <span class="hljs-built_in">to_string</span>(username_map.<span class="hljs-built_in">size</span>());                <span class="hljs-comment">//get the id of the new client</span>                <span class="hljs-type">int</span> id = username_map[<span class="hljs-built_in">string</span>(name)];                <span class="hljs-built_in">print_toggle</span>(INFO, new_client,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">// broadcast</span>                <span class="hljs-type">char</span> msg[MSG_SIZE];                <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TXT_SIZE; j++)                    msg[j + TXT_PTR] = new_client.<span class="hljs-built_in">c_str</span>()[j];                msg[<span class="hljs-number">0</span>] = NEW_C;                <span class="hljs-comment">//add time</span>                <span class="hljs-type">char</span> time[TIME_SIZE];                <span class="hljs-built_in">strcpy</span>(time, <span class="hljs-built_in">get_time_str</span>().<span class="hljs-built_in">c_str</span>());                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TIME_SIZE; j++)                    msg[j + TIME_PTR] = time[j];                <span class="hljs-built_in">broadcast</span>(msg, id);                <span class="hljs-keyword">break</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">send</span>(sock_connects[index], DUL, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);            }        }        HANDLE h_thread_c=<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, handle_msg, (LPVOID) &amp;sock_connects[index], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        <span class="hljs-built_in">CloseHandle</span>(h_thread_c);        string online = <span class="hljs-string">"online: "</span> + <span class="hljs-built_in">to_string</span>(username_map.<span class="hljs-built_in">size</span>());        <span class="hljs-built_in">print_toggle</span>(INFO, online,<span class="hljs-built_in">get_time_str</span>());    }}</code></pre></div></div><h4 id="消息转发线程">消息转发线程</h4><p>消息转发线程主要根据收到的报文控制段对消息进行不同的处理并转发。同时在服务器端输出日志，如下图所示。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20221026193803523871_125_image-20221022225008715.png" alt="image-20221022225008715"><figcaption aria-hidden="true">image-20221022225008715</figcaption></figure><p>在程序中除了根据姓名找<code>socket id</code>,也常常出现反着找的情况。</p><p>这一部分需要注意的点是在<code>PRI_C</code>即私密聊天情况下，如果客户端给出的姓名不在当前上线用户的范围之内，会单独给发送者提示。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lihrv6l9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-lihrv6l9znqyr0"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handle_msg</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CLIENT; i++) {        <span class="hljs-keyword">if</span> (sock_connects[i] == *socket) {            id = i;            <span class="hljs-keyword">break</span>;        }    }    <span class="hljs-comment">// listen to the message from the client</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">char</span> from_user[NAME_SIZE];        <span class="hljs-type">char</span> msg[MSG_SIZE];        <span class="hljs-type">char</span> content[TXT_SIZE];        <span class="hljs-built_in">memset</span>(from_user, <span class="hljs-number">0</span>, NAME_SIZE);        <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);        <span class="hljs-built_in">memset</span>(content, <span class="hljs-number">0</span>, TXT_SIZE);        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {            <span class="hljs-built_in">print_toggle</span>(WARN, <span class="hljs-string">"client closed unexpectedly"</span>);            <span class="hljs-built_in">closesocket</span>(*socket);            <span class="hljs-comment">//remove the socket from the list</span>            sock_connects[id] = INVALID_SOCKET;            <span class="hljs-comment">//remove the username from the ma according to the id</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = username_map.<span class="hljs-built_in">begin</span>(); it != username_map.<span class="hljs-built_in">end</span>(); it++) {                <span class="hljs-keyword">if</span> (it-&gt;second == id) {                    username_map.<span class="hljs-built_in">erase</span>(it);                    <span class="hljs-keyword">break</span>;                }            }            <span class="hljs-keyword">break</span>;        }        <span class="hljs-type">char</span> type = msg[<span class="hljs-number">0</span>];        <span class="hljs-comment">//get the username from the map</span>        string username;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: username_map) {            <span class="hljs-keyword">if</span> (item.second == id) {                username = item.first;                <span class="hljs-keyword">break</span>;            }        }        <span class="hljs-keyword">switch</span> (type) {            <span class="hljs-keyword">case</span> QUIT_C: {                <span class="hljs-comment">// close client through the client's receive thread</span>                <span class="hljs-type">char</span> msg_exit[MSG_SIZE];                <span class="hljs-built_in">memset</span>(msg_exit, <span class="hljs-number">0</span>, MSG_SIZE);                msg_exit[<span class="hljs-number">0</span>] = EXIT_C;                string exit_msg =<span class="hljs-string">"you have been moved out of the chat room"</span>;                <span class="hljs-built_in">send</span>(*socket, msg_exit, MSG_SIZE, <span class="hljs-number">0</span>);                <span class="hljs-built_in">closesocket</span>(*socket);                sock_connects[id] = <span class="hljs-number">0</span>;                username_map.<span class="hljs-built_in">erase</span>(username);                string gone_saying = username + <span class="hljs-string">" has quit the chat room at "</span>;                <span class="hljs-built_in">print_message</span>(GONE, gone_saying,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">//broadcast the quit message</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> sock_connect: sock_connects) {                    <span class="hljs-keyword">if</span> (sock_connect != <span class="hljs-number">0</span>) {                        <span class="hljs-comment">// attach the content to the message</span>                        <span class="hljs-type">char</span> msg_forwards[MSG_SIZE];                        <span class="hljs-built_in">memset</span>(msg_forwards, <span class="hljs-number">0</span>, MSG_SIZE);                        msg_forwards[<span class="hljs-number">0</span>] = QUIT_C;                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                            msg_forwards[TXT_PTR + i] = gone_saying[i];                        }                    }                }                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">case</span> PUB_C: {                <span class="hljs-comment">//get the username from the map</span>                string info=<span class="hljs-string">"received a public message from "</span>;                info+=username;                <span class="hljs-built_in">print_toggle</span>(LOG, info,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-built_in">broadcast</span>(msg, id);                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">case</span> PRI_C: {                <span class="hljs-comment">//get the username from the map</span>                string info=<span class="hljs-string">"received a public message from "</span>;                info+=username;                <span class="hljs-built_in">print_toggle</span>(LOG, info,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">//get the target user</span>                <span class="hljs-type">char</span> target_user[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++) {                    target_user[i] = msg[NAME_PTR + i];                }                <span class="hljs-function">string <span class="hljs-title">target_user_s</span><span class="hljs-params">(target_user)</span></span>;                <span class="hljs-comment">//check if the target user is online</span>                <span class="hljs-keyword">if</span> (username_map.<span class="hljs-built_in">find</span>(target_user) == username_map.<span class="hljs-built_in">end</span>()) {                    <span class="hljs-comment">//target user is not online</span>                    <span class="hljs-comment">// show log on the server</span>                    string error_msg = <span class="hljs-string">"the target user "</span>;                    error_msg.<span class="hljs-built_in">append</span>(target_user);                    error_msg.<span class="hljs-built_in">append</span>(<span class="hljs-string">" provided by "</span>);                    error_msg.<span class="hljs-built_in">append</span>(username);                    error_msg.<span class="hljs-built_in">append</span>(<span class="hljs-string">" is not online!"</span>);                    <span class="hljs-built_in">print_message</span>(LOG, error_msg);                    <span class="hljs-comment">//send the error message to the sender</span>                    <span class="hljs-type">char</span> msg_error[MSG_SIZE];                    <span class="hljs-built_in">memset</span>(msg_error, <span class="hljs-number">0</span>, MSG_SIZE);                    msg_error[<span class="hljs-number">0</span>] = ERR_C;                    string ree_msg_to_send = target_user_s + <span class="hljs-string">" is not online!"</span>;                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                        msg_error[TXT_PTR + i] = error_msg[i];                    }                    <span class="hljs-built_in">send</span>(*socket, msg_error, MSG_SIZE, <span class="hljs-number">0</span>);                } <span class="hljs-keyword">else</span> {                    string info_pri=<span class="hljs-string">"received a private message from "</span>;                    info_pri+=username;                    <span class="hljs-built_in">print_toggle</span>(LOG, info_pri,<span class="hljs-built_in">get_time_str</span>());                    <span class="hljs-comment">//target user is online</span>                    <span class="hljs-comment">//send the message to the target user</span>                    <span class="hljs-type">int</span> target_id = username_map[target_user];                    <span class="hljs-comment">// replace the target user's name with the sender's name</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++) {                        msg[NAME_PTR + i] = username[i];                    }                    <span class="hljs-built_in">send</span>(sock_connects[target_id], msg, MSG_SIZE, <span class="hljs-number">0</span>);                }                <span class="hljs-keyword">break</span>;            }        }    }}</code></pre></div></div><h3 id="客户端进程">客户端进程</h3><h4 id="主线程-1">主线程</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pn1drfl9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-pn1drfl9znqyr0"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockClient, (SOCKADDR *) &amp;addrSrv, <span class="hljs-built_in">sizeof</span>(SOCKADDR)) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"connect failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"connect success"</span>, <span class="hljs-built_in">get_time_str</span>());<span class="hljs-comment">// send username</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {    <span class="hljs-built_in">print_toggle</span>(SERVER, <span class="hljs-string">"please input your username:"</span>, <span class="hljs-built_in">get_time_str</span>());    cin &gt;&gt; user_name;    <span class="hljs-comment">// check if the name is "all" or "quit" that may cause conflict</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(user_name, <span class="hljs-string">"all"</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(user_name, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {        <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"the username cannot be set to system reserved words"</span>);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-built_in">send</span>(sockClient, user_name, NAME_SIZE, <span class="hljs-number">0</span>);    <span class="hljs-comment">//it must be a buffer, although it is only a char</span>    <span class="hljs-type">char</span> status[<span class="hljs-number">1</span>];    <span class="hljs-built_in">recv</span>(sockClient, status, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (status[<span class="hljs-number">0</span>] == HELLO_C) {        <span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"welcome to the chat room!"</span>);        <span class="hljs-keyword">break</span>;    }    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"the username has been used, please input another one"</span>);}HANDLE h_thread[<span class="hljs-number">2</span>];<span class="hljs-comment">// separate the sending and receiving thread to avoid blocking</span>h_thread[<span class="hljs-number">0</span>] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, handlerRec, (LPVOID) &amp;sockClient, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);h_thread[<span class="hljs-number">1</span>] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, handlerSend, (LPVOID) &amp;sockClient, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-built_in">WaitForMultipleObjects</span>(<span class="hljs-number">2</span>, h_thread, TRUE, INFINITE);<span class="hljs-built_in">CloseHandle</span>(h_thread[<span class="hljs-number">0</span>]);<span class="hljs-built_in">CloseHandle</span>(h_thread[<span class="hljs-number">1</span>]);<span class="hljs-built_in">closesocket</span>(sockClient);<span class="hljs-built_in">WSACleanup</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div></div><p>这一部分进行了用户信息发送以及创建了两个子线程用于发送和收取来自服务器的消息。之后阻塞等待线程结束。</p><h4 id="发送线程">发送线程</h4><p>首先将报文字段进行初始化，以便根据实际情况填入。循环等待用户输入，并在过程中两次检查是否需要退出。之后根据报文的控制段<code>TYPE</code>分别构建不同格式信息。注意在这一阶段并不是程报文中的每一个字段都一定用的到。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vlbo7xl9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-vlbo7xl9znqyr0"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handlerSend</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">char</span> to_user[NAME_SIZE];    <span class="hljs-type">char</span> msg[MSG_SIZE];    <span class="hljs-type">char</span> saying[TXT_SIZE];    <span class="hljs-built_in">memset</span>(to_user, <span class="hljs-number">0</span>, NAME_SIZE);    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);    <span class="hljs-built_in">memset</span>(saying, <span class="hljs-number">0</span>, TXT_SIZE);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"please input \"user message\", input 'all' to send to all users"</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, to_user);        <span class="hljs-comment">// if nothing is input, then continue to ask for input again</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(to_user) == <span class="hljs-number">0</span>) {            cout&lt;&lt;<span class="hljs-string">"please input something"</span>&lt;&lt;endl;            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-comment">//check quit</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(to_user, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"you chose to quit the chat room"</span>);            <span class="hljs-comment">//send quit message to server</span>            msg[<span class="hljs-number">0</span>] = QUIT_C;            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%[^\n]"</span>, saying);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(saying) == <span class="hljs-number">0</span>){            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-comment">//check quit</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(saying, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"you have quit the chat room"</span>);            <span class="hljs-comment">//send quit message to server</span>            msg[<span class="hljs-number">0</span>] = QUIT_C;            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-comment">//send message to server for forwarding</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(to_user, <span class="hljs-string">"all"</span>) == <span class="hljs-number">0</span>){            msg[<span class="hljs-number">0</span>] = PUB_C;            <span class="hljs-comment">//construct the message</span>            <span class="hljs-comment">//content</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++){                msg[i + TXT_PTR] = saying[i];            }            <span class="hljs-comment">// from user</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++){                msg[i + NAME_PTR] = user_name[i];            }            <span class="hljs-comment">//time stamp</span>            string time_stamp = <span class="hljs-built_in">get_time_str</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++){                msg[i + TIME_PTR] = time_stamp[i];            }            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        }<span class="hljs-keyword">else</span>{            msg[<span class="hljs-number">0</span>] = PRI_C;            <span class="hljs-comment">//construct the message</span>            <span class="hljs-comment">//content</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++){                msg[i + TXT_PTR] = saying[i];            }            <span class="hljs-comment">// to user</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++){                msg[i + NAME_PTR] = to_user[i];            }            <span class="hljs-comment">//time stamp</span>            string time_stamp = <span class="hljs-built_in">get_time_str</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++){                msg[i + TIME_PTR] = time_stamp[i];            }            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        }    }}</code></pre></div></div><h4 id="接收线程">接收线程</h4><p>接收线程是一个解析的过程，并往控制台进行不同格式输出。模式基本类似。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-67spfdl9znqyr0"></i><span>c++</span><div class="collapse show" id="collapse-67spfdl9znqyr0"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handlerRec</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">char</span> msg[MSG_SIZE];    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">recv</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        <span class="hljs-type">char</span> type = msg[<span class="hljs-number">0</span>];        <span class="hljs-type">char</span> content[TXT_SIZE];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++)            content[i] = msg[i + TXT_PTR];        <span class="hljs-type">char</span> time[TIME_SIZE];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++)            time[i] = msg[i + TIME_PTR];        <span class="hljs-keyword">switch</span> (type) {            <span class="hljs-comment">// new server message</span>            <span class="hljs-keyword">case</span> NEW_C:                <span class="hljs-built_in">print_message</span>(NEW, content);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// typed "quit" and all resources are released, exit the program</span>            <span class="hljs-keyword">case</span> EXIT_C:                <span class="hljs-comment">// end of the program</span>                <span class="hljs-built_in">print_toggle</span>(WARN, content);                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);            <span class="hljs-comment">// public normal message</span>            <span class="hljs-keyword">case</span> PUB_C:                <span class="hljs-comment">// get the sender's name</span>                <span class="hljs-type">char</span> fromUser[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++)                    fromUser[i] = msg[i + NAME_PTR];                <span class="hljs-comment">// print the message</span>                <span class="hljs-built_in">print_message</span>(PUB, content, time, fromUser);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// handle message from server</span>            <span class="hljs-keyword">case</span> SERVER_C:                <span class="hljs-comment">//get the time from the message</span>                <span class="hljs-type">char</span> time_ser[TIME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++)                    time_ser[i] = msg[i + TIME_PTR];                <span class="hljs-built_in">print_message</span>(SERVER, content, time_ser);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// private message</span>            <span class="hljs-keyword">case</span> PRI_C:                <span class="hljs-comment">// get the sender's name</span>                <span class="hljs-type">char</span> from_user[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++)                    from_user[i] = msg[i + NAME_PTR];                <span class="hljs-comment">// print the message</span>                <span class="hljs-built_in">print_message</span>(PRI, content, time, from_user);                <span class="hljs-keyword">break</span>;        }    }}</code></pre></div></div><h2 id="思考">思考</h2><p>在Java程序设计课上，也编写过一个聊天程序。那时只是机械的学习API，虽然也大致了解TCP，UDP的概念，但对于协议的设计还是非常朴素的。虽然本次实验的协议设计也比较简单，但随着学习的深入也会对此有更新的认识。比如很明显的一个设计缺陷是把时间放到了数据段之后。如果把数据段放到最后，可以通过增加长度字段来支持变长数据的传输。其他的比如数据校验等方面也可以继续改进。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网-应用层</title>
    <link href="/posts/31769/"/>
    <url>/posts/31769/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章">第一章</h2><h3 id="一些基本概念">一些基本概念</h3><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090215966691_917_image-20220921102100658.png" alt="image-20220921102100658"> <span class="math display">\[\frac{640*480*3}{1024}=900\text{KB}\]</span></p><h3 id="internet边缘与核心">Internet边缘与核心</h3><h4 id="电路交换">电路交换</h4><h5 id="时分和频分多路复用">时分和频分多路复用</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090217080225_394_image-20220921091644435.png" alt="image-20220921091644435"><figcaption aria-hidden="true">image-20220921091644435</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090219745396_605_image-20220914113833784.png" alt="image-20220914113833784" width="50%" height="50%"></p><h5 id="报文分组交换">报文分组交换</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090222052725_480_image-20220921090426643.png" alt="image-20220921090426643"><figcaption aria-hidden="true">image-20220921090426643</figcaption></figure><p>”谁来用谁,满了就丢“（当然刚满的时候有临时缓存）</p><p class="note note-secondary">由于成本问题，广域网带宽往往比局域网小得多。</p><p>问题：因为有排队现象，延迟大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090236334011_832_image-20220921091804148.png" alt="image-20220921091804148"><figcaption aria-hidden="true">image-20220921091804148</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090239402715_311_image-20220921092457252.png" alt="image-20220921092457252"><figcaption aria-hidden="true">image-20220921092457252</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090242065298_766_image-20220921102342289.png" alt="image-20220921102342289"><figcaption aria-hidden="true">image-20220921102342289</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090244516116_167_image-20220921102115526.png" alt="image-20220921102115526"><figcaption aria-hidden="true">image-20220921102115526</figcaption></figure><p>别忘了字节和bit的转换</p><h4 id="传输时延">传输时延</h4><p><font color="Apricot">别忘了RTP的定义</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090246765227_486_image-20221012101652816.png" alt="image-20221012101652816"><figcaption aria-hidden="true">image-20221012101652816</figcaption></figure><h3 id="web服务器访问示例">Web服务器访问示例</h3><p>网络体系结构概览，理解。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090248226957_689_image-20220921135514064.png" alt="image-20220921135514064"><figcaption aria-hidden="true">image-20220921135514064</figcaption></figure><h2 id="第二章">第二章</h2><h3 id="应用层协议和进程通信模型">应用层协议和进程通信模型</h3><h4 id="进程通信模型">进程通信模型</h4><p class="note note-primary"></p><p>进程之间如何通信？</p>1.管道 2.共享内存 3.消息队列<p></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090249957055_679_image-20220928093225868.png" alt="image-20220928093225868"><figcaption aria-hidden="true">image-20220928093225868</figcaption></figure><p class="note note-info">C/S模型的缺陷：如果访问量大的时候，会影响服务质量，甚至会导致中心服务器瘫痪P2P模型缺陷：不便于管理</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090255703101_824_image-20221012092450719.png" alt="image-20221012092450719"><figcaption aria-hidden="true">image-20221012092450719</figcaption></figure><p>D。客户机面向用户。其实主要注意C是对的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090257212133_865_image-20221012112533931.png" alt="image-20221012112533931"><figcaption aria-hidden="true">image-20221012112533931</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090258905463_489_image-20221012112556726.png" alt="image-20221012112556726"><figcaption aria-hidden="true">image-20221012112556726</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090300525887_688_image-20220928094631013.png" alt="image-20220928094631013"><figcaption aria-hidden="true">image-20220928094631013</figcaption></figure><h4 id="进程地址标识">进程地址标识</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090302563658_334_image-20220928101653200.png" alt="image-20220928101653200"><figcaption aria-hidden="true">image-20220928101653200</figcaption></figure><h4 id="应用层协议定义的内容">应用层协议定义的内容</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090304286709_112_image-20220928103019165.png" alt="image-20220928103019165"><figcaption aria-hidden="true">image-20220928103019165</figcaption></figure><h4 id="传输层">传输层</h4><p>作用：保证端到端服务的可靠性</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090306529509_443_image-20220928103725740.png" alt="image-20220928103725740"><figcaption aria-hidden="true">image-20220928103725740</figcaption></figure><p>UCP服务的不可靠是相对的，只是级别比较低。</p><p>UCP的优势：建立连接快，占用资源少，实现简单，不容易被监控</p><p class="note note-info">无论TCP还是UDP都没有提供任何加密机制，这就是说发送进程传进其套接字的数据，与经网络传送到目的进程的数据相同。因此，举例来说如果某发送进程以明文方式（即没有加密）发送了一个口令进入它的套接字，该明文口令将经过发送方与接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。因为隐私和其他安全问题对许多应用而言已经成为至关重要的问题，所以因特网界已经研制了TCP的加强版本，称为安全套接字层(SecureSocketsLayer，SSL)。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。</p><p>TCP/IP协议通常在操作系统的内核中实现</p><h4 id="socket">socket</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090312331202_111_image-20220928111844557.png" alt="image-20220928111844557"><figcaption aria-hidden="true">image-20220928111844557</figcaption></figure><p>TCP/UDP协议感性认识</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090313969554_614_image-20220928135917798.png" alt="image-20220928135917798" width="50%" height="50%"></p><h4 id="socket编程">socket编程</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090321048624_770_image-20221005095507884.png" alt="image-20221005095507884"><figcaption aria-hidden="true">image-20221005095507884</figcaption></figure><p>PowerPC采用大端序，其他CPU大多使用小端序。网络编程使用大端序。</p><h3 id="文件传输协议">文件传输协议</h3><p>FTP基于TCP的可靠服务</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090322840513_285_image-20221012093347724.png" alt="image-20221012093347724"><figcaption aria-hidden="true">image-20221012093347724</figcaption></figure><p>对应的，邮件传输是带内控制。</p><blockquote><p>FTP客户首先连接服务器的21号端口，建立控制连接（控制连接在整个会话期间一直保持打开)，然后建立数据连接，在数据传送完毕后，数据连接最先释放，控制连接最后释放。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090326097608_519_image-20221012095753630.png" alt="image-20221012095753630"><figcaption aria-hidden="true">image-20221012095753630</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090328651614_685_image-20221012095828837.png" alt="image-20221012095828837"><figcaption aria-hidden="true">image-20221012095828837</figcaption></figure><p>D</p><p class="note note-info">为什么FTP不适合共享读写文件？因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息是带外(Out-of-band)传送的？使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器，来回传送耗费很多时间。网络文件系统(NFS)采用另一种思路，它允许进程打开一个远程文件，并能在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p><blockquote><p>针对文件传输FTP，系统管理员建立了一个特殊的用户ID，名为anonymous，即匿名用户。Internet上的任何人在任何地方都可以使用该用户ID，只是在要求提供用户ID时必须输入anonymous，该用户ID的密码可以是任何字符串。</p></blockquote><p class="note note-info">为什么FTP要采用两个独立的连接？在FTP的实现中，客户与服务器之间采用了两条传输连接，其中控制连接用于传输各种FTP命令，而数据连接用于文件的传送。之所以这样设计，是因为使用两条独立的连接可使FTP变得更加简单、更容易实现、更有效率。同时在文件传输过程中，还可以利用控制连接控制传输过程，如客户可以请求终止、暂停传输等。</p><h3 id="web服务和http协议">Web服务和HTTP协议</h3><h4 id="最新最热http2.0">最新最热HTTP2.0</h4><h5 id="二进制分帧传输">二进制分帧传输</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090330394790_595_image-20221012105830716.png" alt="image-20221012105830716"><figcaption aria-hidden="true">image-20221012105830716</figcaption></figure><h5 id="tcp连接复用">TCP连接复用</h5><p>虽然想法很朴素，但确解决了为追求简单和仅适应文本传输的历史遗留问题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090332798519_644_image-20221012110140184.png" alt="image-20221012110140184"><figcaption aria-hidden="true">image-20221012110140184</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090334780017_529_image-20221012110329212.png" alt="image-20221012110329212"><figcaption aria-hidden="true">image-20221012110329212</figcaption></figure><h5 id="服务器推送和http头压缩">服务器推送和HTTP头压缩</h5><p>当然服务器推送也增加了服务器的压力，因为之前服务器并不需要关注传输的是什么内容</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090336747509_846_image-20221012110625529.png" alt="image-20221012110625529"><figcaption aria-hidden="true">image-20221012110625529</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090338868210_673_image-20221012111205235.png" alt="image-20221012111205235"><figcaption aria-hidden="true">image-20221012111205235</figcaption></figure><h4 id="cdn">CDN</h4><h4 id="dash">DASH</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090340524655_762_image-20221019092551081.png" alt="image-20221019092551081"><figcaption aria-hidden="true">image-20221019092551081</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090342143506_385_image-20221019092718918.png" alt="image-20221019092718918"><figcaption aria-hidden="true">image-20221019092718918</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20221026090343857447_572_image-20221019092804145.png" alt="image-20221019092804145"><figcaption aria-hidden="true">image-20221019092804145</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile急速入门</title>
    <link href="/posts/23557/"/>
    <url>/posts/23557/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile-急速入门">Makefile 急速入门</h1><p>或许你和我一样在没有接触过<code>makefile</code>的时候看到相对复杂一点的项目依赖感到头大。这里从最简单的情况，到常见用法，快速把<code>makefile</code>的基本用法捋一遍。</p><h2 id="最小示例">最小示例</h2><p>考察下面的示例代码：</p><p><em>main.c</em></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j21lsll9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-j21lsll9znqyqz"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>正常情况下，通过 <code>gcc</code>在命令行将其编译后产出相应文件，可执行文件或 object 文件等。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pfluy2l9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-pfluy2l9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o main.out main.c</span></code></pre></div></div><p>上面命令编译后运行 <code>main.out</code> 可执行文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-olla0ll9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-olla0ll9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main.out</span>hello world!</code></pre></div></div><h2 id="make-认知">Make 认知</h2><p>通过 <code>make</code>命令，可以将上面的编译进行有效自动化管理。通过将从输入文件到输出文件的编译无则编写成Makefile 脚本，Make 工具将自动处理文件间依赖及是否需要编译的检测。</p><p><code>make</code> 命令所使用的编译配置文件可以是<code>Makefile</code>，<code>makefile</code> 或<code>GUNMake</code>。</p><p>其中定义任务的基本语法为：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-429h02l9znqyqz"></i><span>jboss-cli</span><div class="collapse show" id="collapse-429h02l9znqyqz"><pre><code class="hljs jboss-cli">target1 [target2 <span class="hljs-string">...</span>]: [pre-req-1 pre-req-2 <span class="hljs-string">...</span>][<span class="hljs-keyword">command</span>1 <span class="hljs-keyword">command</span>2 <span class="hljs-string">......</span>]</code></pre></div></div><p>上面形式也可称作是一条编译规则（rule）。</p><p>其中，</p><ul><li><code>target</code>为任务名或文件产出。如果该任务不产出文件，则称该任务为<code>Phony Targets</code>。<code>make</code> 内置的 phony target 有<code>all</code>, <code>install</code> 及 <code>clean</code>等，这些任务都不实际产出文件，一般用来执行一些命令。</li><li><code>pre-req123...</code>这些是依赖项，即该任务所需要的外部输入，这些输入可以是其他文件，也可以是其他任务产出的文件。</li><li><code>command</code> 为该任务具体需要执行的 shell 命令。</li></ul><h2 id="makefile-实战">Makefile 实战</h2><p>比如文章最开始的编译，可通过编写下面的 Makefile 来完成：</p><p>在与<code>main.c</code>同目录下创建文件‘<code>makefile</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0h2upcl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-0h2upcl9znqyqz"><pre><code class="hljs shell">touch makefile</code></pre></div></div><p>填入以下内容：</p><p><em>Makefile</em></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uhfswvl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-uhfswvl9znqyqz"><pre><code class="hljs makefile"><span class="hljs-section">all:main.out</span><span class="hljs-section">main.out: main.c</span>gcc -o main.out main.c<span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>上面的 Makefile 中定义了三个任务，调用时可通过<code>make &lt;target name&gt;</code> 形式来调用。</p><p>比如:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dhogfnl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-dhogfnl9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make main.out</span>gcc -o main.out main.c</code></pre></div></div><p>产出 <code>main.out</code> 文件。</p><p>再比如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p9x5wcl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-p9x5wcl9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span>rm main.out</code></pre></div></div><p>该 <code>clean</code> 任务清除刚刚生成的 <code>main.out</code>文件。</p><p>三个任务中，<code>all</code> 为内置的任务名，一般一个 Makefile中都会包含，当直接调用 <code>make</code>后面没有跟任务名时，默认执行的就是 <code>all</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kra580l9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-kra580l9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span>gcc -o main.out main.c</code></pre></div></div><h2 id="任务间的依赖">任务间的依赖</h2><p>前面调用 <code>all</code> 的效果等同于调用 <code>main.out</code>任务，因为 <code>all</code> 的输入依赖为 <code>main.out</code>文件。Make 在执行任务前会先检查其输入的依赖项，执行 <code>all</code>时发现它依赖 <code>main.out</code>文件，于是本地查找，发现本地没有，再从 Makefile中查找看是否有相应任务会产生该文件，结果确实有相应任务能产生该文件，所以先执行能够产生依赖项的任务。</p><h2 id="增量编译">增量编译</h2><p>使用 Makefile进行编译有个好处是，在执行任务时，它会先检查依赖项是否比需要产出的文件新，如果说依赖项更新新，则说明我们需要产出的目标文件属于过时的产物，需要重新生成。</p><p>什么意思。比如上面的示例，当执行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rqotsil9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-rqotsil9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make main.out</span></code></pre></div></div><p>试图生成 <code>main.out</code> 产出时，会检查这个任务的依赖文件<code>main.c</code> 是否有修改过。</p><p>比如前面我们已经执行过该任务产生过<code>main.out</code>。再次执行时，会得到如下提示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7wryybl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-7wryybl9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make main.out</span> make: `main.out' is up to date.</code></pre></div></div><p><strong>NOTE:</strong> 上面是 Mac 上最新版本的 Make 工具（GNU Make3.81）的提示语，老版或其他变种工具得到的可能是<code>Nothing to be done for main.out</code> 。</p><p>现在对输入文件 <code>main.c</code> 进行修改：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lo2lj8l9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-lo2lj8l9znqyqz"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{-     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world!"</span>);+     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello wayou!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>再次执行 <code>make main.out</code>会发现任务正常执行并产生了新的输出，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rvzi8el9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-rvzi8el9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make main.out</span>gcc -o main.out main.c<span class="hljs-meta prompt_">$ </span><span class="language-bash">./main.out</span>hello wayou!⏎</code></pre></div></div><p>这里 <code>main.c</code> 修改后，它在文件上来说，就比<code>main.out</code> 更新了，所以我们说 <code>main.out</code>这个目标， <strong>过时（out-dated）</strong> 了。</p><p>过时的任务才会被重新执行，而未过时的会跳过，并输出相应信息。</p><p>以上，Makefile天然实现了增量编译的效果，在大型项目下会节省不少编译时间，因为它只编译过期的任务。</p><h2 id="phony-类型任务的执行">Phony 类型任务的执行</h2><p>需要注意的是，phony 类型的任务永远都属于过时类型，即，每次<code>make</code>都会执行。因为这种类型的任务它没有文件产出，就无所谓检查，它的主体只是调用了另外的命令而以。</p><p>拿这里的 <code>all</code> 来说，当我们执行 <code>make</code> 或<code>make all</code> 时，得到：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6ry89vl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-6ry89vl9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span>make: Nothing to be done for `all'.</code></pre></div></div><p>这里看不出来 <code>all</code>有没有执行，因为目前它还没有包含任何一句命令，调用 <code>all</code>后实际执行的是它的依赖文件 <code>main.out</code>中的任务，而因为后者已经是最新的了，所以无须执行，所以得到了如上的输出。</p><p>为了验证 phony 类型任务是否每次都执行，向 <code>all</code> 及<code>main.out</code> 中添加 <code>echo</code> 命令打印一些信息、</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-67ry2jl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-67ry2jl9znqyqz"><pre><code class="hljs makefile"><span class="hljs-section">all:main.out</span>+echo <span class="hljs-string">"[all] done"</span><span class="hljs-section">main.out: main.c</span>gcc -o main.out main.c+echo <span class="hljs-string">"[main.out] done"</span><span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>再次执行：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-19tnljl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-19tnljl9znqyqz"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span>echo "[all] done"[all] done<span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span>echo "[all] done"[all] done<span class="hljs-meta prompt_">$ </span><span class="language-bash">make main.out</span>make: `main.out' is up to date.</code></pre></div></div><p>可以看到，属于 phony 类型的任务 <code>all</code>每次都会执行其中定义的 shell 命令，而非 phony 类型的任务<code>main.out</code> 则走了增量编译的逻辑。</p><h2 id="变量宏">变量/宏</h2><p>Makefile 中可使用变量（宏）来让脚本更加灵活和减少冗余。</p><p>其中变量使用 <code>$</code>加圆括号或花括号的形式来使用，<code>$(VAR)</code>，定义时类似于 C中定义宏，所以变量也可叫 Makefile 中的宏，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dddhxnl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-dddhxnl9znqyqz"><pre><code class="hljs shell">CC=gcc</code></pre></div></div><p>这里定义 <code>CC</code> 表示 <code>gcc</code>编译工具。然后在后续编译命令中，就可以使用 <code>$(CC)</code> 代替<code>gcc</code> 来书写 shell 命令了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j3ycrll9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-j3ycrll9znqyqz"><pre><code class="hljs makefile">+ CC=gcc<span class="hljs-section">all:main.out</span><span class="hljs-section">main.out: main.c</span>-gcc -o main.out main.c+<span class="hljs-variable">$(CC)</span> -o main.out main.c<span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>这样做的好处是什么？因为编译工具可能随着平台或环境或需要编译的目标不同，而不同。比如<code>gcc</code> 只是用来编译 C 代码的，如果是 C++ 你可能要用<code>g++</code> 来编译。如果是编译 WebAssembly 则需要使用<code>emcc</code>。</p><p>无论怎样变，我们只需要修改定义在文件开头的 <code>CC</code>变量即可，无须修改其他地方。这当然只是其中一点好处。</p><h2 id="自动变量automatic-variables">自动变量/Automatic Variables</h2><p>自动变量/Automatic Variables是在编译规则匹配后工具进行设置的，具体包括：</p><ul><li><code>$@</code>：代表产出文件名</li><li><code>$*</code>：代表产出文件名不包括扩展名</li><li><code>$&lt;</code>：依赖项中第一个文件名</li><li><code>$^</code>：空格分隔的去重后的所有依赖项</li><li><code>$+</code>：同上，但没去重</li><li><code>$?</code>：同上，但只包含比产出更新的那些依赖</li></ul><p>这些变量都只有一个符号，区别于正常用字母命名的变量需要使用<code>$(VAL)</code> 的形式来使用，自动变量无需加括号。</p><p>利用自动变量，前面示例可改造成：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0ytlh2l9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-0ytlh2l9znqyqz"><pre><code class="hljs makefile">CC=gccTARGET=main.out<span class="hljs-section">all:<span class="hljs-variable">$(TARGET)</span></span><span class="hljs-variable">$(TARGET)</span>: main.c<span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-section">clean:</span>rm <span class="hljs-variable">$(TARGET)</span></code></pre></div></div><p>减少了重复代码，更加易于维护，需要修改时，改动比较小。</p><h2 id="vpath-vpath">VPATH &amp; vpath</h2><p>可通过 <code>VPATH</code> 指定依赖文件及产出文件的搜索目录。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8smxscl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-8smxscl9znqyqz"><pre><code class="hljs makefile">VPATH = src <span class="hljs-keyword">include</span></code></pre></div></div><p>通过小写的 <code>vpath</code> 可指定具体的文件名及扩展名类型，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-42wgrcl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-42wgrcl9znqyqz"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.c src<span class="hljs-keyword">vpath</span> %.h <span class="hljs-keyword">include</span></code></pre></div></div><p>此处 <code>%</code> 表示文件名。</p><h2 id="依赖规则dependency-rules">依赖规则/Dependency Rules</h2><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-34ykk4l9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-34ykk4l9znqyqz"><pre><code class="hljs makefile">Main.o : Main.h Test1.h Test2.hTest1.o : Test1.h Test2.hTest2.o : Test2.h</code></pre></div></div><p>像这种，只定义了产出与依赖没包含任务命令的无则，叫作依赖无则。因为它只定义了某个产出依赖哪些输入，故名。</p><p>这种规则可达到这种效果，即，右边任何文件有变更，左边的产出便成为过时的了。</p><h2 id="匹配规则pattern-rules">匹配规则/Pattern Rules</h2><p>区别于明确指定了产出与依赖，如果一条规则包含通配符，则称作匹配规则（PatternRules）。</p><p>比如，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nmub86l9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-nmub86l9znqyqz"><pre><code class="hljs makefile"><span class="hljs-section">%.o: %.c</span>    gcc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span></code></pre></div></div><p>上面定义了这么一条编译规则，将所有匹配到的 c 文件编译成 Object产出。</p><p>有什么用？</p><p>这种规则一般不是直接调用的，是被其他它规则触间接使用。比如上面的依赖规则。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s1mjhsl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-s1mjhsl9znqyqz"><pre><code class="hljs makefile">%.o : %.cpp  g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Main.o : Main.h Test1.h Test2.hTest1.o : Test1.h Test2.hTest2.o : Test2.h</code></pre></div></div><p>当右侧这些头文件有变动时，左边的产出会在 <code>make</code>时被检测到过时，于是会被执行。当执行时匹配规则 <code>%.o</code>会被匹配到，所以匹配规则里面的命令会执行，从而将 <code>cpp</code>文件编译成相应 Object文件。达到了依赖更新后批量更新产出的目的，而不需要写成这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xmv6uwl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-xmv6uwl9znqyqz"><pre><code class="hljs makefile">Main.o : Main.h Test1.h Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Test1.o : Test1.h Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Test2.o : Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span></code></pre></div></div><h2 id="makefile-函数">Makefile 函数</h2><p>函数主要分为两类：make内嵌函数和用户自定义函数。对于 GNUmake内嵌的函数，直接引用就可以了；对于用户自定义的函数，要通过make的call函数来间接调用。</p><h3 id="通配符函数">通配符函数</h3><p>当我们想要对文件名进行通配时，可以采用通配符*或%来进行，如上所述。但只能将其用于规则目标或依赖以及<code>shell</code>命令中：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lmxbbdl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-lmxbbdl9znqyqz"><pre><code class="hljs makefile"><span class="hljs-section">test: *.o  </span>gcc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-section">*.o: *.c    </span>gcc -c <span class="hljs-variable">$^</span></code></pre></div></div><p>但是其他情况比如如果我们想要获取某个目录下所有的C文件列表，可以使用扩展通配符函数<code>wildcard</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dcal39l9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-dcal39l9znqyqz"><pre><code class="hljs makefile">SRC  = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span>HEAD = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.h)</span><span class="hljs-section">all:    </span>@echo <span class="hljs-string">"SRC = <span class="hljs-variable">$(SRC)</span>"</span>    @echo <span class="hljs-string">"HEAD = <span class="hljs-variable">$(HEAD)</span>"</span></code></pre></div></div><h3 id="文本处理函数">文本处理函数</h3><p>如果需要在makefile里进行文件名查找、替换、过滤等操作，则文本处理函数能够帮到忙。可以参阅<a href="https://www.zhaixue.cc/makefile/makefile-text-func.html">这个网站</a>的介绍。</p><h3 id="shell-函数">shell 函数</h3><p>用shell函数在<code>makefile</code>执行过程中使用shell命令。函数的参数就是命令，返回值是命令的执行结果。它和反引号`` 具有相同的功能。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ms07i8l9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-ms07i8l9znqyqz"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span>current_path = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">all:    </span>@echo <span class="hljs-string">"current_path = <span class="hljs-variable">$(current_path)</span>"</span></code></pre></div></div><h3 id="用户自定义函数">用户自定义函数</h3><p>GNUmake提供了大量的内嵌函数，大大方便了makefile编写。但根据需要，我们也需要自定义一些函数，然后在makefile中引用它们：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1gi8bgl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-1gi8bgl9znqyqz"><pre><code class="hljs makefile"><span class="hljs-section">PHONY: all</span><span class="hljs-keyword">define</span> func    @echo <span class="hljs-string">"pram1 = $(0)"</span>    @echo <span class="hljs-string">"pram2 = $(1)"</span><span class="hljs-keyword">endef</span><span class="hljs-section">all:    </span><span class="hljs-variable">$(<span class="hljs-built_in">call</span> func, hello zhaixue.cc)</span></code></pre></div></div><p>用户自定义函以define开头，endef结束，给函数传递的参数在函数中使用$(0)、$(1)引用，分别表示第1个参数、第2个参数…调用时要使用call函数间接调用，各个参数之间使用空格隔开。</p><h2 id="参考链接">参考链接</h2><p>如果希望进行更深入的了解可以参阅：</p><p><a href="https://www.gnu.org/software/make/">官网</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html#zz-2.">GCCand Make Compiling, Linking and Building C/C++ Applications</a></p><p>以及中文教程：</p><p><a href="https://www.zhaixue.cc/makefile/makefile-intro.html">宅学部落</a></p>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++拾遗-基本语法和运算</title>
    <link href="/posts/43168/"/>
    <url>/posts/43168/</url>
    
    <content type="html"><![CDATA[<h2 id="c回顾复习">C++回顾复习</h2><h3 id="认识c">认识C++</h3><h4 id="基本概念和词汇">基本概念和词汇</h4><p>main不是C++中的保留字。因此<code>int main;</code>在C++中合法。</p><p>下列哪个是C++语言的合法的字符常量 "0" '054’ ‘' ‘\092’</p><blockquote><p>A选项，双引号表示的是字符串常量；B选项054表示八进制整数，但是缺少转义符号；D选项是将其后的整数092表示八进制整数，但是八进制不存在9这个数。注意，单引号表示的字符常量，可以是整数，但必须带有转义符号，其字符常量为整数表示的ASC码对应的字符</p></blockquote><p>一个经常设坑的点：八进制表达中出现8或9</p><h4 id="枚举常量">枚举常量</h4><p><code>enum t1 {a1,a2=7,a3,a4=15}time;</code></p><p>则枚举常量<code>a1</code>和<code>a3</code>的值分别是0和8</p><p>枚举值对应的整数值可以是任意整数。</p><p>注意区分枚举类型定义和枚举类型变量定义。前者定义的数据类型，后者是定义变量。定义类型名时不应该有=</p><p class="note note-warning">因此 enum a=[one,two,three);是不对的</p><p>还可以这样写</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7rjivml9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-7rjivml9znqyqz"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">team</span>{my, your=<span class="hljs-number">4</span>, his, her=his+<span class="hljs-number">10</span>};cout&lt;&lt;my&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;your&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;his&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;her&lt;&lt;endl;</code></pre></div></div><p>结果<code>0 4 5 15</code></p><h4 id="string">string</h4><p>关于字符串类型</p><p>使用<code>.length()</code>和<code>strlen()</code>时计算的字符串长度都不包含<code>\0</code></p><p class="note note-warning">注意:+不支持两个字符串字面常量的连接,如 string word4 "hello"+"world!";</p><h3 id="运算符和表达式">运算符和表达式</h3><h4 id="基本概念">基本概念</h4><p>在学习了编译原理之后，对这些概念以及对应的“奇特”写法应当已经见怪不怪。但为应对考试，仍记录以备复习。</p><h5 id="表达式">表达式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201307860409_128_image-20221013141835992.png" alt="image-20221013141835992"><figcaption aria-hidden="true">image-20221013141835992</figcaption></figure><p>注意，“表达式”不带分号，带了分号就是语句。</p><h4 id="优先级和结合性">优先级和结合性</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ri4bmgl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-ri4bmgl9znqyqz"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//test 1</span>    <span class="hljs-type">int</span> k, a, b, c;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> w = <span class="hljs-number">5</span>;    <span class="hljs-type">double</span> x = <span class="hljs-number">1.42</span>;<span class="hljs-comment">//    x%(-3); &lt;Invalid operands to binary expression ('double' and 'int')&gt;</span>    w += <span class="hljs-number">-2</span>; <span class="hljs-comment">// w=3</span>    k = (a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b); <span class="hljs-comment">// k=5</span>    c = k = a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b; <span class="hljs-comment">// c=5, k=2, a=2, b=3</span>    a += a -= (b = <span class="hljs-number">4</span>) * (a = <span class="hljs-number">3</span>); <span class="hljs-comment">// a=-18, b=4</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a=%d"</span>, a);    <span class="hljs-comment">//test 2</span>    <span class="hljs-type">int</span> d2i = <span class="hljs-string">'A'</span> + <span class="hljs-number">1.6</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a2=%d"</span>, d2i); <span class="hljs-comment">//'A'+1.6=66.6=66 (ASCII code of 'A' is 65)</span>    <span class="hljs-comment">//test3</span><span class="hljs-comment">/*    d=9+e+f=d+9;</span><span class="hljs-comment">    expression is a value, not a variable in the memory,so it is not assignable */</span>}</code></pre></div></div><p><a href="https://blog.csdn.net/zb_915574747/article/details/99704639">优先级和结合性一览</a></p><h4 id="赋值运算">赋值运算</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-69xjmbl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-69xjmbl9znqyqz"><pre><code class="hljs c++">设有intx=<span class="hljs-number">11</span>：，则表达式(x++*<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)的值是</code></pre></div></div><p><span class="math inline">\(\lfloor 11*1/3 \rfloor=3\)</span></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201309887843_159_image-20221013142054782.png" alt="image-20221013142054782"><figcaption aria-hidden="true">image-20221013142054782</figcaption></figure><p>做题时容易犯的错误：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mgrn34l9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-mgrn34l9znqyqz"><pre><code class="hljs c++">若d为<span class="hljs-type">double</span>型变量，则表达式d=<span class="hljs-number">1</span>，d+<span class="hljs-number">5</span>，d++的值是<span class="hljs-number">1</span>。d+<span class="hljs-number">5</span>不是d=d+<span class="hljs-number">5</span>。虽然很明显，做题的时候也需要有注意的意识</code></pre></div></div><h4 id="逻辑运算">逻辑运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201311747149_485_image-20221020095906292.png" alt="image-20221020095906292"><figcaption aria-hidden="true">image-20221020095906292</figcaption></figure><p>注意算术运算符优先于关系和除非以外的逻辑运算符！</p><p>短路运算举例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ttqjzrl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-ttqjzrl9znqyqz"><pre><code class="hljs c++">×=y=<span class="hljs-number">3</span>;t=++x||++y后，y的值是</code></pre></div></div><blockquote><p>3，因为后面不会被运算</p></blockquote><p>优先级只是起“加括号”的作用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5kcaj2l9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-5kcaj2l9znqyqz"><pre><code class="hljs c++"><span class="hljs-type">int</span> c,h;std::cout&lt;&lt;((c=<span class="hljs-number">2</span>)&amp;&amp;(h=<span class="hljs-number">-2</span>));<span class="hljs-comment">//always true</span></code></pre></div></div><h4 id="位运算">位运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201313889596_775_image-20221020105755065.png" alt="image-20221020105755065"><figcaption aria-hidden="true">image-20221020105755065</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201315728635_334_image-20221020104858172.png" alt="image-20221020104858172"><figcaption aria-hidden="true">image-20221020104858172</figcaption></figure><p>注意位运算的“地位”不是平等的，不要想当然按顺序算</p><h4 id="条件和逗号运算符">条件和逗号运算符</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/c%2B%2B%E6%8B%BE%E9%81%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/20221020201317368932_518_image-20221020111433316.png" alt="image-20221020111433316"><figcaption aria-hidden="true">image-20221020111433316</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bdjhkdl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-bdjhkdl9znqyqz"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">{</span></span><span class="hljs-params"><span class="hljs-function">cout&lt;&lt;(<span class="hljs-number">0101</span>&amp;<span class="hljs-number">101</span>&gt;&gt;<span class="hljs-number">3</span>|<span class="hljs-number">101</span>&lt;&lt;<span class="hljs-number">3</span>^~<span class="hljs-number">0x10</span>)&lt;&lt;endl;</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span></span><span class="hljs-params"><span class="hljs-function">}</span></span><span class="hljs-params"><span class="hljs-function"></span></span></code></pre></div></div><blockquote><p>优先级按位取反~最高，先将0x10（十六进制）按位取反，得到结果1111111111111111 1111111111101111，其次优先级按位左移和按位右移运算符优先级相同，计算101&gt;&gt;3得到00000000 00000000 00000000 00001100，以及101&lt;&lt;3得到 0000000000000000 0000001100101000，接下来计算0101（八进制）按位与（101&gt;&gt;3）的结果，得到结果为0,0按位或一个数所得结果为原值。因此最终答案为(101&lt;&lt;3)按位异或(~0x10)的结果，其结果为1111111111111111 11111100 11000111，为负数，求补得到绝对值。特别需要注意的是取反的时候是对整个int取反，16变-17</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ug7opcl9znqyqz"></i><span>c++</span><div class="collapse show" id="collapse-ug7opcl9znqyqz"><pre><code class="hljs c++">设intm=<span class="hljs-number">5</span>；<span class="hljs-type">float</span> x=<span class="hljs-number">3.5</span>；则表达式m+x+<span class="hljs-number">4.5</span>的结果应占据[填空]个字节。<span class="hljs-comment">//8.在隐式类型转换中转向了double</span></code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理一二章</title>
    <link href="/posts/34738/"/>
    <url>/posts/34738/</url>
    
    <content type="html"><![CDATA[<h2 id="编译原理一二章">编译原理一二章</h2><h3 id="lec1从代码到可执行文件">Lec1从代码到可执行文件</h3><h4 id="编译器要做哪些事情">编译器要做哪些事情？</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190733227216_229_image-20220929095525300.png" alt="image-20220929095525300"><figcaption aria-hidden="true">image-20220929095525300</figcaption></figure><h5 id="一些gcc编译选项">一些gcc编译选项</h5><h6 id="actions"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id6">Actions</a></h6><p>The action to perform on the input.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wcue3fl9znqyr0"></i><span>shell</span><div class="collapse show" id="collapse-wcue3fl9znqyr0"><pre><code class="hljs shell">-E, --preprocessOnly run the preprocessor-S, --assembleOnly run preprocess and compilation steps-c, --compileOnly run preprocess, compile, and assemble steps-emit-llvmUse the LLVM representation for assembler and object files</code></pre></div></div><h6 id="compilation-flags"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id7">Compilationflags</a></h6><p>Flags controlling the behavior of Clang during compilation. Theseflags have no effect during actions that do not perform compilation.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6gzuyxl9znqyr0"></i><span>shell</span><div class="collapse show" id="collapse-6gzuyxl9znqyr0"><pre><code class="hljs shell">-Xassembler &lt;arg&gt;`Pass &lt;arg&gt; to the assembler-Xclang &lt;arg&gt;, -Xclang=&lt;arg&gt;Pass &lt;arg&gt; to clang -cc1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190735472529_960_image-20220920154109066.png" alt="image-20220920154109066"><figcaption aria-hidden="true">image-20220920154109066</figcaption></figure><p>上面是<strong>抽象语法树</strong>：简化，只包含程序中出现的单词</p><p>下面是<strong>语义分析树（具体语法树）</strong>：完整，还包含抽象出的语法概念</p><h5 id="对过程的相关理解">对过程的相关理解</h5><p class="note note-info">C++编译器检查相容类型计算是否合规是在语义分析阶段编译器识别出标识符是在词法分析阶段</p><p class="note note-warning">C++编译器过滤注释是在_<strong>阶段。答案是词法分析，但实践表明预处理阶段就已经过滤注释了。C++编译器检查数组下标越界是在</strong>_阶段 C++并不会检查数组下标越界。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190736776341_330_image-20220920162038518.png" alt="image-20220920162038518"><figcaption aria-hidden="true">image-20220920162038518</figcaption></figure><p>显然符号表中不会存变量值，因为变量值在运行时才会确定。</p><p class="note note-info">符号表是在词法分析阶段创建的。(习题)</p><p>但是据龙书：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190738941427_725_image-20221004193852281.png" alt="image-20221004193852281"><figcaption aria-hidden="true">image-20221004193852281</figcaption></figure><h3 id="lec2-构造一个简单的编译器">Lec2 构造一个简单的编译器</h3><h4 id="上下文无关文法">上下文无关文法</h4><h5 id="感性理解">感性理解</h5><p>BNF 是一种<strong>上下文无关文法</strong>，那什么是上下文相关文法(CSG呢？</p><p>CSG 在 CFG的基础上进一步放宽限制。</p><p>产生式的左手边也可以有终结符和非终结符。左手边的终结符就是“上下文”的来源。也就是说匹配的时候不能光看当前匹配到哪里了，还得看当前位置的左右到底有啥（也就是上下文是啥），上下文在这条规则应用的时候并不会被消耗掉，只是“看看”。</p><h5 id="形式化定义">形式化定义</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190740496671_209_image-20220927144906987.png" alt="image-20220927144906987"><figcaption aria-hidden="true">image-20220927144906987</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190741666990_453_image-20220927144926174.png" alt="image-20220927144926174"><figcaption aria-hidden="true">image-20220927144926174</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190742819758_795_image-20220927144938067.png" alt="image-20220927144938067"><figcaption aria-hidden="true">image-20220927144938067</figcaption></figure><p>对闭包的理解</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190743880629_933_image-20220927144950874.png" alt="image-20220927144950874"><figcaption aria-hidden="true">image-20220927144950874</figcaption></figure><p>正闭包也叫正则闭包</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190746344914_185_image-20220927145026025.png" alt="image-20220927145026025"><figcaption aria-hidden="true">image-20220927145026025</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190747551802_775_image-20221004164810301.png" alt="image-20221004164810301"><figcaption aria-hidden="true">image-20221004164810301</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190748466161_250_image-20220927150609696.png" alt="image-20220927150609696"><figcaption aria-hidden="true">image-20220927150609696</figcaption></figure><p>在词法分析阶段，所有的expr都是同等对待的，因此不需要加下标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190749626754_765_image-20220927150731839.png" alt="image-20220927150731839"><figcaption aria-hidden="true">image-20220927150731839</figcaption></figure><p>idlist也可用右递归表示。两种方式等价，但生成的语法分析树不一样。</p><p>另外一种设计方案</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190750857129_584_image-20220927155732458.png" alt="image-20220927155732458" width="50%" height="50%"></p><h5 id="二义性语法和非二义性语法">二义性语法和非二义性语法</h5><p>非二义性语法</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190751862164_535_image-20220927154102321.png" alt="image-20220927154102321"><figcaption aria-hidden="true">image-20220927154102321</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190753296213_768_image-20220927154131189.png" alt="image-20220927154131189" width="50%" height="50%"></p><p>采用二义性语法，则会产生歧义问题，同一段代码在不同编译器上产生不一样的结果，显然是我们不想看到的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190754314719_452_image-20220927154314035.png" alt="image-20220927154314035"><figcaption aria-hidden="true">image-20220927154314035</figcaption></figure><p>但是在一定的场合下，通过设计合理的语法分析算法，我们是容许一定的二义性的，因为可以减小语法分析树的复杂性。</p><p>文法左递归，体现出运算符左结合，右递归则是右结合。</p><p>一个右结合的例子</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190755524185_246_image-20220927155426816.png" alt="image-20220927155426816" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190756637988_463_image-20220927161055294.png" alt="image-20220927161055294"><figcaption aria-hidden="true">image-20220927161055294</figcaption></figure><p>注意：不要跳级！左结合的，且从左往右替换。</p><h5 id="练习">练习</h5><h6 id="推导练习">推导练习</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190758243317_959_image-20220927161040537.png" alt="image-20220927161040537"><figcaption aria-hidden="true">image-20220927161040537</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190759789619_359_image-20220928164050330.png" alt="image-20220928164050330"><figcaption aria-hidden="true">image-20220928164050330</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190801270074_244_image-20220928164220732.png" alt="image-20220928164220732"><figcaption aria-hidden="true">image-20220928164220732</figcaption></figure><ol type="1"><li>S -&gt; 0 S 1 | 0 1</li><li>S -&gt; + S S | - S S | a</li><li>S -&gt; S ( S ) S | ε</li><li>S -&gt; a S b S | b S a S | ε</li></ol><p>生成的语言：</p><ol type="1"><li><p>L = {0<sup>n</sup>1<sup>n</sup> | n&gt;=1}</p></li><li><p>L = {支持加法和减法的表达式的前缀表达形式}</p></li><li><p>L = {匹配括号的任意排列和嵌套的括号串，包括 ε}</p><p>()() (()())等</p><p>有二义性：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221025232537498298_547_2.2.3-3.png" alt="2.2.3-3"><figcaption aria-hidden="true">2.2.3-3</figcaption></figure></li><li><p>L = {数量相同的a和b组成的符号串，包括 ε}</p></li></ol><p class="note note-warning">一个文法有二义性不一定就有两个推导！但一定有两课语法树</p><p><a href="https://blog.csdn.net/severestcritic/article/details/109816062?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109816062-blog-88792616.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109816062-blog-88792616.pc_relevant_aa&amp;utm_relevant_index=1">证明语法具有二义性的方法</a></p><h6 id="构建练习">构建练习</h6><p>①</p><p>通常左递归对应左结合，右递归对应右结合。</p><p>比如对于标识符列表：</p><ol type="1"><li>list -&gt; list , id | id</li><li>list -&gt; id , list | id</li></ol><p>1是左结合的，2是右结合的。</p><p>②</p><ol type="1"><li><p>证明：用下面文法生成的所有二进制串的值都能被3整除。`</p><p>num -&gt; 11 | 1001 | num 0 | num num</p><p>符合该文法的二进制串一定是由任意数量的 11，1001 和 0组成的最左位不为0的序列</p><p>该序列的十进制和为： <span class="math display">\[sum =\Sigma_n\left(2^1+2^0\right) *2^n+\Sigma_m\left(2^3+2^0\right) *2^m\\=\Sigma_n 3*2^n+\Sigma_m 9 * 2^m\]</span></p><p>显然是能被3整除的</p></li><li><p>上面的文法是否能生成所有能被3整除的二进制串？</p><p>不能。二进制串10101，数值为21，可被3整除，但无法由文法推导出。</p></li></ol><h4 id="语法制导翻译">语法制导翻译</h4><p>构造翻译模式，中缀-&gt;后缀构造9-5+2的带语义动作的语法分析树，即输出其后缀表达式95-2+</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190802895392_835_image-20220927164002512.png" alt="image-20220927164002512"><figcaption aria-hidden="true">image-20220927164002512</figcaption></figure><p>按深度优先遍历即可打印（翻译）出后缀表达式</p><h4 id="语法分析">语法分析</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190804367395_700_image-20221004152318374.png" alt="image-20221004152318374"><figcaption aria-hidden="true">image-20221004152318374</figcaption></figure><h5 id="自顶向下构造">自顶向下构造</h5><h6 id="平凡算法扫描输入分析">平凡算法：扫描输入分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190808051693_827_image-20221004153229852.png" alt="image-20221004153229852"><figcaption aria-hidden="true">image-20221004153229852</figcaption></figure><h6 id="优化预测分析">优化：预测分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190811525061_463_image-20221004152448359.png" alt="image-20221004152448359"><figcaption aria-hidden="true">image-20221004152448359</figcaption></figure><p><span class="math inline">\(lookahead\)</span>在构造编译器的时候就可以完成。</p><p>实例分析</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190813022183_796_image-20221004152827769.png" alt="image-20221004152827769"><figcaption aria-hidden="true">image-20221004152827769</figcaption></figure><p>对于<span class="math inline">\(simple\)</span>类似构造方法。</p><p><span class="math inline">\(lookahead\)</span>怎么构造？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190816136501_201_image-20221004153753520.png" alt="image-20221004153753520"><figcaption aria-hidden="true">image-20221004153753520</figcaption></figure><p>总体思路是什么，还有什么问题？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190818280251_227_image-20221004154007046.png" alt="image-20221004154007046"><figcaption aria-hidden="true">image-20221004154007046</figcaption></figure><h5 id="左递归问题">左递归问题</h5><p>针对上面的预测分析法，我们发现：左递归会导致递归下降程序无限循环以及预测分析法的失效。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-soqdz7l9znqyr0"></i><span>c</span><div class="collapse show" id="collapse-soqdz7l9znqyr0"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">switch</span>(lookahead){        <span class="hljs-keyword">case</span> a:            A();match(a);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> b:            match(b):<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            report(<span class="hljs-string">"syntax error"</span>)    }}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190819993463_865_image-20221004160548627.png" alt="image-20221004160548627"><figcaption aria-hidden="true">image-20221004160548627</figcaption></figure><p>怎么消除？</p><p>固定的算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190821656013_971_image-20221004160612826.png" alt="image-20221004160612826"><figcaption aria-hidden="true">image-20221004160612826</figcaption></figure><p>理解：<span class="math inline">\(A=\beta \alpha \alpha...\)</span></p><p>采用右递归进行翻译</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190823148967_751_image-20221004161628877.png" alt="image-20221004161628877"><figcaption aria-hidden="true">image-20221004161628877</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221008190827034211_692_image-20221004161643180.png" alt="image-20221004161643180"><figcaption aria-hidden="true">image-20221004161643180</figcaption></figure><h5 id="练习-1">练习</h5><p>构造 S -&gt; S ( S ) S | ε 的语法分析器</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xwtvjdl9znqyr0"></i><span>python</span><div class="collapse show" id="collapse-xwtvjdl9znqyr0"><pre><code class="hljs python"><span class="hljs-comment"># a program to test lookahead grammar analysis</span><span class="hljs-comment"># S -&gt; S ( S ) S | ε to match brackets</span><span class="hljs-comment"># it can be simplified to S -&gt; ( S ) S | ε</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matcher</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, string</span>):        self.string = string        self.index = <span class="hljs-number">0</span>        self.lookahead = self.string[self.index] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.string) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>        self.process = <span class="hljs-string">"S"</span>        self.lookaheads = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">self, char</span>):        <span class="hljs-keyword">if</span> char == <span class="hljs-string">''</span>:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">elif</span> char == self.lookahead:            self.index += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> self.index &lt; <span class="hljs-built_in">len</span>(self.string):                self.lookahead = self.string[self.index]            <span class="hljs-keyword">else</span>:                self.lookahead = <span class="hljs-string">""</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not matched"</span>)            exit(<span class="hljs-number">1</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">S</span>(<span class="hljs-params">self</span>):        self.lookaheads.append(self.lookahead)        <span class="hljs-keyword">if</span> self.lookahead == <span class="hljs-string">'('</span>:            self.process = self.process.replace(<span class="hljs-string">"S"</span>, <span class="hljs-string">"( S ) S"</span>, <span class="hljs-number">1</span>)            <span class="hljs-built_in">print</span>(self.process)            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">'('</span>)            self.S()            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">')'</span>)            self.S()        <span class="hljs-keyword">else</span>:            self.process = self.process.replace(<span class="hljs-string">"S"</span>, <span class="hljs-string">"ε"</span>, <span class="hljs-number">1</span>)            <span class="hljs-built_in">print</span>(self.process)            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">''</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self</span>):        self.S()        <span class="hljs-keyword">if</span> self.lookahead == <span class="hljs-string">''</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Matched"</span>)            <span class="hljs-built_in">print</span>(self.process)            <span class="hljs-built_in">print</span>(self.lookaheads)        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not matched,the lookahead now is"</span>, self.lookahead)            <span class="hljs-built_in">print</span>(self.process)            <span class="hljs-built_in">print</span>(self.lookaheads)            exit(<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Enter a string to match: "</span>)    target = <span class="hljs-built_in">input</span>()    matcher = Matcher(target)    matcher.main()</code></pre></div></div><p>运行结果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_article_resources/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20221025232547008661_894_image-20221009204230516.png" alt="image-20221009204230516"><figcaption aria-hidden="true">image-20221009204230516</figcaption></figure><h4 id="词法分析">词法分析</h4>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索_索引构建、压缩及查询支持</title>
    <link href="/posts/16720/"/>
    <url>/posts/16720/</url>
    
    <content type="html"><![CDATA[<h2 id="信息检索第一部分--索引构建">信息检索第一部分--索引构建</h2><h3 id="倒排索引构建">倒排索引构建</h3><p>六个步骤</p><p>序列化，语言预处理，分配DocID，排序，归并，添加频率标签</p><p class="note note-info">为什么要加文本频率？ 便于进行词频的排序，利于后续查询优化</p><h3 id="倒排索引布尔查询">倒排索引布尔查询</h3><p>略。并行课有涉及。比如当求交时可以先将短的链表求交。</p><h3 id="倒排索引优化改进">倒排索引优化改进</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143627586751_718_image-20220922093753305.png" alt="image-20220922093753305"><figcaption aria-hidden="true">image-20220922093753305</figcaption></figure><p>为了减少字符串所占用的内存，我们可以将键进行序列化。</p><p>Assume we have 1GB of text 800,000 documents 100 million tokens（Reuters-RCV1 collection）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143628933413_566_image-20220922094643439.png" alt="image-20220922094643439" width="50%" height="50%"></p><p>（假设是用int存docID）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143629914308_735_image-20220922095054178.png" alt="image-20220922095054178" width="50%" height="50%"></p><p>16*1.4</p><p>看上去很好。</p><p>然而，代价是必须要维护一张termID和字符串的映射表。</p><p>当需要处理的数据特别多时，由于排序，归并过程中所有的数据都需要这个表，就不得不一直将它放到内存里。</p><h4 id="bsbiblocked-sort-based-indexing">BSBI（Blocked Sort-BasedIndexing）</h4><p>仍然保留进行映射的策略</p><p>此算法的主要步骤如下：</p><p>1、将文档中的词进行id的映射，这里可以用hash的方法去构造</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143631068932_652_image-20220922100056227.png" alt="image-20220922100056227" width="50%" height="50%"></p><p>当然，可以先把全部文档读一遍构建映射，再分块构建倒排索引，也可以在构建每一块的倒排索引的时候边构建边映射。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143632700535_256_image-20220922101046446.png" alt="image-20220922101046446" width="50%" height="50%"></p><p>2、将文档分割成大小相等的部分。分治</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143634153162_211_image-20220922095854934.png" alt="image-20220922095854934" width="50%" height="50%"></p><p>3、将每部分按照词ID对上文档ID的方式进行排序（保证分块可以在内存里放下）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143635299312_759_image-20220922095946828.png" alt="image-20220922095946828" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143636457198_361_image-20220922100557902.png" alt="image-20220922100557902"><figcaption aria-hidden="true">image-20220922100557902</figcaption></figure><p>4、将每部分排序好后的结果进行合并，最后写出到磁盘中。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143637743125_385_image-20220922095721101.png" alt="image-20220922095721101" width="50%" height="50%"></p><p>归并的过程中也可以分治，比如内存中只能放100个词条的总倒排索引，可以在第100个的时候写出磁盘（因为已经确定是最后结果了），从101个再继续。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143639158715_536_image-20220922102146120.png" alt="image-20220922102146120" width="50%" height="50%"></p><h4 id="spimisingle-pass-in-memory-indexing">SPIMI（Single-PassIn-Memory Indexing）</h4><p>不作映射，其他与BSBI一样</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143640277003_250_image-20220922101959755.png" alt="image-20220922101959755" width="50%" height="50%"></p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143641398914_475_image-20220922102104189.png" alt="image-20220922102104189" width="50%" height="50%"></p><p>因为D显然要比T小的多</p><h4 id="分布式解决方案mapreduce">分布式解决方案MapReduce</h4><p>大数据实训有涉及，略。</p><h3 id="在线索引构建">在线索引构建</h3><h4 id="朴素方案">朴素方案</h4><h5 id="朴素方案一重建索引">朴素方案一：重建索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143642866848_892_image-20220928141323699.png" alt="image-20220928141323699"><figcaption aria-hidden="true">image-20220928141323699</figcaption></figure><h5 id="朴素方案二辅助索引">朴素方案二：辅助索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143644019596_168_image-20220928141427687.png" alt="image-20220928141427687"><figcaption aria-hidden="true">image-20220928141427687</figcaption></figure><p>使用辅助索引的话，一个很简便的思路是一个词建一个文档，归并便变为两个文档的合并。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143645445454_230_image-20220928141820357.png" alt="image-20220928141820357"><figcaption aria-hidden="true">image-20220928141820357</figcaption></figure><p>有什么缺陷？文件大小可能差距很大，且大量小文件不便于存储和对索引的快速读写（存储系统的问题）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143646682137_270_image-20220928142759774.png" alt="image-20220928142759774"><figcaption aria-hidden="true">image-20220928142759774</figcaption></figure><p>更大的问题，随着文档的数量变大，归并会越来越慢！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143647947499_639_image-20220928142854979.png" alt="image-20220928142854979"><figcaption aria-hidden="true">image-20220928142854979</figcaption></figure><p>合并时termID是有序的，归并时类似于归并排序，最坏复杂度是较大的那个索引的termID个数。而单个倒排索引合并只需要把新的list放到旧的后面就可以了，因为新的list中的docID肯定会比旧的大（就像上面图上所示）<span class="math display">\[O\left(n+2n+\ldots+\frac{T}{n}\right)=O\left(\frac{T^2}{n}\right)\]</span></p><h4 id="文档删除怎么操作">文档删除怎么操作？</h4><p>无效向量</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143649321808_563_image-20220928142307585.png" alt="image-20220928142307585"><figcaption aria-hidden="true">image-20220928142307585</figcaption></figure><h3 id="倒排索引压缩">倒排索引压缩</h3><h4 id="一些朴素的偷懒方法">一些朴素的偷懒方法</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143650616612_634_image-20220928155207922.png" alt="image-20220928155207922"><figcaption aria-hidden="true">image-20220928155207922</figcaption></figure><p>但是现代检索系统一般不会这么做，因为会导致一些信息的丢失。</p><h4 id="词典压缩">词典压缩</h4><h5 id="方法一使用数组">方法一：使用数组</h5><p>是一种很蠢的方法</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143654714754_145_image-20220928152210011.png" alt="image-20220928152210011" width="50%" height="50%"></p><h5 id="方法二指针">方法二：指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143655839716_271_image-20220928151740804.png" alt="image-20220928151740804"><figcaption aria-hidden="true">image-20220928151740804</figcaption></figure><h5 id="方法二的优化分段指针">方法二的优化：分段指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143657755792_576_image-20220928152418457.png" alt="image-20220928152418457"><figcaption aria-hidden="true">image-20220928152418457</figcaption></figure><p>当然，找termID对应的词项会慢一些。</p><h5 id="采用前缀的方式">采用前缀的方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143659531464_413_image-20220928153011321.png" alt="image-20220928153011321"><figcaption aria-hidden="true">image-20220928153011321</figcaption></figure><h4 id="索引表压缩">索引表压缩</h4><h5 id="encoding-gaps">Encoding gaps</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143700905497_456_image-20220928153421273.png" alt="image-20220928153421273"><figcaption aria-hidden="true">image-20220928153421273</figcaption></figure><h5 id="variable-length-codings">Variable length codings</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143702089613_543_image-20220928153533933.png" alt="image-20220928153533933"><figcaption aria-hidden="true">image-20220928153533933</figcaption></figure><p>例子：可变长UTF-8</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143703419174_526_image-20220928153849498.png" alt="image-20220928153849498"><figcaption aria-hidden="true">image-20220928153849498</figcaption></figure><p>UTF-8 的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的Unicode 码。</p><p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p><p></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pdo5e2l9znqyqz"></i><span>asciidoc</span><div class="collapse show" id="collapse-pdo5e2l9znqyqz"><pre><code class="hljs asciidoc">Unicode符号范围     |        UTF-8编码方式<span class="hljs-section">(十六进制)        |              （二进制）</span><span class="hljs-section">-------------------+---------------------------------------------</span>0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre></div></div><p></p><p>根据上表，解读 UTF-8编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>下面，以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p><p><code>严</code>的 Unicode是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的UTF-8编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的UTF-8编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p><h5 id="gamma-encoding">Gamma Encoding</h5><p>根据<a href="https://en.wikipedia.org/wiki/Elias_gamma_coding">维基百科</a>所述，gamma编码过程如下图所示。虽具体过程与课上讲述稍有不同，但原理是一样的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143704774266_595_image-20220930155723916.png" alt="image-20220930155723916"><figcaption aria-hidden="true">image-20220930155723916</figcaption></figure><p>编码具体案例和解码过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143706251591_500_image-20220930155802505.png" alt="image-20220930155802505"><figcaption aria-hidden="true">image-20220930155802505</figcaption></figure><h3 id="查询优化">查询优化</h3><h4 id="倒排索引数据结构优化">倒排索引数据结构优化</h4><h5 id="跳表">“跳表”</h5><p>动机</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143708733468_476_image-20221005150319520.png" alt="image-20221005150319520"><figcaption aria-hidden="true">image-20221005150319520</figcaption></figure><p>怎么选取间隔？“摔瓶子”。开根号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143710120784_928_image-20221005150404678.png" alt="image-20221005150404678"><figcaption aria-hidden="true">image-20221005150404678</figcaption></figure><p>实例：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143711476304_852_image-20221005150523460.png" alt="image-20221005150523460"><figcaption aria-hidden="true">image-20221005150523460</figcaption></figure><p class="note note-info">为什么是先跳再判断，如果跳过了再倒回去，而不是比较之后再跳？后者比较次数太多，开销大，且慢。</p><h4 id="词项数据结构">词项数据结构</h4><h5 id="哈希表">哈希表</h5><p>优点：快</p><p>缺点：不支持模糊查询</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143713258991_492_image-20221005152131580.png" alt="image-20221005152131580"><figcaption aria-hidden="true">image-20221005152131580</figcaption></figure><h5 id="b树">B树</h5><p>实际使用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143716445073_262_image-20221005152231798.png" alt="image-20221005152231798"><figcaption aria-hidden="true">image-20221005152231798</figcaption></figure><h4 id="通配符查询支持">通配符查询支持</h4><p>前缀：B树天然支持</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143718721740_938_image-20221005153943805.png" alt="image-20221005153943805"><figcaption aria-hidden="true">image-20221005153943805</figcaption></figure><p>后缀：对逆序建B树</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143720264162_261_image-20221005154022485.png" alt="image-20221005154022485"><figcaption aria-hidden="true">image-20221005154022485</figcaption></figure><p>中间的？好像有点问题。。。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143721509249_850_image-20221012140726185.png" alt="image-20221012140726185" width="50%" height="50%"></p><h4 id="轮排索引">轮排索引</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143722646249_170_image-20221012141847402.png" alt="image-20221012141847402"><figcaption aria-hidden="true">image-20221012141847402</figcaption></figure><p>采用B树。但通常这种方法产生的B树会非常大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143723834048_694_image-20221012143335531.png" alt="image-20221012143335531"><figcaption aria-hidden="true">image-20221012143335531</figcaption></figure><h4 id="k-gram">K-gram</h4><p>一定程度上的优化</p><p>在一定长度的字串上建索引</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143725269033_823_image-20221012143730369.png" alt="image-20221012143730369"><figcaption aria-hidden="true">image-20221012143730369</figcaption></figure><p>查$co,ter,er$,$代表起始和结束符号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143726834159_151_image-20221012144353569.png" alt="image-20221012144353569"><figcaption aria-hidden="true">image-20221012144353569</figcaption></figure><h3 id="拼写检查支持">拼写检查支持</h3><h4 id="动态规划编辑距离">动态规划：编辑距离</h4><p>动态规划求字符串距离？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143728315657_544_image-20221012150059012.png" alt="image-20221012150059012"><figcaption aria-hidden="true">image-20221012150059012</figcaption></figure><p>词项太多，算法显得有些复杂，慢</p><h4 id="在k-gram基础上进行">在K-gram基础上进行</h4><p>Jaccard distance判断相似度</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20221013143729475948_696_image-20221012151057155.png" alt="image-20221012151057155"><figcaption aria-hidden="true">image-20221012151057155</figcaption></figure><p>求并集的小trick</p><p>#query term's k-grams +#found term's k-grams-#intersection</p><h4 id="上下文相关检查">上下文相关检查</h4><p>利用搜索历史，启发式</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在mac上编写运行c++程序</title>
    <link href="/posts/51388/"/>
    <url>/posts/51388/</url>
    
    <content type="html"><![CDATA[<h2 id="如何在mac上编写运行c程序">如何在mac上编写运行c++程序</h2><p>有一部分同学买的电脑是mac，也有很多同学问怎么在mac上写c++代码。在这里解答一下。</p><h3 id="方案一使用clion">方案一：使用Clion</h3><h4 id="下载">下载</h4><p><a href="https://www.jetbrains.com/clion/download/#section=mac">下载网址</a></p><p>如果你的苹果电脑是M1/M2芯片，那么请选择Apple Sillcon，否则选Intel</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230752211301_738_image-20220927201026604.png" alt="image-20220927201026604"><figcaption aria-hidden="true">image-20220927201026604</figcaption></figure><p>然后打开dmg文件将其拖到applcation文件夹即可。</p><h4 id="激活">激活</h4><p>Clion并不是一个免费的软件。但是作为学生，可以向其申请免费使用。点击<a href="https://www.jetbrains.com/zh-cn/community/education/#students">这里</a>进入申请页面。正常情况下用你的学生邮箱就可以申请。申请之后会自动跳转到Clion，激活成功。</p><h4 id="创建第一个项目">创建第一个项目</h4><p>点击“新建项目”，选择默认的c++ excutable</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230754550529_520_image-20220927203943145.png" alt="image-20220927203943145"><figcaption aria-hidden="true">image-20220927203943145</figcaption></figure><p>在location处可以改变项目路径和名称。</p><p>如果之前你没写过代码，可能会提示</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230756221193_195_image-20220927204027175.png" alt="image-20220927204027175"><figcaption aria-hidden="true">image-20220927204027175</figcaption></figure><p>安装即可。可能需要等待亿些时间。（类似于visualstudio的工具链，可能会捆绑一些你可能其实用不到的东西）</p><p>然后安装完确认一下</p><p align="center"><img alt="image-20220927211547461" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230757928357_218_image-20220927211547461.png" width="50%"></p><p>项目配置没有报错</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230759316655_492_image-20220927211608280.png" alt="image-20220927211608280"><figcaption aria-hidden="true">image-20220927211608280</figcaption></figure><p>然后选中CMakeLists，点击2处的刷新符号，重新构建</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230801131735_750_image-20220927211726878.png" alt="image-20220927211726878"><figcaption aria-hidden="true">image-20220927211726878</figcaption></figure><p>你应当发现此处的项目配置发生了改变。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230802745480_349_image-20220927211737021.png" alt="image-20220927211737021"><figcaption aria-hidden="true">image-20220927211737021</figcaption></figure><p>此时点击运行，运行helloworld程序，成功</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230804052581_398_image-20220927211838631.png" alt="image-20220927211838631"><figcaption aria-hidden="true">image-20220927211838631</figcaption></figure><h4 id="简单了解cmake">简单了解Cmake</h4><p>如果你想要在这个项目下运行多个cpp文件，你有必要了解一下cmake。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230805695741_398_image-20220927212015622.png" alt="image-20220927212015622"><figcaption aria-hidden="true">image-20220927212015622</figcaption></figure><p>你会发现cmakelist变成了这样。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230808172534_771_image-20220927212042215.png" alt="image-20220927212042215"><figcaption aria-hidden="true">image-20220927212042215</figcaption></figure><p>然后你顺理成章的点击了main函数旁边的运行</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230809367068_211_image-20220927212255496.png" alt="image-20220927212255496"><figcaption aria-hidden="true">image-20220927212255496</figcaption></figure><p>报错了！查看倒数第三行的报错信息，你会发现出现了重复（duplicate）的符号。</p><p>你想到课上使用vs时讲的，一个项目只能使用一个main函数。你把另外一个main改成了main2。学着这样修改。你发现确实可以正常运行。</p><p><font color="Apricot">但有没有更优雅的解决方案呢？</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230811319016_339_image-20220927212700579.png" alt="image-20220927212700579"><figcaption aria-hidden="true">image-20220927212700579</figcaption></figure><p>你注意到了cmake中最后一行是add_executable，刚刚发生了变化。从含义可以推测出一定是它控制了程序的执行。</p><p>让它们各自生成各自的程序一定可以！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230812325537_398_image-20220927212920160.png" alt="image-20220927212920160"><figcaption aria-hidden="true">image-20220927212920160</figcaption></figure><p>点击Reload changes。你会发现项目构建出现了两个程序。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230813838131_522_image-20220927213032997.png" alt="image-20220927213032997"><figcaption aria-hidden="true">image-20220927213032997</figcaption></figure><p>然后你高兴的发现点击哪个程序运行，你就可以运行哪一个cpp文件！</p><p>事实上，你点击cmake_build_debug，你会发现add_excutable第一个参数正是生成程序的名称！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230815024257_502_image-20220927213245467.png" alt="image-20220927213245467"><figcaption aria-hidden="true">image-20220927213245467</figcaption></figure><p>在访达打开<img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230816481939_447_image-20220927213323515.png" alt="image-20220927213323515"></p><p>双击---helloworld出现了！它正是你刚刚编写的程序！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230818933782_519_image-20220927213343594.png" alt="image-20220927213343594"><figcaption aria-hidden="true">image-20220927213343594</figcaption></figure><p>Cmake在大型项目管理中有着重要的用途，其本身也是十分复杂的。但在课程中只需要了解这些即可。</p><p>同时Clion在windows下也可以使用。</p><h3 id="方案二使用xcode">方案二：使用xcode</h3><p>xcode是专为mac平台打造的全功能IDE（当然你要问我能不能写exe，只能说emmm）</p><p>xcode比较大，下载需要耐心等待。</p><h4 id="项目搭建">项目搭建</h4><p>点击新建项目</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230821620085_933_image-20220927213913046.png" alt="image-20220927213913046"><figcaption aria-hidden="true">image-20220927213913046</figcaption></figure><p>选择macOS控制台应用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230823254664_156_image-20220927213932265.png" alt="image-20220927213932265"><figcaption aria-hidden="true">image-20220927213932265</figcaption></figure><p>项目选项</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230824771816_210_image-20220927214102217.png" alt="image-20220927214102217"><figcaption aria-hidden="true">image-20220927214102217</figcaption></figure><p>注意组织名称写com，别的其实也行，但此处不作介绍。</p><p>语言选择c++。</p><p>选择项目位置后就可以愉快开发了！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230826057443_745_image-20220927214344955.png" alt="image-20220927214344955"><figcaption aria-hidden="true">image-20220927214344955</figcaption></figure><p>控制台在屏幕下方。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230827635084_833_image-20220927214423776.png" alt="image-20220927214423776"><figcaption aria-hidden="true">image-20220927214423776</figcaption></figure><h4 id="运行多个cpp">运行多个cpp</h4><p>这个时候已经创建了一个cpp-project的项目，里面包含了一个main.cpp文件如果这个时候想要在同一个工程里面创建第二个带main函数的c++文件并运行，就需要通过创建Target来实现</p><p>Project是一个工程项目，一个Project可以包含多个TargetTarget之间互相没有关系，Target于Project的关系是：Target的Setting一部分继承自Project的Setting</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230828821606_386_image-20220927214845054.png" alt="image-20220927214845054"><figcaption aria-hidden="true">image-20220927214845054</figcaption></figure><p>新建target，同样选择commandline tool，填写一个的名称</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230831064192_247_image-20220927215021382.png" alt="image-20220927215021382"><figcaption aria-hidden="true">image-20220927215021382</figcaption></figure><p>在上方，想运行哪一个target，选择对应的即可。</p><p align="center"><img alt="image-20220927215233319" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230832540286_682_image-20220927215233319.png" width="50%"></p><h3 id="方案三命令行方式">方案三：命令行方式</h3><p>安装homebrew（如果已经下载过xcode可以跳过，不过既然如此为什么不用xcode呢？）</p><p>在你的终端输入这行指令：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-trfhzsl9znqyqz"></i><span>awk</span><div class="collapse show" id="collapse-trfhzsl9znqyqz"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>bash -c <span class="hljs-string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</span></code></pre></div></div><p>如果下载很慢一般是网络问题，请自行解决。</p><p>安装完成后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-itjay7l9znqyqz"></i><span>mipsasm</span><div class="collapse show" id="collapse-itjay7l9znqyqz"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>g++</code></pre></div></div><p>任意位置新建cpp文件。</p><p>cpp文件可以用你喜欢的方式打开编辑。</p><p>按⌘（command）+ ⌥（option）+c复制当前文件夹路径</p><p>终端输入</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tl9gttl9znqyqz"></i><span>bash</span><div class="collapse show" id="collapse-tl9gttl9znqyqz"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 刚才的路径</code></pre></div></div><p>然后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8ylh12l9znqyqz"></i><span>aspectj</span><div class="collapse show" id="collapse-8ylh12l9znqyqz"><pre><code class="hljs aspectj">g++ yourprogram.cpp -o <span class="hljs-keyword">target</span></code></pre></div></div><p>target 是生成的可执行文件的名字。</p><p>然后会发现生成了可执行文件，点击即可运行。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99c%2B%2B%E7%A8%8B%E5%BA%8F/20220929230833974800_101_image-20220927220347236.png" alt="image-20220927220347236"><figcaption aria-hidden="true">image-20220927220347236</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_进程与线程模型</title>
    <link href="/posts/30463/"/>
    <url>/posts/30463/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统--进程与线程">操作系统--进程与线程</h2><h3 id="进程概念">进程概念</h3><h4 id="从并发开始">从并发开始</h4><p>串行排队</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110755222583_746_image-20220926142304076.png" alt="image-20220926142304076"><figcaption aria-hidden="true">image-20220926142304076</figcaption></figure><p>分时调用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110756926120_483_image-20220926142216136.png" alt="image-20220926142216136"><figcaption aria-hidden="true">image-20220926142216136</figcaption></figure><p>“但是并发除了会让脑子更乱以外并不会让事情变得更好”</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110758632298_262_image-20220926151301063.png" alt="image-20220926151301063"><figcaption aria-hidden="true">image-20220926151301063</figcaption></figure><p>尽管如此，并发确实可以提高CPU的利用率。当然可能会带来设备（慢操作）延迟。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110801392732_151_image-20221018192004694.png" alt="image-20221018192004694"><figcaption aria-hidden="true">image-20221018192004694</figcaption></figure><p>C</p><p><strong>进程就是为了“保存”和“恢复”一个程序的执行过程，以实现并发的目标</strong></p><h4 id="进程和程序的区别">进程和程序的区别</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110803473763_292_image-20221016200649356.png" alt="image-20221016200649356"><figcaption aria-hidden="true">image-20221016200649356</figcaption></figure><h3 id="进程和线程的区别">进程和线程的区别</h3><ul><li><p>进程作为分配资源的基本单位，线程作为独立运行和独立调度的基本单位(注意：在多线程OS 中，进程不是一个可执行的实体)</p></li><li><p>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</p></li></ul><h3 id="进程的数据结构--pcb">进程的数据结构--PCB</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110805822552_826_image-20220926152249647.png" alt="image-20220926152249647"><figcaption aria-hidden="true">image-20220926152249647</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110807671323_383_image-20221018191442452.png" alt="image-20221018191442452"><figcaption aria-hidden="true">image-20221018191442452</figcaption></figure><h3 id="进程的组织">进程的组织</h3><h4 id="进程状态和切换">进程状态和切换</h4><p class="note note-primary">对于某一个进程： 为什么被暂停了？ 为什么选它来运行？为什么选择这个时机进行切换？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110809885582_767_image-20221018191551669.png" alt="image-20221018191551669"><figcaption aria-hidden="true">image-20221018191551669</figcaption></figure><p>操作系统可以将会触发慢操作的状态记录下来。</p><p class="note note-primary">“把printf的汇编代码放到自己的程序中，并且把控制休眠的指令注释掉，会不会能正常运行？”</p><p>不能。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110811863911_528_image-20220926161106287.png" alt="image-20220926161106287" width="50%" height="50%"></p><h5 id="五状态进程模型">五状态进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110813764309_930_image-20221014152546893.png" alt="image-20221014152546893"><figcaption aria-hidden="true">image-20221014152546893</figcaption></figure><p>关于进程的创建：</p><p>在一个进程被新建时它并非绝对会被调入内存，通常是分两步，首先创建该进程的PCB，并与之关联，但是此时可能面临内存不足或者操作系统限制了最大进程数导致这个进程还无法被调入进程，因此该进程被暂时留在新建态，在这个状态的进程PCB已经创建并且加载进内存，但是进程的代码和数据往往还留在外存中等待加载。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110816170775_715_image-20221018205252597.png" alt="image-20221018205252597"><figcaption aria-hidden="true">image-20221018205252597</figcaption></figure><p>关于进程的撤销(结束)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110817967015_206_image-20221016192515282.png" alt="image-20221016192515282"><figcaption aria-hidden="true">image-20221016192515282</figcaption></figure><blockquote><p>B。进程有它的生命周期，不会一直存在于系统中，也不一定需要用户显式地撒销。进程在时间片结束时只是就绪，而不是撤销。阻塞和唤醒是进程生存期的中间状态。进程可在完成时撤销，或在出现内存错误等时撤销。</p></blockquote><p>关于进程的阻塞</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110819440912_574_image-20221018192631681.png" alt="image-20221018192631681"><figcaption aria-hidden="true">image-20221018192631681</figcaption></figure><p>阻塞态完了会进就绪队列</p><p><a target="_blank" href="https://houbb.github.io/2020/10/04/os-04-sync" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">关于临界资源及其同步和互斥</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://houbb.github.io/2020/10/04/os-04-sync</span></span></span></a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110821096921_713_image-20221018214846546.png" alt="image-20221018214846546"><figcaption aria-hidden="true">image-20221018214846546</figcaption></figure><blockquote><p>B 可以共享一部分资源，但不共享虚拟地址空间</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110822817914_214_image-20221018214339806.png" alt="image-20221018214339806"><figcaption aria-hidden="true">image-20221018214339806</figcaption></figure><blockquote><p>C</p></blockquote><h5 id="添加了挂起状态的进程模型">添加了挂起状态的进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110824611329_729_image-20220926162706586.png" alt="image-20220926162706586"><figcaption aria-hidden="true">image-20220926162706586</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110826436181_342_image-20221014151453508.png" alt="image-20221014151453508"><figcaption aria-hidden="true">image-20221014151453508</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110828695748_821_image-20221018192900616.png" alt="image-20221018192900616"><figcaption aria-hidden="true">image-20221018192900616</figcaption></figure><p>A</p><p class="note note-info">不同操作系统中进程状态设置区别很大。</p><h5 id="进程调度方式">进程调度方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110830191623_314_image-20220926162928685.png" alt="image-20220926162928685"><figcaption aria-hidden="true">image-20220926162928685</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110832168851_702_image-20220926163633315.png" alt="image-20220926163633315"><figcaption aria-hidden="true">image-20220926163633315</figcaption></figure><p>现在的操作系统都是可抢占系统。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110834324423_859_image-20221018205406513.png" alt="image-20221018205406513"><figcaption aria-hidden="true">image-20221018205406513</figcaption></figure><blockquote><p>A。BC应该将优先级，D时机不合适。</p><p>此部分将在进程调度中详细介绍。</p></blockquote><h4 id="进程通信">进程通信</h4><p>共享存储，消息传递，管道通信</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110836886804_366_image-20221018211857840.png" alt="image-20221018211857840"><figcaption aria-hidden="true">image-20221018211857840</figcaption></figure><p><a href="https://zhuanlan.zhihu.com/p/58489873">linux中的管道通信</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110839761934_452_image-20221018211911941.png" alt="image-20221018211911941"><figcaption aria-hidden="true">image-20221018211911941</figcaption></figure><blockquote><p>A得俩。B容量是一个页的大小(4KB)。管道是一个文件，任何两个不相关的进程当然都可以通过这个管道文件进行通信</p></blockquote><h4 id="进程和线程的设计模型">进程和线程的设计模型</h4><h5 id="线程实现方式">线程实现方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110841591537_254_image-20221018194121923.png" alt="image-20221018194121923"><figcaption aria-hidden="true">image-20221018194121923</figcaption></figure><h6 id="ultuser-level-thread">ULT(User Level Thread)</h6><p>需要注意的是在这种模式下调度仍是以进程为单位进行的</p><p>优势:</p><p>1.线程切换不需要内核模式特权.</p><p>2.线程调用可以是应用程序级的,根据需要可改变调度算法,但不会影响底层的操作系统调度程序.</p><p>3.ULT管理模式可以在任何操作系统中运行,不需要修改系统内核,线程库是提供应用的实用程序。</p><p>劣势:</p><p>1.系统调用(慢操作，如输入输出)会引起进程阻塞，而且进程内的所有线程都被阻塞。(内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行)</p><p>2.不利于使用多处理器并行</p><h6 id="klt">KLT</h6><p>优势：灵活，线程切换快</p><p>劣势：需要用户态到内核态的切换，代价高</p><p>线程库：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110843340452_876_image-20221018193551401.png" alt="image-20221018193551401"><figcaption aria-hidden="true">image-20221018193551401</figcaption></figure><figure><img src="/Users/tianjiaye/Library/Application%20Support/typora-user-images/image-20221031161210652.png" alt="image-20221031161210652"><figcaption aria-hidden="true">image-20221031161210652</figcaption></figure><figure><img src="/Users/tianjiaye/Library/Application%20Support/typora-user-images/image-20221031161504084.png" alt="image-20221031161504084"><figcaption aria-hidden="true">image-20221031161504084</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110847145883_201_image-20221018205754448.png" alt="image-20221018205754448"><figcaption aria-hidden="true">image-20221018205754448</figcaption></figure><blockquote><p>D.其他线程对此不可见</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110848853722_394_image-20221018214600427.png" alt="image-20221018214600427"><figcaption aria-hidden="true">image-20221018214600427</figcaption></figure><blockquote><p>B只有在KLT中才会这么做</p></blockquote><h5 id="轻权进程"><a href="https://en.wikipedia.org/wiki/Light-weight_process#cite_note-Vah96-1">轻权进程</a></h5><p>类似于一种折衷的方案。但是问题是太复杂</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20221019110850808418_676_image-20221018234308117.png" alt="image-20221018234308117"><figcaption aria-hidden="true">image-20221018234308117</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-模型评估与选择</title>
    <link href="/posts/4810/"/>
    <url>/posts/4810/</url>
    
    <content type="html"><![CDATA[<h2 id="模型评估与选择">模型评估与选择</h2><h3 id="模型评估方法">模型评估方法</h3><p>书后习题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234157710423_473_image-20220930231043281.png" alt="image-20220930231043281"><figcaption aria-hidden="true">image-20220930231043281</figcaption></figure><h3 id="经验误差和泛化误差">经验误差和泛化误差</h3><h4 id="定义">定义</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234159328307_660_image-20220930140833923.png" alt="image-20220930140833923"><figcaption aria-hidden="true">image-20220930140833923</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234200690193_368_image-20220930141041690.png" alt="image-20220930141041690"><figcaption aria-hidden="true">image-20220930141041690</figcaption></figure><h4 id="解决过拟合现象正则化">解决过拟合现象：正则化</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234202870906_724_image-20220930141142762.png" alt="image-20220930141142762"><figcaption aria-hidden="true">image-20220930141142762</figcaption></figure><h3 id="性能度量">性能度量</h3><h4 id="基本概念">基本概念</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234204833875_372_image-20220930163038120.png" alt="image-20220930163038120"><figcaption aria-hidden="true">image-20220930163038120</figcaption></figure><h4 id="p-r曲线和roc曲线">P-R曲线和ROC曲线</h4><h5 id="实例">实例</h5><p><a href="https://zhuanlan.zhihu.com/p/92218196">知乎</a>上有一个案例对这些曲线描述的比较形象。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234208101296_478_image-20220930194835021.png" alt="image-20220930194835021"><figcaption aria-hidden="true">image-20220930194835021</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234209475943_307_image-20220930194858579.png" alt="image-20220930194858579"><figcaption aria-hidden="true">image-20220930194858579</figcaption></figure><p>TPR真阳性，FPR假阳性</p><p>一个表现平平的分类器(表现是指分类标准能否将两种样本有效的分开，而threshold是指划分标准更倾向于查全率或准确率)</p><p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234211807031_249_norm.gif" width=""></p>一个更好一些的分类器<p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234215190380_315_norm2.gif" width=""></p><p>F1计算</p><p align="center"><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234218188978_486_F1.gif" width="" hight=""></p><h5 id="用途">用途</h5><p>基于P-R曲线可以大致评判机器学习模型的好坏</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234219845677_195_image-20220930224302678.png" alt="image-20220930224302678"><figcaption aria-hidden="true">image-20220930224302678</figcaption></figure><p>ROC也是如此。</p><p>从定义可知， AUC 可 通过对 ROC 曲 线下各部分的面积 求和而得.</p><p>形式化地看， AUC 考虑的是样本预测的排序质量。</p><p>习题：若学习器A的F1值比学习器B高，试析A的BEP值是否也比B高</p><p>二者是不同维度的指标。当然在达到BEP的条件时(P=R)，F1的值和BEP相等。</p><h4 id="roc代价曲线">ROC代价曲线</h4><p>参考<a href="https://www.zhihu.com/question/63492375">知乎答案</a></p><p>首先, 横坐标是 <span class="math inline">\(\mathrm{P}(+)\)</span>,由公式3可以知道, 当 <span class="math inline">\(\mathrm{P}(+)=0\)</span>时, <span class="math inline">\({c o s t}_{n o rm}=\mathrm{FPR}\)</span>; 当 <span class="math inline">\(\mathrm{P}(+)=1\)</span> 时, <span class="math inline">\(\operatorname{cost}_{n o rm}=\mathrm{FNR}_{\circ}\)</span> 直白含义：当我用来检测模型好坏的样本全是负例(即 $(+)=0 $)，那我模型产生的错误就只有负例被错误的预测 为正例这一种情况, 就是 <span class="math inline">\((0, F P R)\)</span> 。 同样,当我用来检测模型好坏的样本全都是正例（即 $(+)=1 $)，那我模型产生的错误就只有正例被错 误的预测为负例的情况这一种情况，就是<span class="math inline">\((1, \mathrm{FNR})\)</span>两个连线中间的情况, 用来检测模型的样本有正例也有负例的时候, 也就是 <span class="math inline">\(P(+)=0 . x\)</span>, 这时候 <span class="math inline">\(\operatorname{cost}_{n o r m}\)</span>的取值就会同时受到FPR和FNR的影响。</p><p>很像高中化学读图题的定性分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234221742723_477_image-20220930222355725.png" alt="image-20220930222355725"><figcaption aria-hidden="true">image-20220930222355725</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234223625316_668_image-20220930222637642.png" alt="image-20220930222637642"><figcaption aria-hidden="true">image-20220930222637642</figcaption></figure><p>就像做核酸”粉饰太平“一样( <span class="math display">\[P(+)=\frac{p \cdot \cos _{0 \mid 1}}{p \cdot \operatorname{cost}_{0 \mid1}+(1-p) \cdot \operatorname{cost}_{1 \mid 0}}\]</span> <span class="math inline">\(\operatorname{cost}_{0 \mid1}\)</span> 表示: 实际为正类, 而错判成负类的代价, <span class="math inline">\(\operatorname{cost}_{1 \mid 0}\)</span> 表示:实际为负类, 而错判成正类类Q 的代价。 举例说明, 当我们认为,正例错判为负例的代价与负例错判为正例的代价相同时, <span class="math inline">\(P^1(+)=p\)</span>当我们认为把正类判定为负类会造成更大的损失时(比如假设核酸检测瞒报比误报代价更大),此时 <span class="math inline">\(\operatorname{cost}_{1 \mid 0}&gt;;\cost_{0 \mid 1}\)</span>, 带入正例代价公式 得 <span class="math inline">\(P^2(+)\)</span>, 这时候就有 <span class="math inline">\(P^2(+)&gt;;P^1(+)\)</span> 。 对应到ROC代价图,正例概率 <span class="math inline">\(P(+)\)</span> 就会往左移动,对应的阈值就会减小, 模型对负类的判断就会更谨慎(比如下调CT值)。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234224685263_266_image-20220930142416369.png" alt="image-20220930142416369"><figcaption aria-hidden="true">image-20220930142416369</figcaption></figure><p><span class="math inline">\(\beta\)</span>&gt;1时查全率有更大影响；<span class="math inline">\(\beta\)</span>&lt;1时查准率有更大影响。</p><p>(核酸检测评价假设偏向减少瞒报，则<span class="math inline">\(\beta&gt;1\)</span>)</p><h3 id="比较检验">比较检验</h3><p>单边t检验和成对t检验可以分别用于评价单个学习器的错误率和比较两个学习器的性能。</p><p>对二分类问题，使用留出法不仅可估计出学习器 A 和 B的测试错误率，还可获得两学习器分类结果的差别，使用McNemar检验可以做到。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234226080145_532_image-20220930233428713.png" alt="image-20220930233428713"><figcaption aria-hidden="true">image-20220930233428713</figcaption></figure><p>$Min-max$规范化优点：1、计算相对简单一点。2、当新样本进来时，只有在新样本大于原最大值或者小于原最小值时，才需要重新计算规范化之后的值。缺点在于：1、容易受高杠杆点和离群点影响。</p><p><span class="math inline">\(z-score\)</span>规范化优点：1、对异常值敏感低。缺点在于：1、计算更负责。2、每次新样本进来都需要重新计算规范化。</p><h3 id="偏差方差分解">偏差方差分解</h3><p>用途：解释算法泛化性能来源的手段 <span class="math display">\[E(f ;D)=\operatorname{bias}^2(\boldsymbol{x})+\operatorname{var}(\boldsymbol{x})+\varepsilon^2,\]</span> 也就是说, 泛化误差可分解为偏差、方差与噪声之和。</p><p>注意这个式子的推导，详见南瓜书。</p><ul><li><strong>「偏差」</strong>度量了学习算法的期望预测与真实结果的偏离程度，即<strong>「刻画了学习算法本身的拟合能力」</strong>；</li><li><strong>「方差」</strong>度量了同样大小的训练集的变动所导致的学习性能的变化，即<strong>「刻画了数据扰动所造成的影响」</strong>;</li><li><strong>「噪声」</strong>则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即<strong>「刻画了学习问题本身的难度」</strong>.</li></ul><p>偏差一方差分解说明，泛化性能是由<strong>「学习算法的能力」</strong>、<strong>「数据的充分性」</strong>以及<strong>「学习任务本身的难度所共同决定」</strong>的。</p><p align="center"><img alt="image-20220930230353084" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20220930234228241789_843_image-20220930230353084.png" width="50%"></p><p>随训练强度，偏差减小，方差增大，即学习的越充分，但受数据影响越大，可能出现过拟合现象。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统期末工程作业设计</title>
    <link href="/posts/30344/"/>
    <url>/posts/30344/</url>
    
    <content type="html"><![CDATA[<h3 id="期末工程作业">期末工程作业</h3><p class="note note-info">本文暂只提供相关设计思路，不提供最终实现代码。实现方面前端flask或swing上手较为快速，也可尝试其他框架。后端使用mysql数据库，关于连接数据库方式网上很容易搜到，不再赘述。</p><h4 id="需求描述">1. 需求描述</h4><p>疫情期间，学校的润美超市（虚构）需要对商品物资做更详细的管理。为防止供应链出现问题，对商品的供货商需要进行详细的记录，并对顾客的购买记录进行管理。当然，也需要对商品本身和超市内工作人员进行常规的管理。作为典型的数据库应用场景，引入合适的数据管理系统能够更好的落实疫情防控要求，并让超市具有更好的营业效果。</p><p>1.商品根据名称和供应商整理，通过编号标识，记录其价格。同时对于食品还需记录其保质期，以免过期未处理。</p><p>2.进货数据需要包含商品编号、进货价，进货时间等。</p><p>3.超市内有若干工作人员，需要对其个人信息和销售商品所得薪水进行储存。</p><p>4.需要对顾客信息进行储存。并对应购买时间和商品，形成销售日志。</p><h4 id="概念模型er图">2.1 概念模型ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004325018293_610_image-20220919004148336.png" alt="image-20220919004148336"><figcaption aria-hidden="true">image-20220919004148336</figcaption></figure><h4 id="关系模式转换">2.2 关系模式转换</h4><p>注：1.普通商品采用使用空值的方式，food与goods共用一张表</p><p>​ 2.斜体代表外键</p><p>goods（<u>goods_id</u>, goods_name, supplier_id, price, good_num,<em>shelf_no</em>)</p><p>//food（<u>goods_id</u>, goods_name, supplier_id, price,shelf_life)</p><p>supplier（<u>sp_id</u>, sp_name, phone, address)</p><p>supply（<u><em>sp_id</em></u>, <u><em>goods_id</em></u>, enter_time,costs)</p><p>employee（<u>emp_no</u>, <u>emp_name</u>, salary)</p><p>customer（<u>cu_id</u>, cu_name)</p><p>buy(<u><em>cu_id</em></u>, <u><em>goods_id</em></u>, buy_time,buy_costs)</p><p>shelf(<u>shelf_id</u>, goods_num_on_shelf)</p><p>sell (<u><em>emp_no</em></u>, <em><u>goods_id</u></em>)</p><h4 id="sql创建关系模式">2.3 SQL创建关系模式</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rnshkpl9znqyr0"></i><span>sql</span><div class="collapse show" id="collapse-rnshkpl9znqyr0"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div></div><h4 id="查询语句样例">2.4 查询语句样例</h4><p>1.单表查询</p><p>查询单价为10元的商品名称</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k47xk4l9znqyr0"></i><span>sql</span><div class="collapse show" id="collapse-k47xk4l9znqyr0"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name <span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> price<span class="hljs-operator">=</span><span class="hljs-number">10</span></code></pre></div></div><p>2.多表连接查询</p><p>查询每个厂商生产商品的平均价格</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uneo72l9znqyr0"></i><span>SQL</span><div class="collapse show" id="collapse-uneo72l9znqyr0"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> sp_id,<span class="hljs-built_in">avg</span>(price)<span class="hljs-keyword">from</span> supply <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sp_id</code></pre></div></div><p>3.4多表嵌套查询和exist查询</p><p>查询只有一种商品的货架，返回这种商品的名称和货架id</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i779w9l9znqyr0"></i><span>sql</span><div class="collapse show" id="collapse-i779w9l9znqyr0"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name,shelf_id<span class="hljs-keyword">from</span> goods,shelf<span class="hljs-keyword">where</span> goods.shelf_id<span class="hljs-operator">=</span>shelf.shelf_id <span class="hljs-keyword">and</span> goods.goods_num<span class="hljs-operator">=</span>shelf.goods_num_on_shelf</code></pre></div></div><p>也可以只在goods表中查</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ohhshxl9znqyr0"></i><span>sql</span><div class="collapse show" id="collapse-ohhshxl9znqyr0"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name<span class="hljs-keyword">from</span> goods g1<span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span><span class="hljs-operator">*</span><span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> shelf.id<span class="hljs-operator">=</span>e1.shelf.id <span class="hljs-keyword">and</span>goods_name<span class="hljs-operator">&amp;</span>lt;<span class="hljs-operator">&amp;</span>gt;e1.goods_name);</code></pre></div></div><p>5.聚合查询</p><p>有10种以上商品的货架，以及拥有的商品种类数</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w2ts7al9znqyr0"></i><span>sql</span><div class="collapse show" id="collapse-w2ts7al9znqyr0"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> shelf_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">from</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> shef_id<span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&amp;</span>gt; <span class="hljs-number">10</span>;</code></pre></div></div><h4 id="powerdesigner-绘制er图">3.1 PowerDesigner 绘制ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004326633367_468_image-20220415222750452.png" alt="image-20220415222750452"><figcaption aria-hidden="true">image-20220415222750452</figcaption></figure><h4 id="转为关系模型">3.2 转为关系模型</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A/20220919004327928426_899_image-20220415222820109.png" alt="image-20220415222820109"><figcaption aria-hidden="true">image-20220415222820109</figcaption></figure><h4 id="生成sql语句">3.3 生成SQL语句</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-64pfael9znqyr0"></i><span>sql</span><div class="collapse show" id="collapse-64pfael9znqyr0"><pre><code class="hljs sql"><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* DBMS name:      Sybase SQL Anywhere 12                       */</span><span class="hljs-comment">/* Created on:     2022/4/15 22:28:49                           */</span><span class="hljs-comment">/*==============================================================*/</span>if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY_CUSTOMER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY_CUSTOMER<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_GOODS_ON_SHELF'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_GOODS_ON_SHELF<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL_EMPLOYEE'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL_EMPLOYEE<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY2_SUPPLIER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY2_SUPPLIER<span class="hljs-keyword">end</span> if;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> buy;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> customer.customer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> customer;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> employee.emplyer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> employee;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.on_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.goods_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> goods;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> sell;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> shelf.shelf_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> shelf;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supplier.supplier_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supplier;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supply;<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: buy                                                   */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_PK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index buy_PK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_FK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy_FK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy2_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy2_FK <span class="hljs-keyword">on</span> buy (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: customer                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: customer_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index customer_PK <span class="hljs-keyword">on</span> customer (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: employee                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: emplyer_PK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index emplyer_PK <span class="hljs-keyword">on</span> employee (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: goods                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: goods_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index goods_PK <span class="hljs-keyword">on</span> goods (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: on_FK                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index on_FK <span class="hljs-keyword">on</span> goods (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: sell                                                  */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_PK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index sell_PK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell_FK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell2_FK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell2_FK <span class="hljs-keyword">on</span> sell (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: shelf                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: shelf_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index shelf_PK <span class="hljs-keyword">on</span> shelf (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supplier                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supplier_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index supplier_PK <span class="hljs-keyword">on</span> supplier (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supply                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_PK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index supply_PK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>,sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_FK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply_FK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply2_FK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply2_FK <span class="hljs-keyword">on</span> supply (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY2_SUPPLIER <span class="hljs-keyword">foreign</span> key (sp_id)      <span class="hljs-keyword">references</span> supplier (sp_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div></div><h4 id="分析差异">4.1 分析差异</h4><p>有差异。PowerDesigner会事先判断外键约束、索引以及表本身是否存在，若存在会删除。同时也会对表建立索引。但是基本逻辑是一致的，在总体的设计上不会造成影响。</p><h4 id="语句特点">4.2 语句特点</h4><p>从4.1的分析可以看出，PowerDesigner生成的语句更严谨。当然，语句顺序比如外键约束声明的位置也有不同。这些附加语句的作用是防止特殊情况的发生导致无法正常建立表。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ucore Lab0 on Apple Silicon Mac</title>
    <link href="/posts/34966/"/>
    <url>/posts/34966/</url>
    
    <content type="html"><![CDATA[<h2 id="ucore-lab0-on-apple-silicon-mac">Ucore Lab0 on Apple SiliconMac</h2><h3 id="介绍">介绍</h3><p>M1芯片是2020年之后推出的全新适配于Macbook的Arm64芯片。因为底层的指令集与x86_64不同，因此面临着很多兼容性的问题。在ucore的编译，运行和调试的环境配置中也因此踩了一些坑。当然最终得以能够优雅的在这台具有独特架构的PC上探索实现操作系统的魅力。</p><p>现在将其记录下来，以供参考。</p><h3 id="qemu安装">qemu安装</h3><p>qemu是非常成熟的虚拟化解决方案，通过软件的方式逐条将目标文件的二进制指令翻译成目标架构支持的二进制指令，虽然效率不高，但是使用方便，对M1芯片支持也比较完善，足够用来调试ucore了。</p><p>指导书中针对linux给出了使用包管理工具的安装方案。在mac上这个过程也同样比较简单。安装<code>homebrew</code>包管理工具后只需要</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sh8kybl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-sh8kybl9znqyqz"><pre><code class="hljs shell">brew install qemu</code></pre></div></div><p>即可。当然为了保证是最新版本，安装之前可以更新一下homebrew：<code>brew update</code>。</p><h3 id="i386-elf-gcc和i386-elf-gdb安装">i386-elf-gcc和i386-elf-gdb安装</h3><p>按照网上的解决方案，我安装了<code>macport</code>，并</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dgensol9znqyqz"></i><span>elm</span><div class="collapse show" id="collapse-dgensol9znqyqz"><pre><code class="hljs elm"><span class="hljs-title">sudo</span> <span class="hljs-keyword">port</span> -v selfupdatesudo <span class="hljs-keyword">port</span> install i386-elf-gcc</code></pre></div></div><p>但是发现它安装过程中构建失败了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231400206876_223_image-20221003224714488.png" alt="image-20221003224714488"><figcaption aria-hidden="true">image-20221003224714488</figcaption></figure><p>查看发现果然是架构问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231401953713_177_image-20221003224809467.png" alt="image-20221003224809467"><figcaption aria-hidden="true">image-20221003224809467</figcaption></figure><p>查看报错信息。谷歌后从<a href="https://github.com/riscv-collab/riscv-gnu-toolchain/issues/800">githubissue</a>中得知是有支持apple silicon版本的最新i386-elf-gcc的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231403860364_202_image-20221003225239013.png" alt="image-20221003225239013"><figcaption aria-hidden="true">image-20221003225239013</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231405125684_549_image-20221003225245971.png" alt="image-20221003225245971"><figcaption aria-hidden="true">image-20221003225245971</figcaption></figure><p>有希望！但是按官网命令安装问题也没有解决，所谓补丁也不起效。后来尝试用homebrew安装：<code>brew install i386-elf-gdb</code>，但没有安装成功。提示</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-olr9s7l9znqyqz"></i><span>awk</span><div class="collapse show" id="collapse-olr9s7l9znqyqz"><pre><code class="hljs awk">fatal: not <span class="hljs-keyword">in</span> a git directory Error: Command failed with <span class="hljs-keyword">exit</span> <span class="hljs-number">128</span>: git</code></pre></div></div><p>又经过一番谷歌找到了<a href="https://www.jianshu.com/p/07243d214abd">解决方法</a>。执行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-70wyuel9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-70wyuel9znqyqz"><pre><code class="hljs shell">git config --global --add safe.directory 报错信息中homebrew-core路径git config --global --add safe.directory 报错信息中homebrew-cask路径</code></pre></div></div><p>即可。</p><p>然后需要添加一下环境变量。</p><p>这时尝试qemu生成ucore的dmg，发现提示<code>i386-elf-gcc</code>找不到。这才注意到通过homebrew下载的是<code>x86_64-elf-gcc</code>。</p><p>经过搜索，得知在make时需要添加<code>make GCCPREFIX=x86_64-elf-</code>指定交叉编译工具。这时可以高兴的看到控制台闪烁，执行也很顺利。</p><h3 id="执行">执行</h3><p>然后<code>make qemu</code>执行的过程也比较顺利。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20221003231407841829_266_image-20221003230427926.png" alt="image-20221003230427926"><figcaption aria-hidden="true">image-20221003230427926</figcaption></figure><h3 id="调试">调试</h3><p>首先，ARM架构的Mac目前是不能使用<code>gdb</code>进行程序的调试的，默认的调试工具是<code>lldb</code>。然而经过查阅，对于交叉编译反而可以使用实验中对应的<code>gdb</code>工具：运行<code>brew install i386-elf-gdb</code>安装即可。</p><p>以调试lab1中的BIOS的执行为例。</p><p>下面的过程与指导书中“使用远程调试”部分类似。除此之外，额外将运行的汇编指令保存在q.log中。</p><p>在一个终端先执行：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-464cxsl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-464cxsl9znqyqz"><pre><code class="hljs shell">qemu-system-i386 -S -s -d in_asm -D bin/q.log -monitor stdio -hda bin/ucore.img</code></pre></div></div><p>后在另一个终端执行:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-d5z5bal9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-d5z5bal9znqyqz"><pre><code class="hljs shell">i386-elf-gdb</code></pre></div></div><p>进入gdb调试界面。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-d0gerzl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-d0gerzl9znqyqz"><pre><code class="hljs shell">(gdb) file bin/kernelReading symbols from bin/kernel...(gdb) target remote :1234Remote debugging using :12340x0000fff0 in ?? ()</code></pre></div></div><p>上述的过程相比原来<code>makrfile</code>中提供的<code>make debug</code>主要有两个好处：一是能够重定向到<code>q.log</code>方便进行对比；二是可以绕开<code>make</code>中的<code>TERMINAL:=gnome-terminal</code>(<code>gnome-terminal</code>仅在linux下可使用)</p><p>查看 CS:EIP 由于此时在实际模式下 CPU 在加电后执行的第一条指令的地址为0xf000:0xfff0 =&gt; 0xffff0</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-efy4axl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-efy4axl9znqyqz"><pre><code class="hljs shell">(gdb) x/i $cs0xf000:add    %al,(%eax)(gdb) x/i $eip0xfff0:add    %al,(%eax)</code></pre></div></div><p>再来看看这个地址的指令是什么 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yu107il9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-yu107il9znqyqz"><pre><code class="hljs shell">(gdb) x/2i 0xffff0   0xffff0:ljmp   $0x3630,$0xf000e05b   0xffff7:das</code></pre></div></div><p></p><p>可以看到 第一条指令执行完以后 会跳转到<code>0xf000e05b</code>也就是说BIOS 开始的地址是 <code>0xfe05b</code>。</p><p>打上断点</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sp28j1l9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-sp28j1l9znqyqz"><pre><code class="hljs shell">(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.Breakpoint 1, 0x00007c00 in ?? ()</code></pre></div></div><p>一开始为了方便后续在终端中配置了永久别名：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-onn1lsl9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-onn1lsl9znqyqz"><pre><code class="hljs shell">alias makeq="make GCCPREFIX=x86_64-elf-"</code></pre></div></div><p>当然更优雅的方法其实是修改make中的宏：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8m97zel9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-8m97zel9znqyqz"><pre><code class="hljs makefile"><span class="hljs-comment"># try to infer the correct GCCPREFX</span><span class="hljs-keyword">ifndef</span> GCCPREFIX<span class="hljs-comment"># GCCPREFIX := $(shell if i386-elf-objdump -i 2&gt;&amp;1 | </span><span class="hljs-comment">#...comment the original shell function</span><span class="hljs-comment"># echo "***" 1&gt;&amp;2; exit 1; fi)</span>GCCPREFIX := x86_64-elf-<span class="hljs-keyword">endif</span></code></pre></div></div><p>但是，由于<code>makefile</code>里默认认为调试工具一定叫<code>gdb</code>，且mac里没有gdb对应的command，因此这时候用永久别名是比较合适的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tu2vgul9znqyqz"></i><span>shell</span><div class="collapse show" id="collapse-tu2vgul9znqyqz"><pre><code class="hljs shell">alias gdb="i386-elf-gdb"</code></pre></div></div><p>这时候也可以修改make来达到自动化调试的目的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4xbsrhl9znqyqz"></i><span>makefile</span><div class="collapse show" id="collapse-4xbsrhl9znqyqz"><pre><code class="hljs makefile">WORKING_DIR=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(QEMU)</span> -S -s -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null &amp;<span class="hljs-variable">$(V)</span>sleep 2<span class="hljs-variable">$(V)</span> osascript -e 'tell application <span class="hljs-string">"Terminal"</span> to do script <span class="hljs-string">"cd <span class="hljs-variable">$(WORKING_DIR)</span>; gdb -q -x tools/gdbinit"</span>'</code></pre></div></div><p>其中最后一句是为了产生一个在当前工作目录的新终端。</p><h3 id="总结">总结</h3><p>前前后后也花了相当长的时间来应对环境的不同。后续的内容其实更吸引着我们去深入探索。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客增加侧边栏</title>
    <link href="/posts/43390/"/>
    <url>/posts/43390/</url>
    
    <content type="html"><![CDATA[<h3 id="hexo-博客增加侧边栏">Hexo 博客增加侧边栏</h3><p>根据https://github.com/qixa/hexo-theme-fluid-mod修改</p><h4 id="修改主题配置文件">修改主题配置文件</h4><p>color下新增属性</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-brbdegl9znqyqz"></i><span>css</span><div class="collapse show" id="collapse-brbdegl9znqyqz"><pre><code class="hljs css"># 侧边栏颜色sidebar_text_color: <span class="hljs-string">"#3c4858"</span>sidebar_background_color: <span class="hljs-string">"rgba(246, 248, 250, 0.82)"</span> <span class="hljs-number">#f6f8fad1</span>sidebar_button_color: <span class="hljs-string">"#99a9bf"</span>sidebar_button_shift_color: <span class="hljs-string">"#ffffff"</span>sidebar_button_shift_shadow: <span class="hljs-string">"0.1rem 0.1rem 0.5rem #3e3e3e"</span>sidebar_about_link_color: <span class="hljs-string">"#3c4858"</span>sidebar_about_link_hover_color: <span class="hljs-string">"#57A7D9"</span>sidebar_avatar_border: <span class="hljs-string">"5px solid #ffffff"</span>sidebar_subtitle_color: <span class="hljs-string">"#999999"</span>sidebar_friend_title: <span class="hljs-string">"#ffffff"</span>sidebar_friend_title_background: <span class="hljs-string">"#8FABD7"</span>sidebar_friend_link: <span class="hljs-string">"#3c4858"</span>sidebar_friend_link_hover: <span class="hljs-string">"#ffffff"</span>sidebar_friend_li_border: <span class="hljs-string">"1px dashed #bdbdbd"</span>sidebar_friend_li_hover: <span class="hljs-string">"#57A7D9"</span>sidebar_friend_ico: <span class="hljs-string">"#bfbfbf"</span></code></pre></div></div><p>新增全局属性</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xt8vqul9znqyqz"></i><span>css</span><div class="collapse show" id="collapse-xt8vqul9znqyqz"><pre><code class="hljs css">sidebar:    enable: true    name: Lunatic sky    introduce:  # 支持 HTML，留空则使用网站subtitle    icons:         <span class="hljs-string">"fab fa-github"</span>: https://github.com/Lunaticsky-tql        <span class="hljs-string">"fas fa-envelope"</span>: mailto:******#---------------------------# 侧边栏链接# Links#---------------------------    sidebar_links:  <span class="hljs-string">"my repository"</span>: https://github.com/Lunaticsky-tql?tab=repositories</code></pre></div></div><h4 id="新增侧边栏模板文件">新增侧边栏模板文件</h4><p>新建layout/_partial/sidebar.ejs</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-eppnnkl9znqyqz"></i><span>javascript</span><div class="collapse show" id="collapse-eppnnkl9znqyqz"><pre><code class="hljs javascript">&lt;% <span class="hljs-keyword">if</span>(theme.<span class="hljs-property">sidebar</span>.<span class="hljs-property">enable</span>){ %&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sidebar"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-hide"</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-button sidebar-button-shift"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"toggle-sidebar"</span> &gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-arrow-right on"</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-overlay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-intrude"</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-avatar"</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"&lt;%- url_for(theme.avatar) %&gt;"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"&lt;%- url_for(theme.avatar) %&gt;"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"avatar"</span>/&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-center sidebar-about"</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h3 sidebar-author"</span>&gt;</span>&lt;%= theme.sidebar.name || config.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-subtitle"</span>&gt;</span>&lt;%- theme.sidebar.introduce || config.subtitle %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">      &lt;% for(var i in theme.sidebar.icons) { %&gt;</span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"&lt;%- theme.sidebar.icons[i] %&gt;"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h4"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"&lt;%- i %&gt;"</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">        <span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span></span><span class="language-xml">      &lt;% } %&gt;</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-friend"</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h6 sidebar-friend-title"</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-label-left"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-user-friends"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-label"</span>&gt;</span>相关链接<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span></span><span class="language-xml">        &lt;% for(var i in theme.sidebar_links) { %&gt;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"&lt;%- theme.sidebar_links[i] %&gt;"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span></span><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-quote-left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span></span><span class="language-xml">              &lt;%- i %&gt;</span><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">        &lt;% } %&gt;</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;% } %&gt;</code></pre></div></div><p>layout.ejs中引入</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/Hexo%20%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E4%BE%A7%E8%BE%B9%E6%A0%8F/20220920002715526487_276_image-20220919235231945.png" alt="image-20220919235231945"><figcaption aria-hidden="true">image-20220919235231945</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-u8kf92l9znqyqz"></i><span>javascript</span><div class="collapse show" id="collapse-u8kf92l9znqyqz"><pre><code class="hljs javascript">&lt;%- <span class="hljs-title function_">partial</span>(<span class="hljs-string">'_partials/sidebar.ejs'</span>) %&gt;</code></pre></div></div><h4 id="修改css文件">修改CSS文件</h4><p>source/css/_variables/base.styl</p><p>增加侧边栏相关变量</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-n0kfk9l9znqyqz"></i><span>css</span><div class="collapse show" id="collapse-n0kfk9l9znqyqz"><pre><code class="hljs css">//toc$tocbot-link-shadow = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.tocbot_link_shadow</span>", "<span class="hljs-number">0.1em</span> <span class="hljs-number">0.1em</span> <span class="hljs-number">0.2em</span> <span class="hljs-selector-id">#ffffff</span>")$tocbot-active-link-shadow = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.tocbot_active_link_shadow</span>", "<span class="hljs-number">0.1em</span> <span class="hljs-number">0.1em</span> <span class="hljs-number">0.2em</span> <span class="hljs-selector-id">#ffbcbc</span>")//sidebar$sidebar-text-<span class="hljs-attribute">color</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_text_color</span>", "<span class="hljs-selector-id">#3c4858</span>")$sidebar-<span class="hljs-attribute">background-color</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_background_color</span>", "<span class="hljs-selector-id">#f6f8fad1</span>")$sidebar-<span class="hljs-selector-tag">button</span>-<span class="hljs-attribute">color</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_button_color</span>", "<span class="hljs-selector-id">#99a9bf</span>")$sidebar-<span class="hljs-selector-tag">button</span>-shift-<span class="hljs-attribute">color</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_button_shift_color</span>", "<span class="hljs-selector-id">#ffffff</span>")$sidebar-<span class="hljs-selector-tag">button</span>-shift-shadow = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_button_shift_shadow</span>", "<span class="hljs-number">0.1rem</span> <span class="hljs-number">0.1rem</span> <span class="hljs-number">0.5rem</span> <span class="hljs-selector-id">#3e3e3e</span>")$sidebar-about-link-<span class="hljs-attribute">color</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_about_link_color</span>", "<span class="hljs-selector-id">#3c4858</span>")$sidebar-about-link-hover-<span class="hljs-attribute">color</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_about_link_hover_color</span>", "<span class="hljs-selector-id">#fe4365</span>")$sidebar-avatar-<span class="hljs-attribute">border</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_avatar_border</span>", "<span class="hljs-number">5px</span> solid <span class="hljs-selector-id">#ffffff</span>")$sidebar-subtitle-<span class="hljs-attribute">color</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_subtitle_color</span>", "<span class="hljs-selector-id">#999999</span>")$sidebar-friend-title = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_friend_title</span>", "<span class="hljs-selector-id">#ffffff</span>")$sidebar-friend-title-<span class="hljs-attribute">background</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_friend_title_background</span>", "<span class="hljs-selector-id">#fe91b4</span>")$sidebar-friend-link = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_friend_link</span>", "<span class="hljs-selector-id">#3c4858</span>")$sidebar-friend-link-hover = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_friend_link_hover</span>", "<span class="hljs-selector-id">#ffffff</span>")$sidebar-friend-<span class="hljs-selector-tag">li</span>-<span class="hljs-attribute">border</span> = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_friend_li_border</span>", "<span class="hljs-number">1px</span> dashed <span class="hljs-selector-id">#bdbdbd</span>")$sidebar-friend-<span class="hljs-selector-tag">li</span>-hover = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_friend_li_hover</span>", "<span class="hljs-selector-id">#fe91b4</span>")$sidebar-friend-ico = theme-config("<span class="hljs-attribute">color</span><span class="hljs-selector-class">.sidebar_friend_ico</span>", "<span class="hljs-selector-id">#bfbfbf</span>")</code></pre></div></div><p>layout/_partials/css.ejs</p><p>引入需要的图标字体</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f9dwh0l9znqyqz"></i><span>javascript</span><div class="collapse show" id="collapse-f9dwh0l9znqyqz"><pre><code class="hljs javascript">&lt;%- <span class="hljs-title function_">css_ex</span>(theme.<span class="hljs-property">static_prefix</span>.<span class="hljs-property">font_awesome</span>, <span class="hljs-string">"css/all.min.css"</span>) %&gt;</code></pre></div></div><h4 id="js-文件">JS 文件</h4><p>source/js/main.js</p><p>增加侧边栏相关控制代码</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-di5kk9l9znqyqz"></i><span>javascript</span><div class="collapse show" id="collapse-di5kk9l9znqyqz"><pre><code class="hljs javascript"><span class="hljs-comment">/* Sidebar */</span><span class="hljs-keyword">var</span> toggleSidebar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){  $(<span class="hljs-string">"#sidebar"</span>).<span class="hljs-title function_">toggleClass</span>(<span class="hljs-string">'sidebar-hide'</span>);  $(<span class="hljs-string">"#toggle-sidebar"</span>).<span class="hljs-title function_">toggleClass</span>(<span class="hljs-string">'sidebar-button-shift'</span>);}<span class="hljs-keyword">var</span> hideSidebar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){  $(<span class="hljs-string">"#sidebar"</span>).<span class="hljs-title function_">addClass</span>(<span class="hljs-string">'sidebar-hide'</span>);  $(<span class="hljs-string">"#toggle-sidebar"</span>).<span class="hljs-title function_">addClass</span>(<span class="hljs-string">'sidebar-button-shift'</span>);}$(<span class="hljs-string">"#toggle-sidebar"</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">"click"</span>,toggleSidebar);$(<span class="hljs-string">"header"</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">"click"</span>,hideSidebar);$(<span class="hljs-string">"#mainContent"</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">"click"</span>,hideSidebar);$(<span class="hljs-string">"#footerContent"</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">"click"</span>,hideSidebar);</code></pre></div></div><p>layout/_partials/scripts.ejs中进行引用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/Hexo%20%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E4%BE%A7%E8%BE%B9%E6%A0%8F/20220920002717155064_217_image-20220920000758138.png" alt="image-20220920000758138"><figcaption aria-hidden="true">image-20220920000758138</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bnxghvl9znqyqz"></i><span>javascript</span><div class="collapse show" id="collapse-bnxghvl9znqyqz"><pre><code class="hljs javascript">&lt;%- <span class="hljs-title function_">js_ex</span>(theme.<span class="hljs-property">static_prefix</span>.<span class="hljs-property">internal_js</span>, <span class="hljs-string">'main.js'</span>) %&gt;</code></pre></div></div><p>配置完成后，可以从左下角箭头打开侧边栏。</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能导论</title>
    <link href="/posts/46759/"/>
    <url>/posts/46759/</url>
    
    <content type="html"><![CDATA[<p>人工智能导论</p><p>逻辑推理</p><p align="center"><img alt="image-20220831205211237" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221103884501_923_image-20220831205211237.png" width="50%"></p><p align="center"><img alt="image-20220831205344502" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221111633086_904_image-20220831205344502.png" width="50%"></p><p align="center"><img alt="image-20220831205448441" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221120315099_386_image-20220831205448441.png" width="50%"></p><p>任意对析取，存在对合取都是蕴含关系，分开的条件强于合起来的（举个例子就明白了）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221127063207_401_image-20220831210345470.png" alt="image-20220831210345470"><figcaption aria-hidden="true">image-20220831210345470</figcaption></figure><p align="center"><img alt="image-20220831210404798" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221128281126_946_image-20220831210404798.png" width="50%"></p><p>只与新加入的直接相关</p><p align="center"><img alt="image-20220831211022710" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221129758335_145_image-20220831211022710.png" width="50%"></p><p align="center"><img alt="image-20220831211029655" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221130984768_647_image-20220831211029655.png" width="50%"></p><p align="center"><img alt="image-20220831211350521" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221132416550_481_image-20220831211350521.png" width="50%"></p><p>因果分析三层次：关联，介入，反事实</p><p>因果图三种形式：链，分连，汇连（chain，fork，collider)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221134366409_448_image-20220831212134887.png" alt="image-20220831212134887"><figcaption aria-hidden="true">image-20220831212134887</figcaption></figure><p>做法：联合概率分布由每个节点与其父节点之间的条件概率得出。根节点是外生变量，其他的是内生</p><hr><p align="center"><img alt="image-20220831212713182" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221135899101_136_image-20220831212713182.png" width="50%"></p><p>深搜可能会陷入无限循环</p><p align="center"><img alt="image-20220831213452142" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221137133557_194_image-20220831213452142.png" width="50%"></p><p align="center"><img alt="image-20220831213527818" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221139012135_477_image-20220831213527818.png" width="50%"></p><p align="center"><img alt="image-20220831213624058" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221140593318_530_image-20220831213624058.png" width="50%"></p><p>有环路的图会使贪婪最佳优先算法不完备。</p><p>判断：启发函数满足可容性则一定能保证算法最优性x</p><p>树搜索是这样法，图不一定</p><p>判断：启发函数恒为0一定满足可容性x</p><p>启发函数不一定要是正数。</p><p>满足一致性可保证A*搜索算法最优</p><p>启发函数不会过高估计从当前节点到目标结点之间的实际代价。x</p><p>满足可容性的启发函数才有这样的性质。</p><p>MinMax的适用条件：两人博弈，信息透明，零和博弈</p><p align="center"><img alt="image-20220831215141822" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221142369023_436_image-20220831215141822.png" width="50%"></p><p>注意，没有规定必须要公平。D违反了零和博弈</p><p align="center"><img alt="image-20220831220640110" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221144124086_686_image-20220831220640110.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221145565187_669_image-20220831220659274.png" alt="image-20220831220659274"><figcaption aria-hidden="true">image-20220831220659274</figcaption></figure><p>这个做法是不对的，根据课本上的过程，A*算法会考虑所有可达的评价函数，每次从边缘集合拓展的节点并非总是当前节点的后继节点。fn评价函数是唯一标准如果发现有更小的，会倒回去。</p><p align="center"><img alt="image-20220831220818630" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221146871853_388_image-20220831220818630.png" width="50%"></p><p>而且贪婪最佳优先搜索也是启发式算法，优先选择启发函数最小的后继节点拓展。</p><p align="center"><img alt="image-20220831222502968" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221148285550_794_image-20220831222502968.png" width="50%"></p><p align="center"><img alt="image-20220831222848019" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221149618933_986_image-20220831222848019.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221152879301_392_image-20220831223950629.png" alt="image-20220831223950629"><figcaption aria-hidden="true">image-20220831223950629</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221155537145_635_image-20220831223959591.png" alt="image-20220831223959591"><figcaption aria-hidden="true">image-20220831223959591</figcaption></figure><p>记住蒙特卡洛树UCB的公式，明白反向传播的过程。 <span class="math display">\[U C B=\bar{X}_j+C \times \sqrt{\frac{2 \ln n}{n_j}}\]</span> <strong>上限置信区间</strong> <strong>(Upper Confidence Bound,UCB)</strong></p><hr><p>监督学习中经验风险和期望风险的概念</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221157700882_480_image-20220831224734326.png" alt="image-20220831224734326"><figcaption aria-hidden="true">image-20220831224734326</figcaption></figure><p align="center"><img alt="image-20220831224903093" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221159350035_550_image-20220831224903093.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221201393460_662_image-20220831224941130.png" alt="image-20220831224941130"><figcaption aria-hidden="true">image-20220831224941130</figcaption></figure><p align="center"><img alt="image-20220831224941224" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221201393460_662_image-20220831224941130.png" width="50%"></p><p>​常用的正则项方法包括L1正则项和L2正则项：其中L1使权重稀疏，L2使权重平滑。一句话总结就是：L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。</p><p>怎么记：1比2小，生成的特征少</p><p align="center"><img alt="image-20220831225522763" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221204366868_381_image-20220831225522763.png" width="50%"></p><p align="center"><img alt="image-20220831225535198" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221206081717_192_image-20220831225535198.png" width="50%"></p><p>考法：判断哪些算法是判别模型，哪些是生成模型。大部分典型机器学习算法都是判别模型。贝叶斯方法，隐马科代夫链式生成模型</p><p align="center"><img alt="image-20220831230142515" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221207951204_832_image-20220831230142515.png" width="50%"></p><p>信息熵小，信息稳定，单一，纯度高；信息熵大，信息不稳定，纯度低。</p><p align="center"><img alt="image-20220831230645025" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221209692239_698_image-20220831230645025.png" width="50%"></p><p>决策树是在干什么呢？选择最佳属性对样本进行划分，得到最大的“纯度”</p><p>同时注意决策树是有监督学习。</p><p><strong>线性区别分析</strong> <strong>(</strong>linear discriminantanalysis, LDA<strong>)</strong></p><p>线性判别分析的核心：类内方差小，类间间隔大。“君子和而不同，小人同而不和”，是一种降为方法</p><p>#请判断下面说法是否正确：线性判别分析是在最大化类间方差和类内方差的比值(√)</p><p>#在一个监督学习任务中，每个数据样本有4个属性和一个类别标签，每种属性分别有3、2、2和2种可能的取值，类别标签有3种不同的取值。请问可能有多少种不同的样本？（注意，并不是在某个数据集中最多有多少种不同的样本，而是考虑所有可能的样本)()</p><p>乘起来就可以。72</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221224036219_753_image-20220831232017771.png" alt="image-20220831232017771"><figcaption aria-hidden="true">image-20220831232017771</figcaption></figure><p>记住就可以</p><p>重点：</p><p align="center"><img alt="image-20220831231843333" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221225672479_673_image-20220831231843333.png" width="50%"></p><p align="center"><img alt="image-20220831232347725" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221227106679_945_image-20220831232347725.png" width="50%"></p><p align="center"><img alt="image-20220831233241581" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221229085668_716_image-20220831233241581.png" width="50%"></p><p>ada boosting</p><p><span class="math inline">\(Z_m=\sum_{i=1}^N w_{m, i}\mathrm{e}^{-\alpha_m y G_i\left(x_i\right) \text { 。 }}\)</span>可以把对第 <span class="math inline">\(i\)</span>个训练样本更新后的分布权重写为如下分段函数形式: <span class="math display">\[w_{m+1, i}= \begin{cases}\frac{w_{m, i}}{Z_m} \mathrm{e}^{-\alpha_m},&amp;amp; G_m\left(x_i\right)=y_i \\ \frac{w_{m, i}}{Z_m}\mathrm{e}^{\alpha_m}, &amp;amp; G_m\left(x_i\right) \neq y_i\end{cases}\]</span> 可见, 如果第 <span class="math inline">\(i\)</span>个训练样本无法被第 <span class="math inline">\(m\)</span> 个弱分类器<span class="math inline">\(G_m(x)\)</span> 分类成功,则需要增大该样本权重, 否则减少该样本权重。这样, 被错误分类样本会在训练第 <span class="math inline">\(m+1\)</span> 个弱分类器 <span class="math inline">\(G_{m+1}(x)\)</span> 时被 “重点关注”。</p><p>在第 <span class="math inline">\(m\)</span> 次迭代中, Ada Boosting总是趋向于将具有<font color="Apricot">最小误差的学习模型</font>（err最小的）选做本轮次生成的弱分类器<span class="math inline">\(G_m\)</span>, 促使累积误差快速下降。</p><hr><p>无监督学习</p><p>K-means往往找都是一个局部最优</p><p>聚类迭代满足如下任意一个条件，则聚类停止：</p><p>•已经达到了迭代次数上限</p><p>•前后两次迭代中，聚类质心基本保持不变</p><p align="center"><img alt="image-20220831234829916" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221230319204_134_image-20220831234829916.png" width="50%"></p><p align="center"><img alt="image-20220831234856133" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221232576761_180_image-20220831234856133.png" width="50%"></p><p>应当是尽量“不相关”</p><p>•<strong>主成分分析是将𝑛维特征数据映射到𝑙维空间</strong>(<strong>n≫l</strong>)<strong>，去除原始数据之间的冗余性（通过去除相关性手段达到这一目的）。</strong>每一维的样本方差尽可能大</p><p>•<strong>特征人脸方法是一种应用主成份分析来实现人脸图像降维的方法，其本质是用一种称为“特征人脸(eigenface)”的特征向量（而不是像素）按照线性组合形式来表达每一张原始人脸图像，进而实现人脸识别。</strong></p><p>每一个特征人脸的维数与原始人脸图像的维数一样大x 会变小</p><p>特征人脸之间的相关度要尽可能大√</p><p>为了使算法更高效采用了奇异值分解的方法</p><hr><p align="center"><img alt="image-20220901002546496" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221234267125_288_image-20220901002546496.png" width="50%"></p><p>批量梯度下降算法是在整个训练集上计算损失误差C()。如果数据集较大，则会因内存容量不足而无法完成，同时这一方法收敛速度较慢。随机梯度下降算法是使用训练集中每个训练样本计算所得C()来分别更新参数。虽然，随机梯度下降收敛速度会快一些，但可能出现所优化目标函数震荡不稳定现象。</p><p align="center"><img alt="image-20220901004646914" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221236054772_109_image-20220901004646914.png" width="50%"></p><p><span class="math display">\[f(x)=\frac{1}{1+\mathrm{e}^{-x}}\]</span> 选取 sigmoid函数作为激活函数, 因为其具有如下优点: (1)概率形式输出, sigmoid函数值域为 <span class="math inline">\((0,1)\)</span>, 因此使 sigmoid函数输出可视为概率值; (2) 单调递增, sigmoid函数对输人 <span class="math inline">\(x\)</span> 取值范围没有限制, 但当 <span class="math inline">\(x\)</span> 大 于一定值后, 函数输出无限趋近于 1 ,而小于一定数值后, 函数输出无限趋近于 0 , 特别地, 当 <span class="math inline">\(x=0\)</span> 时, 函数输出为 <span class="math inline">\(0.5\)</span>; (3) 非线性变化, <span class="math inline">\(x\)</span> 取 值在 0 附近时,函数输出值的变化幅度比较大 (函数值变化陡峭), 意味 着函数在 0附近容易被激活且是非线性变化, 当 <span class="math inline">\(x\)</span>取值很大或很小时, 函数输出值几乎不变, 这是基于概率的一种认识与需要。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012351440"><figcaption aria-hidden="true">image-20220901012351440</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012412558"><figcaption aria-hidden="true">image-20220901012412558</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221245033698_681_image-20220901012437001.png" alt="image-20220901012437001"><figcaption aria-hidden="true">image-20220901012437001</figcaption></figure><p align="center"><img alt="image-20220901012512732" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221246660573_722_image-20220901012512732.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221248004240_176_image-20220901012559806.png" alt="image-20220901012559806"><figcaption aria-hidden="true">image-20220901012559806</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221249466398_422_image-20220901012619080.png" alt="image-20220901012619080"><figcaption aria-hidden="true">image-20220901012619080</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221251026834_417_image-20220901012639822.png" alt="image-20220901012639822"><figcaption aria-hidden="true">image-20220901012639822</figcaption></figure><hr><p>强化学习的特征</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221252634813_271_image-20220901082606079.png" alt="image-20220901082606079"><figcaption aria-hidden="true">image-20220901082606079</figcaption></figure><p align="center"><img alt="image-20220901082635583" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221254174712_770_image-20220901082635583.png" width="50%"></p><p>一个随机过程实际上是一列随时间变化的随机变量。当时间是离散 量时,一个随机过程可以表示为 <span class="math inline">\(\left\{X_t\right\}_{t=0,1,2, \cdots}\)</span>,这里每个 <span class="math inline">\(X_t\)</span> 都是一个随机变量,这被称为离散随机过程。为了方便分析和求解,通常要求通过合理的问题定义使得一个随机过程满足马尔可夫性 (Markovproperty), 即满足如下性质: <span class="math display">\[P\left(X_{t+1}=x_{t+1} \mid X_0=x_0, X_1=x_1, \cdots,X_t=x_t\right)=P\left(X_{t+1}=x_{t+1} \mid X_t=x_t\right) \text {(式7.1) }\]</span> 这个公式的直观解释为: 下一刻的状态 <span class="math inline">\(X_{t+1}\)</span> 只由当前状态 <span class="math inline">\(X_t\)</span> 决定(而与更早的所有状态均无关)。满足马尔可夫性的离散随机过程被称为马尔可夫链 (Markov chain)。</p><p align="center"><img alt="image-20220901083631487" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221255863567_937_image-20220901083631487.png" width="50%"></p><ul><li>动作 <span class="math inline">\(-\)</span> 价值函数 (action-valuefunction): <span class="math inline">\(q: S \times A \mapsto\mathbb{R}\)</span>, 其中 <span class="math inline">\(q_\pi(s,a)=\mathbb{E}_\pi\left[G_t \mid S_t=s, A_t=a\right]\)</span>,表示智能体在时刻 <span class="math inline">\(t\)</span> 处于状态 <span class="math inline">\(s\)</span> 时, 选择 了动作 <span class="math inline">\(a\)</span> 后，在 <span class="math inline">\(t\)</span> 时刻后根据策略 <span class="math inline">\(\pi\)</span> 采取行动所获得回报的期望。价值函数和动作 <span class="math inline">\(-\)</span>价值函数反映了智能体在某一策略下所对应状态 序列获得回报的期望,它比回报本身更加准确地刻画了智能体的目标。 注意, 价值函数和动作 <span class="math inline">\(-\)</span> 价值函数的定义之所以能够成立,离不开决策 过程所具有的马尔可夫性, 即当位于当前状态 <span class="math inline">\(s\)</span> 时, 无论当前时刻 <span class="math inline">\(t\)</span> 的取值是多少,一个策略回报值的期望是一定的 (当前状态只与前一状态有关，与时间无关）。（所以不是<span class="math inline">\(q_\pi(s,a,t)\)</span>） 至此, 强化学习可以转化为一个策略学习问题, 其定义为:给定一 个马尔可夫决策过程 <span class="math inline">\(M D P=(S, A, P, R,\gamma)\)</span>, 学习一个最优策略 <span class="math inline">\(\pi^*\)</span>, 对任 意 <span class="math inline">\(s \in S\)</span> 使得 <span class="math inline">\(V_{\pi^*}(s)\)</span> 值最大。</li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221257340897_656_image-20220901083736614.png" alt="image-20220901083736614"><figcaption aria-hidden="true">image-20220901083736614</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221258558310_351_image-20220901083803818.png" alt="image-20220901083803818"><figcaption aria-hidden="true">image-20220901083803818</figcaption></figure><hr><p align="center"><img alt="image-20220901090535698" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221300893504_791_image-20220901090535698.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20220916221302843487_985_image-20220901090816141.png" alt="image-20220901090816141"><figcaption aria-hidden="true">image-20220901090816141</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理习题讲解部分勘误</title>
    <link href="/posts/23086/"/>
    <url>/posts/23086/</url>
    
    <content type="html"><![CDATA[<p>4.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150014727108_816_image-20220822231146713.png" alt="image-20220822231146713"><figcaption aria-hidden="true">image-20220822231146713</figcaption></figure><p>流水线周期取决于耗时最长的阶段。此处忘记了IF的时钟周期仍为150ps。</p><p>5.6</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150016592317_276_image-20220821230253484.png" alt="image-20220821230253484"><figcaption aria-hidden="true">image-20220821230253484</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150018066044_526_image-20220821230543233.png" alt="image-20220821230543233"><figcaption aria-hidden="true">image-20220821230543233</figcaption></figure><p>第三问的讲解如上图所示。此处p1和p2的CPI计算有误。原因是未考虑指令缺失造成的代价。<span class="math display">\[CPI=1+平均每条指令阻塞始终周期数\\=1+指令缺失阻塞时钟周期数+数据缺失阻塞时钟周期数\]</span></p><p><span class="math display">\[指令缺失阻塞时钟周期数=\texttt{cache}缺失率*指令缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p><span class="math display">\[数据缺失阻塞时钟周期数=\texttt{cache}缺失率*访存指令占比*数据缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p>得到两个CPI分别约为12.54和7.35</p><p>5.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150019552299_178_image-20220822230445847.png" alt="image-20220822230445847"><figcaption aria-hidden="true">image-20220822230445847</figcaption></figure><p>第三小问关于反置页表。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/my_picbed/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20221013150020954753_868_image-20220822231114457.png" alt="image-20220822231114457"><figcaption aria-hidden="true">image-20220822231114457</figcaption></figure><p>在反置页表中是为每一个物理块设置一个页表项的，视频中也有所阐述,但在计算时依旧是使用的虚拟地址。此处应为$$ PTE= \</p><span class="math display">\[\begin{aligned}&amp;=\frac{\text { Size of physical memory }}{\text { Page size }}\\&amp;=\frac{16 \mathrm{GiB}}{4 \mathrm{KiB}} \\&amp;=\frac{2^{34}}{2^{12}} \\&amp;=2^{22}\end{aligned}\]</span><p>$$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
